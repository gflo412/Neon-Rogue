<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>NEON ROGUE</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <script>
        window.getMetaStats = () => {
            return { hp: 0, dmg: 0, range: 0, reroll: 0 };
        };
    </script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');


        body { margin: 0; overflow: hidden; background-color: #020202; font-family: 'Orbitron', sans-serif; touch-action: none; user-select: none; -webkit-user-select: none; }
        #gameCanvas { display: block; width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }


        .modal { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.95); backdrop-filter: blur(10px); display: flex; flex-direction: column; align-items: center; justify-content: flex-start; padding-top: 40px; padding-bottom: 40px; overflow-y: auto; z-index: 100; pointer-events: auto; opacity: 0; visibility: hidden; transition: opacity 0.3s; }
        .modal.active { opacity: 1; visibility: visible; }


        /* Boss Bar */
        #boss-hud {
            position: absolute; top: 80px; left: 50%; transform: translateX(-50%);
            width: 75%; max-width: 800px; display: none; flex-direction: column; align-items: center; z-index: 20; pointer-events: none;
        }
        #boss-hud.active { display: flex; }
        .boss-name { color: #ff0000; font-weight: 900; letter-spacing: 2px; margin-bottom: 5px; text-shadow: 0 0 10px #ff0000; font-size: 0.8rem; }
        .boss-bar-container { width: 100%; height: 15px; background: #300; border: 2px solid #f00; border-radius: 4px; overflow: hidden; position: relative; }
        .boss-bar-fill { width: 100%; height: 100%; background: #f00; transition: width 0.2s; box-shadow: 0 0 20px #f00; }
        .boss-phase-marker { position: absolute; left: 50%; top: 0; width: 3px; height: 100%; background: #fff; box-shadow: 0 0 10px #fff, 0 0 5px #fff; z-index: 10; }


        .overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; display: flex; flex-direction: column; justify-content: space-between; padding: 20px; box-sizing: border-box; z-index: 50; }
        .bar-container { background: rgba(0, 0, 0, 0.6); height: 20px; width: 160px; border-radius: 4px; overflow: hidden; border: 1px solid rgba(255, 255, 255, 0.1); position: relative; display: flex; align-items: center; justify-content: center; }
        .hp-bar-fill { background: linear-gradient(90deg, #ff3860, #ff829d); height: 100%; width: 100%; transition: width 0.2s; position: absolute; left: 0; top: 0; }
        .hp-text-inner { position: relative; z-index: 10; font-size: 11px; color: #fff; text-shadow: 0 1px 2px rgba(0,0,0,0.8); font-family: monospace; font-weight: bold; }
        .xp-bar-fill { background: linear-gradient(90deg, #00d1b2, #48c774); height: 100%; width: 0%; transition: width 0.2s; }
        
        /* Weapon Slots */
        .weapon-bar { display: flex; align-items: center; gap: 8px; margin-top: auto; pointer-events: auto; position: relative; z-index: 60; }
        .weapon-slot { width: 40px; height: 40px; background: rgba(0,0,0,0.5); border: 1px solid rgba(255,255,255,0.2); border-radius: 4px; display: flex; align-items: center; justify-content: center; color: #555; position: relative; overflow: hidden; }
        .weapon-slot.active { color: #fff; border-color: #fff; }
        
        /* Mod Slot */
        .mod-separator { width: 1px; height: 40px; background: rgba(255,255,255,0.3); margin: 0 4px; }
        .weapon-slot.mod-slot { 
            width: 40px; 
            height: 40px; 
            border-radius: 50%; 
            border: 2px solid #ffdd57; 
            box-shadow: 0 0 10px rgba(255, 221, 87, 0.4), inset 0 0 8px rgba(255, 221, 87, 0.1);
            background: linear-gradient(135deg, rgba(255, 221, 87, 0.15), rgba(0, 0, 0, 0.7));
            cursor: default;
            transition: all 0.2s;
            position: relative;
        }
        .weapon-slot.mod-slot:hover { 
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(255, 221, 87, 0.7), inset 0 0 15px rgba(255, 221, 87, 0.2);
        }
        .weapon-slot.mod-slot.active { 
            background: linear-gradient(135deg, rgba(255, 221, 87, 0.25), rgba(0, 0, 0, 0.5)); 
            color: #ffdd57;
            animation: modPulse 2s infinite;
        }
        @keyframes modPulse {
            0%, 100% { box-shadow: 0 0 15px rgba(255, 221, 87, 0.5), inset 0 0 10px rgba(255, 221, 87, 0.1); }
            50% { box-shadow: 0 0 25px rgba(255, 221, 87, 0.8), inset 0 0 15px rgba(255, 221, 87, 0.3); }
        }
        .weapon-slot.mod-slot i { font-size: 1.6rem; }
        
        /* Mod Cooldown Timer */
        .mod-cooldown-text {
            position: absolute;
            bottom: -18px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 10px;
            font-weight: bold;
            color: #ffdd57;
            text-shadow: 0 0 5px rgba(0, 0, 0, 0.8);
            pointer-events: none;
        }


        .weapon-slot .level-badge { 
            position: absolute; 
            bottom: 2px; 
            right: 2px; 
            background: #000; 
            color: #fff; 
            font-size: 9px; 
            font-weight: bold;
            padding: 0px 3px; 
            border-radius: 2px; 
            border: 1px solid #555; 
            z-index: 5; 
            line-height: 1;
        }
        .weapon-slot i { z-index: 2; position: relative; }
        
        /* Cooldown Overlay */
        .cooldown-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 3; pointer-events: none;
            transition: background 0.1s linear;
        }


        /* Element Borders */
        .weapon-slot.fire { border-color: #ff5722; }
        .weapon-slot.ice { border-color: #88d8ff; }
        .weapon-slot.volt { border-color: #ffeb3b; }
        .weapon-slot.bio { border-color: #00cc44; }
        .weapon-slot.hack { border-color: #00ffff; }

        /* Stacked List of Cards */
        .cards-grid {
            display: flex;
            flex-direction: column;
            gap: 16px;
            width: 100%;
            max-width: 550px;
            margin: 0 auto;
            padding: 20px;
        }

        /* Horizontal Card with Diamond Icon */
        .card { 
            background: linear-gradient(90deg, #1a1d2e 0%, #0f1016 100%);
            border: 2px solid #2a2d3e;
            border-left: none;
            border-radius: 0 8px 8px 0;
            padding: 0;
            cursor: pointer;
            position: relative;
            overflow: visible;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.6);
            display: flex;
            align-items: stretch;
            min-height: 85px;
            padding-left: 65px;
            margin: 4px 0 4px 45px;
        }
        
        .card:hover {
            transform: translateX(8px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.8);
        }
        
        .card:active { 
            transform: translateX(4px) scale(0.98); 
        }
        
        .card.disabled { 
            pointer-events: none; 
            opacity: 0.5;
            filter: grayscale(0.5);
        }
        
        /* Diamond Icon - Left edge of card */
        .card-header {
            position: absolute;
            left: -35px;
            top: 50%;
            transform: translateY(-50%) rotate(45deg);
            width: 70px;
            height: 70px;
            background: linear-gradient(135deg, #2a2d3e 0%, #1a1d2e 100%);
            border: 2px solid;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.8);
            z-index: 5;
        }
        
        .card i { 
            font-size: 2rem;
            transform: rotate(-45deg);
            filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.8));
        }
        
        /* Card Content - Left Aligned, Maximized Width */
        .card-content { 
            flex: 1;
            padding: 9px 12px 12px 0px;
            text-align: left;
            display: flex;
            flex-direction: column;
            justify-content: center;
            gap: 4px;
        }
        
        .card h3 { 
            color: #fff;
            margin: 0;
            font-size: 1.05rem;
            font-weight: 700;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.8);
            line-height: 1.3;
        }
        
        .card p { 
            color: #a0aec0;
            font-size: 0.75rem;
            margin: 0;
            line-height: 1.35;
        }
        
        /* No rarity label - color is shown through borders only */
        
        /* Rarity-based styling - Colors affect card border, diamond, icon, and title */
        .card.common { border-color: #9ca3af; color: #9ca3af; }
        .card.common .card-header { border-color: #9ca3af; background: linear-gradient(135deg, #6b7280 0%, #4b5563 100%); }
        .card.common i { color: #d1d5db; }
        .card.common h3 { color: #d1d5db; }
        
        .card.uncommon { border-color: #10b981; color: #10b981; }
        .card.uncommon .card-header { border-color: #10b981; background: linear-gradient(135deg, #059669 0%, #047857 100%); }
        .card.uncommon i { color: #34d399; }
        .card.uncommon h3 { color: #34d399; }
        
        .card.rare { border-color: #3b82f6; color: #3b82f6; }
        .card.rare .card-header { border-color: #3b82f6; background: linear-gradient(135deg, #2563eb 0%, #1e40af 100%); }
        .card.rare i { color: #60a5fa; }
        .card.rare h3 { color: #60a5fa; }
        .card.rare { box-shadow: 0 4px 15px rgba(59, 130, 246, 0.3); }
        .card.rare:hover { box-shadow: 0 6px 20px rgba(59, 130, 246, 0.5); }
        
        .card.epic { border-color: #a855f7; color: #a855f7; }
        .card.epic .card-header { border-color: #a855f7; background: linear-gradient(135deg, #9333ea 0%, #7e22ce 100%); }
        .card.epic i { color: #c084fc; }
        .card.epic h3 { color: #c084fc; }
        .card.epic { box-shadow: 0 4px 15px rgba(168, 85, 247, 0.4); }
        .card.epic:hover { box-shadow: 0 6px 20px rgba(168, 85, 247, 0.6); }
        
        .card.legendary { 
            border-color: #fbbf24;
            color: #fbbf24;
            background: linear-gradient(90deg, #2c2505 0%, #1a1d2e 100%);
            box-shadow: 0 4px 20px rgba(251, 191, 36, 0.4), inset 0 0 40px rgba(251, 191, 36, 0.08);
        }
        .card.legendary .card-header { 
            border-color: #fbbf24; 
            background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
            box-shadow: 0 0 15px rgba(251, 191, 36, 0.6);
        }
        .card.legendary i { color: #fbbf24; }
        .card.legendary h3 { color: #fbbf24; }
        .card.legendary:hover { box-shadow: 0 6px 25px rgba(251, 191, 36, 0.6); }
        
        /* Ultimate cards - magenta/fuschia theme */
        .card.ultimate { 
            border-color: #ff00ff;
            color: #ff00ff;
            background: linear-gradient(90deg, #1a0a1a 0%, #1a1d2e 100%);
            box-shadow: 0 4px 20px rgba(255, 0, 255, 0.4), inset 0 0 40px rgba(255, 0, 255, 0.08);
        }
        .card.ultimate .card-header { 
            border-color: #ff00ff; 
            background: linear-gradient(135deg, #ff00ff 0%, #c000c0 100%);
            box-shadow: 0 0 15px rgba(255, 0, 255, 0.6);
        }
        .card.ultimate i { color: #fff; }
        .card.ultimate h3 { color: #ff00ff; }
        .card.ultimate:hover { box-shadow: 0 6px 25px rgba(255, 0, 255, 0.6); }
        
        .card.elemental { 
            border-color: #ef4444;
            color: #ef4444;
            background: linear-gradient(90deg, #29080d 0%, #1a1d2e 100%);
        }
        .card.elemental .card-header { 
            border-color: #ef4444;
            background: linear-gradient(135deg, #dc2626 0%, #b91c1c 100%);
        }
        .card.elemental i { color: #f87171; }
        .card.elemental h3 { color: #f87171; }

        
        /* Legendary Particle Effect */
        @keyframes legendaryFloat {
            0%, 100% { transform: translateY(0) translateX(0); opacity: 0; }
            10% { opacity: 1; }
            90% { opacity: 0.7; }
            100% { transform: translateY(-60px) translateX(var(--drift-x)); opacity: 0; }
        }
        .legendary-particle {
            position: absolute;
            width: 4px;
            height: 4px;
            background: #ffdd57;
            border-radius: 50%;
            pointer-events: none;
            box-shadow: 0 0 4px #ffdd57;
            animation: legendaryFloat 2s ease-out infinite;
            bottom: 0;
            left: var(--start-x);
            --drift-x: 0;
            animation-delay: var(--delay);
        }
        
        /* Elemental Card Backgrounds */
        /* Elemental Augment Cards - Match element colors */
        .card.elem-fire { 
            border-color: #ff5722;
            color: #ff5722;
            background: linear-gradient(90deg, #1a0a05 0%, #0f1016 100%);
        }
        .card.elem-fire .card-header { 
            border-color: #ff5722; 
            background: linear-gradient(135deg, #ff5722 0%, #e64a19 100%);
        }
        .card.elem-fire i { color: #ff7043; }
        .card.elem-fire h3 { color: #ff7043; }
        
        .card.elem-ice {
            border-color: #88d8ff;
            color: #88d8ff;
            background: linear-gradient(90deg, #0a1a25 0%, #0f1016 100%);
        }
        .card.elem-ice .card-header { 
            border-color: #88d8ff; 
            background: linear-gradient(135deg, #88d8ff 0%, #5ab8e6 100%);
        }
        .card.elem-ice i { color: #b3e6ff; }
        .card.elem-ice h3 { color: #b3e6ff; }
        
        .card.elem-volt {
            border-color: #ffeb3b;
            color: #ffeb3b;
            background: linear-gradient(90deg, #1f1a05 0%, #0f1016 100%);
        }
        .card.elem-volt .card-header { 
            border-color: #ffeb3b; 
            background: linear-gradient(135deg, #ffeb3b 0%, #fdd835 100%);
        }
        .card.elem-volt i { color: #fff176; }
        .card.elem-volt h3 { color: #fff176; }
        
        .card.elem-bio {
            border-color: #00cc44;
            color: #00cc44;
            background: linear-gradient(90deg, #051a0f 0%, #0f1016 100%);
        }
        .card.elem-bio .card-header { 
            border-color: #00cc44; 
            background: linear-gradient(135deg, #00cc44 0%, #00a036 100%);
        }
        .card.elem-bio i { color: #33ff66; }
        .card.elem-bio h3 { color: #33ff66; }
        
        .card.elem-hack {
            border-color: #00ffff;
            color: #00ffff;
            background: linear-gradient(90deg, #051f1f 0%, #0f1016 100%);
        }
        .card.elem-hack .card-header { 
            border-color: #00ffff; 
            background: linear-gradient(135deg, #00ffff 0%, #00cccc 100%);
        }
        .card.elem-hack i { color: #66ffff; }
        .card.elem-hack h3 { color: #66ffff; }
        
        /* Animated Diamond Icons */
        @keyframes iconPulse {
            0%, 100% { transform: rotate(-45deg) scale(1); }
            50% { transform: rotate(-45deg) scale(1.1); }
        }
        
        @keyframes iconGlow {
            0%, 100% { filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.8)); }
            50% { filter: drop-shadow(0 0 12px currentColor) drop-shadow(0 2px 4px rgba(0, 0, 0, 0.8)); }
        }
        
        @keyframes ultimate-pulse {
            0%, 100% { 
                box-shadow: 0 0 10px rgba(255, 0, 255, 0.5), inset 0 0 10px rgba(255, 255, 255, 0.2);
                transform: scale(1.05);
            }
            50% { 
                box-shadow: 0 0 15px rgba(255, 0, 255, 0.7), inset 0 0 15px rgba(255, 255, 255, 0.3);
                transform: scale(1.07);
            }
        }
        
        /* Apply subtle pulse to rare+ cards */
        .card.rare i,
        .card.epic i,
        .card.legendary i {
            animation: iconPulse 3s ease-in-out infinite;
        }
        
        /* Apply glow pulse to legendary */
        .card.legendary i {
            animation: iconPulse 2s ease-in-out infinite, iconGlow 2s ease-in-out infinite;
        }
            animation: binaryFlash 1.5s infinite;
        }
        @keyframes binaryFlash {
            0%, 100% { content: '01'; opacity: 0.2; }
            33% { content: '10'; opacity: 0.3; }
            66% { content: '11'; opacity: 0.25; }
        }
        
        #reroll-btn { margin-top: 15px; background: #ffdd57; color: #000; border: none; padding: 12px 30px; font-family: 'Orbitron'; font-weight: bold; font-size: 0.9rem; cursor: pointer; clip-path: polygon(10% 0, 100% 0, 90% 100%, 0% 100%); display: flex; align-items: center; gap: 8px; }
        #reroll-btn:disabled { opacity: 0.5; cursor: not-allowed; filter: grayscale(1); }
        #save-btn { margin-top: 15px; background: #00d1b2; color: #000; border: none; padding: 12px 30px; font-family: 'Orbitron'; font-weight: bold; font-size: 0.9rem; cursor: pointer; clip-path: polygon(10% 0, 100% 0, 90% 100%, 0% 100%); display: flex; align-items: center; gap: 8px; }
        #save-btn:disabled { opacity: 0.5; cursor: not-allowed; filter: grayscale(1); }
        .upgrade-buttons { display: flex; gap: 10px; justify-content: center; margin-top: 15px; }
        .card.save-mode { border: 2px solid #00d1b2; box-shadow: 0 0 20px rgba(0, 209, 178, 0.5); }
        .card.saved { border: 3px solid #00d1b2; box-shadow: 0 0 30px rgba(0, 209, 178, 0.8); }
        #pause-btn { pointer-events: auto; background: rgba(0,0,0,0.5); border: 1px solid rgba(255,255,255,0.2); color: #fff; width: 40px; height: 40px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 1.2rem; cursor: pointer; transition: all 0.2s; }
        
        .vignette { position: absolute; top: 0; left: 0; width:100%; height:100%; background: radial-gradient(circle, rgba(0,0,0,0) 50%, rgba(0,0,0,0.8) 100%); pointer-events: none; z-index: 15; }
        #damage-flash { position: absolute; top:0; left:0; width:100%; height:100%; pointer-events: none; background: #ff0000; opacity: 0; transition: opacity 0.1s; z-index: 19; mix-blend-mode: overlay; }
        .joystick-hint { position: absolute; bottom: 15%; left: 50%; transform: translateX(-50%); color: rgba(255,255,255,0.4); font-size: 0.9rem; letter-spacing: 2px; pointer-events: none; animation: pulse 2s infinite; }
        @keyframes pulse { 0% { opacity: 0.2; } 50% { opacity: 0.7; } 100% { opacity: 0.2; } }
        
        #boss-warning {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: red; font-size: 3rem; font-weight: 900; display: none; pointer-events: none;
            text-shadow: 0 0 20px red; letter-spacing: 6px; animation: flash 0.5s infinite; z-index: 200;
            text-align: center; width: 100%;
        }
        @keyframes flash { 0% {opacity: 1;} 50% {opacity: 0.2;} 100% {opacity: 1;} }


        #stats-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px 30px; margin: 0 auto 20px auto; width: 80%; max-width: 500px; }
        .stat-row { display: flex; justify-content: space-between; border-bottom: 1px solid rgba(255,255,255,0.1); padding-bottom: 4px; }
        .stat-label { color: #888; font-size: 0.8rem; }
        .stat-val { color: #fff; font-weight: bold; font-family: monospace; }
        .stat-val.gold { color: #ffdd57; }
        
        #mod-confirm-screen { z-index: 250; }


        /* Toggle Switch */
        .toggle-container { display: flex; align-items: center; gap: 10px; margin-bottom: 15px; cursor: pointer; }
        .toggle-switch { position: relative; width: 40px; height: 20px; background: #333; border-radius: 10px; transition: 0.3s; }
        .toggle-switch::after { content: ''; position: absolute; top: 2px; left: 2px; width: 16px; height: 16px; background: #fff; border-radius: 50%; transition: 0.3s; }
        .toggle-active .toggle-switch { background: #00d1b2; }
        .toggle-active .toggle-switch::after { transform: translateX(20px); }
        .toggle-disabled { opacity: 0.5; pointer-events: none; }


        /* Glossary */
        .glossary-item { margin-bottom: 15px; border-bottom: 1px solid rgba(255,255,255,0.1); padding-bottom: 10px; }
        .g-title { color: #fff; font-weight: bold; display: flex; align-items: center; gap: 10px; }
        .g-desc { color: #aaa; font-size: 0.8rem; margin-left: 24px; }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div class="vignette"></div>
    <div id="damage-flash"></div>
    <div id="boss-warning">WARNING<br>CHAMPION INCOMING!</div>

    <!-- HUD -->
    <div class="overlay" id="hud" style="display:none;">
        <div id="boss-hud">
            <div id="boss-name-display" class="boss-name" style="display: none;"></div>
            <div id="boss-bars-container" style="display: flex; flex-direction: row; gap: 8px; width: 100%; justify-content: center;">
                <!-- Health bars will be dynamically added here side-by-side -->
            </div>
        </div>


        <div class="flex justify-between items-start w-full">
            <!-- Left side: HP and shields -->
            <div class="flex gap-3 items-start">
                <!-- Heart icon -->
                <div class="flex flex-col" style="padding-top: 3px;">
                    <i class="fas fa-heart text-red-500 w-4" style="font-size: 14px;"></i>
                </div>
                <!-- HP bar and shields -->
                <div class="flex flex-col gap-1">
                    <div class="bar-container">
                        <div id="hp-bar" class="hp-bar-fill"></div>
                        <div id="hp-text" class="hp-text-inner">150 / 150</div>
                    </div>
                    <!-- Shield charges and level below HP bar -->
                    <div class="flex justify-between items-center">
                        <!-- Shield charges - left aligned, shield-shaped -->
                        <div class="flex gap-2">
                            <i id="shield-orb-1" class="fas fa-shield-alt" style="font-size: 14px; color: #00d1b2; filter: drop-shadow(0 0 6px #00d1b2); transition: all 0.3s;"></i>
                            <i id="shield-orb-2" class="fas fa-shield-alt" style="font-size: 14px; color: #00d1b2; filter: drop-shadow(0 0 6px #00d1b2); transition: all 0.3s;"></i>
                            <i id="shield-orb-3" class="fas fa-shield-alt" style="font-size: 14px; color: #00d1b2; filter: drop-shadow(0 0 6px #00d1b2); transition: all 0.3s; display: none;"></i>
                            <i id="shield-orb-4" class="fas fa-shield-alt" style="font-size: 14px; color: #00d1b2; filter: drop-shadow(0 0 6px #00d1b2); transition: all 0.3s; display: none;"></i>
                        </div>
                        <!-- Level text - right aligned -->
                        <div id="lvl-text" class="text-[10px] text-gray-400 font-mono">LVL 1</div>
                    </div>
                </div>
            </div>
            
            <!-- Right side: Score and time aligned to top of HP bar -->
            <div class="flex flex-col items-end" style="padding-top: 0px;">
                <div id="score" class="text-3xl text-white font-black tracking-widest drop-shadow-[0_0_10px_rgba(255,255,255,0.5)]" style="line-height: 1;">0</div>
                <div id="time" class="text-xs text-gray-500 font-mono" style="margin-top: 2px;">00:00</div>
            </div>
        </div>
        
        <!-- Bottom UI Bar - Center-aligned: Mod | Weapons | Pause -->
        <div style="position: absolute; bottom: 40px; left: 0; right: 0; display: flex; align-items: center; justify-content: center; gap: 40px; pointer-events: none;">
            <!-- Ultimate Button - Left (replaces mod slot) -->
            <div id="ultimate-container" style="pointer-events: auto; display: none;">
                <button id="ultimate-btn" style="
                    width: 70px;
                    height: 70px;
                    background: linear-gradient(135deg, #2a2a3a 0%, #1a1a2a 100%);
                    border: 3px solid #555;
                    border-radius: 50%;
                    color: #888;
                    font-size: 12px;
                    font-weight: bold;
                    cursor: not-allowed;
                    position: relative;
                    display: flex;
                    flex-direction: column;
                    align-items: center;
                    justify-content: center;
                    gap: 3px;
                    transition: all 0.3s ease;
                    opacity: 0.6;
                ">
                    <i class="fas fa-bolt" style="font-size: 24px;"></i>
                    <div id="ultimate-charge-text" style="font-size: 11px; font-weight: bold;">0%</div>
                </button>
            </div>
            
            <!-- Weapon Slots - Center -->
            <div id="weapon-slots" class="weapon-bar"></div>
            
            <!-- Pause Button - Right -->
            <button id="pause-btn" style="pointer-events: auto;"><i class="fas fa-pause"></i></button>
        </div>
        
        <!-- XP Bar - Bottom of screen, full width -->
        <div style="position: absolute; bottom: 0; left: 0; right: 0; height: 8px; background: rgba(0,0,0,0.7); border-top: 1px solid rgba(0,209,178,0.3);">
            <div id="xp-bar" class="xp-bar-fill" style="height: 100%;"></div>
        </div>

        <div id="start-hint" class="joystick-hint">ENGAGE THRUSTERS</div>
    </div>


    <!-- Main Menu -->
    <div id="menu-screen" class="modal active">
        <!-- Title - Pinned to Top -->
        <div class="absolute top-12 left-0 right-0 flex justify-center">
            <h1 class="text-6xl text-transparent bg-clip-text bg-gradient-to-r from-teal-400 to-blue-500 font-black tracking-tighter filter drop-shadow-[0_0_15px_rgba(0,209,178,0.5)]">NEON<br>ROGUE</h1>
        </div>
        
        <!-- Save Icon Button - Bottom Right Corner (Pinned) -->
        <button id="save-corner-btn" class="absolute bottom-6 right-6 w-12 h-12 bg-gray-800 hover:bg-gray-700 text-gray-400 hover:text-teal-400 rounded-lg border border-gray-700 flex items-center justify-center transition-all z-10">
            <i class="fas fa-save text-lg"></i>
        </button>
        
        <!-- Stats Icon Button - Bottom Left Corner (Pinned) -->
        <button id="view-stats-btn" class="absolute bottom-6 left-6 w-12 h-12 bg-gray-800 hover:bg-gray-700 text-gray-400 hover:text-teal-400 rounded-lg border border-gray-700 flex items-center justify-center transition-all z-10">
            <i class="fas fa-chart-bar text-lg"></i>
        </button>
        
        <!-- Centered Content Area - Fixed positioning, pushed down slightly -->
        <div class="absolute inset-0 flex flex-col items-center justify-center" style="padding-top: 40px;">
            <!-- Ship Selection Carousel - Raised higher with extra top padding -->
            <div class="mb-8 w-80 relative" style="margin-bottom: 40px; padding-top: 50px;">
                <!-- Navigation Arrows - Inside edges -->
                <button id="ship-prev" class="absolute left-2 top-1/2 -translate-y-1/2 text-2xl z-10 transition-all disabled:text-gray-800 disabled:cursor-not-allowed text-teal-400 hover:text-teal-300" disabled>
                    <i class="fas fa-chevron-circle-left"></i>
                </button>
                <button id="ship-next" class="absolute right-2 top-1/2 -translate-y-1/2 text-2xl z-10 transition-all disabled:text-gray-800 disabled:cursor-not-allowed text-teal-400 hover:text-teal-300" disabled>
                    <i class="fas fa-chevron-circle-right"></i>
                </button>
                
                <!-- Ship Display - Vertical Layout -->
                <div class="flex flex-col items-center">
                    <!-- Ship Icon (Canvas) - Top -->
                    <div class="mb-1">
                        <canvas id="ship-canvas" width="70" height="70"></canvas>
                    </div>
                    
                    <!-- Ship Info - Bottom, Centered -->
                    <div class="text-center">
                        <h3 id="ship-name" class="text-base font-bold text-teal-400 mb-1 tracking-wide">PATHFINDER</h3>
                        <p id="ship-desc" class="text-xs text-gray-400 mb-2">Balanced all-around vessel</p>
                        <div id="ship-stats" class="text-[10px] text-gray-500 font-mono space-y-0.5">
                            <div>HP: <span class="text-white">150</span> ‚Ä¢ DMG: <span class="text-white">100%</span> ‚Ä¢ SPD: <span class="text-white">100%</span></div>
                            <div>WEAPON: <span class="text-teal-400">Ion Cannons</span></div>
                            <div class="text-[9px] text-gray-400 mt-0.5 leading-tight max-w-[200px]">Orbiting cannons that auto-target and fire at nearby enemies</div>
                        </div>
                        <button id="ship-details-btn" class="mt-2 text-[10px] text-teal-400 hover:text-teal-300 underline cursor-pointer">
                            More Details
                        </button>
                    </div>
                </div>
            </div>
            
            <!-- Ship Details Pop-up Modal -->
            <div id="ship-details-modal" class="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50" style="display: none;">
                <div class="bg-gray-900 border-2 border-teal-500 p-6 rounded-lg max-w-md max-h-[80vh] overflow-y-auto">
                    <div class="flex justify-between items-center mb-4">
                        <h3 id="modal-ship-name" class="text-2xl font-bold text-teal-400"></h3>
                        <button id="close-details-btn" class="text-gray-400 hover:text-white text-2xl">&times;</button>
                    </div>
                    <div id="modal-ship-details" class="text-sm text-gray-300 space-y-3"></div>
                </div>
            </div>
            
            <div class="flex flex-col gap-4 w-64">
                <button id="start-btn" class="bg-teal-500 hover:bg-teal-400 text-black font-bold py-4 rounded-sm skew-x-[-10deg] shadow-[0_0_30px_rgba(0,209,178,0.3)] transition-all">
                    <span class="inline-block skew-x-[10deg]">DEPLOY</span>
                </button>
                
                <button id="augment-lab-btn" class="bg-purple-900 hover:bg-purple-800 text-purple-300 hover:text-purple-200 text-sm font-bold py-2 rounded transition-all border border-purple-700 shadow-[0_0_15px_rgba(168,85,247,0.3)]">
                    <i class="fas fa-flask mr-2"></i>AUGMENT LAB
                </button>
                
                <!-- Test Mode Toggle with Settings -->
                <div class="flex gap-2">
                    <button id="test-mode-toggle" class="flex-1 bg-gray-900 hover:bg-gray-800 text-gray-400 text-xs font-bold py-2 px-4 rounded transition-all border border-gray-700">
                        <i class="fas fa-vial mr-2"></i>TEST MODE: <span id="test-mode-status" class="text-gray-500">OFF</span>
                    </button>
                    <button id="test-mode-settings-btn" class="w-10 h-10 bg-gray-900 hover:bg-gray-800 text-gray-400 hover:text-teal-400 rounded transition-all border border-gray-700 flex items-center justify-center">
                        <i class="fas fa-cog"></i>
                    </button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Ascension Selection Screen -->
    <div id="ascension-screen" class="modal">
        <h2 class="text-4xl text-purple-400 font-black mb-2 tracking-widest drop-shadow-[0_0_20px_rgba(168,85,247,0.6)]">NEXUS ASCENSION</h2>
        <p class="text-sm text-gray-400 mb-4">Choose your challenge level. Higher ascensions grant greater rewards.</p>
        
        <!-- Ascension Level Selector - Scrollable Container -->
        <div class="w-full max-w-2xl mb-4 overflow-y-auto" style="max-height: 60vh;">
            <div id="ascension-levels-container" class="flex flex-col gap-2 px-2">
                <!-- Ascension levels will be dynamically inserted here -->
            </div>
        </div>
        
        <!-- Action Buttons -->
        <div class="flex gap-4">
            <button id="ascension-start-btn" class="bg-teal-500 hover:bg-teal-400 text-black font-bold py-3 px-8 rounded-sm skew-x-[-10deg] shadow-[0_0_30px_rgba(0,209,178,0.3)] transition-all">
                <span class="inline-block skew-x-[10deg]">START RUN</span>
            </button>
            <button id="ascension-back-btn" class="border border-gray-500 text-gray-400 hover:text-white hover:border-white py-3 px-8 rounded transition-all">
                BACK
            </button>
        </div>
    </div>
    
    <!-- Augment Selector Modal -->
    <div id="augment-selector-modal" class="modal">
        <div class="bg-gray-900 bg-opacity-95 border-2 border-purple-600 rounded-lg p-6 max-w-2xl w-full max-h-[80vh] overflow-hidden flex flex-col">
            <div class="flex items-center justify-between mb-4">
                <h2 class="text-2xl text-purple-400 font-black tracking-widest">
                    <i class="fas fa-flask mr-2"></i>SELECT AUGMENT
                </h2>
                <button onclick="closeAugmentSelector()" class="text-gray-500 hover:text-white text-2xl">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <p class="text-sm text-gray-400 mb-4">Choose an augment for Slot <span id="selector-slot-number">1</span></p>
            
            <!-- Augment List -->
            <div id="augment-selector-list" class="flex-1 overflow-y-auto space-y-2 mb-4">
                <!-- Augments will be populated here -->
            </div>
            
            <!-- Clear Slot Button -->
            <div class="flex gap-2">
                <button onclick="clearAugmentSlot()" class="flex-1 bg-red-900 hover:bg-red-800 text-white font-bold py-2 rounded transition-all">
                    <i class="fas fa-times mr-2"></i>CLEAR SLOT
                </button>
                <button onclick="closeAugmentSelector()" class="flex-1 bg-gray-700 hover:bg-gray-600 text-white font-bold py-2 rounded transition-all">
                    CANCEL
                </button>
            </div>
        </div>
    </div>
    
    <!-- Save Management Modal -->
    <div id="save-modal" class="modal">
        <h2 class="text-3xl text-teal-400 font-black mb-6 tracking-widest">SAVE MANAGEMENT</h2>
        <div class="flex flex-col gap-3 w-72">
            <button id="export-btn" class="bg-gray-700 hover:bg-gray-600 text-white font-bold py-3 rounded transition-all">
                <i class="fas fa-download mr-2"></i>EXPORT SAVE
            </button>
            <button id="import-btn" class="bg-gray-700 hover:bg-gray-600 text-white font-bold py-3 rounded transition-all">
                <i class="fas fa-upload mr-2"></i>IMPORT SAVE
            </button>
            <input type="file" id="import-file-input" accept=".json" style="display: none;">
            <button id="save-close-btn" class="mt-4 border border-gray-500 text-gray-400 hover:text-white hover:border-white py-2 px-8 rounded transition-all">
                CLOSE
            </button>
        </div>
    </div>
    
    <!-- Test Mode Settings Modal -->
    <div id="test-mode-settings-modal" class="modal">
        <div class="bg-gray-900 bg-opacity-95 border-2 border-teal-600 rounded-lg p-6 max-w-2xl w-full max-h-[85vh] overflow-y-auto">
            <div class="flex items-center justify-between mb-4">
                <h2 class="text-2xl text-teal-400 font-black tracking-widest">
                    <i class="fas fa-cog mr-2"></i>TEST MODE SETTINGS
                </h2>
                <button id="test-settings-close" class="text-gray-500 hover:text-white text-2xl">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <p class="text-sm text-gray-400 mb-6">Configure your test scenario. Changes apply when you start a new game.</p>
            
            <div class="space-y-6">
                <!-- Starting Level -->
                <div>
                    <label class="text-sm font-bold text-teal-300 mb-2 block">STARTING LEVEL</label>
                    <div class="flex items-center gap-4">
                        <input type="range" id="test-level-slider" min="1" max="50" value="50" class="flex-1">
                        <span id="test-level-value" class="text-white font-bold text-lg w-12">50</span>
                    </div>
                    <p class="text-xs text-gray-500 mt-1">Level 50 triggers boss after 1 second</p>
                </div>
                
                <!-- Ship Selection -->
                <div>
                    <label class="text-sm font-bold text-teal-300 mb-2 block">SHIP</label>
                    <select id="test-ship-select" class="w-full bg-gray-800 text-white border border-gray-600 rounded px-3 py-2 font-mono text-sm">
                        <option value="pathfinder">Pathfinder (Balanced)</option>
                        <option value="engineer">Engineer (Support)</option>
                        <option value="disruptor">Disruptor (Tech)</option>
                        <option value="vanguard">Vanguard (Tank)</option>
                        <option value="reaper">Reaper (DPS)</option>
                        <option value="catalyst">Catalyst (Specialist)</option>
                    </select>
                </div>
                
                <!-- Weapon Loadout -->
                <div>
                    <label class="text-sm font-bold text-teal-300 mb-2 block">WEAPON LOADOUT & ELEMENTS</label>
                    <div class="space-y-2 mb-2">
                        <!-- Weapon 1 -->
                        <div class="flex gap-2">
                            <select id="test-weapon-1" class="flex-1 bg-gray-800 text-white border border-gray-600 rounded px-3 py-2 font-mono text-xs">
                                <option value="">-- Slot 1 (Starting Weapon) --</option>
                            </select>
                            <select id="test-element-1" class="w-32 bg-gray-800 text-white border border-gray-600 rounded px-2 py-2 font-mono text-xs">
                                <option value="random">Random</option>
                                <option value="fire">üî• Fire</option>
                                <option value="ice">‚ùÑÔ∏è Ice</option>
                                <option value="volt">‚ö° Volt</option>
                                <option value="bio">‚ò£Ô∏è Bio</option>
                                <option value="hack">üíª Hack</option>
                            </select>
                        </div>
                        <!-- Weapon 2 -->
                        <div class="flex gap-2">
                            <select id="test-weapon-2" class="flex-1 bg-gray-800 text-white border border-gray-600 rounded px-3 py-2 font-mono text-xs">
                                <option value="">-- Slot 2 --</option>
                            </select>
                            <select id="test-element-2" class="w-32 bg-gray-800 text-white border border-gray-600 rounded px-2 py-2 font-mono text-xs">
                                <option value="random">Random</option>
                                <option value="fire">üî• Fire</option>
                                <option value="ice">‚ùÑÔ∏è Ice</option>
                                <option value="volt">‚ö° Volt</option>
                                <option value="bio">‚ò£Ô∏è Bio</option>
                                <option value="hack">üíª Hack</option>
                            </select>
                        </div>
                        <!-- Weapon 3 -->
                        <div class="flex gap-2">
                            <select id="test-weapon-3" class="flex-1 bg-gray-800 text-white border border-gray-600 rounded px-3 py-2 font-mono text-xs">
                                <option value="">-- Slot 3 --</option>
                            </select>
                            <select id="test-element-3" class="w-32 bg-gray-800 text-white border border-gray-600 rounded px-2 py-2 font-mono text-xs">
                                <option value="random">Random</option>
                                <option value="fire">üî• Fire</option>
                                <option value="ice">‚ùÑÔ∏è Ice</option>
                                <option value="volt">‚ö° Volt</option>
                                <option value="bio">‚ò£Ô∏è Bio</option>
                                <option value="hack">üíª Hack</option>
                            </select>
                        </div>
                        <!-- Weapon 4 -->
                        <div class="flex gap-2">
                            <select id="test-weapon-4" class="flex-1 bg-gray-800 text-white border border-gray-600 rounded px-3 py-2 font-mono text-xs">
                                <option value="">-- Slot 4 --</option>
                            </select>
                            <select id="test-element-4" class="w-32 bg-gray-800 text-white border border-gray-600 rounded px-2 py-2 font-mono text-xs">
                                <option value="random">Random</option>
                                <option value="fire">üî• Fire</option>
                                <option value="ice">‚ùÑÔ∏è Ice</option>
                                <option value="volt">‚ö° Volt</option>
                                <option value="bio">‚ò£Ô∏è Bio</option>
                                <option value="hack">üíª Hack</option>
                            </select>
                        </div>
                    </div>
                    <button id="test-randomize-weapons" class="text-xs bg-gray-700 hover:bg-gray-600 text-gray-300 font-bold py-1 px-3 rounded">
                        <i class="fas fa-dice mr-1"></i>RANDOMIZE WEAPONS
                    </button>
                </div>
                
                <!-- Weapon Level -->
                <div>
                    <label class="text-sm font-bold text-teal-300 mb-2 block">WEAPON LEVEL</label>
                    <div class="flex items-center gap-4">
                        <input type="range" id="test-weapon-level-slider" min="1" max="10" value="10" class="flex-1">
                        <span id="test-weapon-level-value" class="text-white font-bold text-lg w-12">10</span>
                    </div>
                </div>
                
                <!-- Ultimate Selection -->
                <div>
                    <label class="text-sm font-bold text-teal-300 mb-2 block">ULTIMATE ABILITY</label>
                    <div class="flex gap-2">
                        <select id="test-ultimate-select" class="flex-1 bg-gray-800 text-white border border-gray-600 rounded px-3 py-2 font-mono text-sm">
                            <option value="">-- No Ultimate --</option>
                            <option value="random">Random Ultimate</option>
                            <option value="skyfall">Skyfall Beam</option>
                            <option value="event_horizon">Event Horizon</option>
                            <option value="seismic_bomb">Seismic Bomb</option>
                            <option value="phoenix_protocol">Phoenix Protocol</option>
                            <option value="adrenaline_surge">Adrenaline Surge</option>
                        </select>
                        <div class="flex items-center gap-2 bg-gray-800 border border-gray-600 rounded px-3">
                            <input type="checkbox" id="test-instant-ult" class="w-4 h-4">
                            <label for="test-instant-ult" class="text-xs font-bold text-yellow-300 whitespace-nowrap">
                                Instant Recharge
                            </label>
                        </div>
                    </div>
                    <p class="text-xs text-gray-500 mt-1">Instant recharge: Ultimate refills 3 seconds after use</p>
                </div>
                
                <!-- Ultimate Charge -->
                <div>
                    <label class="text-sm font-bold text-teal-300 mb-2 block">ULTIMATE STARTING CHARGE</label>
                    <div class="flex items-center gap-4">
                        <input type="range" id="test-ult-charge-slider" min="0" max="100" value="90" step="10" class="flex-1">
                        <span id="test-ult-charge-value" class="text-white font-bold text-lg w-12">90%</span>
                    </div>
                </div>
                
                <!-- God Mode -->
                <div class="flex items-center gap-3 bg-gray-800 p-3 rounded">
                    <input type="checkbox" id="test-god-mode" class="w-4 h-4" checked>
                    <label for="test-god-mode" class="text-sm font-bold text-yellow-300">
                        <i class="fas fa-shield-alt mr-2"></i>GOD MODE (Invulnerable)
                    </label>
                </div>
            </div>
            
            <!-- Action Buttons -->
            <div class="flex gap-3 mt-6">
                <button id="test-settings-apply" class="flex-1 bg-teal-600 hover:bg-teal-500 text-white font-bold py-3 rounded transition-all">
                    <i class="fas fa-check mr-2"></i>SAVE SETTINGS
                </button>
                <button id="test-settings-reset" class="bg-gray-700 hover:bg-gray-600 text-gray-300 font-bold py-3 px-6 rounded transition-all">
                    <i class="fas fa-undo mr-2"></i>RESET
                </button>
            </div>
        </div>
    </div>
    
    <!-- Mod Confirmation -->
    <div id="mod-confirm-screen" class="modal">
        <div id="mod-confirm-content" class="mb-6 text-center"></div>
        <!-- Old buttons hidden, using inline HTML from triggerModPickup -->
        <div class="flex gap-4" style="display: none;">
            <button id="mod-equip-btn" class="bg-teal-500 text-black font-bold py-3 px-6 rounded">EQUIP</button>
            <button id="mod-discard-btn" class="border border-gray-500 text-gray-400 py-3 px-6 rounded">DISCARD</button>
        </div>
    </div>
    
    <!-- Weapon Replace -->
    <div id="swap-screen" class="modal">
        <h2 class="text-3xl text-red-500 font-bold mb-2">SLOTS FULL</h2>
        <p class="text-gray-400 mb-6">Select a weapon to DISCARD</p>
        <div id="swap-container" class="w-full flex flex-col items-center"></div>
        <button onclick="cancelSwap()" class="mt-4 text-gray-500 hover:text-white">CANCEL</button>
    </div>


    <!-- Pause -->
    <div id="pause-screen" class="modal">
        <h2 class="text-4xl text-white font-bold mb-4 tracking-widest">SYSTEM PAUSED</h2>
        
        <!-- Tab buttons -->
        <div class="flex gap-4 mb-6 justify-center">
            <button id="stats-tab-btn" class="tab-btn active px-6 py-2 border-b-2 border-teal-500 text-teal-500 font-bold">STATS</button>
            <button id="kit-tab-btn" class="tab-btn px-6 py-2 border-b-2 border-transparent text-gray-400 font-bold hover:text-white">KIT</button>
        </div>
        
        <!-- Stats Tab -->
        <div id="stats-tab" class="tab-content">
            <div id="stats-grid"></div>
        </div>
        
        <!-- Kit Tab -->
        <div id="kit-tab" class="tab-content hidden">
            <div id="kit-grid" class="grid grid-cols-1 gap-4 max-w-2xl mx-auto mb-6 max-h-96 overflow-y-auto px-4"></div>
        </div>
        
        <button id="glossary-btn" class="border border-yellow-400 text-yellow-400 hover:bg-yellow-400/20 font-bold py-2 px-8 rounded mb-4">GLOSSARY</button>
        <button id="bug-report-btn" class="border border-orange-400 text-orange-400 hover:bg-orange-400/20 font-bold py-2 px-8 rounded mb-4">
            <i class="fas fa-bug mr-2"></i>CAPTURE BUG REPORT
        </button>
        <button id="resume-btn" class="bg-teal-500 hover:bg-teal-400 text-black font-bold py-3 px-10 rounded-sm skew-x-[-10deg] transition-all mb-4">RESUME</button>
        <button id="quit-btn" class="border-2 border-red-500 text-red-500 hover:bg-red-500 hover:text-white font-bold py-3 px-10 rounded-sm skew-x-[-10deg] transition-all">ABORT</button>
    </div>


    <!-- Glossary -->
    <div id="glossary-screen" class="modal">
        <h2 class="text-3xl text-white font-bold mb-6">GAME DATABASE</h2>
        <div class="w-full max-w-2xl h-96 overflow-y-auto px-4">
            <div class="text-xl text-teal-400 font-bold mb-3 mt-4">ELEMENTALS</div>
            <div class="glossary-item">
                <div class="g-title"><i class="fas fa-fire text-[#ff5722]"></i> PYRO</div>
                <div class="g-desc">Applies burn DOT for 6 seconds (8s with mastery). Starts at 40% weapon damage and ramps up 20% per tick. Tick rate doubles when hitting burning enemies. Can't Crit.</div>
            </div>
            <div class="glossary-item">
                <div class="g-title"><i class="fas fa-snowflake text-[#00e5ff]"></i> CRYO</div>
                <div class="g-desc">Applies 60% slow that spreads to nearby enemies. Enemies slowed for 2s freeze solid, becoming obstacles. Frozen enemies take +50% damage (mastery) or up to +100% (synergies). Can't Crit.</div>
            </div>
            <div class="glossary-item">
                <div class="g-title"><i class="fas fa-bolt text-[#ffeb3b]"></i> VOLT</div>
                <div class="g-desc">Strikes cause chain lightning to nearby enemies. Each jump has reduced damage and chain chance. Chains prioritize frozen enemies with synergies.</div>
            </div>
            <div class="glossary-item">
                <div class="g-title"><i class="fas fa-biohazard text-[#39ff14]"></i> BIO</div>
                <div class="g-desc">Applies poison DOT for 5 seconds dealing up to 200% weapon damage total. If the host dies, spawns a toxic cloud (100 radius) that damages and infects nearby enemies. Can't Crit.</div>
            </div>
            <div class="glossary-item">
                <div class="g-title"><i class="fas fa-terminal text-[#00ffaa]"></i> HACK</div>
                <div class="g-desc">50% chance to scramble enemy AI, causing them to move erratically and deal damage to other enemies they collide with.</div>
            </div>
            
            <div class="text-xl text-teal-400 font-bold mb-3 mt-6">CORE SYSTEMS</div>
            <div class="glossary-item">
                <div class="g-title"><i class="fas fa-shield-alt text-[#00d1b2]"></i> SHIELDS</div>
                <div class="g-desc">Ships have shield charges that block one hit each. Shields begin recharging after 10 seconds of not taking damage. Only one shield recharges at a time. Vanguard ship creates a massive shockwave when shields break.</div>
            </div>
            <div class="glossary-item">
                <div class="g-title"><i class="fas fa-redo text-[#ff6b9d]"></i> MULTISTRIKE</div>
                <div class="g-desc">10% base chance for attacks to trigger twice. The Cascade mod allows multistrikes to chain further with +25% chance and +25% damage per chain.</div>
            </div>
            <div class="glossary-item">
                <div class="g-title"><i class="fas fa-gem text-[#a855f7]"></i> NEXUS CORES</div>
                <div class="g-desc">Permanent currency earned from runs. Each boss drops 1 core. Higher scores and longer survival yield more cores. Used to unlock new ships.</div>
            </div>
            <div class="glossary-item">
                <div class="g-title"><i class="fas fa-atom text-[#ff00ff]"></i> QUANTUM SINGULARITIES</div>
                <div class="g-desc">Ultra-rare drops from Nexus Prime, the final boss. These singularities contain condensed power from the core of the Nexus network.</div>
            </div>
            <div class="glossary-item">
                <div class="g-title"><i class="fas fa-cog text-[#fbbf24]"></i> MODS</div>
                <div class="g-desc">Powerful passive buffs or abilities. Each Titan champion drops 1 mod crate, giving you a choice of 2 random mods. Examples: Repulsor (pushback aura), Cascade (multistrike chains), Temporal Shift (slow-motion on hit).</div>
            </div>
        </div>
        <button onclick="closeGlossary()" class="mt-6 text-gray-400 hover:text-white border border-gray-600 px-6 py-2 rounded">BACK</button>
    </div>


    <!-- Level Up -->
    <div id="levelup-screen" class="modal">
        <h2 id="lvl-title" class="text-3xl text-yellow-400 font-bold mb-1 drop-shadow-[0_0_10px_rgba(255,221,87,0.5)]">SYSTEM UPGRADE</h2>
        <p id="lvl-subtitle" class="text-sm text-gray-500 mb-2 uppercase tracking-widest">Select Augmentation</p>
        <p id="pending-upgrades" class="text-xs text-gray-600 mb-4" style="display: none;">Pending Upgrades: <span id="pending-count" class="text-teal-400">0</span></p>
        
        <div id="lock-kit-toggle" class="toggle-container" onclick="toggleLockKit()" style="display:none;">
            <div class="toggle-switch"></div>
            <div class="text-gray-300 text-sm font-bold">LOCK KIT (NO NEW WEAPONS)</div>
        </div>


        <div id="cards-container" class="cards-grid"></div>
        <div class="upgrade-buttons">
            <button id="reroll-btn" onclick="rerollUpgrades()"><i class="fas fa-dice"></i> REROLL (<span id="reroll-count">3</span>)</button>
            <button id="save-btn" onclick="toggleSaveMode()"><i class="fas fa-save"></i> SAVE (<span id="save-count">3</span>)</button>
        </div>
    </div>


    <!-- Game Over -->
    <div id="gameover-screen" class="modal">
        <h2 class="text-5xl text-red-600 font-black mb-2 drop-shadow-[0_0_20px_rgba(255,56,96,0.5)]">TERMINATED</h2>
        <div class="flex gap-6 mb-4 font-mono text-gray-300">
            <p>LEVEL: <span id="final-level" class="text-white text-xl">1</span></p>
            <p>SCORE: <span id="final-score" class="text-white text-xl">0</span></p>
            <p>TIME: <span id="final-time" class="text-white text-xl">00:00</span></p>
        </div>
        
        <!-- Weapon Stats Breakdown -->
        <div id="weapon-breakdown" class="mb-4 max-h-64 overflow-y-auto bg-black bg-opacity-40 p-3 rounded border border-gray-700" style="max-width: 500px;">
            <h3 class="text-xl text-teal-400 font-bold mb-3 font-mono">WEAPON PERFORMANCE</h3>
            <div id="weapon-stats-list" class="space-y-2 text-left font-mono text-sm">
                <!-- Will be populated by JavaScript -->
            </div>
        </div>
        
        <div class="flex flex-col gap-3 w-64">
            <button id="restart-btn" class="border-2 border-teal-500 text-teal-500 hover:bg-teal-500 hover:text-white font-bold py-3 px-10 rounded-sm skew-x-[-10deg] transition-all"><span class="inline-block skew-x-[10deg]">RETURN</span></button>
            <button id="death-recap-btn" class="bg-red-900 hover:bg-red-800 text-white text-sm font-bold py-2 rounded transition-all border border-red-700">
                <i class="fas fa-skull-crossbones mr-2"></i>DEATH RECAP
            </button>
            <button id="gameover-export-btn" class="bg-gray-700 hover:bg-gray-600 text-white text-sm font-bold py-2 rounded transition-all">
                <i class="fas fa-download mr-2"></i>EXPORT SAVE
            </button>
        </div>
    </div>

    <!-- Death Recap Modal -->
    <div id="death-recap-modal" class="modal">
        <div class="bg-gray-900 bg-opacity-95 border-2 border-red-600 rounded-lg p-6 max-w-2xl w-full">
            <h2 class="text-3xl text-red-500 font-black mb-4 tracking-widest text-center flex items-center justify-center gap-3">
                <i class="fas fa-skull-crossbones"></i>
                DEATH RECAP
                <i class="fas fa-skull-crossbones"></i>
            </h2>
            <p class="text-gray-400 text-sm mb-4 text-center">Last 5 damage instances before death</p>
            
            <div id="death-recap-list" class="space-y-2 mb-6 max-h-96 overflow-y-auto">
                <!-- Populated by JavaScript -->
            </div>
            
            <div class="text-center">
                <button id="close-death-recap" class="bg-gray-700 hover:bg-gray-600 text-white font-bold py-2 px-6 rounded transition-all">
                    CLOSE
                </button>
            </div>
        </div>
    </div>


    <!-- Stats Screen -->
    <div id="stats-screen" class="modal">
        <h2 class="text-4xl text-teal-400 font-black mb-6 tracking-widest">PROGRESSION STATS</h2>
        <div class="bg-gray-900 bg-opacity-80 border border-teal-500 rounded-lg p-6 w-80 font-mono">
            <div class="space-y-3 text-left">
                <div class="flex justify-between border-b border-gray-700 pb-2">
                    <span class="text-gray-400">Quantum Singularities:</span>
                    <span id="stat-singularities" class="text-yellow-300 font-bold">0</span>
                </div>
                <div class="flex justify-between border-b border-gray-700 pb-2">
                    <span class="text-gray-400">Nexus Cores:</span>
                    <span id="stat-cores" class="text-purple-400 font-bold">0</span>
                </div>
                <div class="flex justify-between border-b border-gray-700 pb-2">
                    <span class="text-gray-400">Total Runs:</span>
                    <span id="stat-runs" class="text-white font-bold">0</span>
                </div>
                <div class="flex justify-between border-b border-gray-700 pb-2">
                    <span class="text-gray-400">Total Kills:</span>
                    <span id="stat-kills" class="text-orange-400 font-bold">0</span>
                </div>
                <div class="flex justify-between border-b border-gray-700 pb-2">
                    <span class="text-gray-400">Highest Level:</span>
                    <span id="stat-level" class="text-yellow-400 font-bold">0</span>
                </div>
                <div class="flex justify-between border-b border-gray-700 pb-2">
                    <span class="text-gray-400">Highest Score:</span>
                    <span id="stat-score" class="text-teal-400 font-bold">0</span>
                </div>
                <div class="flex justify-between">
                    <span class="text-gray-400">Total Playtime:</span>
                    <span id="stat-time" class="text-blue-400 font-bold">0h 0m</span>
                </div>
            </div>
        </div>
        <button id="close-stats-btn" class="mt-6 border border-gray-500 text-gray-400 hover:text-white hover:border-white py-2 px-8 rounded transition-all">
            CLOSE
        </button>
    </div>
    
    <!-- Systems Unlocked Notification Modal -->
    <div id="unlock-notification-screen" class="modal" style="background: rgba(0, 0, 0, 0.98);">
        <!-- Header -->
        <div class="text-center mb-8">
            <div class="text-6xl mb-4 pulse-anim" style="color: #a855f7; text-shadow: 0 0 8px rgba(168, 85, 247, 0.4);">
                <i class="fas fa-trophy"></i>
            </div>
            <h1 class="text-5xl font-black mb-3" style="color: #ec4899; text-shadow: 0 0 10px rgba(236, 72, 153, 0.3);">
                VICTORY ACHIEVED
            </h1>
            <p class="text-xl text-purple-300">
                NEXUS PRIME DEFEATED
            </p>
        </div>

        <!-- Unlock Notification -->
        <div class="bg-gradient-to-br from-purple-900/40 to-pink-900/20 rounded-lg p-8 mb-6 border-2 border-purple-500/50 max-w-4xl">
            <div class="text-center mb-8">
                <div class="text-3xl font-bold mb-2 text-purple-200">
                    NEW SYSTEMS UNLOCKED
                </div>
                <p class="text-gray-300 text-lg">
                    Post-game progression systems are now available!
                </p>
            </div>

            <!-- Two Systems Grid -->
            <div class="grid md:grid-cols-2 gap-6 mb-6">
                <!-- Nexus Ascension -->
                <div class="rounded-lg p-6 bg-gradient-to-br from-purple-900/20 to-transparent border border-purple-500/30 hover:border-purple-500/60 transition-all">
                    <div class="flex items-center gap-4 mb-4">
                        <div class="text-5xl" style="color: #ff3860;">
                            <i class="fas fa-layer-group"></i>
                        </div>
                        <div>
                            <h3 class="text-2xl font-bold text-red-400">NEXUS ASCENSION</h3>
                            <p class="text-sm text-gray-400">Difficulty Tiers</p>
                        </div>
                    </div>
                    <div class="space-y-3 text-sm text-gray-200">
                        <p class="leading-relaxed">
                            <strong class="text-purple-300">Five progressive difficulty levels</strong> that challenge you with unique debuffs and enemy buffs.
                        </p>
                        <p class="pt-2">
                            <strong class="text-yellow-300">Rewards:</strong> Earn <span class="text-yellow-400">Nexus Cores</span> and <span class="text-pink-400">Singularities</span> to upgrade augments!
                        </p>
                    </div>
                </div>

                <!-- Augment Lab -->
                <div class="rounded-lg p-6 bg-gradient-to-br from-cyan-900/20 to-transparent border border-cyan-500/30 hover:border-cyan-500/60 transition-all">
                    <div class="flex items-center gap-4 mb-4">
                        <div class="text-5xl" style="color: #00d1b2;">
                            <i class="fas fa-flask"></i>
                        </div>
                        <div>
                            <h3 class="text-2xl font-bold text-cyan-400">AUGMENT LAB</h3>
                            <p class="text-sm text-gray-400">Permanent Upgrades</p>
                        </div>
                    </div>
                    <div class="space-y-3 text-sm text-gray-200">
                        <p class="leading-relaxed">
                            <strong class="text-purple-300">Permanent augments</strong> that carry between runs. Each has 3 upgrade tiers for increased power!
                        </p>
                        <p class="pt-2">
                            <strong class="text-cyan-300">Build your loadout:</strong> Equip up to <span class="text-yellow-400">3 augments</span> that synergize with your playstyle!
                        </p>
                    </div>
                </div>
            </div>

            <!-- How It Works -->
            <div class="bg-black/40 rounded-lg p-6 border border-purple-500/30">
                <h4 class="text-xl font-bold text-purple-300 mb-4 flex items-center gap-2">
                    <i class="fas fa-info-circle"></i>
                    How It Works
                </h4>
                <div class="grid md:grid-cols-2 gap-4 text-sm text-gray-200">
                    <div class="space-y-2">
                        <div class="flex items-start gap-2">
                            <span class="text-purple-400 font-bold">1.</span>
                            <span>Visit the <strong>Augment Lab</strong> to unlock and upgrade permanent augments</span>
                        </div>
                        <div class="flex items-start gap-2">
                            <span class="text-purple-400 font-bold">2.</span>
                            <span>Select your <strong>Ascension Level</strong> before each run for increased difficulty</span>
                        </div>
                    </div>
                    <div class="space-y-2">
                        <div class="flex items-start gap-2">
                            <span class="text-purple-400 font-bold">3.</span>
                            <span><strong>Equip augments</strong> to power up your ship in Ascension runs</span>
                        </div>
                        <div class="flex items-start gap-2">
                            <span class="text-purple-400 font-bold">4.</span>
                            <span>Higher tiers = More challenge, but <strong>much better rewards!</strong></span>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Continue Button -->
        <button id="unlock-notification-continue-btn" class="bg-gradient-to-r from-purple-600 to-pink-600 hover:from-purple-500 hover:to-pink-500 text-white text-xl font-bold px-12 py-4 rounded-lg transition-all transform hover:scale-105 border-2 border-purple-400">
            <i class="fas fa-rocket mr-2"></i>
            CONTINUE TO HANGAR
        </button>
        <p class="text-gray-400 text-sm mt-3">
            Access these systems anytime from the main menu
        </p>
    </div>
    
    <!-- Augment Lab Screen -->
    <div id="augment-lab-screen" class="modal">
        <h2 class="text-4xl text-purple-400 font-black mb-2 tracking-widest drop-shadow-[0_0_20px_rgba(168,85,247,0.6)]">AUGMENT LAB</h2>
        <p class="text-sm text-gray-400 mb-4">Unlock permanent upgrades with Nexus Cores and Quantum Singularities</p>
        
        <!-- Filter Buttons by Category -->
        <div class="flex gap-2 mb-4">
            <button class="augment-filter-btn active text-xs px-4 py-2 rounded bg-gray-700 text-white font-bold" data-category="all">ALL</button>
            <button class="augment-filter-btn text-xs px-4 py-2 rounded bg-gray-700 text-gray-400 hover:text-white font-bold" data-category="offense">
                <i class="fas fa-crosshairs mr-1"></i>OFFENSE
            </button>
            <button class="augment-filter-btn text-xs px-4 py-2 rounded bg-gray-700 text-gray-400 hover:text-white font-bold" data-category="defense">
                <i class="fas fa-shield mr-1"></i>DEFENSE
            </button>
            <button class="augment-filter-btn text-xs px-4 py-2 rounded bg-gray-700 text-gray-400 hover:text-white font-bold" data-category="utility">
                <i class="fas fa-tools mr-1"></i>UTILITY
            </button>
        </div>
        
        <!-- Augment Cards List (Vertical Stack) -->
        <div id="augment-cards-grid" class="flex flex-col gap-2 max-w-3xl mx-auto overflow-y-auto px-2 mb-4" style="max-height: 400px; min-height: 200px;">
            <!-- Augment cards will be dynamically inserted here -->
        </div>
        
        <!-- Currency Display at Bottom -->
        <div class="flex gap-6 mb-4 text-sm font-mono justify-center bg-gray-900 bg-opacity-80 border border-purple-700 rounded-lg py-2 px-4">
            <div class="flex items-center gap-2">
                <i class="fas fa-gem text-yellow-300"></i>
                <span class="text-gray-400">Singularities:</span>
                <span id="lab-singularities" class="text-yellow-300 font-bold">0</span>
            </div>
            <div class="flex items-center gap-2">
                <i class="fas fa-circle text-purple-400"></i>
                <span class="text-gray-400">Cores:</span>
                <span id="lab-cores" class="text-purple-400 font-bold">0</span>
            </div>
        </div>
        
        <!-- Close Button -->
        <button id="close-lab-btn" class="border border-gray-500 text-gray-400 hover:text-white hover:border-white py-2 px-8 rounded transition-all">
            CLOSE
        </button>
    </div>


    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d', { alpha: false });
        let width, height;
        const resize = () => { width = canvas.width = window.innerWidth; height = canvas.height = window.innerHeight; };
        window.addEventListener('resize', resize); resize();

        // SEEDED RNG SYSTEM
        // Allows for reproducible runs by using a seed instead of seededRandom()
        let rngSeed = 0;
        
        function seededRandom() {
            // Linear Congruential Generator (LCG)
            rngSeed = (rngSeed * 9301 + 49297) % 233280;
            return rngSeed / 233280;
        }
        
        function setSeed(seed) {
            rngSeed = seed;
        }
        
        function generateSeed() {
            // Generate 6-digit seed using true randomness (not seeded)
            const trueRandom = Math.random;
            return Math.floor(100000 + trueRandom() * 900000);
        }

        // ===== SPATIAL HASH GRID SYSTEM =====
        // Performance optimization for collision detection
        // Reduces O(n¬≤) to O(n) by partitioning space into cells
        const spatialGrid = {
            cellSize: 150, // Cell size in game units (tuned for typical enemy spread)
            cells: new Map(),
            
            // Clear all cells (call at start of each frame)
            clear() {
                this.cells.clear();
            },
            
            // Insert entity into grid
            insert(entity, x, y) {
                const cellX = Math.floor(x / this.cellSize);
                const cellY = Math.floor(y / this.cellSize);
                const key = `${cellX},${cellY}`;
                
                if (!this.cells.has(key)) {
                    this.cells.set(key, []);
                }
                this.cells.get(key).push(entity);
            },
            
            // Get all entities in nearby cells (3x3 grid around position)
            getNearby(x, y, radius = 0) {
                const cellX = Math.floor(x / this.cellSize);
                const cellY = Math.floor(y / this.cellSize);
                const nearby = [];
                
                // Calculate how many cells to check based on radius
                const cellRadius = Math.ceil(radius / this.cellSize);
                
                // Check surrounding cells
                for (let dx = -cellRadius; dx <= cellRadius; dx++) {
                    for (let dy = -cellRadius; dy <= cellRadius; dy++) {
                        const key = `${cellX + dx},${cellY + dy}`;
                        if (this.cells.has(key)) {
                            nearby.push(...this.cells.get(key));
                        }
                    }
                }
                
                return nearby;
            },
            
            // Debug: Show grid statistics
            getStats() {
                const cellCount = this.cells.size;
                let totalEntities = 0;
                let maxEntitiesInCell = 0;
                
                this.cells.forEach(cell => {
                    totalEntities += cell.length;
                    maxEntitiesInCell = Math.max(maxEntitiesInCell, cell.length);
                });
                
                return {
                    cells: cellCount,
                    totalEntities,
                    avgPerCell: cellCount > 0 ? (totalEntities / cellCount).toFixed(1) : 0,
                    maxInCell: maxEntitiesInCell
                };
            }
        };
        // ===== END SPATIAL HASH GRID =====

        // ===== PARTICLE POOLING SYSTEM =====
        // Performance optimization to avoid object creation/destruction overhead
        // Reduces GC pauses and improves frame consistency
        const particlePool = {
            pool: [],
            maxPoolSize: 500, // Maximum particles to keep in pool
            
            // Get a particle from pool or create new one
            spawn(x, y, color, speed) {
                let particle;
                if (this.pool.length > 0) {
                    // Reuse from pool
                    particle = this.pool.pop();
                    particle.reset(x, y, color, speed);
                } else {
                    // Create new if pool empty
                    particle = new Particle(x, y, color, speed);
                }
                return particle;
            },
            
            // Return particle to pool for reuse
            recycle(particle) {
                if (this.pool.length < this.maxPoolSize) {
                    this.pool.push(particle);
                }
                // If pool is full, let it be garbage collected
            },
            
            // Get pool statistics
            getStats() {
                return {
                    pooled: this.pool.length,
                    maxSize: this.maxPoolSize,
                    utilizationPercent: ((this.pool.length / this.maxPoolSize) * 100).toFixed(1)
                };
            }
        };
        // ===== END PARTICLE POOLING =====

        // ===== CONSOLE ERROR TRACKING =====
        const consoleErrors = [];
        const MAX_ERRORS_STORED = 50;
        
        // Override console.error to capture errors
        const originalConsoleError = console.error;
        console.error = function(...args) {
            // Call original console.error
            originalConsoleError.apply(console, args);
            
            // Store error with timestamp and stack trace
            const errorText = args.map(arg => {
                if (typeof arg === 'object') {
                    try {
                        return JSON.stringify(arg);
                    } catch {
                        return String(arg);
                    }
                }
                return String(arg);
            }).join(' ');
            
            // Capture stack trace to get line number
            const stack = new Error().stack;
            const stackLines = stack ? stack.split('\n') : [];
            // Skip first 2 lines (Error creation and this function)
            const callerLine = stackLines[2] || '';
            // Extract line number from stack trace (e.g., "at functionName (file.js:123:45)")
            const lineMatch = callerLine.match(/:(\d+):(\d+)/);
            const lineNumber = lineMatch ? `Line ${lineMatch[1]}:${lineMatch[2]}` : 'unknown';
            
            consoleErrors.push({
                timestamp: new Date().toISOString(),
                message: errorText,
                line: lineNumber,
                stackTrace: stackLines.slice(2, 5).join('\n'), // Keep top 3 stack frames
                time: Date.now()
            });
            
            // Keep only last MAX_ERRORS_STORED errors
            if (consoleErrors.length > MAX_ERRORS_STORED) {
                consoleErrors.shift();
            }
        };
        
        // Also capture window.onerror
        window.addEventListener('error', (event) => {
            const errorText = `Uncaught error: ${event.message}`;
            const lineInfo = event.filename ? ` at ${event.filename.split('/').pop()}:${event.lineno}:${event.colno}` : '';
            
            consoleErrors.push({
                timestamp: new Date().toISOString(),
                message: errorText,
                line: event.lineno ? `Line ${event.lineno}:${event.colno}` : 'unknown',
                stackTrace: lineInfo,
                time: Date.now()
            });
            
            if (consoleErrors.length > MAX_ERRORS_STORED) {
                consoleErrors.shift();
            }
        });
        // ===== END CONSOLE ERROR TRACKING =====

        const state = {
            screen: 'menu', score: 0, startTime: 0, level: 1, xp: 0, xpToNext: 10,
            lastTime: 0, camera: { x: 0, y: 0 }, shake: 0, frameCount: 0, rerolls: 3,
            paused: false, timeScale: 1.0, pendingLevelUps: 0, zoom: 0.70,
            upgradeQueue: [], // Queue for all upgrade screens (level ups and ultimate selection)
            pendingSwap: null, bossActive: false, bossWave: 0,
            gameTime: 0,
            spawnTimer: 0, // Framerate-independent enemy spawning
            pendingMod: null, lastTap: 0,
            weaponStats: {}, // Track damage and kills per weapon
            kitLocked: false,
            lockUsed: false,
            breathingRoomTimer: 0,
            saveCharges: 3,
            savedUpgrade: null,
            finalBossTriggered: false, // Level 50 boss
            finalBossActive: false, // Boss fight in progress
            finalBossDefeated: false, // Boss has been defeated (prevents respawn)
            finalBoss: null, // Reference to NEXUS PRIME
            levelUpDelay: null, // Delay before showing upgrade screen (lets XP collection finish)
            elementsProcced: new Set(), // Track which elements have procced this run (for CATALYST achievement)
            pendingUltimateSelection: false, // Trigger ultimate selection after Titan defeat
            cameraLocked: false, // Lock camera during ultimate cinematics
            ultimateCameraTarget: null, // Target enemy to track during ultimate
            manualCameraControl: false, // Manual camera pan mode (prevents game loop interference)
            // Ascension System
            activeAscension: 0, // Current ascension level for this run (0 = normal mode)
            bloodlustTimer: 0, // Timer for Ascension 2 stacking (seconds without damage)
            bloodlustStacks: 0, // Current bloodlust damage bonus stacks
            playerDead: false // Flag to prevent multiple death triggers
        };


        const input = { active: false, origin: {x:0,y:0}, current: {x:0,y:0}, vector: {x:0,y:0} };


        let player;
        let nextEnemyId = 0; // Global counter for unique enemy IDs
        let entities = { enemies: [], projectiles: [], enemyProjectiles: [], particles: [], pickups: [], texts: [], lightnings: [], gasClouds: [] };
        let animationFrameId;


        // --- Defs ---
        const weaponDefs = {
            ion: { id: 'ion', type: 'weapon', name: 'Ion Cannon', icon: 'fa-crosshairs', desc: 'Stationed turrets firing energy blasts.', offensive: true, validUpgrades: ['dmg', 'rate'], shipLocked: 'PATHFINDER' },
            turret: { id: 'turret', type: 'weapon', name: 'Auto-Turret', icon: 'fa-chess-rook', desc: 'Deploys stationary turrets that auto-fire.', offensive: true, validUpgrades: ['dmg', 'rate', 'area'], shipLocked: 'ENGINEER' },
            emp: { id: 'emp', type: 'weapon', name: 'EMP Pulse', icon: 'fa-bullseye', desc: 'Slowing pulses that create lingering fields.', offensive: true, validUpgrades: ['dmg', 'rate', 'area'], shipLocked: 'DISRUPTOR' },
            barrier: { id: 'barrier', type: 'weapon', name: 'Kinetic Barrier', icon: 'fa-shield-alt', desc: 'Frontal energy plow that damages, deflects enemies, and redirects projectiles.', offensive: true, validUpgrades: ['dmg', 'area'], shipLocked: 'VANGUARD' },
            orbital: { id: 'orbital', type: 'weapon', name: 'Bladestorm', icon: 'fa-compact-disc', desc: 'Spinning energy blades orbit the ship at close range.', offensive: true, validUpgrades: ['dmg', 'rate', 'area'], shipLocked: 'REAPER' },
            surge: { id: 'surge', type: 'weapon', name: 'Elemental Surge', icon: 'fa-atom', desc: 'Cycles through elemental orbs. Every 5th hit triggers a burst.', offensive: true, validUpgrades: ['dmg', 'rate', 'area'], shipLocked: 'CATALYST' },
            beam: { id: 'beam', type: 'weapon', name: 'Plasma Beam', icon: 'fa-fire', desc: 'Continuous energy beam.', offensive: true, validUpgrades: ['dmg', 'rate', 'area'] },
            seeker: { id: 'seeker', type: 'weapon', name: 'Seeker Swarm', icon: 'fa-rocket', desc: 'Launches homing missiles.', offensive: true, validUpgrades: ['dmg', 'rate', 'area'] },
            rad: { id: 'rad', type: 'weapon', name: 'Rad-Field', icon: 'fa-radiation', desc: 'Emits a damaging aura.', offensive: true, validUpgrades: ['dmg', 'area'] },
            tesla: { id: 'tesla', type: 'weapon', name: 'Tesla Coil', icon: 'fa-bolt', desc: 'Zaps nearby enemies.', offensive: true, validUpgrades: ['dmg', 'rate', 'area'] },

            whip: { id: 'whip', type: 'weapon', name: 'Plasma Whip', icon: 'fa-slash', desc: 'Energy whip slashes in a wide arc. Returns bullets back to sender.', offensive: true, validUpgrades: ['dmg', 'rate', 'area'] },
            meteor: { id: 'meteor', type: 'weapon', name: 'Meteor Strike', icon: 'fa-meteor', desc: 'Calls down an orbital strike.', offensive: true, validUpgrades: ['dmg', 'rate', 'area'] },
            railgun: { id: 'railgun', type: 'weapon', name: 'Railgun', icon: 'fa-long-arrow-alt-right', desc: 'Fires a piercing high-velocity slug.', offensive: true, validUpgrades: ['dmg', 'rate', 'area'] },
            flak: { id: 'flak', type: 'weapon', name: 'Flak Cannon', icon: 'fa-bomb', desc: 'Fires a shell that bursts into shrapnel.', offensive: true, validUpgrades: ['dmg', 'rate', 'area'] },
            pylons: { id: 'pylons', type: 'weapon', name: 'Energy Pylons', icon: 'fa-project-diagram', desc: 'Energy pylons damage enemies crossing between them.', offensive: true, validUpgrades: ['dmg', 'rate', 'area'] },
            ricochet: { id: 'ricochet', type: 'weapon', name: 'Ricochet Disc', icon: 'fa-circle-notch', desc: 'Bouncing projectile chains between enemies.', offensive: true, validUpgrades: ['dmg', 'rate', 'area'] },
            drones: { id: 'drones', type: 'weapon', name: 'Combat Drones', icon: 'fa-fighter-jet', desc: 'Autonomous drones fire at nearby enemies.', offensive: true, validUpgrades: ['dmg', 'rate', 'area'] },
            mines: { id: 'mines', type: 'weapon', name: 'Collapsar Mines', icon: 'fa-gem', desc: 'Hovering mines pull enemies in before detonating.', offensive: true, validUpgrades: ['dmg', 'rate', 'area'] },
            gas: { id: 'gas', type: 'weapon', name: 'Toxic Barrage', icon: 'fa-cloud', desc: 'Carpets enemy clusters with poison clouds.', offensive: true, validUpgrades: ['dmg', 'rate', 'area'] }
        };


        const modDefs = {
            // KEEP - Good mods
            repulsor: { id: 'repulsor', name: 'Magnetic Repulsor', icon: 'fa-shield-alt', desc: 'Constantly pushes drones and swarms away.' },
            revive: { id: 'revive', name: 'Second Chance', icon: 'fa-heart', desc: 'Survive fatal damage once per 2 min, restore 50% HP.' },
            berserker: { id: 'berserker', name: 'Berserker Module', icon: 'fa-heart-pulse', desc: 'Gain +10% damage for every 20% HP missing.' },
            cascade: { id: 'cascade', name: 'Cascade Amplifier', icon: 'fa-sitemap', desc: 'Multistrikes can chain. +25% multistrike chance, +25% multistrike damage.' },
            
            // NEW - Powerful replacement mods
            momentum: { id: 'momentum', name: 'Momentum Strike', icon: 'fa-angle-double-up', desc: 'Deal +2% damage for each second without taking damage (max +40% at 20s).' },
            glasscannon: { id: 'glasscannon', name: 'Glass Cannon Core', icon: 'fa-skull-crossbones', desc: '+50% Damage, +30% Damage Taken.' },
            reaper: { id: 'reaper', name: 'Reaper Rounds', icon: 'fa-plus', desc: 'Killing enemies restores 1 HP (max 5 HP/sec).' },
            thrust: { id: 'thrust', name: 'Emergency Thrust', icon: 'fa-rocket', desc: 'When hit, gain +50% speed for 2s (10s cooldown).' }
        };

        // ===== AUGMENT SYSTEM =====
        // Complete augment definitions with all 15 augments (5 Common, 7 Rare, 3 Epic)
        const augmentDefs = {
            // COMMON AUGMENTS (5)
            armor_piercing: {
                id: 'armor_piercing',
                name: 'Armor Piercing',
                category: 'offense',
                rarity: 'common',
                icon: 'fa-crosshairs',
                tiers: [
                    { level: 1, effect: 0.15, costCores: 25, costSingularities: 0, desc: 'Ignore 15% of enemy armor' },
                    { level: 2, effect: 0.25, costCores: 50, costSingularities: 0, desc: 'Ignore 25% of enemy armor' },
                    { level: 3, effect: 0.40, costCores: 75, costSingularities: 1, desc: 'Ignore 40% of enemy armor' }
                ]
            },
            fortified_hull: {
                id: 'fortified_hull',
                name: 'Fortified Hull',
                category: 'defense',
                rarity: 'common',
                icon: 'fa-heart',
                tiers: [
                    { level: 1, hpBonus: 0.15, upgradeBonus: 0.15, costCores: 25, costSingularities: 0, desc: '+15% max HP and HP upgrades' },
                    { level: 2, hpBonus: 0.25, upgradeBonus: 0.25, costCores: 50, costSingularities: 0, desc: '+25% max HP and HP upgrades' },
                    { level: 3, hpBonus: 0.40, upgradeBonus: 0.40, costCores: 75, costSingularities: 1, desc: '+40% max HP and HP upgrades' }
                ]
            },
            treasure_hunter: {
                id: 'treasure_hunter',
                name: 'Treasure Hunter',
                category: 'utility',
                rarity: 'common',
                icon: 'fa-gem',
                tiers: [
                    { level: 1, pickupRadius: 0.25, xpBonus: 0.15, costCores: 25, costSingularities: 0, desc: '+25% pickup radius, +15% XP gain' },
                    { level: 2, pickupRadius: 0.50, xpBonus: 0.30, costCores: 50, costSingularities: 0, desc: '+50% pickup radius, +30% XP gain' },
                    { level: 3, pickupRadius: 0.75, xpBonus: 0.50, costCores: 75, costSingularities: 1, desc: '+75% pickup radius, +50% XP gain' }
                ]
            },
            rapid_fire: {
                id: 'rapid_fire',
                name: 'Rapid Fire',
                category: 'offense',
                rarity: 'common',
                icon: 'fa-bolt',
                tiers: [
                    { level: 1, fireRateBonus: 0.20, damageReduction: 0.08, costCores: 25, costSingularities: 0, desc: '+20% fire rate, -8% damage per shot' },
                    { level: 2, fireRateBonus: 0.35, damageReduction: 0.08, costCores: 50, costSingularities: 0, desc: '+35% fire rate, -8% damage per shot' },
                    { level: 3, fireRateBonus: 0.50, damageReduction: 0.08, costCores: 75, costSingularities: 1, desc: '+50% fire rate, -8% damage per shot' }
                ]
            },
            nanite_swarm: {
                id: 'nanite_swarm',
                name: 'Nanite Swarm',
                category: 'defense',
                rarity: 'common',
                icon: 'fa-heartbeat',
                tiers: [
                    { level: 1, healPerSecond: 1, costCores: 25, costSingularities: 0, desc: 'Heal 1 HP per second' },
                    { level: 2, healPerSecond: 2, costCores: 50, costSingularities: 0, desc: 'Heal 2 HP per second' },
                    { level: 3, healPerSecond: 3, costCores: 75, costSingularities: 1, desc: 'Heal 3 HP per second' }
                ]
            },
            
            // RARE AUGMENTS (7)
            critical_mass: {
                id: 'critical_mass',
                name: 'Critical Mass',
                category: 'offense',
                rarity: 'rare',
                icon: 'fa-star',
                tiers: [
                    { level: 1, critChance: 0.10, critDamage: 0.10, costCores: 50, costSingularities: 0, desc: '+10% crit chance, +10% crit damage (adds to base 7% chance, 50% damage)' },
                    { level: 2, critChance: 0.20, critDamage: 0.20, costCores: 100, costSingularities: 0, desc: '+20% crit chance, +20% crit damage (adds to base 7% chance, 50% damage)' },
                    { level: 3, critChance: 0.30, critDamage: 0.30, costCores: 150, costSingularities: 2, desc: '+30% crit chance, +30% crit damage (adds to base 7% chance, 50% damage)' }
                ]
            },
            titan_slayer: {
                id: 'titan_slayer',
                name: 'Titan Slayer',
                category: 'offense',
                rarity: 'rare',
                icon: 'fa-dragon',
                tiers: [
                    { level: 1, bossDamage: 0.50, costCores: 50, costSingularities: 0, desc: '+50% damage to champions/bosses' },
                    { level: 2, bossDamage: 1.00, costCores: 100, costSingularities: 0, desc: '+100% damage to champions/bosses' },
                    { level: 3, bossDamage: 1.50, costCores: 150, costSingularities: 2, desc: '+150% damage to champions/bosses' }
                ]
            },
            adaptive_armor: {
                id: 'adaptive_armor',
                name: 'Adaptive Armor',
                category: 'defense',
                rarity: 'rare',
                icon: 'fa-shield',
                tiers: [
                    { level: 1, armorPerSecond: 0.01, maxStacks: 20, costCores: 50, costSingularities: 0, desc: 'Gain +1% armor/sec without damage (max 20%, resets on hit)' },
                    { level: 2, armorPerSecond: 0.01, maxStacks: 40, costCores: 100, costSingularities: 0, desc: 'Gain +1% armor/sec without damage (max 40%, resets on hit)' },
                    { level: 3, armorPerSecond: 0.01, maxStacks: 60, costCores: 150, costSingularities: 2, desc: 'Gain +1% armor/sec without damage (max 60%, resets on hit)' }
                ]
            },
            elemental_savant: {
                id: 'elemental_savant',
                name: 'Elemental Savant',
                category: 'utility',
                rarity: 'rare',
                icon: 'fa-atom',
                tiers: [
                    { level: 1, procBonus: 0.10, damageBonus: 0.25, costCores: 50, costSingularities: 0, desc: '+10% elemental proc chance, +25% elemental damage' },
                    { level: 2, procBonus: 0.15, damageBonus: 0.40, costCores: 100, costSingularities: 0, desc: '+15% elemental proc chance, +40% elemental damage' },
                    { level: 3, procBonus: 0.25, damageBonus: 0.60, costCores: 150, costSingularities: 2, desc: '+25% elemental proc chance, +60% elemental damage' }
                ]
            },
            shield_capacitor: {
                id: 'shield_capacitor',
                name: 'Shield Capacitor',
                category: 'defense',
                rarity: 'rare',
                icon: 'fa-battery-full',
                tiers: [
                    { level: 1, rechargeSpeedBonus: 0.25, charges: 0, costCores: 50, costSingularities: 0, desc: '+25% shield recharge speed' },
                    { level: 2, rechargeSpeedBonus: 0.50, charges: 0, costCores: 100, costSingularities: 0, desc: '+50% shield recharge speed' },
                    { level: 3, rechargeSpeedBonus: 0.50, charges: 1, costCores: 150, costSingularities: 2, desc: '+50% shield recharge speed, +1 shield charge' }
                ]
            },
            combat_stimulant: {
                id: 'combat_stimulant',
                name: 'Combat Stimulant',
                category: 'offense',
                rarity: 'rare',
                icon: 'fa-syringe',
                tiers: [
                    { level: 1, damageBonus: 0.15, duration: 3, costCores: 50, costSingularities: 0, desc: 'Gain +15% damage for 3s after taking hit' },
                    { level: 2, damageBonus: 0.25, duration: 4, costCores: 100, costSingularities: 0, desc: 'Gain +25% damage for 4s after taking hit' },
                    { level: 3, damageBonus: 0.40, duration: 5, costCores: 150, costSingularities: 2, desc: 'Gain +40% damage for 5s after taking hit' }
                ]
            },
            velocity_thrusters: {
                id: 'velocity_thrusters',
                name: 'Velocity Thrusters',
                category: 'utility',
                rarity: 'rare',
                icon: 'fa-rocket',
                tiers: [
                    { level: 1, speedBonus: 0.10, costCores: 50, costSingularities: 0, desc: '+10% movement speed' },
                    { level: 2, speedBonus: 0.20, costCores: 100, costSingularities: 0, desc: '+20% movement speed' },
                    { level: 3, speedBonus: 0.30, costCores: 150, costSingularities: 2, desc: '+30% movement speed' }
                ]
            },
            
            // EPIC AUGMENTS (3)
            phoenix_core: {
                id: 'phoenix_core',
                name: 'Phoenix Core',
                category: 'defense',
                rarity: 'epic',
                icon: 'fa-fire',
                tiers: [
                    { level: 1, reviveHp: 0.25, cooldown: 180, costCores: 100, costSingularities: 0, desc: 'Revive with 25% HP (3min cooldown)' },
                    { level: 2, reviveHp: 0.40, cooldown: 150, costCores: 200, costSingularities: 0, desc: 'Revive with 40% HP (2.5min cooldown)' },
                    { level: 3, reviveHp: 0.60, cooldown: 120, costCores: 300, costSingularities: 3, desc: 'Revive with 60% HP (2min cooldown)' }
                ]
            },
            cascade_multistrike: {
                id: 'cascade_multistrike',
                name: 'Cascade Multistrike',
                category: 'offense',
                rarity: 'epic',
                icon: 'fa-layer-group',
                tiers: [
                    { level: 1, baseChance: 0.15, chainChance: 0.15, costCores: 100, costSingularities: 0, desc: 'Unlock multistrike (15% chance), +15% chance for 1 additional chain' },
                    { level: 2, baseChance: 0.20, chainChance: 0.30, costCores: 200, costSingularities: 0, desc: 'Unlock multistrike (20% chance), +30% chance for 1 additional chain' },
                    { level: 3, baseChance: 0.25, chainChance: 0.50, costCores: 300, costSingularities: 3, desc: 'Unlock multistrike (25% chance), +50% chance for 1 additional chain' }
                ]
            },
            emergency_barrier: {
                id: 'emergency_barrier',
                name: 'Emergency Barrier',
                category: 'defense',
                rarity: 'epic',
                icon: 'fa-shield-alt',
                tiers: [
                    { level: 1, threshold: 0.20, duration: 2, cooldown: 60, costCores: 100, costSingularities: 0, desc: 'Invulnerable for 2s when below 20% HP (1min cooldown)' },
                    { level: 2, threshold: 0.25, duration: 3, cooldown: 50, costCores: 200, costSingularities: 0, desc: 'Invulnerable for 3s when below 25% HP (50s cooldown)' },
                    { level: 3, threshold: 0.30, duration: 4, cooldown: 40, costCores: 300, costSingularities: 3, desc: 'Invulnerable for 4s when below 30% HP (40s cooldown)' }
                ]
            },
            reactive_shielding: {
                id: 'reactive_shielding',
                name: 'Reactive Shielding',
                category: 'defense',
                rarity: 'epic',
                icon: 'fa-stopwatch',
                tiers: [
                    { level: 1, invulnBonus: 15, costCores: 100, costSingularities: 0, desc: 'Invulnerability window after taking damage: 0.75s ‚Üí 1.0s' },
                    { level: 2, invulnBonus: 30, costCores: 200, costSingularities: 0, desc: 'Invulnerability window after taking damage: 0.75s ‚Üí 1.25s' },
                    { level: 3, invulnBonus: 45, costCores: 300, costSingularities: 3, desc: 'Invulnerability window after taking damage: 0.75s ‚Üí 1.5s' }
                ]
            }
        };

        // Augment progression state (stored in localStorage)
        let augmentProgress = {
            unlocked: {}, // { augmentId: currentTier } - e.g. { 'armor_piercing': 2 } means tier 2 unlocked
            loadout: [null, null, null] // 3 slots, stores augment IDs
        };

        // Global variable to track last completed ascension (for slot availability)
        let lastAscension = 0;

        // Ship data (global so it's accessible during Player initialization)
        const shipDataMap = {
            'PATHFINDER': {
                name: 'PATHFINDER',
                desc: 'Balanced all-around vessel',
                hp: 150,
                dmg: '100%',
                spd: '100%',
                weapon: 'Ion Cannons',
                weaponDesc: 'Orbiting cannons that auto-target and fire at nearby enemies',
                weaponDetails: 'Starts with 1 orbiting ion cannon that automatically targets and fires at the closest enemy to itself. Cannons orbit around the ship at a fixed radius, providing consistent coverage.\n\nAs you upgrade this weapon, you gain additional cannons (up to 4 total at max level), and each upgrade increases damage, fire rate, and orbit radius.\n\nEach cannon independently targets the enemy closest to its current position. Perfect for consistent, reliable damage output.',
                locked: false
            },
            'ENGINEER': {
                name: 'ENGINEER',
                desc: 'Deploy turrets as you move',
                hp: 175,
                dmg: '90%',
                spd: '100%',
                weapon: 'Auto-Turret',
                weaponDesc: 'Deploys stationary turrets that auto-target and fire independently',
                weaponDetails: 'Automatically deploys stationary turrets as you move. Starts with 2 turrets that remain in position and independently target and fire at enemies within their range.\n\nAs you upgrade, you gain more turrets (up to 4 total), increased turret damage, longer range, faster fire rate, and each turret can target multiple enemies simultaneously.\n\nTurrets last indefinitely. Deploying more turrets than the current maximum will replace the oldest turret first.',
                unlockCores: 10,
                unlockAchievement: 'Survive to Level 20',
                locked: true
            },
            'DISRUPTOR': {
                name: 'DISRUPTOR',
                desc: 'Crowd control specialist',
                hp: 130,
                dmg: '95%',
                spd: '110%',
                weapon: 'EMP Pulse',
                weaponDesc: 'Electromagnetic pulse that slows enemies and projectiles in range',
                weaponDetails: 'Fires an EMP projectile that creates an electromagnetic pulse field on impact. Enemies caught in the initial impact take damage.\n\nThe pulse field lingers for 2.5 seconds, slowing all enemies within its radius. The slow effect stacks up to 3 times on each enemy for maximum crowd control.\n\nEnemy projectiles within the field are also slowed, giving you more time to dodge.\n\nAs you upgrade, the pulse field radius expands and damage increases. Particularly effective against large groups and bullet-heavy enemies.',
                unlockCores: 20,
                unlockAchievement: 'Survive to Level 30',
                locked: true
            },
            'VANGUARD': {
                name: 'VANGUARD',
                desc: 'Ramming juggernaut with barrier',
                hp: 225,
                dmg: '90%',
                spd: '80%',
                weapon: 'Kinetic Barrier',
                weaponDesc: 'Frontal energy plow - damages and deflects enemies, redirects projectiles',
                weaponDetails: 'Projects a kinetic energy barrier in front of the ship. Contact with the barrier deals impact damage to enemies, briefly stuns them, and deflects them away.\n\nEnemy projectiles that hit the barrier are redirected harmlessly.\n\nThe barrier\'s damage and size scale with your current Max HP, Armor, and Movement Speed - making defensive upgrades also boost your offensive power.\n\nUpgrades increase base damage, barrier size, and deflection force. Ideal for aggressive, in-your-face gameplay.',
                unlockCores: 30,
                unlockAchievement: 'Survive to Level 40',
                locked: true
            },
            'REAPER': {
                name: 'REAPER',
                desc: 'Glass cannon - high risk, high reward',
                hp: 150,
                dmg: '110%',
                spd: '130%',
                weapon: 'Bladestorm',
                weaponDesc: 'Spinning energy blades orbit close while launching piercing knife bursts',
                weaponDetails: 'Dual-attack weapon system.\n\nClose-range: 5 spinning energy blades orbit tightly around the ship, shredding nearby enemies.\n\nLong-range: Periodically launches piercing knife projectiles at random enemies, dealing high damage and passing through multiple targets.\n\nAs you upgrade, blade length and orbit radius increase, damage improves significantly, knife damage and pierce count increase, and launch frequency increases. High damage output but requires aggressive positioning.',
                unlockSingularities: 1,
                unlockRuns: 30,
                unlockAchievement: 'Defeat NEXUS PRIME & Complete 30 Runs',
                locked: true
            },
            'CATALYST': {
                name: 'CATALYST',
                desc: 'Elemental mastery specialist',
                hp: 165,
                dmg: '90%',
                spd: '100%',
                weapon: 'Elemental Surge',
                weaponDesc: 'Cycles through elemental orbs, every 5th hit bursts',
                weaponDetails: 'Fires elemental orbs that cycle through Pyro, Cryo, Volt, and Bio elements. Each orb applies its respective elemental effect on hit with AOE damage.\n\nEvery 5th hit triggers a powerful resonance burst, creating a massive explosion of the current element.\n\nThe cycling system ensures you consistently apply all elemental effects.\n\nUpgrades increase orb damage, AOE radius, and fire rate. Synergizes exceptionally well with elemental mastery upgrades.',
                unlockSingularities: 3,
                unlockRuns: 50,
                unlockAchievement: 'Proc 4 elements in the same run',
                locked: true
            }
        };


        const statDefs = [
            { id: 'hp', type: 'stat', name: 'Hull Repair', desc: 'Max HP & Heal', icon: 'fa-heart', offensive: false },
            { id: 'multi', type: 'stat', name: 'Double Tap', desc: 'Multistrike Chance', icon: 'fa-microchip', offensive: true },
            { id: 'spd', type: 'stat', name: 'Thrusters', desc: 'Speed', icon: 'fa-wind', offensive: false },
            { id: 'armor', type: 'stat', name: 'Plating', desc: 'Armor', icon: 'fa-shield-alt', offensive: false },
            { id: 'pickup', type: 'stat', name: 'Magnet Range', desc: 'Pickup Radius', icon: 'fa-magnet', offensive: false },
            { id: 'regen', type: 'stat', name: 'Nano-Bots', desc: 'Health Regen', icon: 'fa-plus-square', offensive: false },
            { id: 'luck', type: 'stat', name: 'Fortune Algo', desc: 'Luck & Drop Rate', icon: 'fa-clover', offensive: false },
            { id: 'crit', type: 'stat', name: 'Precision Lens', desc: 'Crit Chance', icon: 'fa-bullseye', offensive: true },
            { id: 'elem', type: 'stat', name: 'Flux Emitter', desc: 'Elemental Chance', icon: 'fa-wifi', offensive: false }
        ];


        const elementalDefs = [
            { id: 'fire', name: 'Pyro Mod', desc: 'Burns for ramping damage over time.', icon: 'fa-fire', color: '#ff5722' },
            { id: 'ice', name: 'Cryo Mod', desc: 'Slows enemies, spreads to nearby, freezes after 2s.', icon: 'fa-snowflake', color: '#88d8ff' },
            { id: 'volt', name: 'Volt Mod', desc: 'Chains lightning to nearby enemies.', icon: 'fa-bolt', color: '#ffeb3b' },
            { id: 'bio', name: 'Bio Mod', desc: 'Decay damage over time that reduces enemy armor. Spreads once to nearest enemy.', icon: 'fa-biohazard', color: '#00cc44' },
            { id: 'hack', name: 'Cyber Hack', desc: 'Turns weaker enemies to fight for you temporarily.', icon: 'fa-terminal', color: '#9c27b0' }
        ];


        const masteryDefs = {
            fire: { id: 'fire', type: 'mastery', name: 'Pyro Mastery', desc: '+2s burn duration, +0.5% HP/tick', icon: 'fa-fire-alt', offensive: true },
            ice: { id: 'ice', type: 'mastery', name: 'Cryo Control', desc: '+50% aura range, frozen take +50% damage', icon: 'fa-snowflake', offensive: true },
            volt: { id: 'volt', type: 'mastery', name: 'Volt Amplifier', desc: '+1 chain jump, +30% chain damage', icon: 'fa-bolt', offensive: true },
            bio: { id: 'bio', type: 'mastery', name: 'Bio Accelerator', desc: 'Decay ticks 50% faster (more armor reduction), +1% starting damage', icon: 'fa-biohazard', offensive: true },
            hack: { id: 'hack', type: 'mastery', name: 'Hack Override', desc: '+2s duration, +67% damage, can hack elite enemies (tanks, voidwalkers)', icon: 'fa-terminal', offensive: true }
        };

        const synergyDefs = {
            pyro_cryo: { id: 'pyro_cryo', type: 'synergy', name: 'Thermal Shock', desc: 'Enemy with both explodes for 50% HP AOE, freezes nearby', icon: 'fa-burst', offensive: true, elements: ['fire', 'ice'] },
            pyro_volt: { id: 'pyro_volt', type: 'synergy', name: 'Pyroclasm', desc: 'Burning enemies shocked deal AOE damage, chains apply 50% burn', icon: 'fa-bolt', offensive: true, elements: ['fire', 'volt'] },
            pyro_bio: { id: 'pyro_bio', type: 'synergy', name: 'Meltdown', desc: 'Bio ticks apply 50% pyro, burning enemies spread bio on death', icon: 'fa-radiation', offensive: true, elements: ['fire', 'bio'] },
            pyro_hack: { id: 'pyro_hack', type: 'synergy', name: 'Digital Inferno', desc: 'Hacked burn 2x faster, burning 50% easier to hack', icon: 'fa-fire', offensive: true, elements: ['fire', 'hack'] },
            cryo_volt: { id: 'cryo_volt', type: 'synergy', name: 'Storm Surge', desc: 'Chains prioritize frozen, +100% damage to frozen enemies', icon: 'fa-bolt', offensive: true, elements: ['ice', 'volt'] },
            cryo_bio: { id: 'cryo_bio', type: 'synergy', name: 'Frozen Plague', desc: 'Freeze spreads bio 100 range, frozen take +100% bio damage', icon: 'fa-snowflake', offensive: true, elements: ['ice', 'bio'] },
            cryo_hack: { id: 'cryo_hack', type: 'synergy', name: 'Shatter Protocol', desc: 'Frozen hack instantly, hacked emit freeze pulses every 2s', icon: 'fa-microchip', offensive: true, elements: ['ice', 'hack'] },
            volt_bio: { id: 'volt_bio', type: 'synergy', name: 'Bioshock', desc: 'Every 3rd bio tick triggers chain, chains double bio rate 2s', icon: 'fa-bolt', offensive: true, elements: ['volt', 'bio'] },
            volt_hack: { id: 'volt_hack', type: 'synergy', name: 'Corrupted Circuitry', desc: 'Hacked emit chains every 2s, volt 25% hack chance', icon: 'fa-bolt', offensive: true, elements: ['volt', 'hack'] },
            bio_hack: { id: 'bio_hack', type: 'synergy', name: 'Necrosis', desc: 'Hacked take double bio, hack end resets bio duration', icon: 'fa-biohazard', offensive: true, elements: ['bio', 'hack'] }
        };


        // --- Game Classes ---
        class Player {
            constructor() {
                this.x = 0; this.y = 0; this.radius = 12; this.speed = 2.5; // Tighter hitbox: 12 (was 16) 
                this.vx = 0; this.vy = 0; // Velocity components
                this.hp = 150; this.maxHp = 150; this.armor = 15; // Base Armor increased from 10 to 15
                
                // Ship-specific shield configuration (set after selectedShip is loaded)
                this.shield1 = 0; // Will be set based on ship
                this.shield2 = 0;
                this.shield3 = 0; // Vanguard only
                this.shield4 = 0; // Vanguard with Shield Capacitor Tier 3 only
                this.shield1RechargeTimer = 0; // Time until bar 1 starts recharging
                this.shield2RechargeTimer = 0; // Time until bar 2 starts recharging
                this.shield3RechargeTimer = 0; // Vanguard only
                this.shield4RechargeTimer = 0; // Vanguard with Shield Capacitor Tier 3 only
                this.shieldRechargeDelay = 600; // 10 seconds (60fps √ó 10)
                this.shieldRechargeRate = 20; // 20% per second (100% in 5 seconds) 
                this.regen = 0; this.regenTimer = 60; // Ticks every 1 second (60 frames)
                this.lastDamageTime = 0; // Track last time damage was taken for regen
                this.luck = 0;
                this.multicast = 0; // Starts at 0 - must be unlocked (was 0.07)
                this.multistrikeUnlocked = false; // Must unlock multistrike first
                this.critChance = 0.07; 
                this.critMult = 1.50; 
                this.elementalMult = 1.0; 
                this.invulnTimer = 0; this.pickupRadius = 120; // Slightly increased for better feel
                this.pickupUpgradeCount = 0; // Track magnet upgrades for hard cap

                // Ship selection
                this.selectedShip = localStorage.getItem('neonrogue_selectedShip') || 'PATHFINDER';
                console.log('üöÄ Initializing player with ship:', this.selectedShip);
                
                // Apply ship stat modifiers
                const shipData = shipDataMap[this.selectedShip];
                if (shipData) {
                    // HP modifier
                    this.maxHp = shipData.hp;
                    this.hp = shipData.hp;
                    
                    // Damage modifier (stored as multiplier)
                    this.shipDamageMult = parseFloat(shipData.dmg) / 100;
                    
                    // Speed modifier (stored as multiplier)
                    this.shipSpeedMult = parseFloat(shipData.spd) / 100;
                } else {
                    // Defaults if ship not found
                    this.shipDamageMult = 1.0;
                    this.shipSpeedMult = 1.0;
                }

                this.weapons = { ion: 0, turret: 0, emp: 0, barrier: 0, orbital: 0, surge: 0, shield: 0, tesla: 0, seeker: 0, rad: 0, beam: 0, whip: 0, meteor: 0, railgun: 0, flak: 0, pylons: 0, mines: 0, gas: 0, ricochet: 0, drones: 0 };
                
                // Set starting weapon based on ship
                if (this.selectedShip === 'PATHFINDER') this.weapons.ion = 1;
                else if (this.selectedShip === 'ENGINEER') this.weapons.turret = 1;
                else if (this.selectedShip === 'DISRUPTOR') this.weapons.emp = 1;
                else if (this.selectedShip === 'VANGUARD') this.weapons.barrier = 1;
                else if (this.selectedShip === 'REAPER') this.weapons.orbital = 1;
                else if (this.selectedShip === 'CATALYST') this.weapons.surge = 1;
                
                // Ship-specific shield charges
                if (this.selectedShip === 'DISRUPTOR') {
                    this.shield1 = 100; // 1 shield only
                    this.shield2 = 0;
                    this.shield3 = 0;
                    this.shield4 = 0; // Disruptor doesn't use shield4
                } else if (this.selectedShip === 'VANGUARD') {
                    this.shield1 = 100; // 3 shields
                    this.shield2 = 100;
                    this.shield3 = 100;
                    this.shield4 = 0; // Only available with Shield Capacitor Tier 3 augment
                } else if (this.selectedShip === 'REAPER') {
                    this.shield1 = 0; // 0 shields - glass cannon
                    this.shield2 = 0;
                    this.shield3 = 0;
                    this.shield4 = 0; // Reaper doesn't use shield4
                } else {
                    // Pathfinder and Engineer: 2 shields (default)
                    this.shield1 = 100;
                    this.shield2 = 100;
                    this.shield3 = 0;
                    this.shield4 = 0; // Only Vanguard uses shield4 with augment
                }
                
                
                // Apply Ascension modifiers
                this.applyAscensionModifiers();
                
                // Apply Augment effects
                this.applyAugmentEffects();
                
                this.weaponAugments = {}; // Single augment per weapon: { ion: 'fire', beam: 'ice', ... }
                this.weaponStats = {};
                Object.keys(this.weapons).forEach(k => {
                     this.weaponAugments[k] = null; // null = no augment yet
                     this.weaponStats[k] = { dmg: 1.0, rate: 1.0, area: 1.0, speed: 1.0 };
                });
                
                // Turret tracking (for Engineer)
                this.turrets = []; // Array of deployed turrets
                this.turretTimer = 0;
                
                // EMP tracking (for Disruptor)
                this.empFields = []; // Array of active EMP fields
                
                // Elemental Masteries (once per element)
                this.elementalMasteries = {
                    fire: false,
                    ice: false,
                    volt: false,
                    bio: false,
                    hack: false
                };
                
                // Synergies (once per pair)
                this.synergies = {
                    pyro_cryo: false,
                    pyro_volt: false,
                    pyro_bio: false,
                    pyro_hack: false,
                    cryo_volt: false,
                    cryo_bio: false,
                    cryo_hack: false,
                    volt_bio: false,
                    volt_hack: false,
                    bio_hack: false
                };
                
                // ULTIMATE SYSTEM
                this.ultimate = null; // No ultimate at start - dropped by Titans
                this.ultimateCharge = 0; // 0-100%
                this.ultimateChargeRate = 2.25; // 2.25% per second (44 seconds to full charge)
                this.ultimateDamageChargeRate = 0.0015; // 0.15% per 100 damage dealt (was 0.002%)
                this.ultimateActive = false; // Is ultimate currently firing/active
                this.ultimateData = {}; // Ultimate-specific state data
                
                this.activeMod = null; 
                this.nukeTimer = 0; 
                this.maxNukeTimer = 7200; // 2 minutes
                this.repulserTimer = 0;
                this.repulserActive = false;
                this.repulserDuration = 0;
                this.empTimer = 0;
                this.overdriveTimer = 0;
                this.overdriveActive = false;
                this.overdriveDuration = 0; 


                this.fireRate = 500; this.lastShot = 0; // Increased from 340 to slow down rapid fire
                this.damage = 15 * this.shipDamageMult; // Apply ship damage modifier
                
                // Apply Overclock mod: +25% fire rate
                if (this.activeMod === 'overclock') {
                    this.fireRate *= 1.25; // 25% faster
                }
                this.projectileSpeed = 12; this.range = 450; this.pierce = 0;
                
                this.teslaTimer = 0; this.maxTeslaTimer = 150; // Increased from 110
                this.seekerTimer = 0; this.maxSeekerTimer = 110; // Increased from 90 (slower base cooldown - nerf) 
                this.beamActive = false; this.beamTimer = 0; this.beamCooldown = 0; this.beamTarget = null; this.beamIgnitionDelay = 0;
                this.beamTargets = [];
                this.beamRampMap = new Map(); // Track damage ramp per enemy
                this.beamTickCounter = 0; // Time dilation compliant tick counter
                
                this.whipTimer = 0;
                this.whipVisualTimer = 0; // Visual feedback for whip slash
                this.whipVisualAngle = 0;
                this.meteorTimer = 0; this.maxMeteorTimer = 300;
                this.railgunTimer = 0; this.maxRailgunTimer = 300;
                this.flakTimer = 0; this.maxFlakTimer = 160;
                this.pylonTimer = 0; this.maxPylonTimer = 300; this.pylons = []; this.maxPylons = 3;
                this.pylonTickCounter = 0; // Time dilation compliant tick counter
                this.radTickCounter = 0; // Time dilation compliant tick counter
                this.minesTimer = 0; this.maxMinesTimer = 240; // 4 seconds base deployment rate
                this.gasTimer = 0; this.maxGasTimer = 390; // 6.5 seconds base lob rate (since clouds last 5s)
                this.ricochetTimer = 0;
                this.drones = []; // Will be initialized when drones weapon is acquired
                
                // CATALYST ship-specific properties
                this.surgeTimer = 0;
                this.maxSurgeTimer = 60; // 1 second between orbs (was 1.5s)
                this.surgeElementIndex = 0; // Cycles through 0-3 (fire, ice, volt, bio)
                this.surgeElements = ['fire', 'ice', 'volt', 'bio']; // Only 4 elements (removed hack)
                this.surgeHitCount = 0; // Count hits for resonance burst (every 3rd hit)
                this.surgeAuraTimer = 0; // Aura duration after hitting with surge orb
                this.surgeAuraElement = null; // Which element's aura is active
                
                this.angle = 0; this.cannons = []; this.shieldOrbs = []; this.fireIndex = 0; this.cannonAngle = 0;
                
                // Passive mod flags
                this.hasBerserker = false;
                this.hasMomentum = false;
                this.momentumTimer = 0; // Tracks time without damage
                this.hasGlassCannon = false;
                this.hasReaper = false;
                this.reaperCooldown = 0; // 1 HP per second limit
                this.hasThrust = false;
                this.thrustActive = false;
                this.thrustTimer = 0;
                this.thrustCooldown = 0;
            }

            applyAscensionModifiers() {
                const ascension = state.activeAscension || 0;
                if (ascension === 0) {
                    console.log('‚úÖ No ascension debuffs applied (Normal Mode)');
                    return; // No modifiers for normal mode
                }
                
                console.log(`üî• Applying Ascension ${ascension} unique debuffs`);
                
                // ASCENSION 1 (1 debuff) - ONLY for Ascension 1
                if (ascension === 1) {
                    // Fragile Hull: -30% max HP and HP upgrades
                    this.fragileHullPenalty = 0.70; // Store for HP upgrade calculations
                    this.maxHp = Math.floor(this.maxHp * 0.70);
                    this.hp = this.maxHp;
                    console.log(`üíî Fragile Hull: Max HP reduced to ${this.maxHp} (70%)`);
                }
                
                // ASCENSION 2 (2 debuffs) - ONLY for Ascension 2
                else if (ascension === 2) {
                    // Power Drain: -20% base damage
                    this.shipDamageMult *= 0.80;
                    console.log(`‚ö° Power Drain: Base damage at ${(this.shipDamageMult * 100).toFixed(0)}%`);
                    
                    // Sluggish Systems: -15% movement speed
                    this.speed *= 0.85;
                    console.log(`üêå Sluggish Systems: Movement speed at ${(this.speed).toFixed(2)}`);
                }
                
                // ASCENSION 3 (3 debuffs) - ONLY for Ascension 3
                else if (ascension === 3) {
                    // Aggressive Swarms: +15% enemy spawn rate (handled in spawn system)
                    console.log(`üêù Aggressive Swarms: Enemies spawn 15% faster`);
                    
                    // Weakened Shields: +50% shield recharge delay
                    this.shieldRechargeDelay = Math.floor(this.shieldRechargeDelay * 1.5);
                    
                    // Energy Leak: Ultimate charges 20% slower
                    this.energyLeakPenalty = 0.80; // Stored for ultimate charge calculations
                    console.log(`‚ö° Energy Leak: Ultimate charges at 80% rate`);
                }
                
                // ASCENSION 4 (4 debuffs) - ONLY for Ascension 4
                else if (ascension === 4) {
                    // Brittle Armor: -1 shield charge
                    if (this.shield3 > 0) {
                        this.shield3 = 0;
                    } else if (this.shield2 > 0) {
                        this.shield2 = 0;
                    } else if (this.shield1 > 0) {
                        this.shield1 = 0;
                    }
                    console.log(`üí• Brittle Armor: Shield removed - now ${this.shield1}/${this.shield2}/${this.shield3}`);
                    
                    // Overloaded Circuits: -15% fire rate
                    this.fireRate *= 0.85;
                    console.log(`üî´ Overloaded Circuits: Fire rate at ${(this.fireRate * 100).toFixed(0)}%`);
                    
                    // Leaky Shields: Shields only block 50% of damage
                    this.leakyShields = true;
                    
                    // Compressed Field: -15% area and area upgrades
                    this.compressedFieldPenalty = 0.85; // Stored for area calculations
                    console.log(`üìâ Compressed Field: Weapon areas at 85%`);
                }
                
                // ASCENSION 5 (5 debuffs) - ONLY for Ascension 5
                else if (ascension === 5) {
                    // Ticking Doom: Lose 1 HP/second
                    this.tickingDoomTimer = 0;
                    console.log(`‚è±Ô∏è Ticking Doom: Losing 1 HP/second`);
                    
                    // Overcharged Enemies: +20% enemy damage (handled in enemy damage calculations)
                    console.log(`‚ö° Overcharged Enemies: Enemies deal 20% more damage`);
                    
                    // Accelerated Enemies: +15% enemy speed (handled in enemy speed calculations)
                    console.log(`üèÉ Accelerated Enemies: Enemies move 15% faster`);
                    
                    // Empowered Titans: Champions +25% HP and damage (handled in champion stats)
                    console.log(`üêâ Empowered Titans: Titans have 25% more HP and damage`);
                    
                    // Critical Weakness: Enemies have +15% crit chance
                    this.enemyCritChance = 0.15; // Base crit chance for enemies
                    console.log(`üéØ Critical Weakness: Enemies can crit (15% base chance, -0.1% per armor point)`);
                }
            }
            
            applyAugmentEffects() {
                console.log('üîÆ Checking for augment effects...');
                console.log('  augmentProgress exists:', typeof augmentProgress !== 'undefined');
                console.log('  augmentProgress:', augmentProgress);
                
                // Safety check: Ensure augmentProgress exists
                if (typeof augmentProgress === 'undefined' || !augmentProgress || !augmentProgress.loadout) {
                    console.log('‚úÖ No augments available (new player or system not unlocked)');
                    return;
                }
                
                // Get equipped augments from loadout
                const equippedAugments = augmentProgress.loadout.filter(id => id !== null);
                console.log('  Equipped augments:', equippedAugments);
                
                if (equippedAugments.length === 0) {
                    console.log('‚úÖ No augments equipped');
                    return;
                }
                
                console.log(`üîÆ Applying ${equippedAugments.length} equipped augment(s)...`);
                
                equippedAugments.forEach(augmentId => {
                    const augment = augmentDefs[augmentId];
                    if (!augment) return;
                    
                    const tier = augmentProgress.unlocked[augmentId] || 0;
                    if (tier === 0) return;
                    
                    const tierData = augment.tiers[tier - 1];
                    console.log(`  ‚ú® ${augment.name} (Tier ${tier})`);
                    
                    // Apply effects based on augment type
                    switch (augmentId) {
                        case 'armor_piercing':
                            this.armorPiercing = tierData.effect;
                            console.log(`  üéØ Armor Piercing: ${(tierData.effect * 100).toFixed(0)}% enemy armor reduction`);
                            break;
                            
                        case 'fortified_hull':
                            // Apply max HP bonus
                            const hpBefore = this.maxHp;
                            this.maxHp = Math.floor(this.maxHp * (1 + tierData.hpBonus));
                            this.hp = this.maxHp;
                            // Store HP upgrade bonus for later use
                            this.fortifiedHullUpgradeBonus = tierData.upgradeBonus;
                            console.log(`  üõ°Ô∏è Fortified Hull: Max HP ${hpBefore} ‚Üí ${this.maxHp}, +${(tierData.upgradeBonus * 100).toFixed(0)}% HP upgrades`);
                            break;
                            
                        case 'treasure_hunter':
                            this.pickupRadiusBonus = tierData.pickupRadius;
                            this.xpBonus = tierData.xpBonus;
                            console.log(`  üíé Treasure Hunter: +${(tierData.pickupRadius * 100).toFixed(0)}% pickup radius, +${(tierData.xpBonus * 100).toFixed(0)}% XP`);
                            break;
                            
                        case 'rapid_fire':
                            this.fireRateBonus = tierData.fireRateBonus;
                            this.rapidFireDamageReduction = tierData.damageReduction;
                            console.log(`  ‚ö° Rapid Fire: +${(tierData.fireRateBonus * 100).toFixed(0)}% fire rate, -${(tierData.damageReduction * 100).toFixed(0)}% damage`);
                            break;
                            
                        case 'nanite_swarm':
                            this.regen += tierData.healPerSecond; // Add to regen stat
                            console.log(`  üîß Nanite Swarm: +${tierData.healPerSecond} HP/s regen (total: ${this.regen.toFixed(2)} HP/s)`);
                            break;
                            
                        case 'critical_mass':
                            const critBefore = this.critChance;
                            const multBefore = this.critMult;
                            this.critChance += tierData.critChance;
                            this.critMult += tierData.critDamage;
                            console.log(`  üí• Critical Mass: Crit ${(critBefore*100).toFixed(1)}% ‚Üí ${(this.critChance*100).toFixed(1)}%, Mult ${multBefore.toFixed(2)}x ‚Üí ${this.critMult.toFixed(2)}x`);
                            break;
                            
                        case 'titan_slayer':
                            this.titanSlayerBonus = tierData.bossDamage;
                            console.log(`  üêâ Titan Slayer: +${(tierData.bossDamage * 100).toFixed(0)}% damage to bosses/titans`);
                            break;
                            
                        case 'adaptive_armor':
                            this.adaptiveArmorPerSecond = tierData.armorPerSecond;
                            this.adaptiveArmorMaxStacks = tierData.maxStacks;
                            this.adaptiveArmorStacks = 0;
                            this.adaptiveArmorTimer = 0;
                            console.log(`  üõ°Ô∏è Adaptive Armor: +${tierData.armorPerSecond} armor/s (max ${tierData.maxStacks} stacks)`);
                            break;
                            
                        case 'elemental_savant':
                            this.elementalProcBonus = tierData.procBonus;
                            this.elementalDamageBonus = tierData.damageBonus;
                            console.log(`  ‚ö° Elemental Savant: +${(tierData.procBonus * 100).toFixed(0)}% proc chance, +${(tierData.damageBonus * 100).toFixed(0)}% elemental damage`);
                            break;
                            
                        case 'shield_capacitor':
                            // Apply shield recharge speed bonus (not applicable to REAPER at Tier 1-2 since they have no shields)
                            const rechargeBonus = tierData.rechargeSpeedBonus || 0;
                            if (rechargeBonus > 0 && this.selectedShip !== 'REAPER') {
                                // Increase recharge rate (more % per second)
                                this.shieldRechargeRate *= (1 + rechargeBonus);
                                // Decrease recharge delay (faster start)
                                this.shieldRechargeDelay = Math.floor(this.shieldRechargeDelay / (1 + rechargeBonus));
                                console.log(`  ‚ö° Shield recharge: ${this.shieldRechargeRate.toFixed(1)}%/sec, ${(this.shieldRechargeDelay/60).toFixed(1)}s delay`);
                            }
                            
                            // Add extra shield charge at Tier 3
                            const charges = tierData.charges || 0;
                            if (charges >= 1) {
                                // Add one extra shield charge based on current ship configuration
                                if (this.selectedShip === 'REAPER') {
                                    // REAPER normally has 0 shields - give it 1!
                                    this.shield1 = 100;
                                    console.log('  üõ°Ô∏è Added shield1 for REAPER (glass cannon protection!)');
                                } else if (this.selectedShip === 'DISRUPTOR') {
                                    // Disruptor normally has 1 shield, add to get 2
                                    this.shield2 = 100;
                                    console.log('  üõ°Ô∏è Added shield2 for DISRUPTOR');
                                } else if (this.selectedShip === 'VANGUARD') {
                                    // Vanguard normally has 3 shields, can add 4th!
                                    // Need to create shield4 property
                                    if (!this.shield4) this.shield4 = 0;
                                    if (!this.shield4RechargeTimer) this.shield4RechargeTimer = 0;
                                    this.shield4 = 100;
                                    console.log('  üõ°Ô∏è Added shield4 for VANGUARD');
                                } else {
                                    // Pathfinder/Engineer normally have 2, add to get 3
                                    this.shield3 = 100;
                                    console.log('  üõ°Ô∏è Added shield3 for PATHFINDER/ENGINEER');
                                }
                            }
                            break;
                            
                        case 'combat_stimulant':
                            this.stimulantDamageBonus = tierData.damageBonus;
                            this.stimulantDuration = tierData.duration * 60; // Convert to frames
                            this.stimulantTimer = 0;
                            break;
                            
                        case 'velocity_thrusters':
                            this.speed *= (1 + tierData.speedBonus);
                            break;
                            
                        case 'phoenix_core':
                            this.phoenixReviveHp = tierData.reviveHp;
                            this.phoenixCooldown = tierData.cooldown * 60; // Convert to frames
                            this.phoenixReady = true;
                            this.phoenixCooldownTimer = 0;
                            break;
                            
                        case 'cascade_multistrike':
                            this.multistrikeUnlocked = true;
                            this.multicast = tierData.baseChance;
                            this.cascadeChainChance = tierData.chainChance;
                            console.log(`  üîó Cascade: base ${(tierData.baseChance*100).toFixed(0)}%, +${(tierData.chainChance*100).toFixed(0)}% chance for 1 extra chain`);
                            break;
                            
                        case 'emergency_barrier':
                            this.barrierThreshold = tierData.threshold;
                            this.barrierDuration = tierData.duration * 60; // Convert to frames
                            this.barrierCooldownDuration = tierData.cooldown * 60; // Convert to frames
                            this.barrierActive = 0;
                            this.barrierCooldown = 0;
                            break;
                            
                        case 'reactive_shielding':
                            this.invulnBonusFrames = tierData.invulnBonus; // Bonus frames added to invuln timer
                            console.log(`  ‚è±Ô∏è Reactive Shielding: +${tierData.invulnBonus} frames (${(tierData.invulnBonus/60).toFixed(2)}s) invuln window`);
                            break;
                    }
                });
                
                console.log('‚úÖ Augment effects applied');
            }
            
            getAscensionDamageMult(target = null) {
                // All ascension buffs removed - now available only through augments
                // Ascension 2 Bloodlust and Ascension 4 Titan Slayer are now augments
                return 1.0;
            }

            heal(amount, allowOvershield=false) {
                if (this.hp < this.maxHp) {
                    const needed = this.maxHp - this.hp;
                    const applied = Math.min(needed, amount);
                    this.hp += applied;
                }
                // Note: allowOvershield parameter kept for compatibility but no longer used
                // Shields are now separate system with their own recharge mechanic
            }


            takeHit(amount, damageSource = 'Unknown', enemyType = 'Unknown') {
                // CRITICAL: Prevent processing damage if already dead
                if (state.playerDead) return;
                if (this.invulnTimer > 0) return;
                if (this.hp <= 0) return; // Already dead, don't process more damage
                
                // Initialize damage log if needed
                if (!this.damageLog) this.damageLog = [];
                
                // Check if we have any FULL shield bars (100% = fully charged)
                const hasShield1 = this.shield1 >= 100;
                const hasShield2 = this.shield2 >= 100;
                const hasShield3 = this.shield3 >= 100;
                const hasShield4 = this.shield4 >= 100;
                
                console.log(`üõ°Ô∏è SHIELDS BEFORE HIT: shield1=${this.shield1}, shield2=${this.shield2}, shield3=${this.shield3}, shield4=${this.shield4 || 0}`);
                console.log(`Has full shields: s1=${hasShield1}, s2=${hasShield2}, s3=${hasShield3}, s4=${hasShield4}`);
                
                // Check if any shield is actively charging (can't be interrupted)
                // Match the recharge logic - only check shields the ship actually has
                const canHaveShield1 = this.selectedShip !== 'REAPER';
                const canHaveShield2 = this.selectedShip !== 'REAPER' && this.selectedShip !== 'DISRUPTOR';
                const canHaveShield3 = this.selectedShip === 'VANGUARD';
                const canHaveShield4 = this.selectedShip === 'VANGUARD' && this.shield4 !== undefined;
                
                const shield1Charging = canHaveShield1 && this.shield1 < 100 && this.shield1 > 0 && this.shield1RechargeTimer <= 0;
                const shield2Charging = canHaveShield2 && this.shield2 < 100 && this.shield2 > 0 && this.shield2RechargeTimer <= 0;
                const shield3Charging = canHaveShield3 && this.shield3 < 100 && this.shield3 > 0 && this.shield3RechargeTimer <= 0;
                const shield4Charging = canHaveShield4 && this.shield4 < 100 && this.shield4 > 0 && this.shield4RechargeTimer <= 0;
                
                console.log(`Shields charging: s1=${shield1Charging}, s2=${shield2Charging}, s3=${shield3Charging}, s4=${shield4Charging}`);
                
                // REAPER HAS NO SHIELDS - skip shield logic entirely
                const canUseShields = this.selectedShip !== 'REAPER';
                
                // If we have at least one full shield bar, consume it and block damage
                // Deplete from RIGHT to LEFT (shield4 ‚Üí shield3 ‚Üí shield2 ‚Üí shield1) for Vanguard
                // CRITICAL: Never deplete a shield that is actively charging
                // LEAKY SHIELDS (Ascension 4+): Shields only block 50% of damage
                if (canUseShields && (hasShield1 || hasShield2 || hasShield3 || hasShield4)) {
                    let shieldBroken = false;
                    let leakyDamage = 0;
                    
                    // Leaky Shields: Calculate damage that goes through
                    if (this.leakyShields) {
                        leakyDamage = amount * 0.5; // 50% of damage leaks through
                    }
                    
                    // Deplete shield4 (rightmost, Vanguard with Shield Capacitor only) first if it's full and not charging
                    if (hasShield4 && !shield4Charging) {
                        console.log('üí• Breaking shield4');
                        this.shield4 = 0;
                        this.shield4RechargeTimer = this.shieldRechargeDelay;
                        shieldBroken = true;
                    }
                    // Then deplete shield3 (Vanguard only) if it's full and not charging
                    else if (hasShield3 && !shield3Charging) {
                        console.log('üí• Breaking shield3');
                        this.shield3 = 0;
                        this.shield3RechargeTimer = this.shieldRechargeDelay;
                        shieldBroken = true;
                    }
                    // Then deplete shield2 (middle) if it's full and not charging
                    else if (hasShield2 && !shield2Charging) {
                        console.log('üí• Breaking shield2');
                        this.shield2 = 0;
                        this.shield2RechargeTimer = this.shieldRechargeDelay;
                        shieldBroken = true;
                    } 
                    // Otherwise deplete shield1 (left) if it's full and not charging
                    else if (hasShield1 && !shield1Charging) {
                        console.log('üí• Breaking shield1');
                        this.shield1 = 0;
                        this.shield1RechargeTimer = this.shieldRechargeDelay;
                        shieldBroken = true;
                    }
                    // Edge case: Shield is full but charging (shouldn't happen, but for safety deplete it)
                    else if (hasShield4) {
                        console.log('üí• Breaking shield4 (edge case)');
                        this.shield4 = 0;
                        this.shield4RechargeTimer = this.shieldRechargeDelay;
                        shieldBroken = true;
                    }
                    else if (hasShield3) {
                        console.log('üí• Breaking shield3 (edge case)');
                        this.shield3 = 0;
                        this.shield3RechargeTimer = this.shieldRechargeDelay;
                        shieldBroken = true;
                    } else if (hasShield2) {
                        console.log('üí• Breaking shield2 (edge case)');
                        this.shield2 = 0;
                        this.shield2RechargeTimer = this.shieldRechargeDelay;
                        shieldBroken = true;
                    } else {
                        console.log('üí• Breaking shield1 (edge case)');
                        this.shield1 = 0;
                        this.shield1RechargeTimer = this.shieldRechargeDelay;
                        shieldBroken = true;
                    }
                    
                    // VANGUARD PASSIVE: Shield break causes massive shockwave
                    if (shieldBroken && this.selectedShip === 'VANGUARD') {
                        const explosionRadius = 400; // MASSIVE: almost screen-wide (was 160)
                        
                        // Calculate barrier stat scaling (same formula as barrier weapon)
                        const hpComponent = this.maxHp / 120;
                        const armorComponent = this.armor / 12;
                        const speedComponent = (this.speed * this.shipSpeedMult) / 2.0;
                        const damageComponent = this.damage / 12;
                        const statScaling = Math.sqrt(hpComponent * armorComponent * speedComponent * damageComponent);
                        
                        // 1.5x full-speed barrier impact damage = 3.0x base damage
                        // (barrier impact at full speed = 2.0x, so 1.5x that = 3.0x)
                        const baseDamage = this.damage * 3.0 * statScaling * this.weaponStats.barrier.dmg;
                        
                        entities.enemies.forEach(e => {
                            const dist = Math.sqrt((e.x - this.x)**2 + (e.y - this.y)**2);
                            if (dist < explosionRadius && e.hp > 0) {
                                // DAMAGE FALLOFF: 100% at center ‚Üí 30% at edge
                                const falloff = 1.0 - (dist / explosionRadius * 0.7); // 100% to 30%
                                const finalDamage = baseDamage * falloff;
                                
                                this.dealElementalDamage(e, finalDamage, 'barrier', '#c0cfe0');
                                // Extra visual feedback on each enemy hit
                                createExplosion(e.x, e.y, '#8b9dc3', 12);
                            }
                        });
                        
                        // SHOCKWAVE RING ANIMATION - expands outward
                        const ringDuration = 40; // Frames
                        const maxRadius = explosionRadius;
                        entities.particles.push({
                            x: this.x,
                            y: this.y,
                            life: ringDuration,
                            maxLife: ringDuration,
                            currentRadius: 0,
                            maxRadius: maxRadius,
                            update() {
                                const progress = 1 - (this.life / this.maxLife); // 0 to 1
                                this.currentRadius = this.maxRadius * progress;
                                this.life--;
                                return this.life > 0;
                            },
                            draw(ctx) {
                                const progress = 1 - (this.life / this.maxLife);
                                const alpha = Math.max(0, 1 - progress); // Fades as it expands
                                const thickness = 8 - (progress * 4); // Gets thinner
                                
                                // Outer bright ring
                                ctx.strokeStyle = `rgba(192, 207, 224, ${alpha * 0.8})`;
                                ctx.lineWidth = thickness;
                                ctx.shadowBlur = 20 * alpha;
                                ctx.shadowColor = `rgba(192, 207, 224, ${alpha})`;
                                ctx.beginPath();
                                ctx.arc(this.x, this.y, this.currentRadius, 0, Math.PI * 2);
                                ctx.stroke();
                                
                                // Inner glow ring
                                ctx.strokeStyle = `rgba(139, 157, 195, ${alpha * 0.5})`;
                                ctx.lineWidth = thickness * 0.6;
                                ctx.shadowBlur = 15 * alpha;
                                ctx.beginPath();
                                ctx.arc(this.x, this.y, this.currentRadius * 0.9, 0, Math.PI * 2);
                                ctx.stroke();
                                
                                ctx.shadowBlur = 0;
                            }
                        });
                        
                        // Center explosion flash
                        createExplosion(this.x, this.y, '#c0cfe0', 50);
                        
                        // Additional particles for visual feedback
                        for (let i = 0; i < 12; i++) {
                            const angle = (Math.PI * 2 / 12) * i;
                            entities.particles.push({
                                x: this.x,
                                y: this.y,
                                vx: Math.cos(angle) * 8,
                                vy: Math.sin(angle) * 8,
                                color: '#c0cfe0',
                                life: 30,
                                size: 3,
                                update: function(dt) {
                                    this.x += this.vx * (dt/16);
                                    this.y += this.vy * (dt/16);
                                    this.life -= dt/16;
                                    this.vx *= 0.95;
                                    this.vy *= 0.95;
                                    return this.life > 0;
                                },
                                draw: function(ctx) {
                                    ctx.fillStyle = this.color;
                                    ctx.shadowBlur = 8;
                                    ctx.shadowColor = this.color;
                                    ctx.beginPath();
                                    ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                                    ctx.fill();
                                    ctx.shadowBlur = 0;
                                }
                            });
                        }
                    }
                    
                    // Visual feedback - shield hit
                    // Shield hit visual feedback
                    const flash = document.getElementById('damage-flash');
                    flash.style.opacity = 0.3; // Lighter flash for shield hit
                    flash.style.background = '#00d1b2'; // Cyan for shield
                    setTimeout(() => {
                        flash.style.opacity = 0;
                        flash.style.background = '#ff0000'; // Reset to red
                    }, 100);
                    
                    // Camera shake removed - only on HP damage now
                    
                    this.invulnTimer = 60;
                    
                    // LEAKY SHIELDS: Apply leaked damage to HP
                    if (this.leakyShields && leakyDamage > 0) {
                        this.hp -= leakyDamage;
                        
                        // Show leaked damage number
                        entities.texts.push({
                            x: this.x + (Math.random() - 0.5) * 30,
                            y: this.y - 20,
                            vx: (Math.random() - 0.5) * 2,
                            vy: -2,
                            text: `-${Math.round(leakyDamage)}`,
                            color: '#ff9900', // Orange for leaked damage
                            life: 60,
                            size: 20,
                            update() { this.x += this.vx; this.y += this.vy; this.life--; return this.life > 0; },
                            draw(ctx) {
                                const alpha = Math.min(1, this.life / 20);
                                ctx.fillStyle = this.color.replace(')', `, ${alpha})`).replace('rgb', 'rgba');
                                ctx.font = `bold ${this.size}px Orbitron`;
                                ctx.shadowColor = 'black';
                                ctx.shadowBlur = 4;
                                ctx.textAlign = 'center';
                                ctx.fillText(this.text, this.x, this.y);
                                ctx.shadowBlur = 0;
                            }
                        });
                        
                        // Log leaked damage for death recap
                        const damageEntry = {
                            damage: Math.round(leakyDamage),
                            source: damageSource + ' (Leaked)',
                            enemyType: enemyType,
                            timestamp: Date.now(),
                            isPlayerDamage: false
                        };
                        this.damageLog.push(damageEntry);
                        if (this.damageLog.length > 10) this.damageLog.shift();
                        
                        // Check if leaked damage killed player
                        if (this.hp <= 0) {
                            // Don't return yet - let it fall through to death logic below
                        } else {
                            return; // Shield blocked, leaked some damage, but player survived
                        }
                    } else {
                        return; // No HP damage taken (normal shield block)
                    }
                }
                
                // No full shields - take HP damage
                // PASSIVE DEFENSIVE SCALING: After level 20, player gains passive damage reduction
                // This helps counter enemy scaling and incentivizes reaching higher levels
                // Caps at 25% reduction at level 30+
                let defensiveScaling = 1.0;
                if (state.level > 20) {
                    const levelsPast20 = Math.min(10, state.level - 20); // Cap at level 30
                    defensiveScaling = 1.0 - (levelsPast20 * 0.025); // 2.5% reduction per level (max 25%)
                }
                
                // ASCENSION 2: BLOODLUST - Reset stacks on damage taken
                if (state.activeAscension === 2 && state.bloodlustStacks > 0) {
                    const lostStacks = state.bloodlustStacks;
                    state.bloodlustStacks = 0;
                    state.bloodlustTimer = 0;
                    
                    // Visual feedback
                    entities.texts.push({
                        x: this.x,
                        y: this.y - 40,
                        vx: 0,
                        vy: -1.5,
                        text: `BLOODLUST RESET`,
                        color: '#ff0066',
                        life: 60,
                        size: 16,
                        update() { this.x += this.vx; this.y += this.vy; this.life--; return this.life > 0; },
                        draw(ctx) {
                            const alpha = Math.min(1, this.life / 20);
                            ctx.fillStyle = this.color.replace(')', `, ${alpha})`).replace('rgb', 'rgba');
                            ctx.font = `bold ${this.size}px Arial`;
                            ctx.textAlign = 'center';
                            ctx.fillText(this.text, this.x, this.y);
                        }
                    });
                    console.log(`üíî Bloodlust reset! Lost ${lostStacks} stacks.`);
                }
                
                // Calculate effective armor (base armor + adaptive armor stacks)
                let effectiveArmor = this.armor;
                if (this.adaptiveArmorStacks > 0) {
                    // Each stack is 1% armor
                    effectiveArmor += this.adaptiveArmorStacks;
                }
                
                const reduction = Math.min(effectiveArmor, 80) / 100;
                let actualDmg = amount * (1 - reduction) * defensiveScaling;
                
                // ASCENSION 5: CRITICAL WEAKNESS - Enemies can crit (15% base chance, reduced by armor)
                // IMPORTANT: Enemies can ONLY crit if this debuff is active
                let isCrit = false;
                if (this.enemyCritChance && this.enemyCritChance > 0) {
                    // Player armor reduces enemy crit chance (10 armor = -1% crit chance)
                    // With 15 starting armor, player has ~13.5% crit chance against them
                    const effectiveCritChance = Math.max(0, this.enemyCritChance - (effectiveArmor * 0.001));
                    
                    if (Math.random() < effectiveCritChance) {
                        isCrit = true;
                        actualDmg *= 2.0; // 2x damage on crit
                        console.log(`üí• ENEMY CRIT! ${(effectiveCritChance * 100).toFixed(1)}% chance (${(this.enemyCritChance * 100).toFixed(1)}% base - ${(effectiveArmor * 0.1).toFixed(1)}% from ${effectiveArmor} armor)`);
                    }
                }
                
                // GLASS CANNON: +30% damage taken
                if (this.hasGlassCannon) {
                    actualDmg *= 1.30;
                }
                
                if (actualDmg > 0) {
                    this.hp -= actualDmg; 
                    
                    // LOG DAMAGE for death recap
                    const damageEntry = {
                        damage: Math.round(actualDmg),
                        source: damageSource,
                        enemyType: enemyType,
                        timestamp: Date.now(),
                        hpAfter: Math.round(this.hp),
                        wasFatal: this.hp <= 0,
                        isCrit: isCrit // Track if this was a crit
                    };
                    this.damageLog.push(damageEntry);
                    // Keep only last 10 damage instances
                    if (this.damageLog.length > 10) {
                        this.damageLog.shift();
                    }
                    
                    // Enhanced camera shake based on damage amount
                    const shakeIntensity = Math.min(20, 8 + actualDmg * 0.3);
                    state.shake = shakeIntensity;
                    
                    this.lastDamageTime = Date.now(); // Track when damage was taken
                    
                    // ADAPTIVE ARMOR: Reset stacks on damage
                    if (this.adaptiveArmorMaxStacks) {
                        this.adaptiveArmorStacks = 0;
                        this.adaptiveArmorTimer = 0;
                    }
                    
                    // MOMENTUM STRIKE: Reset timer when damaged
                    if (this.hasMomentum) {
                        this.momentumTimer = 0;
                    }
                    
                    // EMERGENCY THRUST: Activate speed boost when hit
                    if (this.hasThrust && this.thrustCooldown <= 0) {
                        this.thrustActive = true;
                        this.thrustTimer = 120; // 2 seconds of boost
                        this.thrustCooldown = 600; // 10 second cooldown
                    }
                    
                    const flash = document.getElementById('damage-flash');
                    flash.style.opacity = 0.6; setTimeout(() => flash.style.opacity = 0, 100);
                    
                    // Base invuln: 0.75s (45 frames)
                    // Reactive Shielding augment adds bonus frames
                    this.invulnTimer = 45 + (this.invulnBonusFrames || 0);
                    
                    // RED DAMAGE NUMBER for player (bigger and pulsing for enemy crit)
                    entities.texts.push({
                        x: this.x + (Math.random() - 0.5) * 30,
                        y: this.y - 20,
                        vx: (Math.random() - 0.5) * 2,
                        vy: -2,
                        text: isCrit ? `-${Math.round(actualDmg)} CRIT!` : `-${Math.round(actualDmg)}`,
                        color: '#ff3860', // Keep red for all damage
                        life: 60,
                        size: isCrit ? 30 : 24, // Bigger for crits
                        isCrit: isCrit,
                        pulsePhase: 0,
                        update() { 
                            this.x += this.vx; 
                            this.y += this.vy; 
                            this.life--;
                            if (this.isCrit) this.pulsePhase += 0.3; // Pulse animation for crits
                            return this.life > 0; 
                        },
                        draw(ctx) {
                            const alpha = Math.min(1, this.life / 20);
                            const pulse = this.isCrit ? 1 + Math.sin(this.pulsePhase) * 0.15 : 1; // 15% size pulse for crits
                            ctx.fillStyle = this.color.replace(')', `, ${alpha})`).replace('rgb', 'rgba');
                            ctx.font = `bold ${this.size * pulse}px Orbitron`;
                            ctx.shadowColor = 'black';
                            ctx.shadowBlur = this.isCrit ? 8 : 4;
                            ctx.textAlign = 'center';
                            ctx.fillText(this.text, this.x, this.y);
                            ctx.shadowBlur = 0;
                        }
                    });
                    
                    // Extra visual feedback for crits
                    if (isCrit) {
                        // Extra particles for crit (red to match damage)
                        for (let i = 0; i < 8; i++) {
                            const angle = (Math.PI * 2 / 8) * i;
                            entities.particles.push({
                                x: this.x,
                                y: this.y,
                                vx: Math.cos(angle) * 4,
                                vy: Math.sin(angle) * 4,
                                color: '#ff3860',
                                life: 20,
                                size: 3,
                                update: function(dt) {
                                    this.x += this.vx * (dt/16);
                                    this.y += this.vy * (dt/16);
                                    this.life -= dt/16;
                                    this.vx *= 0.95;
                                    this.vy *= 0.95;
                                    return this.life > 0;
                                },
                                draw: function(ctx) {
                                    ctx.fillStyle = this.color;
                                    ctx.shadowBlur = 6;
                                    ctx.shadowColor = '#ff0000';
                                    ctx.beginPath();
                                    ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                                    ctx.fill();
                                    ctx.shadowBlur = 0;
                                }
                            });
                        }
                    }
                    
                    // Start recharge timers for depleted shields that aren't already charging
                    if (this.shield1 < 100 && this.shield1RechargeTimer > 0) {
                        // Shield needs charging but isn't charging yet - reset delay
                        this.shield1RechargeTimer = this.shieldRechargeDelay;
                    }
                    if (this.shield2 < 100 && this.shield2RechargeTimer > 0) {
                        // Shield needs charging but isn't charging yet - reset delay
                        this.shield2RechargeTimer = this.shieldRechargeDelay;
                    }
                    // Note: If a shield is actively charging (timer <= 0), we don't touch its timer
                    
                    // SHIELD BURST: Push enemies away when taking damage
                    if (this.hasShieldBurst) {
                        const burstRadius = 200;
                        const burstPower = 25;
                        
                        entities.enemies.forEach(e => {
                            // Boss entities immune to knockback
                            if (e.isNexusPrime || e.isBossShield || e.isBossTurret) return;
                            
                            const dx = e.x - this.x;
                            const dy = e.y - this.y;
                            const dist = Math.sqrt(dx*dx + dy*dy);
                            
                            if (dist < burstRadius && dist > 0) {
                                const strength = (burstRadius - dist) / burstRadius;
                                const pushForce = burstPower * strength;
                                e.pushX = (dx/dist) * pushForce;
                                e.pushY = (dy/dist) * pushForce;
                            }
                        });
                        
                        // Visual feedback for shield burst
                        entities.particles.push(new Shockwave(this.x, this.y, burstRadius, 'rgba(0, 229, 255, 0.4)'));
                        createExplosion(this.x, this.y, '#88d8ff', 15);
                    }
                }
                
                // SECOND CHANCE MOD: Survive fatal damage
                if (this.hp <= 0 && this.activeMod === 'revive') {
                    if (!this.reviveCooldown) this.reviveCooldown = 0;
                    
                    if (this.reviveCooldown <= 0) {
                        // REVIVE!
                        this.hp = this.maxHp * 0.5; // Restore to 50% HP
                        this.reviveCooldown = 7200; // 2 minute cooldown (60 fps * 120 seconds)
                        this.invulnTimer = 120; // 2 seconds invulnerability
                        
                        // Visual feedback
                        createExplosion(this.x, this.y, '#00ff00', 40);
                        entities.particles.push(new Shockwave(this.x, this.y, 150, '#00ff00'));
                        
                        // Screen flash
                        const flash = document.getElementById('damage-flash');
                        flash.style.background = 'rgba(0, 255, 0, 0.5)';
                        flash.style.opacity = 0.8;
                        setTimeout(() => {
                            flash.style.background = 'rgba(255, 0, 0, 0.5)';
                            flash.style.opacity = 0;
                        }, 200);
                        
                        return; // Don't die!
                    }
                }
                
                // PHOENIX CORE (Augment): Respawn with % HP based on tier (cooldown-based)
                if (this.hp <= 0 && this.phoenixReady && this.phoenixReviveHp) {
                    const now = Date.now();
                    
                    // Check if cooldown has expired (first use OR cooldown elapsed)
                    if (this.phoenixCooldownTimer === 0 || (now - this.phoenixCooldownTimer) >= this.phoenixCooldown * 16.67) {
                        // RESPAWN!
                        this.hp = Math.floor(this.maxHp * this.phoenixReviveHp);
                        this.phoenixCooldownTimer = now; // Start cooldown
                        this.phoenixReady = false; // Mark as used (will be ready again after cooldown in update loop)
                        this.invulnTimer = 120; // 2 seconds invulnerability
                    
                    // Visual feedback - Phoenix flames
                    createExplosion(this.x, this.y, '#ff6600', 50);
                    createExplosion(this.x, this.y, '#ffaa00', 40);
                    entities.particles.push(new Shockwave(this.x, this.y, 200, 'rgba(255, 102, 0, 0.5)'));
                    
                    // Phoenix flame particles radiating outward
                    for (let i = 0; i < 20; i++) {
                        const angle = (Math.PI * 2 / 20) * i;
                        const speed = 3 + Math.random() * 2;
                        entities.particles.push({
                            x: this.x,
                            y: this.y,
                            vx: Math.cos(angle) * speed,
                            vy: Math.sin(angle) * speed,
                            color: i % 2 === 0 ? '#ff6600' : '#ffaa00',
                            life: 40,
                            size: 4,
                            update: function(dt) {
                                this.x += this.vx * (dt/16);
                                this.y += this.vy * (dt/16);
                                this.life -= dt/16;
                                this.vx *= 0.95;
                                this.vy *= 0.95;
                                this.size *= 0.98;
                                return this.life > 0;
                            },
                            draw: function(ctx) {
                                const alpha = Math.min(1, this.life / 20);
                                ctx.fillStyle = this.color;
                                ctx.shadowBlur = 12;
                                ctx.shadowColor = this.color;
                                ctx.beginPath();
                                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                                ctx.fill();
                                ctx.shadowBlur = 0;
                            }
                        });
                    }
                    
                    // Upward rising flame particles
                    for (let i = 0; i < 15; i++) {
                        entities.particles.push({
                            x: this.x + (Math.random() - 0.5) * 40,
                            y: this.y + (Math.random() - 0.5) * 20,
                            vx: (Math.random() - 0.5) * 0.5,
                            vy: -2 - Math.random() * 2,
                            color: Math.random() > 0.5 ? '#ff6600' : '#ffdd00',
                            life: 50 + Math.random() * 20,
                            size: 3 + Math.random() * 2,
                            update: function(dt) {
                                this.x += this.vx * (dt/16);
                                this.y += this.vy * (dt/16);
                                this.life -= dt/16;
                                this.vy -= 0.05 * (dt/16); // Rise faster over time
                                return this.life > 0;
                            },
                            draw: function(ctx) {
                                const alpha = Math.min(1, this.life / 30);
                                ctx.fillStyle = this.color;
                                ctx.shadowBlur = 10;
                                ctx.shadowColor = '#ff6600';
                                ctx.beginPath();
                                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                                ctx.fill();
                                ctx.shadowBlur = 0;
                            }
                        });
                    }
                    
                    // Screen flash - orange phoenix flames
                    const flash = document.getElementById('damage-flash');
                    flash.style.background = 'rgba(255, 102, 0, 0.6)';
                    flash.style.opacity = 0.9;
                    setTimeout(() => {
                        flash.style.background = 'rgba(255, 170, 0, 0.4)';
                        flash.style.opacity = 0.6;
                    }, 150);
                    setTimeout(() => {
                        flash.style.background = 'rgba(255, 0, 0, 0.5)';
                        flash.style.opacity = 0;
                    }, 400);
                    
                    // Giant notification text with glow effect
                    entities.texts.push({
                        x: this.x,
                        y: this.y - 40,
                        vx: 0,
                        vy: -1.5,
                        text: 'PHOENIX CORE',
                        color: '#ff6600',
                        life: 90,
                        size: 28,
                        update() { this.x += this.vx; this.y += this.vy; this.life--; return this.life > 0; },
                        draw(ctx) {
                            const alpha = Math.min(1, this.life / 30);
                            const pulse = 1 + Math.sin(this.life * 0.2) * 0.2;
                            ctx.save();
                            ctx.shadowBlur = 30;
                            ctx.shadowColor = '#ff6600';
                            ctx.fillStyle = this.color.replace(')', `, ${alpha})`).replace('rgb', 'rgba');
                            ctx.font = `bold ${this.size * pulse}px Orbitron, Arial`;
                            ctx.textAlign = 'center';
                            ctx.fillText(this.text, this.x, this.y);
                            ctx.restore();
                        }
                    });
                    
                    // Second text line
                    entities.texts.push({
                        x: this.x,
                        y: this.y - 10,
                        vx: 0,
                        vy: -1,
                        text: 'ACTIVATED',
                        color: '#ffaa00',
                        life: 90,
                        size: 18,
                        update() { this.x += this.vx; this.y += this.vy; this.life--; return this.life > 0; },
                        draw(ctx) {
                            const alpha = Math.min(1, this.life / 30);
                            ctx.save();
                            ctx.shadowBlur = 20;
                            ctx.shadowColor = '#ffaa00';
                            ctx.fillStyle = this.color.replace(')', `, ${alpha})`).replace('rgb', 'rgba');
                            ctx.font = `bold ${this.size}px Orbitron, Arial`;
                            ctx.textAlign = 'center';
                            ctx.fillText(this.text, this.x, this.y);
                            ctx.restore();
                        }
                    });
                    
                    console.log(`üî• PHOENIX CORE: Player respawned at ${(this.phoenixReviveHp * 100).toFixed(0)}% HP!`);
                    return; // Don't die!
                    }
                }
                
                // CRITICAL: Force immediate HUD update to show damage taken
                // This ensures the UI reflects current HP/shields even if game is running slow
                if (typeof updateHud === 'function') {
                    updateHud();
                }
                
                if(this.hp <= 0) {
                    console.log('üíÄ Player HP <= 0, triggering death...');
                    console.log('   state.playerDead:', state.playerDead);
                    console.log('   state.screen:', state.screen);
                    
                    // Set flag immediately to prevent multiple death triggers
                    if (!state.playerDead) {
                        console.log('   Setting playerDead flag...');
                        state.playerDead = true;
                        
                        // Call gameOver asynchronously to prevent freezing
                        console.log('   Scheduling gameOver()...');
                        setTimeout(() => {
                            console.log('   setTimeout callback executing...');
                            gameOver();
                        }, 0);
                    } else {
                        console.log('   ‚ö†Ô∏è playerDead already set, skipping gameOver()');
                    }
                }
            }



            update(dt) {
                // Reset volt chain counter each frame for performance
                this.voltChainsThisFrame = 0;
                
                // Calculate fire rate multiplier for Adrenaline Surge (applied to all weapon timers)
                const fireRateMult = (this.ultimateActive && this.ultimate === 'adrenaline_surge' && this.ultimateData) 
                    ? this.ultimateData.fireRateMult 
                    : 1.0;
                
                if (this.invulnTimer > 0) this.invulnTimer -= dt/16;
                
                // ASCENSION 2: BLOODLUST - gain +2% damage per second without taking damage (max 50 stacks = 100%)
                if (state.activeAscension === 2) {
                    if (!state.bloodlustTimer) state.bloodlustTimer = 0;
                    if (!state.bloodlustStacks) state.bloodlustStacks = 0;
                    
                    state.bloodlustTimer += dt/16;
                    
                    // Gain 1 stack every 60 frames (1 second) without damage
                    if (state.bloodlustTimer >= 60 && state.bloodlustStacks < 50) {
                        state.bloodlustStacks++;
                        state.bloodlustTimer = 0;
                        
                        // Visual feedback every 5 stacks
                        if (state.bloodlustStacks % 5 === 0) {
                            entities.texts.push({
                                x: this.x,
                                y: this.y - 30,
                                vx: 0,
                                vy: -1,
                                text: `BLOODLUST ${state.bloodlustStacks}`,
                                color: '#ff0066',
                                life: 45,
                                size: 14,
                                update() { this.x += this.vx; this.y += this.vy; this.life--; return this.life > 0; },
                                draw(ctx) {
                                    const alpha = Math.min(1, this.life / 20);
                                    ctx.fillStyle = this.color.replace(')', `, ${alpha})`).replace('rgb', 'rgba');
                                    ctx.font = `bold ${this.size}px Arial`;
                                    ctx.textAlign = 'center';
                                    ctx.fillText(this.text, this.x, this.y);
                                }
                            });
                        }
                    }
                }
                
                // ADAPTIVE ARMOR AUGMENT: Gain armor per second without taking damage
                if (this.adaptiveArmorMaxStacks) {
                    if (!this.adaptiveArmorTimer) this.adaptiveArmorTimer = 0;
                    if (!this.adaptiveArmorStacks) this.adaptiveArmorStacks = 0;
                    
                    this.adaptiveArmorTimer += dt/16;
                    
                    // Gain 1 stack every 60 frames (1 second) without damage
                    if (this.adaptiveArmorTimer >= 60 && this.adaptiveArmorStacks < this.adaptiveArmorMaxStacks) {
                        this.adaptiveArmorStacks++;
                        this.adaptiveArmorTimer = 0;
                        
                        // Visual feedback every 10 stacks
                        if (this.adaptiveArmorStacks % 10 === 0) {
                            entities.texts.push({
                                x: this.x,
                                y: this.y - 30,
                                vx: 0,
                                vy: -1,
                                text: `ARMOR +${this.adaptiveArmorStacks}%`,
                                color: '#00d1b2',
                                life: 45,
                                size: 14,
                                update() { this.x += this.vx; this.y += this.vy; this.life--; return this.life > 0; },
                                draw(ctx) {
                                    const alpha = Math.min(1, this.life / 20);
                                    ctx.fillStyle = this.color.replace(')', `, ${alpha})`).replace('rgb', 'rgba');
                                    ctx.font = `bold ${this.size}px Arial`;
                                    ctx.textAlign = 'center';
                                    ctx.fillText(this.text, this.x, this.y);
                                }
                            });
                        }
                    }
                }
                
                // ASCENSION 5: Ticking Doom - lose 2 HP per second
                if (state.activeAscension === 5) {
                    if (!this.tickingDoomTimer) this.tickingDoomTimer = 0;
                    this.tickingDoomTimer += dt/16;
                    
                    if (this.tickingDoomTimer >= 60) { // Every 60 frames (1 second)
                        this.hp = Math.max(1, this.hp - 2); // Lose 2 HP per second, never go below 1 HP
                        this.tickingDoomTimer = 0;
                    }
                }
                
                // Whip visual timer
                if (this.whipVisualTimer > 0) {
                    this.whipVisualTimer -= dt/16;
                    if (this.whipVisualTimer < 0) this.whipVisualTimer = 0;
                }
                
                // CATALYST: Aura functionality removed for clean gameplay
                // Burst every 5th hit still functions normally
                
                // SHIELD RECHARGE SYSTEM
                // Once a shield STARTS charging (timer <= 0), it NEVER stops until 100%
                // Only ONE shield can be charging at a time
                // Priority when multiple depleted: Left to right (shield1 ‚Üí shield2 ‚Üí shield3)
                
                // Determine which shield is actively charging
                // Only allow shields to charge if the ship actually has them
                const hasShield1 = this.selectedShip !== 'REAPER'; // All ships except Reaper have shield1
                const hasShield2 = this.selectedShip !== 'REAPER' && this.selectedShip !== 'DISRUPTOR'; // Pathfinder, Engineer, Vanguard
                const hasShield3 = this.selectedShip === 'VANGUARD'; // Only Vanguard
                const hasShield4 = this.selectedShip === 'VANGUARD' && (this.shield4 === 100 || this.shield4RechargeTimer > 0); // Only Vanguard with Shield Capacitor Tier 3
                
                const shield1Charging = hasShield1 && this.shield1 < 100 && this.shield1RechargeTimer <= 0;
                const shield2Charging = hasShield2 && this.shield2 < 100 && this.shield2RechargeTimer <= 0;
                const shield3Charging = hasShield3 && this.shield3 < 100 && this.shield3RechargeTimer <= 0;
                const shield4Charging = hasShield4 && this.shield4 < 100 && this.shield4RechargeTimer <= 0;
                
                // REAPER HAS NO SHIELDS - skip all recharge logic
                if (this.selectedShip !== 'REAPER') {
                    // Shield 1 recharge (LEFT)
                    if (shield1Charging) {
                        // Actively charging - NEVER STOPS
                        this.shield1 += this.shieldRechargeRate * (dt/16) / 60; // 20% per second
                        if (this.shield1 >= 100) {
                            this.shield1 = 100;
                            // Shield 1 finished - if shield 2, 3, or 4 needs charging, start timer
                            if (this.shield2 < 100 && this.shield2RechargeTimer > 0) {
                                this.shield2RechargeTimer = this.shieldRechargeDelay;
                            }
                            if (this.shield3 < 100 && this.shield3RechargeTimer > 0) {
                                this.shield3RechargeTimer = this.shieldRechargeDelay;
                            }
                            if (hasShield4 && this.shield4 < 100 && this.shield4RechargeTimer > 0) {
                                this.shield4RechargeTimer = this.shieldRechargeDelay;
                            }
                        }
                    } else if (this.shield1 < 100 && this.shield1RechargeTimer > 0 && !shield2Charging && !shield3Charging && !shield4Charging) {
                        // Waiting to start charging (only count down if no other shield is charging)
                        this.shield1RechargeTimer -= dt/16;
                    }
                    
                    // Shield 2 recharge (MIDDLE) - only if shield 1 is NOT charging
                    if (shield2Charging && !shield1Charging) {
                        // Actively charging - NEVER STOPS
                        this.shield2 += this.shieldRechargeRate * (dt/16) / 60; // 20% per second
                        if (this.shield2 >= 100) {
                            this.shield2 = 100;
                            // Shield 2 finished - if shield 1, 3, or 4 needs charging, start timer
                            if (this.shield1 < 100 && this.shield1RechargeTimer > 0) {
                                this.shield1RechargeTimer = this.shieldRechargeDelay;
                            }
                            if (this.shield3 < 100 && this.shield3RechargeTimer > 0) {
                                this.shield3RechargeTimer = this.shieldRechargeDelay;
                            }
                            if (hasShield4 && this.shield4 < 100 && this.shield4RechargeTimer > 0) {
                                this.shield4RechargeTimer = this.shieldRechargeDelay;
                            }
                        }
                    } else if (this.shield2 < 100 && this.shield2RechargeTimer > 0 && !shield1Charging && !shield2Charging && !shield3Charging && !shield4Charging) {
                        // Waiting to start charging (only count down if no shield is charging)
                        this.shield2RechargeTimer -= dt/16;
                    }
                    
                    // Shield 3 recharge (RIGHT, Vanguard only) - only if shield 1 and 2 are NOT charging
                    if (shield3Charging && !shield1Charging && !shield2Charging) {
                        // Actively charging - NEVER STOPS
                        this.shield3 += this.shieldRechargeRate * (dt/16) / 60; // 20% per second
                        if (this.shield3 >= 100) {
                            this.shield3 = 100;
                            // Shield 3 finished - if shield 1, 2, or 4 needs charging, start timer
                            if (this.shield1 < 100 && this.shield1RechargeTimer > 0) {
                                this.shield1RechargeTimer = this.shieldRechargeDelay;
                            }
                            if (this.shield2 < 100 && this.shield2RechargeTimer > 0) {
                                this.shield2RechargeTimer = this.shieldRechargeDelay;
                            }
                            if (hasShield4 && this.shield4 < 100 && this.shield4RechargeTimer > 0) {
                                this.shield4RechargeTimer = this.shieldRechargeDelay;
                            }
                        }
                    } else if (this.shield3 < 100 && this.shield3RechargeTimer > 0 && !shield1Charging && !shield2Charging && !shield3Charging && !shield4Charging) {
                        // Waiting to start charging (only count down if no shield is charging)
                        this.shield3RechargeTimer -= dt/16;
                    }
                    
                    // Shield 4 recharge (RIGHTMOST, Vanguard with Shield Capacitor only) - only if shield 1, 2, and 3 are NOT charging
                    if (shield4Charging && !shield1Charging && !shield2Charging && !shield3Charging) {
                        // Actively charging - NEVER STOPS
                        this.shield4 += this.shieldRechargeRate * (dt/16) / 60; // 20% per second
                        if (this.shield4 >= 100) {
                            this.shield4 = 100;
                            // Shield 4 finished - if shield 1, 2, or 3 needs charging, start timer
                            if (this.shield1 < 100 && this.shield1RechargeTimer > 0) {
                                this.shield1RechargeTimer = this.shieldRechargeDelay;
                            }
                            if (this.shield2 < 100 && this.shield2RechargeTimer > 0) {
                                this.shield2RechargeTimer = this.shieldRechargeDelay;
                            }
                            if (this.shield3 < 100 && this.shield3RechargeTimer > 0) {
                                this.shield3RechargeTimer = this.shieldRechargeDelay;
                            }
                        }
                    } else if (hasShield4 && this.shield4 < 100 && this.shield4RechargeTimer > 0 && !shield1Charging && !shield2Charging && !shield3Charging && !shield4Charging) {
                        // Waiting to start charging (only count down if no shield is charging)
                        this.shield4RechargeTimer -= dt/16;
                    }
                }
                
                if (this.regen > 0) {
                    this.regenTimer -= dt/16; // Properly affected by time dilation
                    if (this.regenTimer <= 0) { this.heal(this.regen, false); this.regenTimer = 60; } // Ticks every 1 second
                }
                
                // NEW MOD EFFECTS
                
                // MOMENTUM STRIKE: Track time without damage for damage bonus
                if (this.hasMomentum) {
                    this.momentumTimer += dt/16; // Count frames (60 fps = 1 second per 60 frames)
                    // Cap at 20 seconds = 1200 frames (40% damage bonus)
                    if (this.momentumTimer > 1200) this.momentumTimer = 1200;
                }
                
                // EMERGENCY THRUST: Count down active timer and cooldown
                if (this.hasThrust) {
                    if (this.thrustActive) {
                        this.thrustTimer -= dt/16;
                        if (this.thrustTimer <= 0) {
                            this.thrustActive = false;
                        }
                    }
                    if (this.thrustCooldown > 0) {
                        this.thrustCooldown -= dt/16;
                    }
                }
                
                // REAPER ROUNDS: Count down heal cooldown
                if (this.hasReaper && this.reaperCooldown > 0) {
                    this.reaperCooldown -= dt/16;
                }
                
                // PASSIVE MOD EFFECTS
                if (this.activeMod === 'repulsor') {
                    // Repulsor Field: Passive constant push on drones and swarms
                    entities.enemies.forEach(e => {
                        if ((e.type === 'drone' || e.type === 'swarm') && !e.hackState.active) {
                            const dx = e.x - this.x;
                            const dy = e.y - this.y;
                            const dist = Math.sqrt(dx*dx + dy*dy);
                            if (dist < 150 && dist > 0) { // Increased from 120
                                const pushStrength = (150 - dist) / 150;
                                const pushForce = 0.35 * pushStrength; // Increased from 0.15 - much stronger
                                e.pushX += (dx/dist) * pushForce;
                                e.pushY += (dy/dist) * pushForce;
                            }
                        }
                    });
                }
                
                if (this.activeMod === 'chrono') {
                    // Chrono Shield: Slow time for 10s when HP drops below 30%, 60s cooldown
                    if (!this.chronoCooldown) this.chronoCooldown = 0;
                    
                    const hpPercent = this.hp / this.maxHp;
                    
                    // Trigger if below 30% HP and cooldown ready
                    if (hpPercent < 0.3 && !this.chronoActive && this.chronoCooldown <= 0) {
                        this.chronoActive = true;
                        this.chronoDuration = 600; // 10 seconds (60 fps * 10)
                    }
                    
                    // Handle active duration
                    if (this.chronoActive) {
                        this.chronoDuration -= dt/16;
                        if (this.chronoDuration <= 0) {
                            this.chronoActive = false;
                            this.chronoCooldown = 3600; // 60 second cooldown starts NOW (60 fps * 60)
                        }
                    } else {
                        // Count down cooldown only when NOT active
                        if (this.chronoCooldown > 0) {
                            this.chronoCooldown -= dt/16;
                        }
                    }
                }
                
                if (this.activeMod === 'revive') {
                    // Second Chance: Count down cooldown
                    if (!this.reviveCooldown) this.reviveCooldown = 0;
                    if (this.reviveCooldown > 0) {
                        this.reviveCooldown -= dt/16;
                    }
                }

                // Calculate effective speed (apply ship multiplier and mod bonuses)
                let effectiveSpeed = this.speed * this.shipSpeedMult;
                
                // ADRENALINE SURGE: 3x speed boost when active
                if (this.ultimateActive && this.ultimate === 'adrenaline_surge' && this.ultimateData) {
                    effectiveSpeed *= this.ultimateData.speedMult;
                }
                
                // EMERGENCY THRUST: +50% speed boost when active
                if (this.thrustActive) {
                    effectiveSpeed *= 1.50;
                }

                if (input.active) {
                    // Calculate actual velocity (for weapons that need speed info like barrier)
                    this.vx = input.vector.x * effectiveSpeed;
                    this.vy = input.vector.y * effectiveSpeed;
                    
                    // Phoenix Protocol: Lock player position during channeling
                    if (this.phoenixLocked) {
                        this.x = this.phoenixLockedX;
                        this.y = this.phoenixLockedY;
                        this.vx = 0;
                        this.vy = 0;
                    } else {
                        this.x += this.vx * (dt/16);
                        this.y += this.vy * (dt/16);
                    }
                    
                    this.angle = Math.atan2(input.vector.y, input.vector.x);
                    
                    // Thruster particle trail (5 frames = ~0.083s at 60fps)
                    if (!this.thrusterParticleTimer) this.thrusterParticleTimer = 0;
                    this.thrusterParticleTimer += dt/16;
                    if (this.thrusterParticleTimer >= 5) {
                        this.thrusterParticleTimer -= 5;
                        const backAngle = this.angle + Math.PI;
                        entities.particles.push(new Particle(this.x + Math.cos(backAngle)*15, this.y + Math.sin(backAngle)*15, '#00d1b2', 0.8));
                    }
                } else {
                    // Not moving - zero velocity
                    this.vx = 0;
                    this.vy = 0;
                }
                if(Number.isNaN(this.x)) this.x = 0; 
                if(Number.isNaN(this.y)) this.y = 0;


                // ION
                if (this.weapons.ion > 0) this.cannonAngle += 0.02 * (dt/16);
                const cannonCount = Math.min(4, Math.max(1, this.weapons.ion));
                if (this.cannons.length !== cannonCount) this.cannons = Array(cannonCount).fill(0).map((_, i) => ({ recoil: 0 }));
                this.cannons.forEach(c => { c.recoil *= 0.8; });
                
                if(this.weapons.ion > 0) {
                    this.lastShot -= dt * fireRateMult;
                    // Prevent catch-up firing after lag spikes by clamping how negative the timer can go
                    if (this.lastShot < -100) this.lastShot = -100; // Max 100ms behind
                    
                    if (this.lastShot <= 0) {
                        // Each cannon fires in sequence with independent targeting
                        const cIdx = this.fireIndex % cannonCount;
                        const formationRadius = 24;
                        const offsetAngle = this.cannonAngle + (cIdx * (Math.PI*2/cannonCount));
                        const cannonX = this.x + Math.cos(offsetAngle) * formationRadius;
                        const cannonY = this.y + Math.sin(offsetAngle) * formationRadius;
                        
                        // Find closest enemy to THIS cannon's position
                        // PRIORITY: Boss shields first (if any exist), then closest enemy
                        let target = null;
                        let minDist = this.range * this.weaponStats.ion.area;
                        
                        // Check for boss shields first (highest priority)
                        const activeShields = entities.enemies.filter(e => 
                            e.isBossShield && e.hp > 0 && (!e.spawnInvuln || e.spawnInvuln <= 0)
                        );
                        
                        if (activeShields.length > 0) {
                            // Target closest shield
                            activeShields.forEach(shield => {
                                const dx = shield.x - cannonX;
                                const dy = shield.y - cannonY;
                                const dist = Math.sqrt(dx*dx + dy*dy);
                                if (dist < minDist) {
                                    minDist = dist;
                                    target = shield;
                                }
                            });
                        } else {
                            // No shields - target closest enemy (including boss core)
                            entities.enemies.forEach(e => {
                                if (e.hp <= 0) return;
                                const dx = e.x - cannonX;
                                const dy = e.y - cannonY;
                                const dist = Math.sqrt(dx*dx + dy*dy);
                                if (dist < minDist) {
                                    minDist = dist;
                                    target = e;
                                }
                            });
                        }
                        
                        if (target) {
                            const shootFn = (tgt, cascadeBonus = 1.0) => {
                                const c = this.cannons[cIdx];
                                const formationRadius = 24;
                                const offsetAngle = this.cannonAngle + (cIdx * (Math.PI*2/cannonCount));
                                const cx = this.x + Math.cos(offsetAngle) * formationRadius;
                                const cy = this.y + Math.sin(offsetAngle) * formationRadius;
                                
                                const angle = Math.atan2(tgt.y - cy, tgt.x - cx);
                                c.recoil = 8;
                                entities.particles.push(new MuzzleFlash(cx + Math.cos(angle)*10, cy + Math.sin(angle)*10));
                                
                                // Damage falloff per cannon: 4 cannons total max
                                // 1 cannon = 100%, 2 = 65%, 3 = 55%, 4 = 50%
                                // Total DPS: 1x, 1.3x, 1.65x, 2.0x
                                const cannonPenalty = cannonCount === 1 ? 1.0 : 
                                                      cannonCount === 2 ? 0.65 : 
                                                      cannonCount === 3 ? 0.55 : 0.50;
                                
                                const dmg = this.damage * this.weaponStats.ion.dmg * cannonPenalty * cascadeBonus;
                                entities.projectiles.push(new Projectile(cx, cy, Math.cos(angle) * this.projectileSpeed, Math.sin(angle) * this.projectileSpeed, dmg, this.pierce, 'ion', null, 'ion'));
                            };
                            
                            const shootWithMulti = (dmgMult = 1.0, depth = 0) => {
                                shootFn(target, dmgMult); // Use the target found for THIS cannon
                                checkMultistrike(shootWithMulti, 1.25, depth);
                            };
                            
                            shootWithMulti();
                            
                            // Cooldown divided by cannon count - creates sequential rapid fire
                            const rate = this.fireRate / (this.weaponStats.ion.rate * Math.min(4, Math.max(1, this.weapons.ion)));
                            this.lastShot = rate;
                            this.fireIndex++;
                        }
                    }
                }


                // TESLA - FORKING CHAIN LIGHTNING
                if (this.weapons.tesla > 0) {
                    this.teslaTimer -= (dt/16) * fireRateMult;
                    if (this.teslaTimer < -5) this.teslaTimer = -5; // Prevent catch-up
                    if (this.teslaTimer <= 0) {
                        // Number of bolts: 1 at level 1-2, 2 at level 3-5, 3 at level 6+
                        const numBolts = this.weapons.tesla >= 6 ? 3 : this.weapons.tesla >= 3 ? 2 : 1;
                        
                        const fireTesla = (depth = 0, cascadeDmg = null) => {
                            const range = (250 + (this.weapons.tesla * 25)) * this.weaponStats.tesla.area;
                            const baseDmg = this.damage * 2.5 * this.weaponStats.tesla.dmg;
                            const dmg = cascadeDmg || baseDmg; // Use cascade damage if provided
                            
                            // Recursive forking chain function
                            const chainFork = (source, sourceX, sourceY, hitEnemies, currentDepth, damageMult) => {
                                if (currentDepth >= 3) return; // Max 3 chain depths for 1>2>4 pattern
                                
                                // Find candidates within chain range that haven't been hit
                                // Base 80, scales significantly with area upgrades
                                const chainRange = 80 * this.weaponStats.tesla.area;
                                const candidates = entities.enemies.filter(e => 
                                    !hitEnemies.has(e) && 
                                    e.hp > 0 &&
                                    Math.sqrt((e.x - sourceX)**2 + (e.y - sourceY)**2) < chainRange
                                );
                                
                                // Chains jump to RANDOM enemies within range (not nearest!)
                                // Shuffle candidates
                                for (let i = candidates.length - 1; i > 0; i--) {
                                    const j = Math.floor(seededRandom() * (i + 1));
                                    [candidates[i], candidates[j]] = [candidates[j], candidates[i]];
                                }
                                
                                // Fork to 2 enemies (creates 1>2>4 pattern)
                                const forkCount = Math.min(2, candidates.length);
                                for (let i = 0; i < forkCount; i++) {
                                    const target = candidates[i];
                                    hitEnemies.add(target);
                                    
                                    // Damage decreases: 100% -> 80% -> 64%
                                    const newDamageMult = damageMult * 0.8;
                                    this.dealElementalDamage(target, dmg * newDamageMult, 'tesla', '#ffffff');
                                    
                                    // MORE INTENSE: Double lightning bolt + particles
                                    entities.lightnings.push(new LightningBolt(sourceX, sourceY, target.x, target.y, '#ffeb3b'));
                                    setTimeout(() => {
                                        entities.lightnings.push(new LightningBolt(sourceX, sourceY, target.x, target.y, '#ffeb3b'));
                                    }, 20);
                                    
                                    // Add electric particles for more intensity
                                    for (let p = 0; p < 8; p++) {
                                        entities.particles.push(new Particle(target.x, target.y, '#ffeb3b', 3));
                                    }
                                    
                                    // Recursively chain from this target
                                    setTimeout(() => {
                                        chainFork(target, target.x, target.y, hitEnemies, currentDepth + 1, newDamageMult);
                                    }, 50); // Small delay for visual effect
                                }
                            };
                            
                            // Fire multiple bolts - each gets its own chain
                            const usedEnemies = new Set(); // Track enemies hit across all bolts
                            
                            for (let boltIdx = 0; boltIdx < numBolts; boltIdx++) {
                                // Find CLOSEST enemy within range (exclude already targeted) - ONLY for initial hit
                                const candidates = entities.enemies.filter(e => 
                                    !usedEnemies.has(e) && 
                                    e.hp > 0 &&
                                    Math.sqrt((e.x - this.x)**2 + (e.y - this.y)**2) < range
                                );
                                
                                // Sort by distance and pick closest (ONLY for initial target)
                                candidates.sort((a, b) => {
                                    const distA = Math.sqrt((a.x - this.x)**2 + (a.y - this.y)**2);
                                    const distB = Math.sqrt((b.x - this.x)**2 + (b.y - this.y)**2);
                                    return distA - distB;
                                });
                                
                                const initial = candidates[0];
                                
                                if(initial) {
                                    usedEnemies.add(initial);
                                    const hitEnemies = new Set([initial]);
                                    
                                    // Stagger bolt firing with 500ms delay between each
                                    setTimeout(() => {
                                        this.dealElementalDamage(initial, dmg, 'tesla', '#ffffff');
                                        
                                        // MORE INTENSE: Triple lightning bolt for initial hit
                                        entities.lightnings.push(new LightningBolt(this.x, this.y, initial.x, initial.y, '#ffeb3b'));
                                        setTimeout(() => {
                                            entities.lightnings.push(new LightningBolt(this.x, this.y, initial.x, initial.y, '#ffeb3b'));
                                        }, 15);
                                        setTimeout(() => {
                                            entities.lightnings.push(new LightningBolt(this.x, this.y, initial.x, initial.y, '#ffeb3b'));
                                        }, 30);
                                        
                                        // Add explosion effect for more intensity
                                        createExplosion(initial.x, initial.y, '#ffeb3b', 20);
                                        
                                        // Add electric particles
                                        for (let p = 0; p < 12; p++) {
                                            entities.particles.push(new Particle(initial.x, initial.y, '#ffeb3b', 4));
                                        }
                                        
                                        // Start forking chains after 50ms
                                        setTimeout(() => {
                                            chainFork(initial, initial.x, initial.y, hitEnemies, 0, 1.0);
                                        }, 50);
                                    }, boltIdx * 500); // 500ms between bolts (was 30ms)
                                }
                            }
                        };
                        
                        const fireTeslaWithMulti = (dmgMult = 1.0, depth = 0) => {
                            const baseDmg = this.damage * 2.5 * this.weaponStats.tesla.dmg;
                            fireTesla(depth, baseDmg * dmgMult);
                            checkMultistrike(fireTeslaWithMulti, 1.25, depth);
                        };
                        
                        fireTeslaWithMulti();
                        this.maxTeslaTimer = Math.max(40, 180 / this.weaponStats.tesla.rate); // Increased from 150 (20% longer cooldown)
                        this.teslaTimer = this.maxTeslaTimer;
                    }
                }


                // RAD
                if (this.weapons.rad > 0) {
                    const radius = (60 + (this.weapons.rad * 15)) * this.weaponStats.rad.area;
                    const baseDotDmg = (this.damage * 0.08 * this.weaponStats.rad.dmg) * (dt/16); // Reduced from 0.15 back to 0.08 (more balanced)
                    
                    // Tick counter that respects time dilation
                    if (!this.radTickCounter) this.radTickCounter = 0;
                    this.radTickCounter += dt/16;
                    
                    if(this.radTickCounter >= 20) {
                        this.radTickCounter -= 20;
                         for(let e of entities.enemies) {
                            const distSq = (e.x-this.x)**2 + (e.y-this.y)**2;
                            if (distSq < radius*radius) {
                                // Distance-based damage multiplier: 1.5x at center, 0.75x at edge (less extreme)
                                const dist = Math.sqrt(distSq);
                                const distanceRatio = 1 - (dist / radius); // 1.0 at center, 0.0 at edge
                                const damageMultiplier = 0.75 + (distanceRatio * 0.75); // 1.5x at center, 0.75x at edge
                                const tickDmg = baseDotDmg * 20 * damageMultiplier;
                                this.dealElementalDamage(e, tickDmg, 'rad', '#ffffff', false); 
                            }
                        }
                    }
                }


                // SEEKER
                if (this.weapons.seeker > 0) {
                    this.seekerTimer -= (dt/16) * fireRateMult;
                    if (this.seekerTimer <= 0) {
                        const fireSeeker = (dmgMult = 1.0, depth = 0) => {
                            const count = Math.min(4, this.weapons.seeker); // Cap at 4 missiles instead of 5
                            
                            // Target ANY visible enemies on screen - no distance limit
                            const visibleEnemies = entities.enemies.filter(e => e.hp > 0);
                            
                            if (visibleEnemies.length === 0) return false; // Return false = didn't fire
                            
                            // PRIORITY TARGETING: Boss Shields > Champions > Clusters
                            let bestTarget;
                            let clusterEnemies;
                            
                            // Check for boss shields FIRST (highest priority) - exclude destroyed shields
                            const bossShields = visibleEnemies.filter(e => e.isBossShield && e.active && e.hp > 0 && (!e.spawnInvuln || e.spawnInvuln <= 0));
                            const champions = visibleEnemies.filter(e => e.isChampion);
                            
                            if (bossShields.length > 0) {
                                // Target all shields
                                bestTarget = bossShields[0];
                                clusterEnemies = bossShields;
                            } else if (champions.length > 0) {
                                // Target champion(s)
                                bestTarget = champions[0];
                                clusterEnemies = champions;
                            } else if (visibleEnemies.length === 1) {
                                // Simple case: only one enemy (like a boss) - target it directly
                                bestTarget = visibleEnemies[0];
                                clusterEnemies = [bestTarget];
                            } else {
                                // Find cluster (densest area)
                                bestTarget = null;
                                let bestDensity = 0;
                                
                                for (let e of visibleEnemies) {
                                    const nearby = visibleEnemies.filter(e2 => {
                                        const dist = Math.sqrt((e.x - e2.x)**2 + (e.y - e2.y)**2);
                                        return dist < 150; // Cluster radius
                                    }).length;
                                    
                                    if (nearby >= bestDensity) {
                                        bestDensity = nearby;
                                        bestTarget = e;
                                    }
                                }
                                
                                if (!bestTarget) bestTarget = visibleEnemies[0];
                                
                                // Get enemies near the cluster center for targeting
                                clusterEnemies = visibleEnemies.filter(e => {
                                    const dist = Math.sqrt((e.x - bestTarget.x)**2 + (e.y - bestTarget.y)**2);
                                    return dist < 200;
                                });
                                
                                // Ensure we always have at least the best target
                                if (clusterEnemies.length === 0) {
                                    clusterEnemies = [bestTarget];
                                }
                            }
                            
                            const targets = clusterEnemies.slice(0, count + 2);
                            const dmg = this.damage * 2.8 * this.weaponStats.seeker.dmg * dmgMult; // Adjusted from 3.0x for 4 missiles
                            
                            // Create randomized firing order
                            const firingOrder = [];
                            for(let i = 0; i < count; i++) {
                                firingOrder.push(i);
                            }
                            // Shuffle the array (Fisher-Yates)
                            for(let i = firingOrder.length - 1; i > 0; i--) {
                                const j = Math.floor(seededRandom() * (i + 1));
                                [firingOrder[i], firingOrder[j]] = [firingOrder[j], firingOrder[i]];
                            }
                            
                            for(let idx = 0; idx < count; idx++) {
                                const i = firingOrder[idx]; // Use randomized index
                                const target = targets[i % targets.length] || null;
                                const spread = (Math.PI/6) * (i - (count-1)/2) * 0.5; 
                                const fireAngle = this.angle + spread;
                                const vx = Math.cos(fireAngle) * 8; 
                                const vy = Math.sin(fireAngle) * 8;
                                
                                // Stagger missile launches with small delays (2-3 frames between each)
                                const launchDelay = idx * (2 + seededRandom() * 1);
                                
                                setTimeout(() => {
                                    entities.projectiles.push(new Projectile(
                                        this.x + Math.cos(this.angle)*20, 
                                        this.y + Math.sin(this.angle)*20, 
                                        vx, vy, dmg, 0, 'seeker', target, 'seeker'
                                    ));
                                }, launchDelay * (1000/60)); // Convert frames to milliseconds
                            }
                            
                            // Check for multistrike with decay
                            checkMultistrike(fireSeeker, 1.25, depth);
                            
                            return true; // Return true = successfully fired
                        };
                        
                        const didFire = fireSeeker();
                        
                        // Only reset timer if we actually fired
                        if (didFire) {
                            this.maxSeekerTimer = 110 / this.weaponStats.seeker.rate;
                            this.seekerTimer = this.maxSeekerTimer;
                        } else {
                            // Didn't fire - try again sooner
                            this.seekerTimer = 10; // Try again in 10 frames
                        }
                    }
                }



                // PLASMA WHIP - Wide arc slash in front of player
                if (this.weapons.whip > 0) {
                    this.whipTimer -= (dt/16) * fireRateMult;
                    if (this.whipTimer <= 0) {
                        const range = (100 + (this.weapons.whip * 5)) * this.weaponStats.whip.area; // Much slower scaling: 5 per level
                        const dmg = this.damage * 2.5 * this.weaponStats.whip.dmg; // High damage for cooldown weapon
                        const arcAngle = Math.PI * 2; // Full 360 degrees
                        
                        const fireWhip = (damageBonus = 1.0) => {
                            const centerAngle = this.angle;
                            const startAngle = centerAngle - arcAngle / 2;
                            const finalDmg = dmg * damageBonus;
                            
                            // Plasma whip has 2x crit chance multiplier and +25% crit damage
                            const originalCrit = this.critChance;
                            const originalCritMult = this.critMult;
                            this.critChance *= 2;
                            this.critMult *= 1.25; // +25% crit damage
                            
                            // PROJECTILE DEFLECTION: Check for enemy projectiles in whip arc
                            entities.enemyProjectiles.forEach(proj => {
                                const dist = Math.sqrt((proj.x - this.x)**2 + (proj.y - this.y)**2);
                                if (dist < range && !proj.deflected) {
                                    const angleToProj = Math.atan2(proj.y - this.y, proj.x - this.x);
                                    let angleDiff = angleToProj - centerAngle;
                                    while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                                    while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
                                    
                                    if (Math.abs(angleDiff) <= arcAngle / 2) {
                                        // Store the original shooter as the target
                                        const originEnemy = entities.enemies.find(e => e === proj.shooter);
                                        let targetEnemy = originEnemy;
                                        
                                        if (originEnemy && originEnemy.hp > 0) {
                                            // Origin enemy is alive, target them
                                            const angle = Math.atan2(originEnemy.y - proj.y, originEnemy.x - proj.x);
                                            proj.vx = Math.cos(angle) * 12;
                                            proj.vy = Math.sin(angle) * 12;
                                        } else {
                                            // If origin enemy is dead or not found, find nearest enemy
                                            let nearestEnemy = null;
                                            let minDist = Infinity;
                                            entities.enemies.forEach(e => {
                                                if (e.hp > 0) {
                                                    const d = Math.sqrt((e.x - proj.x)**2 + (e.y - proj.y)**2);
                                                    if (d < minDist) {
                                                        minDist = d;
                                                        nearestEnemy = e;
                                                    }
                                                }
                                            });
                                            if (nearestEnemy) {
                                                targetEnemy = nearestEnemy;
                                                const angle = Math.atan2(nearestEnemy.y - proj.y, nearestEnemy.x - proj.x);
                                                proj.vx = Math.cos(angle) * 12;
                                                proj.vy = Math.sin(angle) * 12;
                                            }
                                        }
                                        
                                        proj.deflected = true; // Mark as deflected
                                        proj.originEnemy = targetEnemy; // Track target for homing (always set to valid enemy)
                                        proj.deflectedDamage = finalDmg; // Full whip damage
                                        proj.color = '#ff00ff'; // Change to plasma whip purple
                                        proj.hitEnemies = []; // Track hit enemies to avoid double-hitting
                                        
                                        // Visual feedback
                                        createExplosion(proj.x, proj.y, '#ff00ff', 15);
                                    }
                                }
                            });
                            
                            // Hit all enemies in arc
                            entities.enemies.forEach(e => {
                                if (e.hp > 0) {
                                    const dist = Math.sqrt((e.x - this.x)**2 + (e.y - this.y)**2);
                                    if (dist < range) {
                                        const angleToEnemy = Math.atan2(e.y - this.y, e.x - this.x);
                                        let angleDiff = angleToEnemy - centerAngle;
                                        while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                                        while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
                                        
                                        if (Math.abs(angleDiff) <= arcAngle / 2) {
                                            this.dealElementalDamage(e, finalDmg, 'whip', '#ff00ff');
                                        }
                                    }
                                }
                            });
                            
                            // Restore original crit stats
                            this.critChance = originalCrit;
                            this.critMult = originalCritMult;
                        };
                        
                        const fireWhipWithMulti = (dmgMult = 1.0, depth = 0) => {
                            fireWhip(dmgMult);
                            checkMultistrike(fireWhipWithMulti, 1.25, depth);
                        };
                        
                        fireWhipWithMulti();
                        this.whipTimer = Math.max(40, 120 / this.weaponStats.whip.rate);
                        
                // Set visual timer for drawing
                        this.whipVisualTimer = 20; // Faster, snappier animation (was 30)
                        this.whipVisualAngle = this.angle;
                    }
                }


                // METEOR SHOWER (5 meteors in cluster)
                if (this.weapons.meteor > 0) {
                    this.meteorTimer -= (dt/16) * fireRateMult;
                    if (this.meteorTimer <= 0) {
                        const fireMeteorShower = (damageBonus = 1.0) => {
                            // Filter enemies closer to center of screen (within 60% of visible area)
                            const visibleEnemies = entities.enemies.filter(e => {
                                 return Math.abs(e.x - this.x) < width/state.zoom/2.5 && Math.abs(e.y - this.y) < height/state.zoom/2.5;
                            });
                            
                            // PRIORITY: Target champions if available
                            const visibleChampions = visibleEnemies.filter(e => e.type === 'champion');
                            const targetPool = visibleChampions.length > 0 ? visibleChampions : visibleEnemies;
                            
                            // Find best cluster: enemy with most nearby allies
                            let bestTarget = null;
                            let maxNearby = 0;
                            
                            targetPool.forEach(e => {
                                let nearbyCount = 0;
                                visibleEnemies.forEach(other => {
                                    if (other !== e) {
                                        const dist = Math.sqrt((e.x - other.x)**2 + (e.y - other.y)**2);
                                        if (dist < 150) nearbyCount++; // Count enemies within 150 units
                                    }
                                });
                                // Bonus weight for champions
                                if (e.type === 'champion') nearbyCount += 5;
                                
                                if (nearbyCount > maxNearby) {
                                    maxNearby = nearbyCount;
                                    bestTarget = e;
                                }
                            });
                            
                            // Use clustered target if found, otherwise pick random from visible, fallback to near player
                            let centerX, centerY;
                            if (bestTarget) {
                                centerX = bestTarget.x;
                                centerY = bestTarget.y;
                            } else if (visibleEnemies.length > 0) {
                                const target = visibleEnemies[Math.floor(seededRandom() * visibleEnemies.length)];
                                centerX = target.x;
                                centerY = target.y;
                            } else {
                                // Fallback: near player but not too far
                                centerX = this.x + (seededRandom()-0.5) * 150;
                                centerY = this.y + (seededRandom()-0.5) * 150;
                            }
                            
                            const rad = (25 + (this.weapons.meteor * 6)) * this.weaponStats.meteor.area; // Reduced base: 30‚Üí25, scaling: 8‚Üí6
                            const baseDmg = 25 + (this.weapons.meteor * 8); // Reduced scaling: 15‚Üí12‚Üí8 per level
                            const dmg = baseDmg * this.weaponStats.meteor.dmg * damageBonus; // Apply cascade bonus
                            const clusterSpread = 80; // Meteors land within 80 units of center
                            
                            // Fire 5 meteors in cluster with increased delays
                            for (let i = 0; i < 5; i++) {
                                setTimeout(() => {
                                    const offsetX = (seededRandom() - 0.5) * clusterSpread;
                                    const offsetY = (seededRandom() - 0.5) * clusterSpread;
                                    const tx = centerX + offsetX;
                                    const ty = centerY + offsetY;
                                    
                                    entities.projectiles.push(new Projectile(
                                        tx, ty, 0, 0, dmg, 999, 'meteor_warning', { radius: rad }, 'meteor'
                                    ));
                                }, i * 120); // Increased delay: 80ms ‚Üí 120ms
                            }
                        };
                        
                        const fireMeteorWithMulti = (dmgMult = 1.0, depth = 0) => {
                            fireMeteorShower(dmgMult);
                            checkMultistrike(fireMeteorWithMulti, 1.25, depth);
                        };
                        
                        fireMeteorWithMulti();
                        this.maxMeteorTimer = Math.max(120, 300 / this.weaponStats.meteor.rate); 
                        this.meteorTimer = this.maxMeteorTimer;
                    }
                }


                // RAILGUN
                if (this.weapons.railgun > 0) {
                    this.railgunTimer -= (dt/16) * fireRateMult;
                    if (this.railgunTimer <= 0) {
                        const fireRailgun = (damageBonus = 1.0, depth = 0) => {
                            // Find dense enemy clusters to target
                            const visibleRadius = Math.min(width, height) / state.zoom * 0.4;
                            const maxSearchRadius = 500; // Railgun has longer range
                            
                            // Find enemies in visible range
                            const visibleEnemies = entities.enemies.filter(e => {
                                const dist = Math.sqrt((e.x - this.x)**2 + (e.y - this.y)**2);
                                return dist < visibleRadius && e.hp > 0;
                            });
                            
                            let targetPool = visibleEnemies.length > 0 ? visibleEnemies : entities.enemies.filter(e => {
                                const dist = Math.sqrt((e.x - this.x)**2 + (e.y - this.y)**2);
                                return dist < maxSearchRadius && e.hp > 0;
                            });
                            
                            if (targetPool.length === 0) return; // No targets
                            
                            // Find cluster (densest area)
                            let bestTarget = null;
                            let bestDensity = 0;
                            
                            for (let e of targetPool) {
                                const nearby = targetPool.filter(e2 => {
                                    const dist = Math.sqrt((e.x - e2.x)**2 + (e.y - e2.y)**2);
                                    return dist < 200; // Cluster radius
                                }).length;
                                
                                if (nearby > bestDensity) {
                                    bestDensity = nearby;
                                    bestTarget = e;
                                }
                            }
                            
                            if (!bestTarget) bestTarget = targetPool[0];
                            
                            const angle = Math.atan2(bestTarget.y - this.y, bestTarget.x - this.x);
                            const vx = Math.cos(angle); 
                            const vy = Math.sin(angle);
                            const dmg = 150 * this.weaponStats.railgun.dmg * damageBonus; // Increased from 100 - devastating single shot
                            entities.projectiles.push(new Projectile(
                                this.x, this.y, vx, vy, dmg, 999, 'railgun', { level: this.weapons.railgun }, 'railgun'
                            ));
                            entities.particles.push(new MuzzleFlash(this.x + vx*20, this.y + vy*20));
                            
                            // Check for multistrike with depth parameter
                            checkMultistrike(fireRailgun, 1.25, depth);
                        };
                        fireRailgun();

                        const rateMod = (400 / this.fireRate); 
                        this.maxRailgunTimer = (203 / this.weaponStats.railgun.rate) * rateMod; // Reduced from 270 (25% faster)
                        this.railgunTimer = this.maxRailgunTimer;
                    }
                }


                // FLAK CANNON
                if (this.weapons.flak > 0) {
                    this.flakTimer -= (dt/16) * fireRateMult;
                    if (this.flakTimer <= 0) {
                        // Find dense enemy clusters to target
                        const visibleRadius = Math.min(width, height) / state.zoom * 0.4;
                        const maxSearchRadius = 450;
                        
                        // Find enemies in visible range
                        const visibleEnemies = entities.enemies.filter(e => {
                            const dist = Math.sqrt((e.x - this.x)**2 + (e.y - this.y)**2);
                            return dist < visibleRadius && e.hp > 0;
                        });
                        
                        let targetPool = visibleEnemies.length > 0 ? visibleEnemies : entities.enemies.filter(e => {
                            const dist = Math.sqrt((e.x - this.x)**2 + (e.y - this.y)**2);
                            return dist < maxSearchRadius && e.hp > 0;
                        });
                        
                        // Find cluster (densest area)
                        let bestTarget = null;
                        let bestDensity = 0;
                        
                        if (targetPool.length > 0) {
                            for (let e of targetPool) {
                                const nearby = targetPool.filter(e2 => {
                                    const dist = Math.sqrt((e.x - e2.x)**2 + (e.y - e2.y)**2);
                                    return dist < 200; // Cluster radius
                                }).length;
                                
                                if (nearby > bestDensity) {
                                    bestDensity = nearby;
                                    bestTarget = e;
                                }
                            }
                            
                            if (!bestTarget) bestTarget = targetPool[0];
                        }
                        
                        let baseAngle = this.angle;
                        if (bestTarget) {
                            baseAngle = Math.atan2(bestTarget.y - this.y, bestTarget.x - this.x);
                        }

                        const fireFlak = (dmgMult = 1.0, depth = 0) => {
                            // Fire 3 pellets in a spread pattern
                            const pelletCount = 3;
                            const spreadAngle = Math.PI / 15; // 12 degrees spread (was 15)
                            
                            for (let i = 0; i < pelletCount; i++) {
                                const angleOffset = (i - 1) * spreadAngle; // -12¬∞, 0¬∞, +12¬∞
                                const angle = baseAngle + angleOffset;
                                const vx = Math.cos(angle) * 10;
                                const vy = Math.sin(angle) * 10;
                                
                                // Base damage: 30, scales 30% per level
                                const dmg = 30 * this.weaponStats.flak.dmg * dmgMult;
                                entities.projectiles.push(new Projectile(
                                    this.x, this.y, vx, vy, dmg, 0, 'flak_shell', { range: 300, level: this.weapons.flak }, 'flak'
                                ));
                                entities.particles.push(new MuzzleFlash(this.x + vx, this.y + vy));
                            }
                            
                            checkMultistrike(fireFlak, 1.25, depth);
                        };
                        fireFlak();
                        
                        this.maxFlakTimer = Math.max(100, 166 / this.weaponStats.flak.rate); // Reduced from 200 (17% faster)
                        this.flakTimer = this.maxFlakTimer;
                    }
                }


                // PLASMA BEAM
                if (this.weapons.beam > 0) {
                    if (this.beamActive) {
                        // Track beam active time for ignition flash
                        if (!this.beamActiveTime) this.beamActiveTime = 0;
                        this.beamActiveTime += dt/16;
                        
                        this.beamTimer -= dt;
                        if (this.beamTimer <= 0) { 
                            this.beamActive = false; 
                            this.beamActiveTime = 0;
                            this.beamCooldown = 3000 / this.weaponStats.beam.rate; 
                            
                            // Store termination data before clearing targets
                            if (this.beamTargets.length > 0) {
                                // Store target positions for fade-out rendering
                                this.beamTerminationTargets = this.beamTargets.map(t => ({x: t.x, y: t.y}));
                                
                                // Randomize termination order
                                this.beamTerminationOrder = [];
                                const indices = this.beamTargets.map((_, i) => i);
                                for (let i = indices.length - 1; i > 0; i--) {
                                    const j = Math.floor(seededRandom() * (i + 1));
                                    [indices[i], indices[j]] = [indices[j], indices[i]];
                                }
                                this.beamTerminationOrder = indices;
                            }
                            
                            this.beamTargets = [];
                            this.beamRampMap.clear(); // Reset ramp when beam ends
                            this.beamTerminationTimer = 25; // Total termination animation time (25 frames)
                        } 
                        else {
                            // Tick counter that respects time dilation
                            if (!this.beamTickCounter) this.beamTickCounter = 0;
                            this.beamTickCounter += dt/16; // Use scaled dt
                            
                            if (this.beamTickCounter >= 20) {
                                this.beamTickCounter -= 20;
                                
                                const maxTargets = Math.min(3, this.weapons.beam);
                                // Filter to ALIVE enemies only (hp > 0), including shields
                                const possibleTargets = entities.enemies.filter(e => {
                                    if (e.hp <= 0) return false; // Dead enemies/shields
                                    const dist = Math.sqrt((e.x-this.x)**2 + (e.y-this.y)**2);
                                    return dist < (300 + this.weapons.beam * 30) * this.weaponStats.beam.area;
                                });
                                possibleTargets.sort((a,b) => {
                                    const da = Math.sqrt((a.x-this.x)**2 + (a.y-this.y)**2);
                                    const db = Math.sqrt((b.x-this.x)**2 + (b.y-this.y)**2);
                                    return da - db;
                                });
                                
                                const newTargets = possibleTargets.slice(0, maxTargets);
                                
                                // Clear ramp for enemies no longer targeted
                                const currentTargetIds = new Set(newTargets.map(t => t));
                                for (let [enemy, ramp] of this.beamRampMap.entries()) {
                                    if (!currentTargetIds.has(enemy)) {
                                        this.beamRampMap.delete(enemy);
                                    }
                                }
                                
                                this.beamTargets = newTargets;
                                
                                // Set up staggered ignition order (only once when targets first acquired)
                                if (!this.beamIgnitionOrder && this.beamTargets.length > 0) {
                                    this.beamIgnitionOrder = [];
                                    const indices = this.beamTargets.map((_, i) => i);
                                    // Randomize ignition order
                                    for (let i = indices.length - 1; i > 0; i--) {
                                        const j = Math.floor(seededRandom() * (i + 1));
                                        [indices[i], indices[j]] = [indices[j], indices[i]];
                                    }
                                    this.beamIgnitionOrder = indices;
                                }
                                
                                const baseDmg = this.damage * 1.5 * this.weaponStats.beam.dmg; // Buffed from 1.0x to 1.5x

                                // Check if targeting a boss - if so, count number of beams hitting it
                                const bossTarget = this.beamTargets.find(t => t.type === 'boss');
                                const bossBeamCount = bossTarget ? this.beamTargets.filter(t => t === bossTarget).length : 0;
                                
                                this.beamTargets.forEach(t => {
                                    // Track damage ramp: increases from 0.75x to 2.0x over 3 seconds (180 frames)
                                    if (!this.beamRampMap.has(t)) {
                                        this.beamRampMap.set(t, 0);
                                    }
                                    let rampFrames = this.beamRampMap.get(t);
                                    rampFrames += 20; // Increment by tick interval
                                    this.beamRampMap.set(t, rampFrames);
                                    
                                    // Damage multiplier: 0.75x ‚Üí 2.0x over 180 frames (linear ramp)
                                    const rampProgress = Math.min(rampFrames / 180, 1.0);
                                    const damageMultiplier = 0.75 + (rampProgress * 1.25); // 0.75x ‚Üí 2.0x
                                    
                                    let finalDmg = baseDmg * damageMultiplier;
                                    
                                    // MULTI-BEAM BONUS: If all beams hit same target, multiply damage
                                    // Count how many beams are on THIS specific target
                                    const beamsOnThisTarget = this.beamTargets.filter(target => target === t).length;
                                    if (beamsOnThisTarget > 1) {
                                        finalDmg *= beamsOnThisTarget; // 2 beams = 2x, 3 beams = 3x
                                    }
                                    
                                    this.dealElementalDamage(t, finalDmg, 'beam', '#ffffff');
                                });
                            }
                        }
                    } else {
                        this.beamCooldown -= dt * fireRateMult;
                        if (this.beamCooldown <= 0) { 
                            this.beamActive = true; 
                            this.beamTimer = 3000; 
                            this.beamTickCounter = 0;
                            this.beamIgnitionOrder = null; // Reset for next activation
                            this.beamIgnitionFlash = 15; // Trigger flash when beam activates
                        }
                    }
                }

                // ENERGY PYLONS
                if (this.weapons.pylons > 0) {
                    const pylonsStartTime = performance.now();
                    
                    this.pylonTimer -= (dt/16) * fireRateMult;
                    if (this.pylonTimer <= 0) {
                        // Place new pylon at current location
                        this.pylons.push({ x: this.x, y: this.y, life: 99999 });
                        
                        // Remove oldest if over max
                        const maxPylons = Math.min(6, 3 + Math.floor(this.weapons.pylons / 2));
                        while (this.pylons.length > maxPylons) {
                            this.pylons.shift();
                        }
                        
                        this.maxPylonTimer = Math.max(200, 300 / this.weaponStats.pylons.rate);
                        this.pylonTimer = this.maxPylonTimer;
                    }
                    
                    // Damage enemies crossing pylon lines
                    // Tick counter that respects time dilation
                    if (!this.pylonTickCounter) this.pylonTickCounter = 0;
                    this.pylonTickCounter += dt/16;
                    
                    // Tick every 0.33 seconds (20 frames at 60fps) - framerate independent
                    const pylonTickInterval = 20; // In "frames" but dt-scaled
                    if (this.pylonTickCounter >= pylonTickInterval && this.pylons.length >= 2) {
                        const damageCheckStart = performance.now();
                        this.pylonTickCounter -= pylonTickInterval;
                        
                        // Cache pylon pairs to avoid recalculating every frame
                        if (!this.cachedPylonPairs || this.pylons.length !== this.lastPylonCount) {
                            this.cachedPylonPairs = [];
                            for (let i = 0; i < this.pylons.length; i++) {
                                for (let j = i + 1; j < this.pylons.length; j++) {
                                    this.cachedPylonPairs.push({ i, j });
                                }
                            }
                            this.lastPylonCount = this.pylons.length;
                        }
                        
                        // Pre-calculate threshold
                        const hitRadius = 18 * this.weaponStats.pylons.area;
                        const hitRadiusSq = hitRadius * hitRadius;
                        const pylonDmg = this.damage * 0.5 * this.weaponStats.pylons.dmg;
                        
                        let enemiesChecked = 0;
                        let pairsChecked = 0;
                        let boundingBoxSkips = 0;
                        let lineChecksCalled = 0;
                        
                        // OPTIMIZED: Only check enemies once against all pairs
                        for (let e of entities.enemies) {
                            if (e.hp <= 0) continue; // Skip dead enemies
                            enemiesChecked++;
                            
                            let hitThisFrame = false;
                            
                            // Check against cached pairs
                            for (let pair of this.cachedPylonPairs) {
                                if (hitThisFrame) break; // Only hit once per frame per enemy
                                pairsChecked++;
                                
                                const p1 = this.pylons[pair.i];
                                const p2 = this.pylons[pair.j];
                                
                                // Quick bounding box check first (much faster than line segment distance)
                                const minX = Math.min(p1.x, p2.x) - hitRadius;
                                const maxX = Math.max(p1.x, p2.x) + hitRadius;
                                const minY = Math.min(p1.y, p2.y) - hitRadius;
                                const maxY = Math.max(p1.y, p2.y) + hitRadius;
                                
                                if (e.x < minX || e.x > maxX || e.y < minY || e.y > maxY) {
                                    boundingBoxSkips++;
                                    continue; // Skip expensive distance calculation
                                }
                                
                                // Only now do the precise line segment check
                                lineChecksCalled++;
                                const dist = this.distanceToLineSegment(e.x, e.y, p1.x, p1.y, p2.x, p2.y);
                                if (dist < hitRadius) {
                                    this.dealElementalDamage(e, pylonDmg, 'pylons', '#ff64ff', false);
                                    hitThisFrame = true;
                                }
                            }
                        }
                        
                        const damageCheckTime = performance.now() - damageCheckStart;
                        
                        // Log performance metrics every 5 seconds
                        if (!this.pylonPerfLogTimer) this.pylonPerfLogTimer = 0;
                        this.pylonPerfLogTimer += dt/16;
                        if (this.pylonPerfLogTimer >= 300) { // Every 5 seconds
                            console.log(`‚ö° PYLONS DAMAGE CHECK - ${damageCheckTime.toFixed(2)}ms | Enemies: ${enemiesChecked} | Pairs: ${this.cachedPylonPairs.length} | Total checks: ${pairsChecked} | BB skips: ${boundingBoxSkips} | Line checks: ${lineChecksCalled}`);
                            this.pylonPerfLogTimer = 0;
                        }
                    }
                    
                    const pylonsTotalTime = performance.now() - pylonsStartTime;
                    
                    // Track peak pylons time
                    if (!this.pylonsPeakTime) this.pylonsPeakTime = 0;
                    if (pylonsTotalTime > this.pylonsPeakTime) {
                        this.pylonsPeakTime = pylonsTotalTime;
                        if (pylonsTotalTime > 2) { // Log if over 2ms
                            console.warn(`‚ö†Ô∏è PYLONS SLOW UPDATE: ${pylonsTotalTime.toFixed(2)}ms (peak) | Pylons: ${this.pylons.length} | Enemies: ${entities.enemies.length}`);
                        }
                    }
                }

                // COLLAPSAR MINES - Launch toward enemy clusters
                if (this.weapons.mines > 0) {
                    this.minesTimer -= (dt/16) * fireRateMult;
                    if (this.minesTimer <= 0) {
                        // Multi-mine deployment based on level
                        let mineCount = 1; // Level 1-2: 1 mine
                        if (this.weapons.mines >= 5) mineCount = 3; // Level 5+: 3 mines
                        else if (this.weapons.mines >= 3) mineCount = 2; // Level 3-4: 2 mines
                        
                        const deployMine = (dmgMult = 1.0, depth = 0, angleOffset = 0) => {
                            // Find dense enemy clusters to target
                            const visibleRadius = Math.min(width, height) / state.zoom * 0.4;
                            const maxSearchRadius = 350; // Reduced from 450 to prevent off-screen throws
                            
                            // Find enemies in visible range
                            const visibleEnemies = entities.enemies.filter(e => {
                                const dist = Math.sqrt((e.x - this.x)**2 + (e.y - this.y)**2);
                                return dist < visibleRadius && e.hp > 0;
                            });
                            
                            let targetPool = visibleEnemies.length > 0 ? visibleEnemies : entities.enemies.filter(e => {
                                const dist = Math.sqrt((e.x - this.x)**2 + (e.y - this.y)**2);
                                return dist < maxSearchRadius && e.hp > 0;
                            });
                            
                            if (targetPool.length === 0) return; // No targets
                            
                            // Find cluster (densest area) - each mine targets independently
                            let bestTarget = null;
                            let bestDensity = 0;
                            
                            for (let e of targetPool) {
                                const nearby = targetPool.filter(e2 => {
                                    const dist = Math.sqrt((e.x - e2.x)**2 + (e.y - e2.y)**2);
                                    return dist < 200; // Cluster radius
                                }).length;
                                
                                if (nearby > bestDensity) {
                                    bestDensity = nearby;
                                    bestTarget = e;
                                }
                            }
                            
                            if (!bestTarget) bestTarget = targetPool[0];
                            
                            // Deploy mine with angle spread for multiple mines
                            const baseAngle = Math.atan2(bestTarget.y - this.y, bestTarget.x - this.x) + angleOffset;
                            
                            // Variable speed based on distance AND index to prevent stacking
                            const distToTarget = Math.sqrt((bestTarget.x - this.x)**2 + (bestTarget.y - this.y)**2);
                            const baseSpeed = 10; // Reduced from 12 for more control
                            // Much larger speed variation: 4-12 units (was 2-6)
                            const speedVariation = Math.random() * 8 + 4; 
                            const speed = baseSpeed + speedVariation;
                            
                            const vx = Math.cos(baseAngle) * speed;
                            const vy = Math.sin(baseAngle) * speed;
                            
                            // Balanced damage - same base as before (3.0x)
                            const levelScaling = 1 + (this.weapons.mines * 0.15); // Same 15% per level
                            const baseDmg = this.damage * 3.0 * levelScaling * this.weaponStats.mines.dmg * dmgMult;
                            const detectionRadius = 60 + (this.weaponStats.mines.area * 10);
                            const blastRadius = (100 + (this.weaponStats.mines.area * 15)) * 1.0; // Buffed base: 100 (was 80), reduced scaling: 15/level (was 20)
                            
                            entities.projectiles.push(new Projectile(
                                this.x, this.y, vx, vy, baseDmg, blastRadius, 'mine', bestTarget, 'mines', detectionRadius
                            ));
                            
                            checkMultistrike(deployMine, 1.25, depth);
                        };
                        
                        // Deploy multiple mines with angle spread AND radial offset
                        if (!this.lastMinePositions) this.lastMinePositions = [];
                        
                        // Clear old positions (older than 2 seconds)
                        this.lastMinePositions = this.lastMinePositions.filter(pos => 
                            Date.now() - pos.time < 2000
                        );
                        
                        if (mineCount === 1) {
                            deployMine(1.0, 0, 0);
                        } else if (mineCount === 2) {
                            // Spread mines in a V formation
                            deployMine(1.0, 0, -0.4); // 40 degrees left (wider spread)
                            deployMine(1.0, 0, 0.4);  // 40 degrees right
                        } else if (mineCount === 3) {
                            // Spread mines in a fan pattern
                            deployMine(1.0, 0, -0.5);  // 50 degrees left (wider spread)
                            deployMine(1.0, 0, 0);     // Center
                            deployMine(1.0, 0, 0.5);   // 50 degrees right
                        }
                        
                        this.maxMinesTimer = Math.max(90, 180 / this.weaponStats.mines.rate); // 180 frames base (3 seconds)
                        this.minesTimer = this.maxMinesTimer;
                    }
                }

                // TOXIC BARRAGE - Smart-targeted line of overlapping gas clouds
                if (this.weapons.gas > 0) {
                    this.gasTimer -= (dt/16) * fireRateMult;
                    if (this.gasTimer <= 0) {
                        const lobBarrage = (damageBonus = 1.0) => {
                            // Prioritize enemies within visible range, then find densest cluster
                            const visibleRadius = Math.min(width, height) / state.zoom * 0.4;
                            const maxSearchRadius = 400;
                            
                            const visibleEnemies = entities.enemies.filter(e => {
                                const dist = Math.sqrt((e.x - this.x)**2 + (e.y - this.y)**2);
                                return dist < visibleRadius;
                            });
                            
                            const searchPool = visibleEnemies.length > 0 ? visibleEnemies : entities.enemies;
                            const searchLimit = visibleEnemies.length > 0 ? visibleRadius : maxSearchRadius;
                            
                            let bestTarget = null;
                            let bestCount = 0;
                            
                            searchPool.forEach(e => {
                                const distToPlayer = Math.sqrt((e.x - this.x)**2 + (e.y - this.y)**2);
                                if (distToPlayer > searchLimit) return;
                                
                                const nearbyCount = entities.enemies.filter(ne => {
                                    const dist = Math.sqrt((ne.x - e.x)**2 + (ne.y - e.y)**2);
                                    return dist < 120;
                                }).length;
                                
                                if (nearbyCount > bestCount || (nearbyCount === bestCount && (!bestTarget || distToPlayer < Math.sqrt((bestTarget.x - this.x)**2 + (bestTarget.y - this.y)**2)))) {
                                    bestCount = nearbyCount;
                                    bestTarget = e;
                                }
                            });
                            
                            if (!bestTarget && visibleEnemies.length > 0) {
                                bestTarget = visibleEnemies[0];
                                let minDist = Math.sqrt((bestTarget.x - this.x)**2 + (bestTarget.y - this.y)**2);
                                visibleEnemies.forEach(e => {
                                    const dist = Math.sqrt((e.x - this.x)**2 + (e.y - this.y)**2);
                                    if (dist < minDist) {
                                        minDist = dist;
                                        bestTarget = e;
                                    }
                                });
                            }
                            
                            if (bestTarget) {
                                // Calculate line perpendicular to player-target vector
                                const toTargetAngle = Math.atan2(bestTarget.y - this.y, bestTarget.x - this.x);
                                const perpAngle = toTargetAngle + Math.PI / 2; // Perpendicular angle
                                
                                // Number of grenades: 3-5 based on weapon level
                                const numGrenades = Math.min(5, 3 + Math.floor(this.weapons.gas / 2));
                                
                                // Line length scales with weapon level and area
                                const lineLength = (180 + this.weapons.gas * 30) * this.weaponStats.gas.area;
                                
                                const cloudRadius = 65 + (this.weaponStats.gas.area * 15);
                                // Slight per-level scaling: 1.0 + (level * 0.03) = +3% per level
                                const levelScaling = 1.0 + (state.level * 0.03);
                                const tickDamage = this.damage * 1.0 * this.weaponStats.gas.dmg * damageBonus * levelScaling;
                                
                                // Launch grenades in staggered pattern along the line
                                for (let i = 0; i < numGrenades; i++) {
                                    // Position along perpendicular line through target
                                    const lineProgress = (i / (numGrenades - 1)) - 0.5; // -0.5 to +0.5
                                    const lineOffset = lineProgress * lineLength;
                                    
                                    // Add stagger offset (zigzag pattern for overlap)
                                    const staggerOffset = (i % 2 === 0 ? 1 : -1) * 25;
                                    
                                    // Target point on the line
                                    const targetX = bestTarget.x + Math.cos(perpAngle) * lineOffset + Math.cos(toTargetAngle) * staggerOffset;
                                    const targetY = bestTarget.y + Math.sin(perpAngle) * lineOffset + Math.sin(toTargetAngle) * staggerOffset;
                                    
                                    // Calculate trajectory to target point
                                    const angle = Math.atan2(targetY - this.y, targetX - this.x);
                                    const speed = 8;
                                    const vx = Math.cos(angle) * speed;
                                    const vy = Math.sin(angle) * speed;
                                    
                                    // Create virtual target for this grenade
                                    const grenadeTarget = { x: targetX, y: targetY, hp: 1 };
                                    
                                    // Stagger launch timing for visual effect
                                    const launchDelay = i * 50; // 50ms between each grenade
                                    
                                    setTimeout(() => {
                                        entities.projectiles.push(new Projectile(
                                            this.x, this.y, vx, vy, tickDamage, cloudRadius, 'gas_grenade', grenadeTarget, 'gas'
                                        ));
                                    }, launchDelay);
                                }
                            }
                        };
                        
                        const lobBarrageWithMulti = (dmgMult = 1.0, depth = 0) => {
                            lobBarrage(dmgMult);
                            checkMultistrike(lobBarrageWithMulti, 1.25, depth);
                        };
                        
                        lobBarrageWithMulti();
                        this.maxGasTimer = Math.max(180, 390 / this.weaponStats.gas.rate); // 390 frames base (6.5 seconds)
                        this.gasTimer = this.maxGasTimer;
                    }
                }

                // RICOCHET DISC - Bouncing projectile that chains between enemies
                if (this.weapons.ricochet > 0) {
                    this.ricochetTimer -= (dt/16) * fireRateMult;
                    if (this.ricochetTimer <= 0) {
                        const fireRicochet = (damageBonus = 1.0) => {
                            // Disc count: 1/1/2/2/3 by level
                            const discCount = this.weapons.ricochet <= 2 ? 1 : this.weapons.ricochet <= 4 ? 2 : 3;
                            const maxBounces = Math.min(9, 5 + this.weapons.ricochet); // Increased by 2: 6-9 bounces (was 4-7)
                            // Reduced damage to compensate for more bounces: 2.5 ‚Üí 2.0 ‚Üí 1.65
                            const dmgPerDisc = discCount === 1 ? 2.5 : discCount === 2 ? 2.0 : 1.65;
                            // DAMAGE SCALING: Scales independently with both weapon level AND damage upgrades
                            // - Per-level scaling: +15% damage per level (1.0 ‚Üí 1.6x at level 5)
                            // - maxBounces increases with weapon level (more ricochets)
                            // - this.weaponStats.ricochet.dmg scales with damage card upgrades
                            const levelScaling = 1 + (this.weapons.ricochet - 1) * 0.15; // 1.0, 1.15, 1.3, 1.45, 1.6
                            const baseDmg = this.damage * dmgPerDisc * levelScaling * this.weaponStats.ricochet.dmg * damageBonus;
                            const bounceRange = (600 + this.weapons.ricochet * 150) * this.weaponStats.ricochet.area; // MASSIVE: 750-1350 range!
                            
                            // Track which enemies are already targeted
                            const targetedEnemies = new Set();
                            
                            for (let discIdx = 0; discIdx < discCount; discIdx++) {
                                // Find different target for each disc - SIMPLIFIED
                                let bestTarget = null;
                                let bestDist = Infinity;
                                const searchRange = 500;
                                
                                // Simple nearest-enemy selection (no expensive cluster calculation)
                                entities.enemies.forEach(e => {
                                    if (e.hp > 0 && !targetedEnemies.has(e)) {
                                        const dx = e.x - this.x;
                                        const dy = e.y - this.y;
                                        const dist = Math.sqrt(dx*dx + dy*dy);
                                        if (dist < searchRange && dist < bestDist) {
                                            bestDist = dist;
                                            bestTarget = e;
                                        }
                                    }
                                });
                                
                                const initialTarget = bestTarget || this.getNearestEnemy(500);
                                if (!initialTarget) continue;
                                
                                targetedEnemies.add(initialTarget); // Mark as targeted
                                
                                // Spread discs in an arc pattern
                                const angle = Math.atan2(initialTarget.y - this.y, initialTarget.x - this.x);
                                const spreadAngle = (discIdx - (discCount - 1) / 2) * 0.4; // Wider spread
                                const vx = Math.cos(angle + spreadAngle) * 12;
                                const vy = Math.sin(angle + spreadAngle) * 12;
                                
                                const proj = new Projectile(
                                    this.x, this.y, vx, vy, baseDmg, 0, 'ricochet', 
                                    initialTarget,
                                    'ricochet'
                                );
                                
                                // Add bounce tracking to the projectile
                                proj.bounces = 0;
                                proj.maxBounces = maxBounces;
                                proj.bounceRange = bounceRange;
                                proj.hitEnemies = new Set();
                                
                                entities.projectiles.push(proj);
                            }
                        };
                        
                        const fireRicochetWithMulti = (dmgMult = 1.0, depth = 0) => {
                            fireRicochet(dmgMult);
                            checkMultistrike(fireRicochetWithMulti, 1.25, depth);
                        };
                        
                        fireRicochetWithMulti();
                        this.ricochetTimer = Math.max(60, 150 / this.weaponStats.ricochet.rate);
                    }
                }

                // ELEMENTAL SURGE (Catalyst weapon) - Cycling elemental orbs
                if (this.weapons.surge > 0) {
                    this.surgeTimer -= (dt/16) * fireRateMult;
                    if (this.surgeTimer <= 0) {
                        const fireSurge = (damageBonus = 1.0) => {
                            // Get current element in cycle
                            const currentElement = this.surgeElements[this.surgeElementIndex];
                            
                            // Orb properties
                            const orbSpeed = 6.0; // Increased from 5.0 for faster travel
                            const baseDmg = 35 + (this.weapons.surge * 12); // Buffed from 20 + 8
                            const dmg = baseDmg * this.weaponStats.surge.dmg * damageBonus;
                            const orbRadius = 8; // Fixed size, doesn't scale with level or area
                            const aoeRadius = 50 * this.weaponStats.surge.area; // AOE scales with area upgrades
                            
                            // Check if this is a burst orb (every 5th hit)
                            const isBurstOrb = (this.surgeHitCount === 4); // Next hit triggers burst
                            
                            // CLOSEST ENEMY TARGETING: Target nearest enemy
                            let targetAngle = this.angle; // Default to player facing
                            
                            if (entities.enemies.length > 0) {
                                let closestEnemy = null;
                                let minDist = Infinity;
                                
                                // Find closest enemy
                                entities.enemies.forEach(e => {
                                    if (e.hp > 0) {
                                        const distToPlayer = Math.sqrt((e.x - this.x)**2 + (e.y - this.y)**2);
                                        if (distToPlayer < minDist) {
                                            minDist = distToPlayer;
                                            closestEnemy = e;
                                        }
                                    }
                                });
                                
                                if (closestEnemy) {
                                    targetAngle = Math.atan2(closestEnemy.y - this.y, closestEnemy.x - this.x);
                                }
                            } else if (input.active && (input.vector.x !== 0 || input.vector.y !== 0)) {
                                // No enemies, use input direction
                                targetAngle = Math.atan2(input.vector.y, input.vector.x);
                            }
                            
                            // Element colors (only 4 elements)
                            const elementColors = {
                                fire: '#ff5722',
                                ice: '#00e5ff',
                                volt: '#ffeb3b',
                                bio: '#39ff14'
                            };
                            
                            // Create orb projectile
                            // Spawn slightly ahead in direction of travel to prevent visual lag
                            const spawnOffsetDist = 15; // Spawn 15 pixels ahead
                            const spawnX = this.x + Math.cos(targetAngle) * spawnOffsetDist;
                            const spawnY = this.y + Math.sin(targetAngle) * spawnOffsetDist;
                            
                            entities.projectiles.push({
                                x: spawnX,
                                y: spawnY,
                                vx: Math.cos(targetAngle) * orbSpeed,
                                vy: Math.sin(targetAngle) * orbSpeed,
                                damage: dmg,
                                life: 180,
                                radius: orbRadius,
                                aoeRadius: aoeRadius, // Scales with area upgrades
                                type: 'surge',
                                element: currentElement,
                                color: elementColors[currentElement],
                                source: 'surge',
                                isBurstOrb: isBurstOrb, // Flag for dramatic visuals
                                update(dt) {
                                    this.x += this.vx * (dt/16);
                                    this.y += this.vy * (dt/16);
                                    this.life -= dt/16;
                                    return this.life > 0;
                                },
                                draw(ctx) {
                                    ctx.save();
                                    ctx.translate(this.x, this.y);
                                    
                                    const time = Date.now() * 0.001;
                                    const burstIntensity = this.isBurstOrb ? 2.0 : 1.0; // 2x intensity for burst orbs
                                    
                                    // Subtle AOE radius indicator (50px)
                                    const aoeRadius = 50;
                                    const pulse = 0.3 + Math.sin(Date.now() * 0.004) * 0.15;
                                    ctx.strokeStyle = this.color;
                                    ctx.globalAlpha = 0.15 * pulse;
                                    ctx.lineWidth = 1.5;
                                    ctx.setLineDash([4, 4]);
                                    ctx.beginPath();
                                    ctx.arc(0, 0, aoeRadius, 0, Math.PI * 2);
                                    ctx.stroke();
                                    ctx.setLineDash([]);
                                    
                                    // ELEMENT-SPECIFIC EFFECTS (STREAMLINED)
                                    if (this.element === 'fire') {
                                        // Fire: Flickering flames (reduced count)
                                        const numFlames = this.isBurstOrb ? 6 : 4; // Reduced from 8/6
                                        for (let i = 0; i < numFlames; i++) {
                                            const angle = (i / numFlames) * Math.PI * 2 + time * 4;
                                            const flicker = 0.6 + Math.sin(time * 12 + i * 2) * 0.4;
                                            const dist = this.radius * (1.8 + (this.isBurstOrb ? 0.5 : 0));
                                            const x = Math.cos(angle) * dist * flicker;
                                            const y = Math.sin(angle) * dist * flicker;
                                            const size = (3 + flicker * 2) * burstIntensity; // Slightly smaller
                                            
                                            ctx.fillStyle = this.isBurstOrb ? '#ffff00' : this.color;
                                            ctx.globalAlpha = (0.6 + flicker * 0.3) * burstIntensity;
                                            ctx.shadowBlur = 10 * burstIntensity; // Reduced blur
                                            ctx.shadowColor = this.color;
                                            ctx.beginPath();
                                            ctx.arc(x, y, size, 0, Math.PI * 2);
                                            ctx.fill();
                                        }
                                        
                                        // Burst version: Spinning fire ring
                                        if (this.isBurstOrb) {
                                            ctx.strokeStyle = '#ffaa00';
                                            ctx.globalAlpha = 0.7;
                                            ctx.lineWidth = 2;
                                            ctx.shadowBlur = 15; // Reduced
                                            ctx.shadowColor = this.color;
                                            ctx.beginPath();
                                            ctx.arc(0, 0, this.radius * 2.5, 0, Math.PI * 2);
                                            ctx.stroke();
                                        }
                                        
                                    } else if (this.element === 'ice') {
                                        // Ice: Crystalline shards (reduced count)
                                        const numShards = this.isBurstOrb ? 8 : 6; // Reduced from 12/8
                                        for (let i = 0; i < numShards; i++) {
                                            const angle = (i / numShards) * Math.PI * 2 + time * 2.5;
                                            const dist = this.radius * (1.8 + (this.isBurstOrb ? 0.6 : 0));
                                            const x = Math.cos(angle) * dist;
                                            const y = Math.sin(angle) * dist;
                                            const shardLength = 5 * burstIntensity; // Slightly smaller
                                            
                                            ctx.strokeStyle = this.isBurstOrb ? '#ffffff' : this.color;
                                            ctx.globalAlpha = 0.8 * burstIntensity;
                                            ctx.lineWidth = 2 * burstIntensity;
                                            ctx.shadowBlur = 8 * burstIntensity; // Reduced
                                            ctx.shadowColor = this.color;
                                            ctx.beginPath();
                                            // Draw X-shaped shard
                                            ctx.moveTo(x - shardLength, y - shardLength);
                                            ctx.lineTo(x + shardLength, y + shardLength);
                                            ctx.moveTo(x - shardLength, y + shardLength);
                                            ctx.lineTo(x + shardLength, y - shardLength);
                                            ctx.stroke();
                                        }
                                        
                                        // Burst version: Frost hexagon
                                        if (this.isBurstOrb) {
                                            ctx.strokeStyle = '#aaffff';
                                            ctx.globalAlpha = 0.6;
                                            ctx.lineWidth = 2;
                                            ctx.shadowBlur = 12; // Reduced
                                            ctx.shadowColor = this.color;
                                            ctx.beginPath();
                                            for (let i = 0; i < 6; i++) {
                                                const angle = (i / 6) * Math.PI * 2;
                                                const x = Math.cos(angle) * this.radius * 2.5;
                                                const y = Math.sin(angle) * this.radius * 2.5;
                                                if (i === 0) ctx.moveTo(x, y);
                                                else ctx.lineTo(x, y);
                                            }
                                            ctx.closePath();
                                            ctx.stroke();
                                        }
                                        
                                    } else if (this.element === 'volt') {
                                        // Volt: Electric arcs (streamlined)
                                        const numArcs = this.isBurstOrb ? 4 : 3; // Reduced from 6/4
                                        ctx.strokeStyle = this.isBurstOrb ? '#ffffff' : this.color;
                                        ctx.globalAlpha = 0.7 * burstIntensity;
                                        ctx.lineWidth = 2 * burstIntensity;
                                        ctx.shadowBlur = 10 * burstIntensity; // Reduced
                                        ctx.shadowColor = this.color;
                                        
                                        for (let i = 0; i < numArcs; i++) {
                                            const arcTime = time * 10 + i * 2;
                                            const angle1 = (i / numArcs) * Math.PI * 2 + Math.sin(arcTime) * 0.5;
                                            const angle2 = angle1 + Math.PI * 0.4;
                                            const dist1 = this.radius * 0.8;
                                            const dist2 = this.radius * 1.8 * burstIntensity;
                                            
                                            ctx.beginPath();
                                            ctx.moveTo(Math.cos(angle1) * dist1, Math.sin(angle1) * dist1);
                                            
                                            // Simplified lightning path (fewer steps)
                                            const steps = 2; // Reduced from 3
                                            for (let j = 0; j <= steps; j++) {
                                                const t = j / steps;
                                                const midAngle = angle1 + (angle2 - angle1) * t;
                                                const midDist = dist1 + (dist2 - dist1) * t;
                                                const jitter = (Math.random() - 0.5) * 4 * burstIntensity;
                                                ctx.lineTo(
                                                    Math.cos(midAngle) * midDist + jitter,
                                                    Math.sin(midAngle) * midDist + jitter
                                                );
                                            }
                                            ctx.stroke();
                                        }
                                        
                                        // Burst version: Single electric ring
                                        if (this.isBurstOrb) {
                                            ctx.strokeStyle = '#ffff88';
                                            ctx.globalAlpha = 0.5;
                                            ctx.lineWidth = 2;
                                            ctx.shadowBlur = 15; // Reduced
                                            ctx.beginPath();
                                            ctx.arc(0, 0, this.radius * 2.2, 0, Math.PI * 2);
                                            ctx.stroke();
                                        }
                                        
                                    } else if (this.element === 'bio') {
                                        // Bio: Toxic bubbles (streamlined)
                                        const numBubbles = this.isBurstOrb ? 7 : 5; // Reduced from 10/7
                                        for (let i = 0; i < numBubbles; i++) {
                                            const bubblePulse = Math.sin(time * 5 + i * 0.8) * 0.5 + 0.5;
                                            const angle = (i / numBubbles) * Math.PI * 2 + time * 1.5;
                                            const dist = this.radius * (1.4 + bubblePulse * 0.5) * burstIntensity;
                                            const x = Math.cos(angle) * dist;
                                            const y = Math.sin(angle) * dist;
                                            const size = (2.5 + bubblePulse * 3) * burstIntensity; // Slightly smaller
                                            
                                            ctx.fillStyle = this.isBurstOrb ? '#88ff44' : this.color;
                                            ctx.globalAlpha = (0.5 + bubblePulse * 0.3) * burstIntensity;
                                            ctx.shadowBlur = 8 * burstIntensity; // Reduced
                                            ctx.shadowColor = this.color;
                                            ctx.beginPath();
                                            ctx.arc(x, y, size, 0, Math.PI * 2);
                                            ctx.fill();
                                        }
                                        
                                        // Burst version: Lighter toxic cloud
                                        if (this.isBurstOrb) {
                                            ctx.fillStyle = this.color;
                                            ctx.globalAlpha = 0.15; // More subtle
                                            ctx.beginPath();
                                            ctx.arc(0, 0, this.radius * 2.5, 0, Math.PI * 2);
                                            ctx.fill();
                                        }
                                    }
                                    
                                    // Outer glow (reduced for burst orbs)
                                    ctx.shadowBlur = 15 * burstIntensity; // Reduced from 20
                                    ctx.shadowColor = this.color;
                                    ctx.fillStyle = this.color;
                                    ctx.globalAlpha = 0.35 * burstIntensity;
                                    ctx.beginPath();
                                    ctx.arc(0, 0, this.radius * 1.4, 0, Math.PI * 2);
                                    ctx.fill();
                                    
                                    // Main orb (slightly larger for burst)
                                    ctx.globalAlpha = 0.85;
                                    ctx.beginPath();
                                    const mainRadius = this.radius * (this.isBurstOrb ? 1.2 : 1.0);
                                    ctx.arc(0, 0, mainRadius, 0, Math.PI * 2);
                                    ctx.fill();
                                    
                                    // Inner bright core (pulsing for burst)
                                    ctx.globalAlpha = 1;
                                    ctx.fillStyle = '#ffffff';
                                    ctx.shadowBlur = 15 * burstIntensity;
                                    const coreSize = this.isBurstOrb ? 0.6 : 0.5;
                                    ctx.beginPath();
                                    ctx.arc(0, 0, this.radius * coreSize, 0, Math.PI * 2);
                                    ctx.fill();
                                    
                                    ctx.shadowBlur = 0;
                                    ctx.globalAlpha = 1;
                                    ctx.restore();
                                }
                            });
                            
                            // Cycle to next element
                            this.surgeElementIndex = (this.surgeElementIndex + 1) % this.surgeElements.length;
                        };
                        
                        const fireSurgeWithMulti = (dmgMult = 1.0, depth = 0) => {
                            fireSurge(dmgMult);
                            checkMultistrike(fireSurgeWithMulti, 1.25, depth);
                        };
                        
                        fireSurgeWithMulti();
                        // Cap fire rate at aura duration (60 frames = 1 second) to prevent overlap
                        const calculatedCooldown = this.maxSurgeTimer / this.weaponStats.surge.rate;
                        this.surgeTimer = Math.max(60, calculatedCooldown);
                    }
                }

                // COMBAT DRONES - Autonomous flying drones that hunt enemies
                if (this.weapons.drones > 0) {
                    const droneCount = Math.min(3, this.weapons.drones); // Max 3 drones
                    const droneDmg = this.damage * 0.6 * this.weaponStats.drones.dmg; // Reduced from 0.85 to 0.6 (weaker individual shots)
                    const droneRange = (250 + this.weapons.drones * 25) * this.weaponStats.drones.area; // 275-350 range
                    const droneSpeed = 10; // Faster movement - increased from 8
                    const fireRate = 18 / this.weaponStats.drones.rate; // Much faster fire rate - reduced from 28
                    
                    // Initialize drones array if needed
                    if (!this.drones) {
                        this.drones = [];
                    }
                    
                    // Add new drones if weapon leveled up
                    while (this.drones.length < droneCount) {
                        const angle = (Math.PI * 2 / droneCount) * this.drones.length;
                        const droneIndex = this.drones.length;
                        this.drones.push({
                            x: this.x + Math.cos(angle) * 80,
                            y: this.y + Math.sin(angle) * 80,
                            vx: 0,
                            vy: 0,
                            target: null,
                            fireTimer: (droneIndex * (fireRate / droneCount)), // Stagger: drone 0 fires first, then 1, then 2
                            orbitAngle: angle,
                            shotsFired: 0 // Track for mini-rocket
                        });
                    }
                    
                    // Remove excess drones
                    while (this.drones.length > droneCount) {
                        this.drones.pop();
                    }
                    
                    // Update each drone
                    this.drones.forEach((drone, idx) => {
                        // Keep drones within visible area (with small margin)
                        const screenMargin = 25;
                        const minX = this.x - (width / state.zoom / 2) + screenMargin;
                        const maxX = this.x + (width / state.zoom / 2) - screenMargin;
                        const minY = this.y - (height / state.zoom / 2) + screenMargin;
                        const maxY = this.y + (height / state.zoom / 2) - screenMargin;
                        
                        // Find target if we don't have one or current target is dead/hacked/fleeing
                        if (!drone.target || drone.target.hp <= 0 || (drone.target.hackState && drone.target.hackState.active) || drone.target.fleeing) {
                            // Priority targeting influenced by proximity to player
                            const priorityOrder = (enemy) => {
                                // Boss shields are HIGHEST priority (only when active and vulnerable)
                                if (enemy.isBossShield && enemy.hp > 0 && (!enemy.spawnInvuln || enemy.spawnInvuln <= 0)) return 10;
                                
                                // Final boss (Nexus Prime) is SECOND HIGHEST priority (after shields down)
                                if (enemy.isNexusPrime) return 9;
                                
                                // TITAN BOSS - Very high priority (right after final boss)
                                if (enemy.isTitan) return 8.5;
                                
                                // Boss turrets are lower priority than bosses
                                if (enemy.isBossTurret) return 5;
                                
                                // Skip invulnerable voidwalkers
                                if (enemy.type === 'voidwalker' && enemy.cloaked) return -1; // Never target cloaked voidwalkers
                                
                                // NEVER target hacked enemies - completely untargetable
                                if (enemy.hackState && enemy.hackState.active) return -1;
                                
                                // NEVER target fleeing enemies - they're running away from boss
                                if (enemy.fleeing) return -1;
                                
                                let priority = 0;
                                if (enemy.isChampion) priority = 7;
                                else if (enemy.type === 'voidwalker') priority = 6; // Only if not cloaked
                                else if (enemy.type === 'tank') priority = 5;
                                else if (enemy.type === 'splitter') priority = 4;
                                else if (enemy.type === 'swarmer') priority = 3.5; // Higher than drones even with proximity boost
                                else if (enemy.type === 'drone') priority = 2;
                                
                                // Boost priority if enemy is close to player (protector role)
                                const distToPlayer = Math.sqrt((enemy.x - this.x)**2 + (enemy.y - this.y)**2);
                                if (distToPlayer < 150) priority += 0.5; // Small boost for nearby threats
                                
                                return priority;
                            };
                            
                            let bestTarget = null;
                            let bestPriority = -1;
                            let minDist = droneRange;
                            
                            entities.enemies.forEach(e => {
                                if (e.hp > 0) {
                                    const dist = Math.sqrt((e.x - drone.x)**2 + (e.y - drone.y)**2);
                                    if (dist < droneRange) {
                                        const priority = priorityOrder(e);
                                        // Skip enemies with priority -1 (invulnerable)
                                        if (priority < 0) return;
                                        // Take higher priority, or if same priority, closer distance
                                        if (priority > bestPriority || (priority === bestPriority && dist < minDist)) {
                                            bestPriority = priority;
                                            minDist = dist;
                                            bestTarget = e;
                                        }
                                    }
                                }
                            });
                            
                            drone.target = bestTarget;
                        }
                        
                        // Move drone with more aggressive AI (skip fleeing enemies)
                        if (drone.target && !(drone.target.hackState && drone.target.hackState.active) && !drone.target.fleeing) {
                            // Chase target more actively
                            const dx = drone.target.x - drone.x;
                            const dy = drone.target.y - drone.y;
                            const dist = Math.sqrt(dx*dx + dy*dy);
                            
                            // Stay at optimal range (120-180px from target) - farther back
                            const optimalDist = 150;
                            if (dist > optimalDist + 20) {
                                // Too far, move closer aggressively
                                drone.vx += (dx / dist) * 0.7 * (dt/16);
                                drone.vy += (dy / dist) * 0.7 * (dt/16);
                            } else if (dist < optimalDist - 20) {
                                // Too close, back off
                                drone.vx -= (dx / dist) * 0.5 * (dt/16);
                                drone.vy -= (dy / dist) * 0.5 * (dt/16);
                            }
                            
                            // Gentle pull toward player to keep them nearby
                            const toPlayerX = this.x - drone.x;
                            const toPlayerY = this.y - drone.y;
                            const playerDist = Math.sqrt(toPlayerX*toPlayerX + toPlayerY*toPlayerY);
                            if (playerDist > 200) { // If getting far from player
                                const pullStrength = 0.15 * (dt/16); // dt-scaled pull
                                drone.vx += (toPlayerX / playerDist) * pullStrength;
                                drone.vy += (toPlayerY / playerDist) * pullStrength;
                            }
                        } else {
                            // No target, orbit player faster
                            drone.orbitAngle += 0.03 * (dt/16); // Faster orbit - was 0.02
                            const targetX = this.x + Math.cos(drone.orbitAngle) * 80;
                            const targetY = this.y + Math.sin(drone.orbitAngle) * 80;
                            const dx = targetX - drone.x;
                            const dy = targetY - drone.y;
                            drone.vx += dx * 0.08 * (dt/16); // dt-scaled - was 0.05
                            drone.vy += dy * 0.08 * (dt/16);
                        }
                        
                        // Apply velocity with damping (exponential decay)
                        drone.vx *= Math.pow(0.92, dt/16); // Exponential damping
                        drone.vy *= Math.pow(0.92, dt/16);
                        const speed = Math.sqrt(drone.vx**2 + drone.vy**2);
                        if (speed > droneSpeed) {
                            drone.vx = (drone.vx / speed) * droneSpeed;
                            drone.vy = (drone.vy / speed) * droneSpeed;
                        }
                        
                        drone.x += drone.vx * (dt/16);
                        drone.y += drone.vy * (dt/16);
                        
                        // Enforce screen boundaries - pull drones back if too far
                        if (drone.x < minX) {
                            drone.x = minX;
                            drone.vx = Math.abs(drone.vx) * 0.5; // Bounce back gently
                        } else if (drone.x > maxX) {
                            drone.x = maxX;
                            drone.vx = -Math.abs(drone.vx) * 0.5;
                        }
                        if (drone.y < minY) {
                            drone.y = minY;
                            drone.vy = Math.abs(drone.vy) * 0.5;
                        } else if (drone.y > maxY) {
                            drone.y = maxY;
                            drone.vy = -Math.abs(drone.vy) * 0.5;
                        }
                        
                        // Prevent drones from overlapping each other
                        this.drones.forEach((otherDrone, otherIdx) => {
                            if (otherIdx !== idx) {
                                const dx = otherDrone.x - drone.x;
                                const dy = otherDrone.y - drone.y;
                                const dist = Math.sqrt(dx*dx + dy*dy);
                                const minSeparation = 30; // Minimum distance between drones
                                
                                if (dist < minSeparation && dist > 0) {
                                    // Push drones apart
                                    const pushStrength = (minSeparation - dist) / minSeparation * 0.5;
                                    drone.vx -= (dx / dist) * pushStrength;
                                    drone.vy -= (dy / dist) * pushStrength;
                                }
                            }
                        });
                        
                        // Fire at target (skip fleeing enemies)
                        drone.fireTimer -= dt/16;
                        if (drone.fireTimer <= 0 && drone.target && !(drone.target.hackState && drone.target.hackState.active) && !drone.target.fleeing) {
                            drone.shotsFired = (drone.shotsFired || 0) + 1;
                            
                            // Every 5th shot fires a mini-rocket with AOE splash
                            const isMiniRocket = (drone.shotsFired % 5 === 0);
                            
                            // Create fire function for multistrike
                            const fireDroneShot = (damageMultiplier = 1.0, depth = 0) => {
                                // Verify target still exists and is valid (not dead/hacked/fleeing)
                                if (!drone.target || drone.target.hp <= 0 || (drone.target.hackState && drone.target.hackState.active) || drone.target.fleeing) {
                                    return;
                                }
                                
                                const angle = Math.atan2(drone.target.y - drone.y, drone.target.x - drone.x);
                                const vx = Math.cos(angle) * (isMiniRocket ? 16 : 14);
                                const vy = Math.sin(angle) * (isMiniRocket ? 16 : 14);
                                
                                if (isMiniRocket) {
                                    // Mini-rocket: AOE splash damage on impact
                                    const rocketProj = new Projectile(
                                        drone.x, drone.y, vx, vy, droneDmg * 2.0 * damageMultiplier, 0, 'drone_rocket', drone.target, 'drones'
                                    );
                                    // Mark projectile for AOE splash on hit
                                    rocketProj.hasSplash = true;
                                    rocketProj.splashRange = 80; // Small AOE radius
                                    rocketProj.splashDamage = droneDmg * 1.2 * damageMultiplier; // Splash does 60% of rocket damage
                                    entities.projectiles.push(rocketProj);
                                    createExplosion(drone.x, drone.y, '#ff8800', 8);
                                } else {
                                    // Normal shot - faster and weaker
                                    entities.projectiles.push(new Projectile(
                                        drone.x, drone.y, vx, vy, droneDmg * damageMultiplier, 0, 'drone_shot', drone.target, 'drones'
                                    ));
                                }
                                
                                // Check for multistrike (only on initial shot, depth=0)
                                if (depth === 0 && player.multistrikeUnlocked) {
                                    checkMultistrike(fireDroneShot, damageMultiplier, depth);
                                }
                            };
                            
                            // Fire the initial shot
                            fireDroneShot();
                            
                            drone.fireTimer = fireRate;
                        }
                    });
                }

                // AUTO-TURRET (Engineer weapon)
                if (this.weapons.turret > 0) {
                    // Scaling: Start with 2 turrets, up to 4 max
                    const maxTurrets = Math.min(4, 1 + this.weapons.turret); // 2 at L1, 3 at L2, 4 at L3+
                    const deployInterval = Math.max(120, 240 / this.weaponStats.turret.rate); // 4 sec base, faster with upgrades
                    const turretRange = (120 + this.weapons.turret * 18) * this.weaponStats.turret.area; // Increased base: 120 (was 100), reduced scaling: +18/level (was 20)
                    const turretDmg = this.damage * 0.8 * this.weaponStats.turret.dmg; // Buffed: 80% base damage (was 70%)
                    const turretFireRate = 24; // Fires every 0.4 seconds
                    // Targets per turret matches turret count: 2 turrets = 2 targets each, 3 = 3, 4 = 4
                    const maxTargetsPerTurret = Math.min(4, Math.max(2, this.turrets.length)); // At least 2, scales with active turrets
                    
                    // Deploy turret on cooldown
                    this.turretTimer -= (dt/16) * fireRateMult;
                    if (this.turretTimer <= 0) {
                        // Deploy turret sliding forward from ship
                        const slideDistance = 80; // How far forward turret slides
                        const targetX = this.x + Math.cos(this.angle) * slideDistance;
                        const targetY = this.y + Math.sin(this.angle) * slideDistance;
                        
                        this.turrets.push({
                            x: this.x, // Start at ship position
                            y: this.y,
                            targetX: targetX, // Where it will slide to
                            targetY: targetY,
                            slideProgress: 0, // 0 to 1 animation
                            spawnAnimation: 30, // Frames for "coming online" animation
                            life: 1200, // 20 seconds lifespan
                            fireTimer: 60, // Start with 1 second delay before first shot
                            range: turretRange // Store range for visual indicator
                        });
                        
                        // Remove oldest if over limit
                        while (this.turrets.length > maxTurrets) {
                            this.turrets.shift();
                        }
                        
                        this.turretTimer = deployInterval;
                        createExplosion(this.x, this.y, '#ff8800', 10); // Smaller explosion
                    }
                    
                    // Update and fire turrets
                    this.turrets = this.turrets.filter(turret => {
                        turret.life -= dt/16;
                        if (turret.life <= 0) return false;
                        
                        // Slide animation
                        if (turret.slideProgress < 1) {
                            turret.slideProgress += 0.05; // 20 frames to slide
                            turret.x = this.x + (turret.targetX - this.x) * turret.slideProgress;
                            turret.y = this.y + (turret.targetY - this.y) * turret.slideProgress;
                        } else {
                            // Lock position once slide complete
                            turret.x = turret.targetX;
                            turret.y = turret.targetY;
                        }
                        
                        // Spawn animation countdown
                        if (turret.spawnAnimation > 0) {
                            turret.spawnAnimation -= dt/16;
                        }
                        
                        turret.fireTimer -= dt/16;
                        if (turret.fireTimer <= 0 && turret.spawnAnimation <= 0) {
                            // Priority targeting system (same as combat drones)
                            const priorityOrder = (enemy) => {
                                // Boss shields are HIGHEST priority
                                if (enemy.isBossShield && enemy.hp > 0) return 10;
                                
                                // Boss core is SECOND HIGHEST priority
                                if (enemy.isNexusPrime) return 9;
                                
                                // Boss turrets are lower priority
                                if (enemy.isBossTurret) return 5;
                                
                                // Skip invulnerable voidwalkers
                                if (enemy.type === 'voidwalker' && enemy.cloaked) return -1;
                                
                                // NEVER target hacked enemies - completely untargetable
                                if (enemy.hackState && enemy.hackState.active) return -1;
                                
                                let priority = 0;
                                if (enemy.isChampion) priority = 7;
                                else if (enemy.type === 'voidwalker') priority = 6; // Only if not cloaked
                                else if (enemy.type === 'tank') priority = 5;
                                else if (enemy.type === 'splitter') priority = 4;
                                else if (enemy.type === 'swarmer') priority = 3.5;
                                else if (enemy.type === 'drone') priority = 2;
                                
                                // Boost priority if enemy is close to player (protector role)
                                const distToPlayer = Math.sqrt((enemy.x - this.x)**2 + (enemy.y - this.y)**2);
                                if (distToPlayer < 150) priority += 0.5;
                                
                                return priority;
                            };
                            
                            // Find multiple targets based on turret level, sorted by priority
                            const targetsWithPriority = entities.enemies
                                .filter(e => e.hp > 0)
                                .map(e => ({
                                    enemy: e,
                                    dist: Math.sqrt((e.x - turret.x)**2 + (e.y - turret.y)**2),
                                    priority: priorityOrder(e)
                                }))
                                .filter(({dist, priority}) => dist < turretRange && priority >= 0)
                                .sort((a, b) => {
                                    // Sort by priority first, then distance
                                    if (b.priority !== a.priority) return b.priority - a.priority;
                                    return a.dist - b.dist;
                                })
                                .slice(0, maxTargetsPerTurret);
                            
                            // Fire at each target with staggered timing
                            targetsWithPriority.forEach(({enemy: target}, index) => {
                                const staggerDelay = index * 5; // 5 frames between each shot (increased from 3)
                                
                                setTimeout(() => {
                                    if (target.hp > 0) { // Check target still alive
                                        const angle = Math.atan2(target.y - turret.y, target.x - turret.x);
                                        const vx = Math.cos(angle) * 10;
                                        const vy = Math.sin(angle) * 10;
                                        entities.projectiles.push(new Projectile(
                                            turret.x, turret.y, vx, vy, turretDmg, 0, 'turret_shot', target, 'turret'
                                        ));
                                    }
                                }, staggerDelay * 16); // Convert frames to ms
                            });
                            
                            if (targetsWithPriority.length > 0) {
                                turret.fireTimer = turretFireRate;
                            }
                        }
                        
                        return true;
                    });
                }
                
                // EMP PULSE (Disruptor weapon)
                if (this.weapons.emp > 0) {
                    if (!this.empTimer) this.empTimer = 0;
                    const fireInterval = Math.max(60, 75 / this.weaponStats.emp.rate); // 1.25 sec base (was 1.5)
                    const empDmg = this.damage * 1.2 * this.weaponStats.emp.dmg; // Buffed from 0.8x to 1.2x
                    const fieldRadius = (60 + this.weapons.emp * 10) * this.weaponStats.emp.area; // Reduced: 60 base (was 80), +10/level (was 15)
                    
                    this.empTimer -= dt/16;
                    if (this.empTimer <= 0) {
                        const fireEmpPulse = (dmgMult = 1.0) => {
                            // CLUSTER TARGETING - Find densest enemy cluster (like missiles/railgun)
                            const visibleRadius = Math.min(width, height) / state.zoom * 0.4;
                            const maxSearchRadius = 500;
                            
                            // Find enemies in visible range first
                            const visibleEnemies = entities.enemies.filter(e => {
                                const dist = Math.sqrt((e.x - this.x)**2 + (e.y - this.y)**2);
                                return dist < visibleRadius && e.hp > 0;
                            });
                            
                            let targetPool = visibleEnemies.length > 0 ? visibleEnemies : entities.enemies.filter(e => {
                                const dist = Math.sqrt((e.x - this.x)**2 + (e.y - this.y)**2);
                                return dist < maxSearchRadius && e.hp > 0;
                            });
                            
                            if (targetPool.length === 0) {
                                return;
                            }
                            
                            // Find densest cluster
                            let bestTarget = null;
                            let bestDensity = 0;
                            
                            for (let e of targetPool) {
                                const nearby = targetPool.filter(e2 => {
                                    const dist = Math.sqrt((e.x - e2.x)**2 + (e.y - e2.y)**2);
                                    return dist < 200; // Cluster radius
                                }).length;
                                
                                if (nearby > bestDensity) {
                                    bestDensity = nearby;
                                    bestTarget = e;
                                }
                            }
                            
                            if (!bestTarget) bestTarget = targetPool[0];
                            
                            const angle = Math.atan2(bestTarget.y - this.y, bestTarget.x - this.x);
                            const vx = Math.cos(angle) * 8;
                            const vy = Math.sin(angle) * 8;
                            const adjustedDmg = empDmg * dmgMult;
                            entities.projectiles.push(new Projectile(
                                this.x, this.y, vx, vy, adjustedDmg, fieldRadius, 'emp_pulse', bestTarget, 'emp'
                            ));
                        };
                        
                        const fireEmpWithMulti = (dmgMult = 1.0, depth = 0) => {
                            fireEmpPulse(dmgMult);
                            checkMultistrike(fireEmpWithMulti, 1.25, depth);
                        };
                        
                        fireEmpWithMulti();
                        this.empTimer = fireInterval;
                    }
                    
                    // Update EMP fields
                    if (!this.empFields) this.empFields = [];
                    this.empFields = this.empFields.filter(field => {
                        field.life -= dt/16;
                        return field.life > 0;
                    });
                }
                
                // KINETIC BARRIER (Vanguard weapon) - FRONTAL PLOW
                if (this.weapons.barrier > 0) {
                    // AREA UPGRADE: Increases cone reach/depth (how far forward the plow extends)
                    // Base 65px - with area upgrades can reach ~130px+ forward
                    const barrierRadius = 65 * this.weaponStats.barrier.area; // 65px base
                    
                    // Track which enemies are inside barrier (for one-time impact on entry)
                    if (!this.barrierEnemies) this.barrierEnemies = new Set();
                    const currentBarrierEnemies = new Set();
                    
                    // Tick system - damage every 10 frames (6 times per second)
                    if (!this.barrierTickCounter) this.barrierTickCounter = 0;
                    this.barrierTickCounter += dt/16;
                    
                    if (this.barrierTickCounter >= 10) {
                        this.barrierTickCounter -= 10;
                        
                        // Calculate speed ratio for movement multiplier
                        const currentSpeed = Math.sqrt(this.vx**2 + this.vy**2);
                        const maxSpeed = this.speed * this.shipSpeedMult;
                        const speedRatio = Math.min(1.0, currentSpeed / maxSpeed); // 0 to 1
                        
                        // IMPROVED DAMAGE FORMULA: Better scaling with stats
                        // Base components (normalized to baseline values) - BUFFED SCALING
                        const hpComponent = this.maxHp / 120; // Was 150, now 120 (25% more scaling from HP)
                        const armorComponent = this.armor / 12; // Was 15, now 12 (25% more scaling from armor)
                        const speedComponent = (this.speed * this.shipSpeedMult) / 2.0; // Was 2.5, now 2.0 (25% more scaling from speed)
                        const damageComponent = this.damage / 12; // Was 15, now 12 (25% more scaling from damage)
                        
                        // Combined scaling - now MULTIPLIES instead of averages (much stronger)
                        const statScaling = Math.sqrt(hpComponent * armorComponent * speedComponent * damageComponent);
                        
                        // Base impact damage - back to 2.0x (was 3.5x frontal buff, too strong)
                        const baseImpactDamage = this.damage * 2.0 * statScaling * this.weaponStats.barrier.dmg;
                        
                        // Movement speed multiplier: 10% to 100%
                        const movementMultiplier = 0.1 + (speedRatio * 0.9);
                        const impactDamage = baseImpactDamage * movementMultiplier;
                        
                        // DOT damage - back to 0.3x (was 0.5x frontal buff, too strong)
                        const dotDamage = this.damage * 0.3 * statScaling * this.weaponStats.barrier.dmg;
                        
                        // Calculate ship's forward direction
                        const shipAngle = this.angle;
                        const coneHalfAngle = (100 * Math.PI / 180) / 2; // 50¬∞ on each side = 100¬∞ total (reduced from 120¬∞)
                        
                        // Damage enemies in FRONTAL CONE only
                        for(let e of entities.enemies) {
                            if (e.hp <= 0) continue;
                            
                            const dx = e.x - this.x;
                            const dy = e.y - this.y;
                            const dist = Math.sqrt(dx**2 + dy**2);
                            const enemyId = e.id;
                            
                            // Calculate angle to enemy relative to ship's forward direction
                            const angleToEnemy = Math.atan2(dy, dx);
                            let angleDiff = angleToEnemy - shipAngle;
                            
                            // Normalize angle difference to -PI to PI
                            while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                            while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
                            
                            // Check if enemy is within frontal cone AND range
                            const inCone = Math.abs(angleDiff) <= coneHalfAngle;
                            const inRange = dist < barrierRadius + e.radius;
                            
                            if (inCone && inRange) {
                                currentBarrierEnemies.add(enemyId);
                                
                                // IMPACT DAMAGE + KNOCKBACK: Only on first entry
                                if (!this.barrierEnemies.has(enemyId)) {
                                    // No crit bonus - removed for balance
                                    this.dealElementalDamage(e, impactDamage, 'barrier', '#c0cfe0', true, 'normal');
                                    
                                    // PLOW KNOCKBACK - Strong side deflection like a real snowplow
                                    // Asymmetric design: pointed center, stronger side deflection at edges
                                    const baseKnockback = 22;
                                    const speedBonus = speedRatio * 12;
                                    const knockbackForce = baseKnockback + speedBonus; // 22-34 units
                                    
                                    // Calculate which side enemy is on (left or right of ship's forward vector)
                                    const sideDirection = Math.sign(angleDiff); // -1 for left, +1 for right
                                    
                                    // SNOWPLOW ASYMMETRY: Enemies closer to the edge get pushed MORE to the side
                                    // Normalize angle within cone: 0 (center) to 1 (edge)
                                    const coneHalfAngle = (100 * Math.PI / 180) / 2; // 50¬∞ half angle
                                    const normalizedAngle = Math.abs(angleDiff) / coneHalfAngle; // 0 to 1
                                    
                                    // Lerp between center and edge deflection angles
                                    // Center (0): 20% forward, 80% side, 105¬∞ deflection
                                    // Edge (1): 10% forward, 90% side, 120¬∞ deflection (even more side!)
                                    const forwardPush = 0.20 - (normalizedAngle * 0.10); // 20% -> 10%
                                    const sidePush = 0.80 + (normalizedAngle * 0.10);    // 80% -> 90%
                                    
                                    // Deflection angle increases toward edges (like snowplow curve)
                                    // Center: 105¬∞ (90¬∞ + 15¬∞), Edge: 120¬∞ (90¬∞ + 30¬∞)
                                    const baseDeflection = Math.PI / 2; // 90¬∞ perpendicular
                                    const additionalAngle = (Math.PI / 12) + (normalizedAngle * Math.PI / 12); // 15¬∞ to 30¬∞
                                    
                                    // Small forward push in ship's direction
                                    const forwardVx = Math.cos(shipAngle) * knockbackForce * forwardPush;
                                    const forwardVy = Math.sin(shipAngle) * knockbackForce * forwardPush;
                                    
                                    // Strong push to the side with asymmetric angle
                                    const sideAngle = shipAngle + (baseDeflection + additionalAngle) * sideDirection;
                                    const sideVx = Math.cos(sideAngle) * knockbackForce * sidePush;
                                    const sideVy = Math.sin(sideAngle) * knockbackForce * sidePush;
                                    
                                    // Apply as VELOCITY instead of position - creates smooth animation
                                    if (!e.knockbackVx) e.knockbackVx = 0;
                                    if (!e.knockbackVy) e.knockbackVy = 0;
                                    
                                    // Add to existing knockback velocity (additive)
                                    e.knockbackVx += (forwardVx + sideVx) * 0.15; // Scale down to smooth velocity
                                    e.knockbackVy += (forwardVy + sideVy) * 0.15;
                                    
                                    // STUN WEAKER ENEMIES: 0.5 second stun on impact
                                    // Only affects basic enemies (not bosses, tanks, or champions)
                                    if (e.type !== 'boss' && e.type !== 'tank' && !e.isChampion) {
                                        if (!e.barrierStunTimer) e.barrierStunTimer = 0;
                                        e.barrierStunTimer = 30; // 30 frames = 0.5 seconds at 60fps
                                    }
                                    
                                    // Impact visual
                                    createExplosion(e.x, e.y, '#c0cfe0', 12);
                                    
                                    // Directional particle burst showing the plow effect
                                    for (let i = 0; i < 8; i++) {
                                        const spreadAngle = shipAngle + (sideDirection * (Math.PI / 6)) + (Math.random() - 0.5) * (Math.PI / 4);
                                        const px = e.x + Math.cos(spreadAngle) * 10;
                                        const py = e.y + Math.sin(spreadAngle) * 10;
                                        entities.particles.push({
                                            x: px, y: py,
                                            vx: Math.cos(spreadAngle) * 3,
                                            vy: Math.sin(spreadAngle) * 3,
                                            life: 12,
                                            maxLife: 12,
                                            color: '#8b9dc3',
                                            radius: 2.5,
                                            update() { this.x += this.vx; this.y += this.vy; this.life--; return this.life > 0; },
                                            draw(ctx) {
                                                const alpha = this.life / this.maxLife;
                                                ctx.fillStyle = this.color.replace(')', `, ${alpha})`).replace('rgb', 'rgba');
                                                ctx.beginPath();
                                                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                                                ctx.fill();
                                            }
                                        });
                                    }
                                }
                                
                                // DOT DAMAGE removed - area too small after redesign
                                // this.dealElementalDamage(e, dotDamage, 'barrier', '#8b9dc3', false, 'dot');
                            }
                        }
                        
                        // Update tracked enemies (for next frame)
                        this.barrierEnemies = currentBarrierEnemies;
                    }
                    
                    // Projectile redirection - FRONTAL CONE ONLY (deflects based on impact angle)
                    // No damage reflection - pure defensive positioning skill
                    entities.enemyProjectiles.forEach(ep => {
                        const dx = ep.x - this.x;
                        const dy = ep.y - this.y;
                        const dist = Math.sqrt(dx**2 + dy**2);
                        
                        // Check if projectile is in frontal cone
                        const shipAngle = this.angle;
                        const coneHalfAngle = (100 * Math.PI / 180) / 2; // 50¬∞ half angle
                        const angleToProjectile = Math.atan2(dy, dx);
                        let angleDiff = angleToProjectile - shipAngle;
                        while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                        while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
                        
                        const inCone = Math.abs(angleDiff) <= coneHalfAngle;
                        
                        // Check if projectile is near barrier edge (not just ship center)
                        const barrierEdge = barrierRadius * 0.9; // Deflect at 90% of barrier radius
                        
                        if (dist < barrierEdge && inCone && !ep.barrierProcessed) {
                            ep.barrierProcessed = true; // Mark as processed
                            
                            // REDIRECT projectile based on impact angle (like a real deflector shield)
                            // Calculate reflection angle - bounce off the barrier surface
                            
                            // Which side of the ship did it hit? (left or right)
                            const impactSide = Math.sign(angleDiff);
                            
                            // Redirect angle: perpendicular to ship + away from ship
                            // 90¬∞ to the side + slight forward angle
                            const redirectAngle = shipAngle + (Math.PI / 2) * impactSide + (Math.PI / 6) * impactSide;
                            
                            // Keep projectile speed but change direction
                            const speed = Math.sqrt(ep.vx**2 + ep.vy**2);
                            ep.vx = Math.cos(redirectAngle) * speed;
                            ep.vy = Math.sin(redirectAngle) * speed;
                            
                            // Visual feedback - deflection spark
                            createExplosion(ep.x, ep.y, '#8b9dc3', 6);
                            
                            // Deflection particles showing redirect direction
                            for (let i = 0; i < 4; i++) {
                                const spreadAngle = redirectAngle + (Math.random() - 0.5) * (Math.PI / 6);
                                entities.particles.push({
                                    x: ep.x,
                                    y: ep.y,
                                    vx: Math.cos(spreadAngle) * 4,
                                    vy: Math.sin(spreadAngle) * 4,
                                    life: 10,
                                    maxLife: 10,
                                    color: '#c0cfe0',
                                    radius: 2,
                                    update() { this.x += this.vx; this.y += this.vy; this.vx *= 0.95; this.vy *= 0.95; this.life--; return this.life > 0; },
                                    draw(ctx) {
                                        const alpha = this.life / this.maxLife;
                                        ctx.fillStyle = this.color.replace(')', `, ${alpha})`).replace('rgb', 'rgba');
                                        ctx.beginPath();
                                        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                                        ctx.fill();
                                    }
                                });
                            }
                        }
                    });
                    
                    // Store barrier radius and angle for visual
                    this.barrierRadius = barrierRadius;
                    this.barrierAngle = this.angle;
                    this.barrierConeAngle = 100 * Math.PI / 180; // Store in radians (100¬∞)
                }
                
                // ORBITAL BLADESTORM (Reaper weapon) - Close-range melee + projectile throws
                if (this.weapons.orbital > 0) {
                    const numBlades = 5; // 5 blades for better coverage
                    const innerRadius = 35; // FIXED - blades start slightly away from ship (was 25)
                    const baseOuterRadius = 65; // Increased from 55 - better reach
                    const maxOuterRadius = 150; // Max outer reach (increased)
                    
                    // Calculate outer radius - grows with area upgrades AND level
                    const levelAreaBonus = this.weapons.orbital * 4; // +4px per weapon level (was 3)
                    const outerRadius = Math.min(maxOuterRadius, baseOuterRadius + levelAreaBonus + (this.weaponStats.orbital.area - 1) * 20);
                    
                    // Blades orbit at FIXED inner radius - only blade length extends outward
                    const orbitRadius = innerRadius; // FIXED - blades grow outward from here
                    
                    // Rotation speed - scales with rate, minimal level scaling
                    const levelBonus = 1 + (this.weapons.orbital * 0.05); // Slightly increased: +5% per level (was +3%)
                    const rotationSpeed = 0.09 * this.weaponStats.orbital.rate * levelBonus; // Slightly slower base (was 0.1)
                    
                    // Update rotation angle
                    if (!this.orbitalAngle) this.orbitalAngle = 0;
                    this.orbitalAngle += rotationSpeed * (dt / 16);
                    
                    // Blade length - extends from inner radius to outer radius
                    const bladeLength = outerRadius - innerRadius; // Blades grow longer, not move away
                    
                    // Blade damage - buffed further
                    const baseDamageMultiplier = 1.75; // Increased from 1.6
                    const levelScaling = 1 + (this.weapons.orbital * 0.12); // +12% damage per level (was 10%)
                    const bladeDamage = this.damage * baseDamageMultiplier * levelScaling * this.weaponStats.orbital.dmg;
                    
                    // BLADE THROWING MECHANIC - burst fire: 3 rapid shots, then pause
                    if (!this.orbitalThrowTimer) this.orbitalThrowTimer = 0;
                    if (!this.orbitalBurstCount) this.orbitalBurstCount = 0;
                    
                    const burstInterval = 9 / this.weaponStats.orbital.rate; // 0.15s between shots in burst
                    const pauseInterval = 72 / this.weaponStats.orbital.rate; // 1.2s pause after burst
                    const shotsPerBurst = 3;
                    
                    this.orbitalThrowTimer += dt / 16;
                    
                    // Check if we should fire
                    let shouldFire = false;
                    if (this.orbitalBurstCount < shotsPerBurst) {
                        // In burst mode - fire rapidly
                        if (this.orbitalThrowTimer >= burstInterval) {
                            shouldFire = true;
                            this.orbitalBurstCount++;
                            this.orbitalThrowTimer = 0;
                        }
                    } else {
                        // Burst complete - wait for pause
                        if (this.orbitalThrowTimer >= pauseInterval) {
                            shouldFire = true;
                            this.orbitalBurstCount = 1; // Reset to 1 (we're firing the first of next burst)
                            this.orbitalThrowTimer = 0;
                        }
                    }
                    
                    if (shouldFire) {
                        // Find nearby enemies to target
                        const maxThrowRange = 350 * this.weaponStats.orbital.area;
                        const nearbyEnemies = entities.enemies.filter(e => {
                            if (e.hp <= 0) return false;
                            const dist = Math.sqrt((e.x - this.x)**2 + (e.y - this.y)**2);
                            return dist < maxThrowRange;
                        });
                        
                        if (nearbyEnemies.length > 0) {
                            // Pick random enemy to target
                            const target = nearbyEnemies[Math.floor(Math.random() * nearbyEnemies.length)];
                            
                            // Calculate angle from ship to target
                            const targetAngle = Math.atan2(target.y - this.y, target.x - this.x);
                            
                            // Spawn blade from the side of ship facing the target (at orbit radius)
                            const spawnX = this.x + Math.cos(targetAngle) * orbitRadius;
                            const spawnY = this.y + Math.sin(targetAngle) * orbitRadius;
                            
                            // Direction toward target (straight line from spawn to target)
                            const dx = target.x - spawnX;
                            const dy = target.y - spawnY;
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            const dirX = dx / dist;
                            const dirY = dy / dist;
                            
                            const speed = 8; // Medium speed projectile
                            const vx = dirX * speed;
                            const vy = dirY * speed;
                            
                            const bladeAngle = Math.atan2(vy, vx);
                            
                            entities.projectiles.push({
                                x: spawnX,
                                y: spawnY,
                                vx: vx,
                                vy: vy,
                                damage: bladeDamage,
                                life: 150,
                                color: '#ff3333',
                                source: 'orbital',
                                pierceCount: 0,
                                maxPierce: 3,
                                hitEnemies: new Set(),
                                distanceTraveled: 0,
                                maxDistance: maxThrowRange,
                                angle: bladeAngle,
                                bladeLength: bladeLength,
                                update() {
                                    this.x += this.vx;
                                    this.y += this.vy;
                                    this.distanceTraveled += Math.sqrt(this.vx**2 + this.vy**2);
                                    this.angle = Math.atan2(this.vy, this.vx);
                                    this.life--;
                                    
                                    // Check for enemy hits - pierce up to 3 enemies
                                    if (this.pierceCount < this.maxPierce) {
                                        entities.enemies.forEach(e => {
                                            if (e.hp <= 0 || this.hitEnemies.has(e.id)) return;
                                            const dist = Math.sqrt((e.x - this.x)**2 + (e.y - this.y)**2);
                                            if (dist < 18 + e.radius) { // Increased detection radius
                                                this.hitEnemies.add(e.id);
                                                this.pierceCount++;
                                                
                                                // Use dealElementalDamage for proper elemental procs
                                                player.dealElementalDamage(e, this.damage, 'orbital', '#ff3333');
                                                createExplosion(e.x, e.y, '#ff3333', 10);
                                            }
                                        });
                                    }
                                    
                                    // Die after 3 hits OR max distance, whichever comes first
                                    return this.life > 0 && this.distanceTraveled < this.maxDistance && this.pierceCount < this.maxPierce;
                                },
                                draw(ctx) {
                                    ctx.save();
                                    ctx.translate(this.x, this.y);
                                    ctx.rotate(this.angle);
                                    
                                    const len = this.bladeLength * 0.6; // Smaller thrown blade
                                    const wid = 8; // Narrower too
                                    
                                    // Triangle pointing forward
                                    const tipX = len;
                                    const tipY = 0;
                                    const base1X = -len * 0.3;
                                    const base1Y = wid / 2;
                                    const base2X = -len * 0.3;
                                    const base2Y = -wid / 2;
                                    
                                    // Dark red base
                                    ctx.fillStyle = '#cc0000';
                                    ctx.shadowBlur = 15;
                                    ctx.shadowColor = '#ff0000';
                                    ctx.beginPath();
                                    ctx.moveTo(tipX, tipY);
                                    ctx.lineTo(base1X, base1Y);
                                    ctx.lineTo(base2X, base2Y);
                                    ctx.closePath();
                                    ctx.fill();
                                    
                                    // Bright red core
                                    ctx.fillStyle = '#ff3333';
                                    ctx.shadowBlur = 20;
                                    ctx.shadowColor = '#ff3333';
                                    ctx.beginPath();
                                    ctx.moveTo(tipX * 0.7, tipY);
                                    ctx.lineTo(base1X * 0.7, base1Y * 0.7);
                                    ctx.lineTo(base2X * 0.7, base2Y * 0.7);
                                    ctx.closePath();
                                    ctx.fill();
                                    
                                    // Gold edge
                                    ctx.strokeStyle = '#ffcc00';
                                    ctx.lineWidth = 2;
                                    ctx.shadowBlur = 15;
                                    ctx.shadowColor = '#ffcc00';
                                    ctx.beginPath();
                                    ctx.moveTo(tipX, tipY);
                                    ctx.lineTo(base1X, base1Y);
                                    ctx.lineTo(base2X, base2Y);
                                    ctx.closePath();
                                    ctx.stroke();
                                    
                                    ctx.restore();
                                }
                            });
                            
                            // Visual effect - red flash at spawn
                            createExplosion(spawnX, spawnY, '#ff3333', 8);
                        }
                    }
                    
                    // Check each blade for collisions along their length
                    for (let i = 0; i < numBlades; i++) {
                        const bladeAngle = this.orbitalAngle + (Math.PI * 2 / numBlades) * i;
                        
                        // Blade extends from inner radius to outer radius
                        const innerX = this.x + Math.cos(bladeAngle) * innerRadius;
                        const innerY = this.y + Math.sin(bladeAngle) * innerRadius;
                        const outerX = this.x + Math.cos(bladeAngle) * outerRadius;
                        const outerY = this.y + Math.sin(bladeAngle) * outerRadius;
                        
                        entities.enemies.forEach(e => {
                            if (e.hp <= 0) return;
                            
                            // Initialize hit tracking if needed (for enemies that spawned after initial loop)
                            if (!e.orbitalBladeHits) e.orbitalBladeHits = {};
                            
                            // Per-blade cooldown using game time (respects time dilation)
                            const bladeKey = `blade_${i}`;
                            const lastHitTime = e.orbitalBladeHits[bladeKey] || 0;
                            const timeSinceLastHit = state.gameTime - lastHitTime;
                            if (timeSinceLastHit < 333) return; // 333ms = 0.33 seconds, respects slow motion
                            
                            // Check distance to blade line segment (inner to outer)
                            // Project enemy position onto blade line
                            const dx = outerX - innerX;
                            const dy = outerY - innerY;
                            const length = Math.sqrt(dx * dx + dy * dy);
                            const ex = e.x - innerX;
                            const ey = e.y - innerY;
                            
                            // Dot product to find closest point on line
                            const t = Math.max(0, Math.min(1, (ex * dx + ey * dy) / (length * length)));
                            const closestX = innerX + t * dx;
                            const closestY = innerY + t * dy;
                            
                            const dist = Math.sqrt((e.x - closestX)**2 + (e.y - closestY)**2);
                            const bladeWidth = 15; // Hit detection width
                            
                            if (dist < bladeWidth + e.radius) {
                                e.orbitalBladeHits[bladeKey] = state.gameTime; // Mark hit time in game milliseconds
                                
                                // Use dealElementalDamage for proper elemental procs
                                this.dealElementalDamage(e, bladeDamage, 'orbital', '#ff3333');
                                createExplosion(e.x, e.y, '#ff3333', 12);
                                
                                // Gold sparks
                                for (let j = 0; j < 4; j++) {
                                    const angle = Math.random() * Math.PI * 2;
                                    entities.particles.push({
                                        x: e.x,
                                        y: e.y,
                                        vx: Math.cos(angle) * 3,
                                        vy: Math.sin(angle) * 3,
                                        life: 12,
                                        maxLife: 12,
                                        color: '#ffcc00',
                                        radius: 2,
                                        update() { 
                                            this.x += this.vx; 
                                            this.y += this.vy;
                                            this.vx *= 0.9;
                                            this.vy *= 0.9;
                                            this.life--; 
                                            return this.life > 0; 
                                        },
                                        draw(ctx) {
                                            const alpha = this.life / this.maxLife;
                                            ctx.fillStyle = `rgba(255, 204, 0, ${alpha})`;
                                            ctx.beginPath();
                                            ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                                            ctx.fill();
                                        }
                                    });
                                }
                            }
                        });
                    }
                    
                    // Store for visual
                    this.orbitalRadius = outerRadius; // Outer edge for blade positioning
                    this.orbitalInnerRadius = innerRadius; // Inner edge (stays fixed)
                    this.orbitalBladeCount = numBlades;
                    this.orbitalBladeLength = bladeLength;
                }
                

            }


            getActiveWeaponCount() {
                let c = 0; 
                const keys = ['ion', 'turret', 'emp', 'barrier', 'orbital', 'beam', 'seeker', 'rad', 'tesla', 'whip', 'meteor', 'railgun', 'flak', 'pylons', 'mines', 'gas', 'ricochet', 'drones', 'surge'];
                keys.forEach(k => { if(this.weapons[k] > 0) c++; });
                return c;
            }

            distanceToLineSegment(px, py, x1, y1, x2, y2) {
                const A = px - x1;
                const B = py - y1;
                const C = x2 - x1;
                const D = y2 - y1;
                const dot = A * C + B * D;
                const lenSq = C * C + D * D;
                let param = -1;
                if (lenSq !== 0) param = dot / lenSq;
                let xx, yy;
                if (param < 0) { xx = x1; yy = y1; }
                else if (param > 1) { xx = x2; yy = y2; }
                else { xx = x1 + param * C; yy = y1 + param * D; }
                const dx = px - xx;
                const dy = py - yy;
                return Math.sqrt(dx * dx + dy * dy);
            }



            getNearestEnemy(range) {
                let nearest = null; let minDist = range;
                let nearestHacked = null; let minHackedDist = range;
                let nearestChampion = null; let minChampionDist = range;
                let nearestTank = null; let minTankDist = range;
                let nearestSplitter = null; let minSplitterDist = range;
                
                for(let e of entities.enemies) {
                    const d = Math.sqrt((e.x-this.x)**2 + (e.y-this.y)**2);
                    if(d < minDist) {
                        if(e.hackState.active) {
                            // Track hacked enemies separately (lowest priority)
                            if(d < minHackedDist) {
                                minHackedDist = d;
                                nearestHacked = e;
                            }
                        } else if (e.isChampion) {
                            // Track champions separately (highest priority)
                            if (d < minChampionDist) {
                                minChampionDist = d;
                                nearestChampion = e;
                            }
                        } else if (e.type === 'tank') {
                            // Track tanks separately (high priority)
                            if (d < minTankDist) {
                                minTankDist = d;
                                nearestTank = e;
                            }
                        } else if (e.type === 'splitter') {
                            // Track splitters separately (high priority due to range)
                            if (d < minSplitterDist) {
                                minSplitterDist = d;
                                nearestSplitter = e;
                            }
                        } else {
                            // Normal enemies
                            minDist = d;
                            nearest = e;
                        }
                    }
                }
                
                // Priority: 1. Champions, 2. Tanks, 3. Splitters, 4. Normal enemies, 5. Hacked enemies
                // Give champions 1.7x, tanks 1.5x, splitters 1.3x effective range
                if (nearestChampion && minChampionDist < range * 1.7) {
                    return nearestChampion;
                }
                if (nearestTank && minTankDist < range * 1.5) {
                    return nearestTank;
                }
                if (nearestSplitter && minSplitterDist < range * 1.3) {
                    return nearestSplitter;
                }
                return nearest || nearestHacked;
            }

            triggerCryoShatter(enemy) {
                // Controlled shatter - spreads freeze to nearby enemies, no explosion damage
                createExplosion(enemy.x, enemy.y, '#88d8ff', 15);
                
                const shatterRadius = 150;
                const freezeChance = 0.7; // 70% chance to freeze nearby
                const maxTargets = 6;
                
                // Find nearby enemies
                const nearbyEnemies = entities.enemies
                    .filter(e => e !== enemy && e.hp > 0)
                    .map(e => ({
                        enemy: e,
                        dist: Math.sqrt((e.x - enemy.x)**2 + (e.y - enemy.y)**2)
                    }))
                    .filter(({dist}) => dist < shatterRadius)
                    .sort((a, b) => a.dist - b.dist)
                    .slice(0, maxTargets);
                
                // Spread freeze to nearby enemies (no damage)
                // Only create visual explosions for successfully frozen enemies (performance optimization)
                nearbyEnemies.forEach(({enemy: e, dist}) => {
                    // Chance to freeze nearby enemies
                    if (seededRandom() < freezeChance && e.type !== 'boss' && !e.isChampion && e.cryoState.frozenTimer <= 0) {
                        e.cryoState.frozenTimer = 90; // 1.5s freeze
                        // Small explosion only for frozen targets (reduced performance impact)
                        createExplosion(e.x, e.y, '#88d8ff', 3);
                    }
                });
                
                // Reduced ice particles for visual feedback (6 -> 4 for better performance)
                for (let i = 0; i < 4; i++) {
                    const angle = (Math.PI * 2 / 4) * i;
                    const speed = 2 + seededRandom() * 2;
                    entities.particles.push({
                        x: enemy.x,
                        y: enemy.y,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed,
                        color: '#88d8ff',
                        life: 15,
                        size: 2,
                        update: function(dt) {
                            this.x += this.vx * (dt/16);
                            this.y += this.vy * (dt/16);
                            this.life -= dt/16;
                            this.vx *= 0.92;
                            this.vy *= 0.92;
                            return this.life > 0;
                        },
                        draw: function(ctx) {
                            ctx.fillStyle = this.color;
                            ctx.shadowBlur = 4;
                            ctx.shadowColor = this.color;
                            ctx.beginPath();
                            ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.shadowBlur = 0;
                        }
                    });
                }
            }

            dealElementalDamage(enemy, dmg, sourceId, color, allowCrit = true, type = 'normal', forceElement = null) {
                // Safety check - ensure enemy is valid and has cryoState
                if (!enemy) {
                    return;
                }
                
                // Spawn invulnerability - turrets can't take damage during spawn
                if (enemy.spawnInvuln && enemy.spawnInvuln > 0) {
                    return;
                }
                
                // Apply Ascension damage multipliers
                dmg *= this.getAscensionDamageMult(enemy);
                
                // BOSS SHIELD entities - damage them directly
                if (enemy.isBossShield) {
                    // Don't damage shields that are already dead
                    if (enemy.hp <= 0) {
                        return;
                    }
                    
                    enemy.hp -= dmg;
                    enemy.flash = 5;
                    
                    // Use normal damage number styling (color from weapon, shows element icons)
                    let isCrit = false;
                    if (allowCrit && seededRandom() < player.critChance) {
                        dmg *= player.critMult;
                        isCrit = true;
                    }
                    
                    const elementType = forceElement || player.weaponAugments[sourceId] || null;
                    entities.texts.push(new FloatingText(enemy.x, enemy.y - 20, Math.ceil(dmg), color, isCrit, type, sourceId, elementType));
                    
                    // Only explode ONCE when dying (not every damage tick after death)
                    if (enemy.hp <= 0 && !enemy.hasExploded) {
                        enemy.hp = 0;
                        enemy.hasExploded = true; // Flag to prevent repeated explosions
                        createExplosion(enemy.x, enemy.y, '#00d1b2', 30);
                        // Bullet spread on destruction
                        for (let i = 0; i < 12; i++) {
                            const angle = (Math.PI * 2 / 12) * i;
                            entities.enemyProjectiles.push({
                                x: enemy.x,
                                y: enemy.y,
                                vx: Math.cos(angle) * 3,
                                vy: Math.sin(angle) * 3,
                                life: 120,
                                dmg: 10,
                                radius: 4
                            });
                        }
                        // NOTE: Shield destruction check moved to boss update loop
                    }
                    return;
                }
                
                // BOSS TURRET entities - damage them directly
                if (enemy.isBossTurret) {
                    // Don't damage turrets that are already dead
                    if (enemy.hp <= 0) {
                        return;
                    }
                    
                    enemy.hp -= dmg;
                    enemy.flash = 5;
                    
                    // Use normal damage number styling (color from weapon, shows element icons)
                    let isCrit = false;
                    if (allowCrit && seededRandom() < player.critChance) {
                        dmg *= player.critMult;
                        isCrit = true;
                    }
                    
                    const elementType = forceElement || player.weaponAugments[sourceId] || null;
                    entities.texts.push(new FloatingText(enemy.x, enemy.y - 20, Math.ceil(dmg), color, isCrit, type, sourceId, elementType));
                    
                    if (enemy.hp <= 0) {
                        enemy.hp = 0;
                        createExplosion(enemy.x, enemy.y, '#ff8800', 20);
                    }
                    return;
                }
                
                // NEXUS PRIME boss doesn't have cryoState - skip elemental effects
                if (enemy.isNexusPrime) {
                    // Boss core only vulnerable when shields down
                    if (!enemy.coreVulnerable) {
                        return; // Core is immune
                    }
                    
                    // Core is vulnerable - deal INCREASED damage (25% bonus for satisfying feedback)
                    dmg *= 1.25; // Chunky damage when shields are down!
                    
                    let isCrit = false;
                    if (allowCrit && seededRandom() < player.critChance) {
                        dmg *= player.critMult;
                        isCrit = true;
                    }
                    
                    enemy.hp -= dmg;
                    
                    // ULTIMATE CHARGE: Gain charge from damage dealt (using ultimate-specific rate)
                    if (player.ultimate && player.ultimateCharge < 100 && !player.ultimateActive) {
                        const ultimateData = ULTIMATES[player.ultimate];
                        if (ultimateData && ultimateData.damageChargeBonus) {
                            let chargeGain = dmg * ultimateData.damageChargeBonus;
                            
                            // ASCENSION 3+: ENERGY LEAK - Ultimate charges 20% slower
                            if (player.energyLeakPenalty) {
                                chargeGain *= player.energyLeakPenalty; // 0.80 = -20%
                            }
                            
                            player.ultimateCharge += chargeGain;
                            if (player.ultimateCharge > 100) player.ultimateCharge = 100;
                        }
                    }
                    
                    const elementType = forceElement || player.weaponAugments[sourceId] || null;
                    entities.texts.push(new FloatingText(enemy.x, enemy.y - 20, Math.ceil(dmg), color, isCrit, type, sourceId, elementType));
                    return;
                }
                
                // Ensure enemy has cryoState (normal enemies should have this)
                if (!enemy.cryoState) {
                    return;
                }
                
                // NEXUS PRIME SPECIAL HANDLING
                if (enemy.isNexusPrime) {
                    // Check if shields are active - core is immune
                    if (enemy.shieldsActive && !enemy.coreVulnerable) {
                        // Try to hit shields instead
                        for (let shield of enemy.shields) {
                            if (shield.hp <= 0) continue;
                            
                            const sx = enemy.x + Math.cos(shield.angle) * shield.orbitRadius;
                            const sy = enemy.y + Math.sin(shield.angle) * shield.orbitRadius;
                            const dx = player.x - sx;
                            const dy = player.y - sy;
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            
                            // Check if this weapon would hit this shield (rough check)
                            if (dist < 300) { // Generous collision for AOE
                                let finalDmg = dmg;
                                let isCrit = false;
                                if (allowCrit && seededRandom() < player.critChance) {
                                    finalDmg *= player.critMult;
                                    isCrit = true;
                                }
                                
                                shield.hp -= finalDmg;
                                shield.flash = 5;
                                
                                // Use normal damage number styling (color from weapon, shows element icons)
                                const elementType = forceElement || player.weaponAugments[sourceId] || null;
                                entities.texts.push(new FloatingText(sx, sy - 20, Math.ceil(finalDmg), color, isCrit, type, sourceId, elementType));
                                
                                if (shield.hp <= 0) {
                                    shield.hp = 0;
                                    shield.active = false; // Mark as inactive so it won't be targeted
                                    createExplosion(sx, sy, '#00d1b2', 30);
                                    // Bullet spread on destruction
                                    for (let i = 0; i < 12; i++) {
                                        const angle = (Math.PI * 2 / 12) * i;
                                        entities.enemyProjectiles.push({
                                            x: sx,
                                            y: sy,
                                            vx: Math.cos(angle) * 3,
                                            vy: Math.sin(angle) * 3,
                                            life: 180,
                                            dmg: 15,
                                            radius: 5
                                        });
                                    }
                                }
                                return; // Damage absorbed by shield
                            }
                        }
                        // No shield hit and core is immune - no damage
                        return;
                    }
                    // Core is vulnerable - damage applies normally
                }
                
                let isCrit = false;
                let finalDmg = dmg;
                
                // CHAMPION ELEMENTAL DAMAGE CAP
                // Champions take massive damage from elementals - cap it to prevent instant kills
                if (enemy.isChampion) {
                    const maxElementalDmg = enemy.maxHp * 0.08; // Max 8% of max HP per hit (reduced from 15%)
                    if (finalDmg > maxElementalDmg) {
                        finalDmg = maxElementalDmg;
                    }
                }
                
                // CRYO SHATTER: Cryo weapons hitting frozen enemies trigger shatter explosion
                // This is the NEW controlled shatter mechanic
                if (enemy.cryoState.frozenTimer > 0) {
                    const cryoWeapons = ['ice']; // Weapons with ice augment
                    const isCryoSource = this.weaponAugments[sourceId] === 'ice';
                    
                    if (isCryoSource) {
                        // Bonus damage to frozen target (buffed since no more shatter damage)
                        finalDmg *= 2.0; // 100% bonus damage to frozen enemies (was 50%)
                        
                        // Trigger shatter (now just spreads freeze)
                        this.triggerCryoShatter(enemy);
                    }
                }
                
                // BERSERKER MODULE: +10% damage for every 20% HP missing
                if (this.hasBerserker) {
                    const hpPercent = this.hp / this.maxHp;
                    const missingHpPercent = 1.0 - hpPercent;
                    // 20% missing = 10% damage, 40% missing = 20% damage, etc.
                    // At 20% HP (80% missing) = +40% damage
                    const berserkerBonus = Math.floor(missingHpPercent / 0.20) * 0.10;
                    finalDmg *= (1 + berserkerBonus);
                }
                
                // MOMENTUM STRIKE: Damage bonus based on time without taking damage
                if (this.hasMomentum) {
                    const momentumSeconds = this.momentumTimer / 60; // Convert frames to seconds
                    const momentumBonus = Math.min(0.40, momentumSeconds * 0.02); // 2% per second, max 40% at 20s
                    finalDmg *= (1 + momentumBonus);
                }
                
                // GLASS CANNON: +50% damage
                if (this.hasGlassCannon) {
                    finalDmg *= 1.50;
                }
                
                // BOSS FOCUS BONUS: When fighting a boss alone, weapons deal significantly more damage
                // This makes single-target weapons more viable against bosses without changing mob clear
                if (enemy.type === 'boss') {
                    const otherEnemiesCount = entities.enemies.filter(e => e.type !== 'boss' && e.hp > 0).length;
                    if (otherEnemiesCount === 0) {
                        // Boss is alone - apply weapon-specific boss damage bonuses
                        const bossBonuses = {
                            'ion': 1.4,        // Precision weapon
                            'turret': 1.4,     // Stationary weapon
                            'emp': 1.5,        // Control weapon with AOE
                            'barrier': 1.3,    // Contact weapon (requires close range)
                            'beam': 1.6,       // Sustained damage weapon (plus multi-beam bonus)
                            'seeker': 1.5,     // Homing weapon
                            'railgun': 1.8,    // Anti-armor weapon
                            'tesla': 1.3,      // Chain weapon (less effective solo)
                            'rad': 1.5,        // Aura weapon
                            'whip': 1.8,       // Melee-range weapon - HIGH RISK HIGH REWARD
                            'meteor': 1.2,     // AOE weapon (less effective solo)
                            'flak': 1.2,       // Shotgun weapon
                            'pylons': 1.4,     // Trap weapon
                            'mines': 1.5,      // Burst damage weapon
                            'gas': 1.6,        // DOT weapon
                            'ricochet': 1.3,   // Bouncing weapon (less effective solo)
                            'drones': 1.4      // Sustained DPS weapon
                        };
                        const bossBonus = bossBonuses[sourceId] || 1.3; // Default 30% bonus
                        finalDmg *= bossBonus;
                    }
                }
                
                if(allowCrit) {
                    isCrit = seededRandom() < this.critChance;
                    finalDmg = isCrit ? finalDmg * this.critMult : finalDmg;
                }


                // Apply damage with crit flag, sourceId for weapon coloring, and element type
                enemy.takeDamage(finalDmg, color, isCrit, type, sourceId, forceElement); 


                const augElement = forceElement || this.weaponAugments[sourceId]; // Use forced element or weapon augment
                if (!augElement) return; // No augment on this weapon


                // Base Chance 50% * Multiplier
                // CATALYST PASSIVE: +25% elemental proc chance
                let baseChance = 0.5;
                if (this.selectedShip === 'CATALYST') {
                    baseChance += 0.25; // 50% ‚Üí 75% base
                }
                const chance = baseChance * this.elementalMult;
                const isDirect = (sourceId !== 'mod'); // Prevent chaining from detonations


                if (isDirect && augElement === 'fire') { 
                    if (seededRandom() < chance) {
                        const baseDuration = 360;
                        const duration = this.elementalMasteries.fire ? baseDuration + 120 : baseDuration; // +2s with mastery
                        
                        if (!enemy.pyroState.active) {
                            // First application
                            enemy.pyroState.active = true;
                            enemy.pyroState.timer = duration;
                            enemy.pyroState.level = 1;
                            enemy.pyroState.baseDmg = this.damage * 0.4;
                            enemy.pyroState.sourceWeapon = sourceId; // Track which weapon caused this DOT
                        } else if (enemy.pyroState.level < 3) {
                            // Stack up to level 3
                            enemy.pyroState.level++;
                            enemy.pyroState.timer = duration; // Refresh duration
                            enemy.pyroState.baseDmg = this.damage * 0.4; // Update base damage
                            enemy.pyroState.sourceWeapon = sourceId; // Update source
                        } else {
                            // Already at max stacks, just refresh duration
                            enemy.pyroState.timer = duration;
                            enemy.pyroState.sourceWeapon = sourceId; // Update source
                        }
                        
                        // Track for CATALYST achievement
                        state.elementsProcced.add('fire');
                    }
                }
                // CRYO: Spreading Slow ‚Üí Freeze
                if (isDirect && augElement === 'ice' && !enemy.cryoState.frozen) {
                    if (seededRandom() < chance) {
                        // Apply 60% slow instantly
                        enemy.cryoState.slowed = true;
                        // Track for CATALYST achievement
                        state.elementsProcced.add('ice');
                        
                        // Chill aura radius (with mastery boost)
                        const auraRadius = this.elementalMasteries.ice ? 150 : 100;
                        
                        // Spread 30% slow to nearby enemies
                        entities.enemies.forEach(e => {
                            if (e !== enemy && e.hp > 0 && !e.cryoState.frozen) {
                                const dist = Math.sqrt((e.x - enemy.x)**2 + (e.y - enemy.y)**2);
                                if (dist < auraRadius) {
                                    e.cryoState.slowed = true;
                                }
                            }
                        });
                        
                        // Frozen Plague synergy: Freeze spreads bio to nearby enemies
                        if (player.synergies.cryo_bio && enemy.cryoState.slowed) {
                            const spreadRangeSq = 100 * 100;
                            entities.enemies.forEach(e => {
                                if (e === enemy || e.hp <= 0 || e.bioState.active) return;
                                
                                // Use squared distance for faster check
                                const dx = e.x - enemy.x;
                                const dy = e.y - enemy.y;
                                const distSq = dx*dx + dy*dy;
                                
                                if (distSq < spreadRangeSq) {
                                    e.bioState.active = true;
                                    e.bioState.timer = 300;
                                    e.bioState.level = 1;
                                    e.bioState.jumpCount = 0;
                                    e.bioState.maxDmg = this.damage * 0.5 * 4;
                                }
                            });
                        }
                    }
                }
                // Bio Spread (type check) bypasses chance, Initial Hit uses chance
                if (isDirect && augElement === 'bio') {
                    if (type === 'bio_spread' || seededRandom() < chance) {
                        if (!enemy.bioState.active) {
                            // First application
                            enemy.bioState.active = true;
                            enemy.bioState.timer = 300;
                            enemy.bioState.level = 1;
                            enemy.bioState.jumpCount = 0;
                            enemy.bioState.maxDmg = this.damage * 0.5 * 4;
                            enemy.bioState.sourceWeapon = sourceId;
                        } else if (enemy.bioState.level < 3) {
                            // Stack up to level 3
                            enemy.bioState.level++;
                            enemy.bioState.timer = 300; // Refresh duration
                            enemy.bioState.maxDmg = this.damage * 0.5 * 4; // Update damage
                            enemy.bioState.sourceWeapon = sourceId;
                        } else {
                            // Already at max stacks, just refresh duration
                            enemy.bioState.timer = 300;
                            enemy.bioState.sourceWeapon = sourceId;
                        }
                        // Track for CATALYST achievement
                        state.elementsProcced.add('bio');
                    }
                }
                if (isDirect && augElement === 'volt') {
                    if (seededRandom() < chance) {
                        this.chainVolt(enemy, finalDmg * 0.7, 0, 1, sourceId); // Pass sourceId for tracking
                        // Track for CATALYST achievement
                        state.elementsProcced.add('volt');
                        
                        // Pyroclasm: Burning enemies shocked deal AOE damage
                        if (player.synergies.pyro_volt && enemy.pyroState.active) {
                            createExplosion(enemy.x, enemy.y, '#ffaa00', 15);
                            // AOE damage equal to current burn tick
                            const enemyMaxHp = enemy.maxHp || enemy.hp || 100;
                            const burnDmg = enemyMaxHp * 0.015; // Approximate burn tick
                            entities.enemies.forEach(e => {
                                if (e !== enemy && e.hp > 0 && Math.sqrt((e.x-enemy.x)**2 + (e.y-enemy.y)**2) < 80) {
                                    e.takeDamage(burnDmg, '#ffaa00');
                                }
                            });
                        }
                    }
                    
                    // Pyroclasm: Chains apply 50% burn
                    if (player.synergies.pyro_volt && !enemy.pyroState.active && seededRandom() < 0.5) {
                        enemy.pyroState.active = true;
                        enemy.pyroState.timer = this.elementalMasteries.fire ? 480 : 360;
                        enemy.pyroState.level = 1;
                        enemy.pyroState.baseDmg = this.damage * 0.2; // 50% of normal pyro
                    }
                }
                // HACK: Tier-based system
                // Basic: Always hackable (drone, swarm, splitter)
                // Elite: Only with mastery (tank, voidwalker)
                // Boss: Never hackable
                const canHack = enemy.tier === 'basic' || 
                               (enemy.tier === 'elite' && this.elementalMasteries.hack);
                
                if (isDirect && augElement === 'hack' && canHack && !enemy.hackState.active) {
                    // Digital Inferno: Burning enemies 50% easier to hack
                    let hackChance = chance;
                    if (player.synergies.pyro_hack && enemy.pyroState.active) {
                        hackChance *= 1.5;
                    }
                    
                    // Cap hacked enemies at 10
                    const currentHackedCount = entities.enemies.filter(e => e.hackState.active).length;
                    if (currentHackedCount >= 10) {
                        // Don't hack if we're at the cap
                    } else if ((state.gameTime - enemy.lastHackTime > 5000) && seededRandom() < hackChance) {
                        // Determine duration based on enemy tier
                        let baseDuration = 300; // 5s base duration for basic
                        if (enemy.tier === 'elite') baseDuration = 150; // 2.5s for elite
                        
                        // Hack Override: +2s duration with mastery (basic only)
                        if (this.elementalMasteries.hack && enemy.tier === 'basic') {
                            baseDuration += 120; // +2s with mastery
                        }
                        
                        // If this damage would kill the enemy, save them temporarily
                        const wouldDie = enemy.hp - finalDmg <= 0;
                        if (wouldDie) {
                            enemy.hp = 1; // Set to 1 HP to prevent death
                            // Voidwalkers should detonate, not die after hack
                            const shouldDieAfter = enemy.type !== 'voidwalker';
                            enemy.hackState = { active: true, timer: baseDuration, diesAfter: shouldDieAfter }; // Mark to die after (unless voidwalker)
                        } else {
                            enemy.hackState = { active: true, timer: baseDuration, diesAfter: false };
                        }
                        enemy.lastHackTime = state.gameTime;
                        // Track for CATALYST achievement
                        state.elementsProcced.add('hack');
                        // Don't apply damage yet if it would kill
                        if (wouldDie) {
                            finalDmg = 0; // Nullify this damage
                        }
                    }
                }
            }



            chainVolt(target, dmg, depth, level, sourceWeapon = null) {
                // Performance safeguard: Limit chain calls per frame
                if (!this.voltChainsThisFrame) this.voltChainsThisFrame = 0;
                if (this.voltChainsThisFrame > 30) return; // Cap at 30 chains per frame to prevent hitching
                this.voltChainsThisFrame++;
                
                if(depth > 0) entities.particles.push(new Particle(target.x, target.y, '#ffeb3b', 1));
                
                // Volt Amplifier: +25% chain damage (moderate buff)
                let chainDmg = this.elementalMasteries.volt ? dmg * 1.25 : dmg;
                
                // Storm Surge: +100% damage to frozen enemies
                if (player.synergies.cryo_volt && target.cryoState.frozen) {
                    chainDmg *= 2;
                }
                
                if(depth > 0) {
                    target.takeDamage(chainDmg, '#ffeb3b', false, 'normal', sourceWeapon, 'volt');
                    
                    // Bioshock: Volt chains double bio tick rate for 2s
                    if (player.synergies.volt_bio && target.bioState.active) {
                        target.bioState.voltBuff = 120; // 2 seconds
                    }
                    
                    // Corrupted Circuitry: Volt chains have 25% chance to hack
                    // TIER CHECK: basic always, elite with mastery, boss never
                    if (player.synergies.volt_hack && !target.hackState.active && seededRandom() < 0.25) {
                        const canHackChain = target.tier === 'basic' || 
                                           (target.tier === 'elite' && this.elementalMasteries.hack);
                        
                        if (canHackChain) {
                            let hackDuration = 300; // 5s base duration for basic
                            if (target.tier === 'elite') hackDuration = 150; // 2.5s for elite
                            if (this.elementalMasteries.hack && target.tier === 'basic') hackDuration += 120; // +2s with mastery (basic only)
                            target.hackState = { active: true, timer: hackDuration, diesAfter: false };
                            target.lastHackTime = state.gameTime;
                        }
                    }
                }
                
                // Volt Amplifier: +1 max depth
                const maxDepth = this.elementalMasteries.volt ? 6 : 5;
                if (depth > maxDepth) return;
                
                // DIMINISHING CHAIN CHANCE - decreases with each hop
                let baseChance = 0.5 + (this.multicast * 0.1); // 50-60% base
                let depthPenalty = depth * 0.15; // -15% per chain depth
                let chance = Math.max(0.2, baseChance - depthPenalty); // Minimum 20% chance
                
                if (depth === 0) chance = 1.0; // First chain always succeeds
                
                // Chance decay example:
                // Depth 0: 100% (guaranteed)
                // Depth 1: 50-60% (base)
                // Depth 2: 35-45% (-15%)
                // Depth 3: 20-30% (-30%)
                // Depth 4+: 20% (floor)
                
                if (seededRandom() < chance) {
                    // Storm Surge: Prioritize frozen enemies
                    let neighbor;
                    if (player.synergies.cryo_volt) {
                        // First try to find frozen enemy
                        neighbor = entities.enemies.find(n => n !== target && n.hp > 0 && n.cryoState.frozen && Math.sqrt((n.x-target.x)**2 + (n.y-target.y)**2) < 150);
                    }
                    // Fallback to any enemy
                    if (!neighbor) {
                        neighbor = entities.enemies.find(n => n !== target && n.hp > 0 && Math.sqrt((n.x-target.x)**2 + (n.y-target.y)**2) < 150);
                    }
                    if (neighbor) {
                        entities.lightnings.push(new LightningBolt(target.x, target.y, neighbor.x, neighbor.y, '#ffeb3b'));
                        this.chainVolt(neighbor, dmg * 0.7, depth + 1, level, sourceWeapon); // Pass sourceWeapon through chain
                    }
                }
            }


            draw(ctx) {
                // WHIP VISUAL - Dramatic curved sweep with extreme momentum (SLOWED DOWN)
                if (this.weapons.whip > 0 && this.whipVisualTimer > 0) {
                    const range = (100 + (this.weapons.whip * 5)) * this.weaponStats.whip.area;
                    const arcAngle = Math.PI * 2; // Full 360 degrees
                    const centerAngle = this.whipVisualAngle;
                    const startAngle = centerAngle - arcAngle / 2;
                    
                    // Faster, snappier animation - complete in 20 frames instead of 30
                    const sweepProgress = 1 - (this.whipVisualTimer / 20);
                    
                    const alpha = Math.min(1, this.whipVisualTimer / 15); // Faster fade
                    
                    ctx.save();
                    ctx.translate(this.x, this.y);
                    
                    // Brightness ramps up during animation - starts dimmer, gets brighter
                    const brightnessRamp = 0.4 + (sweepProgress * 0.6); // 40% to 100%
                    
                    const segments = 16;
                    
                    // Pre-calculate all segment data
                    const segmentData = [];
                    for (let seg = 0; seg < segments; seg++) {
                        const segmentRatio = (seg + 1) / segments;
                        const segmentRange = range * (0.6 + segmentRatio * 0.4);
                        const lagAmount = Math.pow(segmentRatio, 3) * 0.5;
                        const segmentProgress = Math.max(0, Math.min(1, sweepProgress - lagAmount));
                        const currentAngle = startAngle + (arcAngle * segmentProgress);
                        const segmentAlpha = alpha * (0.3 + segmentRatio * 0.5) * brightnessRamp;
                        
                        segmentData.push({
                            angle: currentAngle,
                            range: segmentRange,
                            alpha: segmentAlpha,
                            ratio: segmentRatio,
                            seg: seg
                        });
                    }
                    
                    const bladeWidth = 0.35;
                    
                    // BATCH 1: Draw all outer glows in one pass
                    ctx.shadowBlur = 40;
                    ctx.shadowColor = '#ff00ff';
                    for (let data of segmentData) {
                        ctx.fillStyle = `rgba(255, 0, 255, ${data.alpha * 0.6})`;
                        ctx.beginPath();
                        ctx.moveTo(0, 0);
                        ctx.arc(0, 0, data.range, data.angle - bladeWidth, data.angle + bladeWidth);
                        ctx.closePath();
                        ctx.fill();
                    }
                    
                    // BATCH 2: Draw all inner cores in one pass
                    ctx.shadowBlur = 25;
                    ctx.shadowColor = '#ff88ff';
                    for (let data of segmentData) {
                        ctx.fillStyle = `rgba(255, 180, 255, ${data.alpha * 0.8})`;
                        ctx.beginPath();
                        ctx.moveTo(0, 0);
                        ctx.arc(0, 0, data.range * 0.95, data.angle - bladeWidth * 0.5, data.angle + bladeWidth * 0.5);
                        ctx.closePath();
                        ctx.fill();
                    }
                    
                    // BATCH 3: Draw edge lines (every other segment)
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = '#ff88ff';
                    ctx.lineWidth = 2;
                    ctx.lineCap = 'round';
                    for (let data of segmentData) {
                        if (data.seg % 2 === 0) {
                            ctx.strokeStyle = `rgba(255, 220, 255, ${data.alpha * 0.7})`;
                            ctx.beginPath();
                            ctx.moveTo(Math.cos(data.angle) * data.range * 0.5, Math.sin(data.angle) * data.range * 0.5);
                            ctx.lineTo(Math.cos(data.angle) * data.range, Math.sin(data.angle) * data.range);
                            ctx.stroke();
                        }
                    }
                    
                    ctx.shadowBlur = 0;
                    ctx.restore();
                }
                
                // PYLON RENDERING (OPTIMIZED)
                if (this.weapons.pylons > 0 && this.pylons.length > 0) {
                    const renderStartTime = performance.now();
                    
                    // Draw pylons - simplified but still distinctive
                    this.pylons.forEach((pylon, idx) => {
                        ctx.save();
                        ctx.translate(pylon.x, pylon.y);
                        
                        // Pulsing glow effect (single calculation for whole pylon)
                        const pulsePhase = state.frameCount * 0.05 + idx;
                        const pulseIntensity = 0.6 + Math.sin(pulsePhase) * 0.4;
                        
                        // Single radial gradient for efficient glow
                        const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, 15);
                        gradient.addColorStop(0, '#ff99ff');
                        gradient.addColorStop(0.5, '#cc44cc');
                        gradient.addColorStop(1, 'rgba(204, 68, 204, 0)');
                        
                        ctx.fillStyle = gradient;
                        ctx.beginPath();
                        ctx.arc(0, 0, 15, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Core - simple bright circle
                        ctx.fillStyle = `rgba(255, 200, 255, ${pulseIntensity})`;
                        ctx.beginPath();
                        ctx.arc(0, 0, 6, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Inner core
                        ctx.fillStyle = '#ffffff';
                        ctx.beginPath();
                        ctx.arc(0, 0, 3, 0, Math.PI * 2);
                        ctx.fill();
                        
                        ctx.restore();
                    });
                    
                    const beamRenderStart = performance.now();
                    
                    // Draw energy beams between pylons - SINGLE PASS, NO SHADOWS
                    if (this.pylons.length >= 2) {
                        const frameTime = state.frameCount;
                        const areaScale = this.weaponStats.pylons.area;
                        
                        // Cache pylon pairs for rendering if not already done
                        if (!this.cachedPylonPairs || this.pylons.length !== this.lastPylonCount) {
                            this.cachedPylonPairs = [];
                            for (let i = 0; i < this.pylons.length; i++) {
                                for (let j = i + 1; j < this.pylons.length; j++) {
                                    this.cachedPylonPairs.push({ i, j });
                                }
                            }
                            this.lastPylonCount = this.pylons.length;
                        }
                        
                        ctx.lineCap = 'round';
                        
                        // Single beam pass with animated pulse - inspired by rad field ripples
                        for (let pair of this.cachedPylonPairs) {
                            const p1 = this.pylons[pair.i];
                            const p2 = this.pylons[pair.j];
                            
                            // Animated pulse intensity (keeps visual interest without multiple passes)
                            const pulseFactor = 0.5 + Math.sin(frameTime * 0.08 + pair.i * 2 + pair.j * 3) * 0.3;
                            const baseAlpha = 0.5 + pulseFactor * 0.3;
                            
                            // Draw beam with gradient for depth
                            const dx = p2.x - p1.x;
                            const dy = p2.y - p1.y;
                            const midX = (p1.x + p2.x) / 2;
                            const midY = (p1.y + p2.y) / 2;
                            
                            // Create linear gradient along the beam
                            const gradient = ctx.createLinearGradient(p1.x, p1.y, p2.x, p2.y);
                            gradient.addColorStop(0, `rgba(255, 100, 255, ${baseAlpha * 0.6})`);
                            gradient.addColorStop(0.5, `rgba(255, 100, 255, ${baseAlpha})`);
                            gradient.addColorStop(1, `rgba(255, 100, 255, ${baseAlpha * 0.6})`);
                            
                            ctx.strokeStyle = gradient;
                            ctx.lineWidth = 5 * areaScale;
                            ctx.beginPath();
                            ctx.moveTo(p1.x, p1.y);
                            ctx.lineTo(p2.x, p2.y);
                            ctx.stroke();
                            
                            // Add energy sparks traveling along beam (every 3rd frame, limited count)
                            if (state.frameCount % 3 === 0 && pair.i === 0) { // Only draw for first pair to limit count
                                const beamLength = Math.sqrt(dx * dx + dy * dy);
                                const sparkProgress = ((frameTime * 4) % beamLength) / beamLength;
                                const sparkX = p1.x + dx * sparkProgress;
                                const sparkY = p1.y + dy * sparkProgress;
                                
                                ctx.fillStyle = `rgba(255, 200, 255, ${0.8 * pulseFactor})`;
                                ctx.beginPath();
                                ctx.arc(sparkX, sparkY, 4 * areaScale, 0, Math.PI * 2);
                                ctx.fill();
                            }
                        }
                    }
                    
                    const renderTotalTime = performance.now() - renderStartTime;
                    const beamRenderTime = performance.now() - beamRenderStart;
                    
                    // Track peak render time
                    if (!this.pylonsRenderPeakTime) this.pylonsRenderPeakTime = 0;
                    if (renderTotalTime > this.pylonsRenderPeakTime) {
                        this.pylonsRenderPeakTime = renderTotalTime;
                        if (renderTotalTime > 2) { // Log if over 2ms (lowered threshold)
                            console.warn(`‚ö†Ô∏è PYLONS SLOW RENDER: ${renderTotalTime.toFixed(2)}ms (peak) | Beams: ${beamRenderTime.toFixed(2)}ms | Pylons: ${this.pylons.length} | Pairs: ${this.cachedPylonPairs?.length || 0}`);
                        }
                    }
                    
                    // Periodic performance summary
                    if (!this.pylonsRenderLogFrame) this.pylonsRenderLogFrame = 0;
                    this.pylonsRenderLogFrame++;
                    if (this.pylonsRenderLogFrame >= 300) { // Every 300 frames (~5 seconds at 60fps)
                        this.pylonsRenderLogFrame = 0;
                        this.pylonsRenderPeakTime = 0; // Reset peak after logging
                    }
                }
                
                // Rad-Field Visual (Pulse Cloud)
                if (this.weapons.rad > 0) {
                     const radius = (60 + (this.weapons.rad * 15)) * this.weaponStats.rad.area;
                     ctx.save();
                     ctx.translate(this.x, this.y);
                     
                     // Create 3 concentric ripples that pulse outward
                     const numRipples = 3;
                     for (let i = 0; i < numRipples; i++) {
                         const phase = (state.frameCount * 0.03 + i * (Math.PI * 2 / numRipples)) % (Math.PI * 2);
                         const rippleRadius = radius * (0.3 + (phase / (Math.PI * 2)) * 0.7);
                         const alpha = 0.3 * (1 - (phase / (Math.PI * 2)));
                         
                         ctx.strokeStyle = `rgba(57, 255, 20, ${alpha})`;
                         ctx.lineWidth = 3 + Math.sin(phase) * 2;
                         ctx.shadowColor = 'rgba(57, 255, 20, 0.6)';
                         ctx.shadowBlur = 20;
                         ctx.beginPath();
                         ctx.arc(0, 0, rippleRadius, 0, Math.PI * 2);
                         ctx.stroke();
                     }
                     
                     ctx.restore();
                }
                
                // KINETIC BARRIER VISUAL (Vanguard weapon) - FRONTAL PLOW CONE
                if (this.weapons.barrier > 0 && this.barrierRadius) {
                    ctx.save();
                    ctx.translate(this.x, this.y);
                    ctx.rotate(this.angle);
                    
                    const radius = this.barrierRadius;
                    const coneAngle = this.barrierConeAngle || (100 * Math.PI / 180); // 100 degrees (reduced from 120)
                    const halfCone = coneAngle / 2;
                    
                    // Speed-based color shift
                    const currentSpeed = Math.sqrt(this.vx**2 + this.vy**2);
                    const maxSpeed = this.speed * this.shipSpeedMult;
                    const speedRatio = Math.min(1.0, currentSpeed / maxSpeed);
                    
                    // Color interpolation: Blue (slow) ‚Üí Cyan (medium) ‚Üí White (fast)
                    const r = Math.floor(100 + (speedRatio * 80));
                    const g = Math.floor(130 + (speedRatio * 90));
                    const b = Math.floor(180 + (speedRatio * 60));
                    
                    // MINIMAL FILL - just slight tint to show the area
                    const segments = 16; // Smooth curve
                    ctx.beginPath();
                    ctx.moveTo(0, 0); // Center point (ship)
                    
                    // Draw arc from -60¬∞ to +60¬∞ (120¬∞ total)
                    for (let i = 0; i <= segments; i++) {
                        const angle = -halfCone + (coneAngle / segments) * i;
                        const x = Math.cos(angle) * radius;
                        const y = Math.sin(angle) * radius;
                        ctx.lineTo(x, y);
                    }
                    
                    ctx.closePath();
                    
                    // Very subtle fill - just barely visible
                    ctx.fillStyle = `rgba(${r}, ${g}, ${b}, 0.08)`;
                    ctx.fill();
                    
                    // BRIGHT EDGE OUTLINE ONLY - this is the main visual
                    // Front arc edge (the plow blade)
                    ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, ${0.7 + (speedRatio * 0.3)})`; // 0.7 to 1.0 opacity
                    ctx.lineWidth = 4 + (speedRatio * 3); // Thicker at speed
                    ctx.shadowBlur = 15 + (speedRatio * 15); // Strong glow
                    ctx.shadowColor = `rgba(${r}, ${g}, ${b}, ${0.8})`;
                    
                    ctx.beginPath();
                    for (let i = 0; i <= segments; i++) {
                        const angle = -halfCone + (coneAngle / segments) * i;
                        const x = Math.cos(angle) * radius;
                        const y = Math.sin(angle) * radius;
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.stroke();
                    
                    // Side edges (plow blades) - slightly dimmer
                    ctx.lineWidth = 3 + (speedRatio * 2);
                    ctx.shadowBlur = 10 + (speedRatio * 10);
                    ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, ${0.5 + (speedRatio * 0.3)})`;
                    
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(Math.cos(-halfCone) * radius, Math.sin(-halfCone) * radius);
                    ctx.stroke();
                    
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(Math.cos(halfCone) * radius, Math.sin(halfCone) * radius);
                    ctx.stroke();
                    
                    // Front tip markers (only at high speed for direction feedback)
                    if (speedRatio > 0.4) {
                        ctx.fillStyle = `rgba(${r + 50}, ${g + 50}, ${b + 50}, ${speedRatio * 0.9})`;
                        ctx.shadowBlur = 12;
                        
                        // Three markers along the front arc
                        const tipDistance = radius * 0.85;
                        for (let i = -1; i <= 1; i++) {
                            const markerAngle = i * (coneAngle / 4);
                            const mx = Math.cos(markerAngle) * tipDistance;
                            const my = Math.sin(markerAngle) * tipDistance;
                            
                            ctx.beginPath();
                            ctx.arc(mx, my, 3, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    }
                    
                    ctx.shadowBlur = 0;
                    ctx.restore();
                }
                
                // ORBITAL BLADESTORM VISUAL (Reaper weapon) - Red sawblade with spiral
                if (this.weapons.orbital > 0 && this.orbitalRadius) {
                    ctx.save();
                    
                    const outerRadius = this.orbitalRadius;
                    const innerRadius = this.orbitalInnerRadius || 35; // FIXED inner radius (moved from 25 to 35)
                    const numBlades = this.orbitalBladeCount || 5;
                    const angle = this.orbitalAngle || 0;
                    const bladeLength = this.orbitalBladeLength || 30;
                    
                    for (let i = 0; i < numBlades; i++) {
                        const bladeAngle = angle + (Math.PI * 2 / numBlades) * i;
                        
                        // Blade orbits at FIXED inner radius - blade extends OUTWARD from here
                        const orbitRadius = innerRadius; // Fixed - blades grow longer, not move away
                        const bladeX = this.x + Math.cos(bladeAngle) * orbitRadius;
                        const bladeY = this.y + Math.sin(bladeAngle) * orbitRadius;
                        
                        // MIRRORED blade - wide end OUTWARD, tip INWARD
                        const bladeWidth = 14; // Width at outer end
                        
                        // MORE EXTREME SPIRAL ANGLE - 35 degrees outward
                        const spiralAngle = 0.61; // ~35 degrees in radians
                        const rotationDirection = bladeAngle + Math.PI / 2 + spiralAngle;
                        const radialDirection = bladeAngle;
                        
                        // MIRRORED triangle vertices - tip points INWARD (toward ship)
                        const tipX = bladeX - Math.cos(rotationDirection) * bladeLength; // INWARD
                        const tipY = bladeY - Math.sin(rotationDirection) * bladeLength;
                        
                        // Wide base at OUTER edge
                        const base1X = bladeX + Math.cos(radialDirection) * bladeWidth / 2;
                        const base1Y = bladeY + Math.sin(radialDirection) * bladeWidth / 2;
                        const base2X = bladeX - Math.cos(radialDirection) * bladeWidth / 2;
                        const base2Y = bladeY - Math.sin(radialDirection) * bladeWidth / 2;
                        
                        // RED TRAIL - more prominent
                        const trailDirection = rotationDirection + Math.PI;
                        
                        for (let t = 0; t < 5; t++) {
                            const trailFade = (1 - t / 5);
                            const trailAlpha = 0.5 * trailFade;
                            const trailScale = 0.4 + trailFade * 0.6;
                            
                            const trailCenterX = bladeX + Math.cos(trailDirection) * (t + 1) * 8;
                            const trailCenterY = bladeY + Math.sin(trailDirection) * (t + 1) * 8;
                            
                            // Mirrored trail triangles
                            const tTipX = trailCenterX - Math.cos(rotationDirection) * bladeLength * trailScale;
                            const tTipY = trailCenterY - Math.sin(rotationDirection) * bladeLength * trailScale;
                            const tBase1X = trailCenterX + Math.cos(radialDirection) * bladeWidth / 2 * trailScale;
                            const tBase1Y = trailCenterY + Math.sin(radialDirection) * bladeWidth / 2 * trailScale;
                            const tBase2X = trailCenterX - Math.cos(radialDirection) * bladeWidth / 2 * trailScale;
                            const tBase2Y = trailCenterY - Math.sin(radialDirection) * bladeWidth / 2 * trailScale;
                            
                            // Alternate red and gold
                            const isRed = t % 2 === 0;
                            ctx.fillStyle = isRed ? `rgba(255, 51, 51, ${trailAlpha})` : `rgba(255, 204, 0, ${trailAlpha})`;
                            ctx.shadowBlur = 15;
                            ctx.shadowColor = isRed ? `rgba(255, 51, 51, ${trailAlpha})` : `rgba(255, 204, 0, ${trailAlpha})`;
                            
                            ctx.beginPath();
                            ctx.moveTo(tTipX, tTipY);
                            ctx.lineTo(tBase1X, tBase1Y);
                            ctx.lineTo(tBase2X, tBase2Y);
                            ctx.closePath();
                            ctx.fill();
                        }
                        
                        // DARK RED BASE
                        ctx.fillStyle = '#cc0000';
                        ctx.shadowBlur = 20;
                        ctx.shadowColor = '#ff0000';
                        ctx.beginPath();
                        ctx.moveTo(tipX, tipY);
                        ctx.lineTo(base1X, base1Y);
                        ctx.lineTo(base2X, base2Y);
                        ctx.closePath();
                        ctx.fill();
                        
                        // BRIGHT RED CORE - smaller inner triangle
                        const innerScale = 0.7;
                        const iTipX = bladeX - Math.cos(rotationDirection) * bladeLength * innerScale;
                        const iTipY = bladeY - Math.sin(rotationDirection) * bladeLength * innerScale;
                        const iBase1X = bladeX + Math.cos(radialDirection) * bladeWidth / 2 * innerScale;
                        const iBase1Y = bladeY + Math.sin(radialDirection) * bladeWidth / 2 * innerScale;
                        const iBase2X = bladeX - Math.cos(radialDirection) * bladeWidth / 2 * innerScale;
                        const iBase2Y = bladeY - Math.sin(radialDirection) * bladeWidth / 2 * innerScale;
                        
                        ctx.fillStyle = '#ff3333';
                        ctx.shadowBlur = 30;
                        ctx.shadowColor = '#ff3333';
                        ctx.beginPath();
                        ctx.moveTo(iTipX, iTipY);
                        ctx.lineTo(iBase1X, iBase1Y);
                        ctx.lineTo(iBase2X, iBase2Y);
                        ctx.closePath();
                        ctx.fill();
                        
                        // GOLD EDGE accent
                        ctx.strokeStyle = '#ffcc00';
                        ctx.lineWidth = 2;
                        ctx.shadowBlur = 25;
                        ctx.shadowColor = '#ffcc00';
                        ctx.beginPath();
                        ctx.moveTo(tipX, tipY);
                        ctx.lineTo(base1X, base1Y);
                        ctx.lineTo(base2X, base2Y);
                        ctx.closePath();
                        ctx.stroke();
                    }
                    
                    ctx.shadowBlur = 0;
                    ctx.restore();
                }


                ctx.save(); ctx.translate(this.x, this.y);
                if (this.invulnTimer > 0 && Math.floor(Date.now() / 66) % 2 === 0) {
                    ctx.restore(); // Clean up before returning
                    return; // Flicker every ~66ms
                }
                
                // BERSERKER MODULE VISUAL - Red aura that intensifies as HP drops
                if (this.hasBerserker) {
                    const hpPercent = this.hp / this.maxHp;
                    const missingPercent = 1.0 - hpPercent;
                    
                    // Only show visual when at least 20% HP is missing
                    if (missingPercent >= 0.20) {
                        const pulsePhase = state.frameCount * 0.08;
                        const auraRadius = 50;
                        
                        // Intensity scales with missing HP (0.20 missing = 0.4 alpha, 0.80 missing = 0.8 alpha)
                        const intensityBase = missingPercent * 0.8; // 0.16 to 0.8
                        
                        // Outer pulsing red ring - more intense at lower HP
                        const pulseAlpha = intensityBase + Math.sin(pulsePhase) * 0.2;
                        ctx.strokeStyle = `rgba(255, 50, 50, ${pulseAlpha})`;
                        ctx.lineWidth = 3;
                        ctx.shadowBlur = 15 * (1 + missingPercent); // Stronger glow at low HP
                        ctx.shadowColor = '#ff0000';
                        ctx.beginPath();
                        ctx.arc(0, 0, auraRadius, 0, Math.PI * 2);
                        ctx.stroke();
                        
                        // Inner rage glow - scales with missing HP
                        const rageGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, auraRadius);
                        rageGradient.addColorStop(0, `rgba(255, 0, 0, ${intensityBase * 0.3})`);
                        rageGradient.addColorStop(0.6, `rgba(255, 50, 0, ${intensityBase * 0.15})`);
                        rageGradient.addColorStop(1, 'rgba(255, 0, 0, 0)');
                        ctx.fillStyle = rageGradient;
                        ctx.beginPath();
                        ctx.arc(0, 0, auraRadius, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Rage pulse rings - faster and more intense at low HP
                        const ringCount = Math.floor(missingPercent * 3) + 1; // 1-3 rings
                        for (let i = 0; i < ringCount; i++) {
                            const ringProgress = ((pulsePhase * (1 + missingPercent) + i * 0.4) % 1);
                            const ringRadius = auraRadius * (0.3 + ringProgress * 0.7);
                            const ringAlpha = (1 - ringProgress) * intensityBase;
                            ctx.strokeStyle = `rgba(255, 80, 80, ${ringAlpha})`;
                            ctx.lineWidth = 2;
                            ctx.beginPath();
                            ctx.arc(0, 0, ringRadius, 0, Math.PI * 2);
                            ctx.stroke();
                        }
                        
                        ctx.shadowBlur = 0;
                    }
                }
                
                // PHOENIX PROTOCOL VISUAL - Intense solar glow during channeling
                if (this.phoenixLocked) {
                    const pulsePhase = state.frameCount * 0.12;
                    const pulse = Math.sin(pulsePhase) * 0.3 + 0.7; // Oscillate between 0.7 and 1.0
                    
                    // Outer solar corona (expanding rings)
                    for (let ring = 0; ring < 4; ring++) {
                        const ringPhase = (pulsePhase + ring * 0.5) % (Math.PI * 2);
                        const ringRadius = 60 + ring * 20 + Math.sin(ringPhase) * 15;
                        const ringAlpha = (0.6 - ring * 0.1) * pulse;
                        
                        ctx.strokeStyle = `rgba(255, ${200 - ring * 30}, 0, ${ringAlpha})`;
                        ctx.lineWidth = 4 - ring;
                        ctx.shadowBlur = 25;
                        ctx.shadowColor = '#ff6600';
                        ctx.beginPath();
                        ctx.arc(0, 0, ringRadius, 0, Math.PI * 2);
                        ctx.stroke();
                    }
                    
                    // Intense inner glow (solar core)
                    const coreRadius = 70;
                    const phoenixGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, coreRadius);
                    phoenixGradient.addColorStop(0, `rgba(255, 255, 200, ${0.8 * pulse})`);
                    phoenixGradient.addColorStop(0.3, `rgba(255, 180, 50, ${0.5 * pulse})`);
                    phoenixGradient.addColorStop(0.6, `rgba(255, 100, 0, ${0.3 * pulse})`);
                    phoenixGradient.addColorStop(1, 'rgba(200, 50, 0, 0)');
                    
                    ctx.fillStyle = phoenixGradient;
                    ctx.shadowBlur = 40;
                    ctx.shadowColor = '#ffaa00';
                    ctx.beginPath();
                    ctx.arc(0, 0, coreRadius, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Solar flares (rotating energy spikes)
                    for (let i = 0; i < 8; i++) {
                        const flareAngle = (i / 8) * Math.PI * 2 + pulsePhase * 0.5;
                        const flareLength = 30 + Math.sin(pulsePhase * 2 + i) * 10;
                        const flareX = Math.cos(flareAngle) * 40;
                        const flareY = Math.sin(flareAngle) * 40;
                        const flareEndX = Math.cos(flareAngle) * (40 + flareLength);
                        const flareEndY = Math.sin(flareAngle) * (40 + flareLength);
                        
                        ctx.strokeStyle = `rgba(255, 200, 50, ${0.7 * pulse})`;
                        ctx.lineWidth = 3;
                        ctx.shadowBlur = 15;
                        ctx.shadowColor = '#ff8800';
                        ctx.beginPath();
                        ctx.moveTo(flareX, flareY);
                        ctx.lineTo(flareEndX, flareEndY);
                        ctx.stroke();
                    }
                    
                    ctx.shadowBlur = 0;
                }
                
                // REPULSOR FIELD VISUAL - Draw before everything else
                if (this.activeMod === 'repulsor') {
                    const pulsePhase = state.frameCount * 0.05;
                    const fieldRadius = 150;
                    
                    // Multiple expanding wave rings
                    for (let i = 0; i < 3; i++) {
                        const waveProgress = ((pulsePhase * 0.5 + i * 0.33) % 1);
                        const waveRadius = fieldRadius * (0.5 + waveProgress * 0.5);
                        const waveAlpha = (1 - waveProgress) * 0.25;
                        ctx.strokeStyle = `rgba(0, 255, 255, ${waveAlpha})`;
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.arc(0, 0, waveRadius, 0, Math.PI * 2);
                        ctx.stroke();
                    }
                    
                    // Inner glow gradient
                    const fieldGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, fieldRadius);
                    fieldGradient.addColorStop(0, 'rgba(0, 229, 255, 0)');
                    fieldGradient.addColorStop(0.7, 'rgba(0, 229, 255, 0.02)');
                    fieldGradient.addColorStop(1, 'rgba(0, 229, 255, 0.08)');
                    ctx.fillStyle = fieldGradient;
                    ctx.beginPath();
                    ctx.arc(0, 0, fieldRadius, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                if(this.weapons.ion > 0) {
                    const cannonVisualCount = Math.min(4, this.weapons.ion);
                    for(let i = 0; i < cannonVisualCount; i++) {
                        const formationRadius = 24; 
                        const offsetAngle = this.cannonAngle + (i * (Math.PI*2/cannonVisualCount));
                        const c = this.cannons[i] || {recoil: 0};
                        const cx = Math.cos(offsetAngle) * (formationRadius - c.recoil); 
                        const cy = Math.sin(offsetAngle) * (formationRadius - c.recoil);
                        ctx.fillStyle = '#0ff'; ctx.shadowBlur = 8; ctx.shadowColor = '#0ff';
                        ctx.beginPath(); ctx.arc(cx, cy, 4, 0, Math.PI*2); ctx.fill(); ctx.shadowBlur = 0;
                    }
                }
                

                // COMBAT DRONES - Draw at their actual positions (not orbiting)
                if (this.weapons.drones > 0 && this.drones && this.drones.length > 0) {
                    this.drones.forEach((drone, idx) => {
                        ctx.save();
                        // Drones are at absolute positions, need to translate relative to player
                        ctx.translate(drone.x - this.x, drone.y - this.y);
                        
                        // Drone facing direction (toward velocity or target)
                        let droneAngle = 0;
                        if (drone.target) {
                            droneAngle = Math.atan2(drone.target.y - drone.y, drone.target.x - drone.x);
                        } else if (Math.abs(drone.vx) > 0.1 || Math.abs(drone.vy) > 0.1) {
                            droneAngle = Math.atan2(drone.vy, drone.vx);
                        }
                        ctx.rotate(droneAngle);
                        
                        // Pulsing glow intensity
                        const glowPulse = 0.7 + Math.sin(state.frameCount * 0.15 + idx * 2) * 0.3;
                        
                        ctx.shadowBlur = 15 * glowPulse;
                        ctx.shadowColor = '#00aaff';
                        
                        // Drone body (simple clean triangle)
                        ctx.fillStyle = '#003366';
                        ctx.strokeStyle = '#00aaff';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(10, 0);   // Front point (larger for visibility)
                        ctx.lineTo(-6, -6);  // Back left
                        ctx.lineTo(-4, 0);   // Back center indent
                        ctx.lineTo(-6, 6);   // Back right
                        ctx.closePath();
                        ctx.fill();
                        ctx.stroke();
                        
                        // Bright core light (pulsing)
                        ctx.fillStyle = `rgba(0, 221, 255, ${glowPulse})`;
                        ctx.shadowBlur = 12 * glowPulse;
                        ctx.shadowColor = '#00ddff';
                        ctx.beginPath();
                        ctx.arc(0, 0, 3, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Enhanced engine glow when moving
                        const isMoving = Math.abs(drone.vx) > 0.5 || Math.abs(drone.vy) > 0.5;
                        if (isMoving) {
                            const enginePulse = 0.6 + Math.sin(state.frameCount * 0.4 + idx) * 0.4;
                            ctx.fillStyle = `rgba(0, 170, 255, ${enginePulse * 0.6})`;
                            ctx.shadowBlur = 15;
                            ctx.shadowColor = '#00aaff';
                            ctx.beginPath();
                            ctx.arc(-5, 0, 5, 0, Math.PI * 2);
                            ctx.fill();
                        }
                        
                        // Spotting ring - subtle pulsing
                        const ringPulse = 0.5 + Math.sin(state.frameCount * 0.1 + idx) * 0.2;
                        ctx.strokeStyle = `rgba(0, 170, 255, ${ringPulse})`;
                        ctx.lineWidth = 2;
                        ctx.shadowBlur = 10;
                        ctx.beginPath();
                        ctx.arc(0, 0, 14, 0, Math.PI * 2);
                        ctx.stroke();
                        
                        ctx.shadowBlur = 0;
                        ctx.restore();
                    });
                }
                
                // DRAW TURRETS (if Engineer)
                if (this.turrets && this.turrets.length > 0) {
                    this.turrets.forEach(turret => {
                        ctx.save();
                        ctx.translate(turret.x - this.x, turret.y - this.y); // Relative to player
                        
                        // Spawn animation - pulsing glow and scale
                        let spawnScale = 1;
                        let spawnAlpha = 1;
                        if (turret.spawnAnimation > 0) {
                            const progress = 1 - (turret.spawnAnimation / 30);
                            spawnScale = 0.5 + progress * 0.5; // Scale from 50% to 100%
                            spawnAlpha = progress; // Fade in
                            
                            // Pulsing spawn glow
                            const pulseAlpha = Math.sin(turret.spawnAnimation * 0.3) * 0.5 + 0.5;
                            ctx.fillStyle = `rgba(255, 136, 0, ${pulseAlpha * spawnAlpha * 0.3})`;
                            ctx.shadowBlur = 20;
                            ctx.shadowColor = '#ff8800';
                            ctx.beginPath();
                            ctx.arc(0, 0, 20, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.shadowBlur = 0;
                        }
                        
                        // Apply spawn scale
                        ctx.scale(spawnScale, spawnScale);
                        ctx.globalAlpha = spawnAlpha;
                        
                        // Visible range indicator - soft gradient glow (no hard ring) - only when active
                        if (turret.spawnAnimation <= 0) {
                            const rangeAlpha = 0.12 + Math.sin(state.frameCount * 0.03) * 0.04; // Gentle pulse
                            const gradient = ctx.createRadialGradient(0, 0, turret.range * 0.7, 0, 0, turret.range);
                            gradient.addColorStop(0, 'rgba(255, 136, 0, 0)'); // Transparent center
                            gradient.addColorStop(0.7, `rgba(255, 136, 0, ${rangeAlpha * 0.15})`); // Very faint middle
                            gradient.addColorStop(0.9, `rgba(255, 136, 0, ${rangeAlpha})`); // Visible edge
                            gradient.addColorStop(1, 'rgba(255, 136, 0, 0)'); // Fade out at edge
                            ctx.fillStyle = gradient;
                            ctx.beginPath();
                            ctx.arc(0, 0, turret.range, 0, Math.PI * 2);
                            ctx.fill();
                        }
                        
                        // Hexagonal base (smaller - reduced from 8 to 6)
                        const baseSize = 6;
                        ctx.fillStyle = '#4a2511';
                        ctx.strokeStyle = '#ff8800';
                        ctx.lineWidth = 2;
                        ctx.shadowBlur = 10;
                        ctx.shadowColor = '#ff8800';
                        ctx.beginPath();
                        for (let i = 0; i < 6; i++) {
                            const angle = (Math.PI / 3) * i;
                            const x = Math.cos(angle) * baseSize;
                            const y = Math.sin(angle) * baseSize;
                            if (i === 0) ctx.moveTo(x, y);
                            else ctx.lineTo(x, y);
                        }
                        ctx.closePath();
                        ctx.fill();
                        ctx.stroke();
                        
                        // Rotating barrel
                        const barrelAngle = state.frameCount * 0.1;
                        ctx.rotate(barrelAngle);
                        ctx.fillStyle = '#ff8800';
                        ctx.fillRect(-2, -1, baseSize, 2);
                        
                        ctx.shadowBlur = 0;
                        ctx.globalAlpha = 1;
                        ctx.restore();
                    });
                }
                
                // DRAW EMP FIELDS (if Disruptor)
                if (this.empFields && this.empFields.length > 0) {
                    this.empFields.forEach(field => {
                        ctx.save();
                        ctx.translate(field.x - this.x, field.y - this.y); // Relative to player
                        
                        const alpha = field.life / 150;
                        const pulse = 0.7 + Math.sin(state.frameCount * 0.1) * 0.3;
                        const time = state.frameCount * 0.05;
                        
                        // Multiple expanding rings for depth
                        for (let i = 0; i < 3; i++) {
                            const ringPhase = (time + i * 0.3) % 1;
                            const ringRadius = field.radius * (0.4 + ringPhase * 0.6);
                            const ringAlpha = alpha * (1 - ringPhase) * 0.4;
                            
                            ctx.strokeStyle = `rgba(168, 85, 247, ${ringAlpha})`;
                            ctx.lineWidth = 2;
                            ctx.shadowBlur = 10;
                            ctx.shadowColor = '#a855f7';
                            ctx.beginPath();
                            ctx.arc(0, 0, ringRadius, 0, Math.PI * 2);
                            ctx.stroke();
                        }
                        
                        // Inner radial gradient glow with more intensity variation
                        const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, field.radius);
                        gradient.addColorStop(0, `rgba(192, 132, 252, ${alpha * 0.4 * pulse})`);
                        gradient.addColorStop(0.3, `rgba(168, 85, 247, ${alpha * 0.25 * pulse})`);
                        gradient.addColorStop(0.6, `rgba(168, 85, 247, ${alpha * 0.1})`);
                        gradient.addColorStop(1, 'rgba(168, 85, 247, 0)');
                        ctx.fillStyle = gradient;
                        ctx.beginPath();
                        ctx.arc(0, 0, field.radius, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Central core pulse
                        ctx.fillStyle = `rgba(192, 132, 252, ${alpha * pulse * 0.6})`;
                        ctx.shadowBlur = 25;
                        ctx.shadowColor = '#a855f7';
                        ctx.beginPath();
                        ctx.arc(0, 0, 8 * pulse, 0, Math.PI * 2);
                        ctx.fill();
                        
                        ctx.shadowBlur = 0;
                        ctx.restore();
                    });
                }
                
                // DRAW SURGE AURA (if CATALYST and aura is active) - PERFORMANCE OPTIMIZED
                if (this.selectedShip === 'CATALYST' && this.surgeAuraTimer > 0 && this.surgeAuraElement) {
                    const elementColors = {
                        fire: '#ff5722',
                        ice: '#00e5ff',
                        volt: '#ffeb3b',
                        bio: '#39ff14'
                    };
                    
                    // Performance mode detection
                    const perfMode = typeof state !== 'undefined' && state.performanceMode ? state.performanceMode : 'normal';
                    const useShadows = perfMode === 'normal';
                    
                    const auraColor = elementColors[this.surgeAuraElement];
                    const alpha = this.surgeAuraTimer / 60; // Fade out over 1 second
                    const time = Date.now() * 0.001;
                    const auraRadius = 120;
                    
                    // Simple pulsing glow instead of complex spirals (prevents flickering during slowdown)
                    const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, auraRadius * 0.8);
                    const rgb = auraColor.match(/\w\w/g).map(x => parseInt(x, 16));
                    const pulseAlpha = alpha * (0.2 + Math.sin(time * 3) * 0.1);
                    gradient.addColorStop(0, `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${pulseAlpha})`);
                    gradient.addColorStop(0.5, `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${pulseAlpha * 0.5})`);
                    gradient.addColorStop(1, `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, 0)`);
                    ctx.fillStyle = gradient;
                    ctx.globalAlpha = 1;
                    ctx.beginPath();
                    ctx.arc(0, 0, auraRadius * 0.8, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.globalAlpha = 1.0;
                    if (useShadows) ctx.shadowBlur = 0;
                }
                
                // SHIELD GLOW INDICATOR - Visible soft glow when at least one shield is up
                // Shield glow - only show when at least 1 shield is FULL (100%) AND not Reaper
                const hasFullShield = (this.shield1 >= 100 || this.shield2 >= 100 || this.shield3 >= 100 || (this.shield4 && this.shield4 >= 100)) && this.selectedShip !== 'REAPER';
                if (hasFullShield) {
                    const pulseIntensity = 0.7 + Math.sin(Date.now() * 0.0016) * 0.3; // Use time instead of frameCount
                    const glowRadius = 28;
                    
                    // Brighter radial glow - visible but soft, no hard edges
                    const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, glowRadius);
                    gradient.addColorStop(0, `rgba(0, 255, 245, ${0.3 * pulseIntensity})`); // Brighter cyan at center
                    gradient.addColorStop(0.4, `rgba(0, 209, 178, ${0.25 * pulseIntensity})`); 
                    gradient.addColorStop(0.7, `rgba(0, 209, 178, ${0.15 * pulseIntensity})`);
                    gradient.addColorStop(1, 'rgba(0, 209, 178, 0)');
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(0, 0, glowRadius, 0, Math.PI * 2);
                    ctx.fill();
                }

                ctx.rotate(this.angle);
                
                // Draw ship based on selectedShip
                if (this.selectedShip === 'VANGUARD') {
                    // VANGUARD - Heavy armored OCTAGON with steel/silver armor
                    ctx.scale(1.4, 1.4); // 40% larger - heavy ship
                    ctx.fillStyle = '#2a3845';
                    ctx.strokeStyle = '#8b9dc3';
                    ctx.lineWidth = 3;
                    ctx.shadowBlur = 12;
                    ctx.shadowColor = '#5b7ba8';
                    
                    // Main OCTAGONAL armored body (8 sides)
                    ctx.beginPath();
                    for (let i = 0; i < 8; i++) {
                        const angle = (Math.PI / 4) * i;
                        const x = Math.cos(angle) * 10;
                        const y = Math.sin(angle) * 10;
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                    
                    // Front armor wedge (bright steel)
                    ctx.fillStyle = '#c0cfe0';
                    ctx.beginPath();
                    ctx.moveTo(13, 0);
                    ctx.lineTo(6, -4);
                    ctx.lineTo(6, 4);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Shield emitter nodes (4 cardinal points - blue glow)
                    const nodePositions = [0, 2, 4, 6]; // Right, top, left, bottom
                    nodePositions.forEach(i => {
                        const angle = (Math.PI / 4) * i;
                        const nx = Math.cos(angle) * 8;
                        const ny = Math.sin(angle) * 8;
                        
                        ctx.fillStyle = '#5b9bd5';
                        ctx.shadowBlur = 10;
                        ctx.beginPath();
                        ctx.arc(nx, ny, 2.5, 0, Math.PI * 2);
                        ctx.fill();
                    });
                    
                    // Core glow (steel/blue)
                    ctx.fillStyle = '#8b9dc3';
                    ctx.shadowBlur = 15;
                    ctx.beginPath();
                    ctx.arc(0, 0, 4, 0, Math.PI * 2);
                    ctx.fill();
                    
                } else if (this.selectedShip === 'REAPER') {
                    // REAPER - Glass cannon aggressive design with red/gold
                    ctx.scale(1.2, 1.2); // 20% larger - menacing presence
                    ctx.fillStyle = '#2a0a0a';
                    ctx.strokeStyle = '#ff3333';
                    ctx.lineWidth = 2.5;
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = '#ff3333';
                    
                    // Sharp aggressive wedge body
                    ctx.beginPath();
                    ctx.moveTo(14, 0);      // Sharp front
                    ctx.lineTo(-5, 7);      // Bottom wing
                    ctx.lineTo(-8, 5);      // Bottom back
                    ctx.lineTo(-6, 0);      // Center back
                    ctx.lineTo(-8, -5);     // Top back
                    ctx.lineTo(-5, -7);     // Top wing
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                    
                    // Gold accent blades
                    ctx.strokeStyle = '#ffcc00';
                    ctx.lineWidth = 2;
                    ctx.shadowColor = '#ffcc00';
                    ctx.shadowBlur = 12;
                    ctx.beginPath();
                    ctx.moveTo(10, 0);
                    ctx.lineTo(4, -5);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(10, 0);
                    ctx.lineTo(4, 5);
                    ctx.stroke();
                    
                    // Red energy core
                    ctx.fillStyle = '#ff6666';
                    ctx.shadowBlur = 18;
                    ctx.shadowColor = '#ff3333';
                    ctx.beginPath();
                    ctx.arc(0, 0, 3.5, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Gold engine glow
                    ctx.fillStyle = '#ffcc00';
                    ctx.shadowBlur = 12;
                    ctx.shadowColor = '#ffcc00';
                    ctx.beginPath();
                    ctx.arc(-5, 0, 2, 0, Math.PI * 2);
                    ctx.fill();
                    
                } else if (this.selectedShip === 'ENGINEER') {
                    // ENGINEER - Hexagonal/industrial design with orange accents (LARGER)
                    ctx.scale(1.3, 1.3); // 30% larger
                    ctx.fillStyle = '#2a2511';
                    ctx.strokeStyle = '#ff8800';
                    ctx.lineWidth = 2;
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = '#ff8800';
                    
                    // Main hexagonal body
                    ctx.beginPath();
                    for (let i = 0; i < 6; i++) {
                        const angle = (Math.PI / 3) * i;
                        const x = Math.cos(angle) * 8;
                        const y = Math.sin(angle) * 8;
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                    
                    // Front panel
                    ctx.fillStyle = '#ff8800';
                    ctx.fillRect(-2, -3, 6, 6);
                    
                    // Core glow
                    ctx.fillStyle = '#ffaa44';
                    ctx.shadowBlur = 8;
                    ctx.beginPath();
                    ctx.arc(0, 0, 3, 0, Math.PI * 2);
                    ctx.fill();
                    
                } else if (this.selectedShip === 'DISRUPTOR') {
                    // DISRUPTOR - Sleek diamond design with purple accents (LARGER)
                    ctx.scale(1.3, 1.3); // 30% larger
                    ctx.fillStyle = '#1a0f2e';
                    ctx.strokeStyle = '#a855f7';
                    ctx.lineWidth = 2;
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = '#a855f7';
                    
                    // Diamond/kite shape
                    ctx.beginPath();
                    ctx.moveTo(12, 0);      // Front point
                    ctx.lineTo(-4, 6);      // Top wing
                    ctx.lineTo(-8, 0);      // Back point
                    ctx.lineTo(-4, -6);     // Bottom wing
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                    
                    // Wing accents
                    ctx.strokeStyle = '#c084fc';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(6, 0);
                    ctx.lineTo(-2, 4);
                    ctx.moveTo(6, 0);
                    ctx.lineTo(-2, -4);
                    ctx.stroke();
                    
                    // Core glow
                    ctx.fillStyle = '#c084fc';
                    ctx.shadowBlur = 12;
                    ctx.beginPath();
                    ctx.arc(0, 0, 3, 0, Math.PI * 2);
                    ctx.fill();
                    
                } else if (this.selectedShip === 'CATALYST') {
                    // CATALYST - Crystalline prism with color-cycling core
                    ctx.scale(1.25, 1.25); // Slightly larger
                    ctx.fillStyle = '#1a1a2e';
                    ctx.strokeStyle = '#a855f7';
                    ctx.lineWidth = 2.5;
                    ctx.shadowBlur = 12;
                    ctx.shadowColor = '#a855f7';
                    
                    // Faceted prism body
                    ctx.beginPath();
                    ctx.moveTo(10, 0);      // Front point
                    ctx.lineTo(3, -5);      // Upper right
                    ctx.lineTo(-3, -5);     // Upper left
                    ctx.lineTo(-7, 0);      // Back point
                    ctx.lineTo(-3, 5);      // Lower left
                    ctx.lineTo(3, 5);       // Lower right
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                    
                    // Inner facet lines
                    ctx.strokeStyle = '#c084fc';
                    ctx.lineWidth = 1;
                    ctx.shadowBlur = 6;
                    ctx.beginPath();
                    ctx.moveTo(10, 0);
                    ctx.lineTo(0, 0);
                    ctx.moveTo(3, -5);
                    ctx.lineTo(0, 0);
                    ctx.lineTo(3, 5);
                    ctx.stroke();
                    
                    // Elemental core - cycles through colors (4 elements only)
                    const coreColors = ['#ff5722', '#00e5ff', '#ffeb3b', '#39ff14'];
                    const currentElement = this.surgeElements[this.surgeElementIndex];
                    const elementIndex = this.surgeElements.indexOf(currentElement);
                    let coreColor = coreColors[elementIndex];
                    
                    // Pulse effect based on hit count (builds up to burst at 3)
                    let pulseIntensity = 1.0;
                    if (this.surgeHitCount > 0) {
                        // Pulse brighter as we approach burst (1/3, 2/3, ready at 3)
                        pulseIntensity = 1.0 + (this.surgeHitCount * 0.4);
                        const pulse = Math.sin(Date.now() * 0.004) * 0.2 + 0.8;
                        pulseIntensity *= pulse;
                    }
                    
                    ctx.fillStyle = coreColor;
                    ctx.shadowBlur = 15 * pulseIntensity;
                    ctx.shadowColor = coreColor;
                    ctx.globalAlpha = 0.9;
                    ctx.beginPath();
                    ctx.arc(0, 0, 3.5, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.globalAlpha = 1.0;
                    
                    // Bright center
                    ctx.fillStyle = '#ffffff';
                    ctx.shadowBlur = 10;
                    ctx.beginPath();
                    ctx.arc(0, 0, 1.5, 0, Math.PI * 2);
                    ctx.fill();
                    
                } else {
                    // PATHFINDER (default) - Classic triangle design with cyan
                    ctx.fillStyle = '#1a1a2e';
                    ctx.strokeStyle = '#00d1b2';
                    ctx.lineWidth = 2;
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = '#00fff5';
                    
                    ctx.beginPath();
                    ctx.moveTo(10, 0);
                    ctx.lineTo(-8, 8);
                    ctx.lineTo(-5, 0);
                    ctx.lineTo(-8, -8);
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                    
                    // Core glow
                    ctx.fillStyle = '#00fff5';
                    ctx.shadowBlur = 15;
                    ctx.beginPath();
                    ctx.arc(0, 0, 4, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                ctx.shadowBlur = 0;
                ctx.restore();
            }
        }


        // ==========================================
        // ULTIMATE SYSTEM
        // ==========================================
        
        const ULTIMATES = {
            skyfall: {
                id: 'skyfall',
                name: 'Skyfall Beam',
                desc: 'Devastating orbital beam locked on target. 5 ticks of ramping damage over 5 seconds.',
                icon: 'fa-bolt',
                color: '#00d4ff',
                // Damage per tick as % of target max HP
                tickDamage: [6, 6, 6, 6, 10], // 5 ticks: 6% + 6% + 6% + 6% + 10% = 34% total
                duration: 5000, // 5 seconds
                tickInterval: 1000, // 1 second per tick
                chargeTime: 90, // Base 90 seconds
                damageChargeBonus: 0.0002 // 0.02% per 100 damage
            },
            event_horizon: {
                id: 'event_horizon',
                name: 'Event Horizon',
                desc: 'Deploy a singularity that pulls enemies in, then collapses for massive damage.',
                icon: 'fa-circle-dot',
                color: '#9400ff',
                pullDuration: 3000, // 3 seconds
                pullRadius: 400,
                pullStrength: 5, // units per frame
                collapseDamage: {
                    center: 30, // 30% max HP within 100 radius (buffed from 20%)
                    mid: 20,    // 20% max HP within 200 radius (buffed from 12%)
                    outer: 12   // 12% max HP within 300 radius (buffed from 6%)
                },
                chargeTime: 120, // Base 120 seconds
                damageChargeBonus: 0.00016 // 0.016% per 100 damage
            },
            seismic_bomb: {
                id: 'seismic_bomb',
                name: 'Seismic Bomb',
                desc: 'Devastating nuclear explosion followed by dual shockwaves and burning ground.',
                icon: 'fa-bomb',
                color: '#ff6600',
                blastRadius: 180, // Increased from 150
                blastDamage: {
                    primary: 28, // Increased from 18% - MASSIVE damage to primary
                    aoe: 18      // Increased from 12% - strong AoE
                },
                shockwave1: {
                    delay: 300, // Reduced from 500ms - faster sequence
                    radius: 280, // Increased from 250
                    damage: 14,  // Increased from 10%
                    stunDuration: 2500 // Increased from 2000ms
                },
                shockwave2: {
                    delay: 600, // Reduced from 1000ms - faster sequence
                    radius: 400, // Increased from 350
                    damage: 9,   // Increased from 6%
                    stunDuration: 2500
                },
                burningGround: {
                    radius: 180, // Increased from 150
                    duration: 2000, // Reduced from 3500ms - much faster
                    damagePerSecond: 4 // 4% per second = 8% total over 2s
                },
                chargeTime: 75, // Base 75 seconds
                damageChargeBonus: 0.00024 // 0.024% per 100 damage
            },
            phoenix_protocol: {
                id: 'phoenix_protocol',
                name: 'Phoenix Protocol',
                desc: 'Channel devastating pulse waves. Incinerates everything in expanding radius.',
                icon: 'fa-sun',
                color: '#ff6600',
                duration: 4000, // 4 seconds total
                pulseCount: 6,
                pulseInterval: 666, // ~every 0.66 seconds
                pulseData: [
                    { radius: 150, damage: 8 },  // Pulse 1: 8% max HP (buffed from 4%)
                    { radius: 200, damage: 10 },  // Pulse 2: 10% max HP (buffed from 5%)
                    { radius: 250, damage: 12 },  // Pulse 3: 12% max HP (buffed from 6%)
                    { radius: 300, damage: 14 },  // Pulse 4: 14% max HP (buffed from 7%)
                    { radius: 350, damage: 16 },  // Pulse 5: 16% max HP (buffed from 8%)
                    { radius: 500, damage: 22 }  // Pulse 6: 22% max HP (buffed from 12%) - MASSIVE FINALE
                ],
                knockbackForce: 15, // Push enemies outward
                burningGround: {
                    duration: 3000, // 3 seconds
                    radius: 500, // Same as final pulse
                    damagePerSecond: 4 // 4% max HP/sec (buffed from 2%)
                },
                chargeTime: 100, // Base 100 seconds
                damageChargeBonus: 0.0002 // 0.02% per 100 damage
            },
            adrenaline_surge: {
                id: 'adrenaline_surge',
                name: 'Adrenaline Surge',
                desc: 'Explosive speed and firepower. Contact damage and deadly energy trail.',
                icon: 'fa-bolt-lightning',
                color: '#ffeb3b',
                
                duration: 5000, // 5 seconds (increased from 4)
                speedMultiplier: 3.0, // 300% movement speed
                fireRateMultiplier: 3.0, // 3x weapon fire rate
                
                contactDamage: 12, // 12% max HP on contact
                contactCooldown: 500, // 0.5 seconds between hits on SAME enemy
                
                trailDamage: 5, // 5% max HP/sec
                trailTickRate: 200, // Damage tick every 0.2 seconds (5 ticks/sec)
                trailWidth: 60, // Width of damage trail
                trailLength: 150, // How far behind player the trail extends
                
                chargeTime: 85, // Base 85 seconds
                damageChargeBonus: 0.00022 // 0.022% per 100 damage
            }
        };
        
        // Damage reduction multipliers for different enemy types
        const ULTIMATE_DAMAGE_REDUCTION = {
            normal: 1.0,      // 100% damage to normal enemies
            titan: 0.6,       // 60% damage to Titans (buffed from 50%)
            nexusPrime: 0.3   // 30% damage to Nexus Prime
        };
        
        // Fire the equipped ultimate ability
        function fireUltimate() {
            if (!player.ultimate || player.ultimateCharge < 100 || player.ultimateActive) {
                console.log('‚ùå Cannot fire ultimate - not ready');
                return;
            }
            
            console.log('‚úÖ Firing ultimate:', player.ultimate);
            
            // Reset charge
            player.ultimateCharge = 0;
            player.ultimateActive = true;
            
            // Test Mode: Instant Ultimate Recharge (refill after 3 seconds)
            if (testModeEnabled && testModeSettings.instantUltRecharge) {
                setTimeout(() => {
                    player.ultimateCharge = 100;
                    console.log('‚ö° Test Mode: Ultimate instantly recharged to 100%');
                }, 3000); // 3 seconds
            }
            
            // Phoenix Protocol doesn't need a target - centered on player
            if (player.ultimate === 'phoenix_protocol') {
                executePhoenixProtocol();
                return;
            }
            
            // Adrenaline Surge doesn't need a target - self-buff ultimate
            if (player.ultimate === 'adrenaline_surge') {
                executeAdrenalineSurge();
                return;
            }
            
            // Find target using auto-targeting (on-screen only)
            const target = findUltimateTarget();
            
            if (!target) {
                console.log('‚ö†Ô∏è No valid target found for ultimate');
                player.ultimateActive = false;
                player.ultimateCharge = 50; // Refund 50% charge if no target
                return;
            }
            
            console.log('üéØ Target found:', target.type, 'HP:', target.hp);
            
            // Execute ultimate based on type
            switch (player.ultimate) {
                case 'skyfall':
                    // Skyfall uses camera pan
                    panCameraToTarget(target, (targetEnemy) => {
                        executeSkyfallBeam(targetEnemy);
                    });
                    break;
                    
                case 'event_horizon':
                    // Event Horizon targets densest cluster (like Seismic Bomb)
                    const eventHorizonCluster = findDensestCluster(target);
                    executeEventHorizon(eventHorizonCluster);
                    break;
                    
                case 'seismic_bomb':
                    // Seismic Bomb handles its own camera (no pan needed)
                    const clusterLocation = findDensestCluster(target);
                    executeSeismicBomb(clusterLocation);
                    break;
            }
        }
        
        // Auto-targeting: Find highest priority enemy ON SCREEN
        function findUltimateTarget() {
            console.log('üéØ Finding ultimate target (no distance limit)');
            
            // Count enemies
            const aliveEnemies = entities.enemies.filter(e => e.hp > 0);
            console.log(`üëæ Total alive enemies: ${aliveEnemies.length}`);
            
            // Priority 1: Nexus Prime core (if vulnerable)
            const nexusPrime = entities.enemies.find(e => e.isNexusPrime);
            if (nexusPrime) {
                // If shields are down, target the core
                if (nexusPrime.coreVulnerable) {
                    return nexusPrime;
                }
                
                // Shields are up - target highest HP shield or turret
                // If tied, prioritize closest to player
                let highestHpEnemy = null;
                let highestHp = 0;
                let closestDistance = Infinity;
                
                entities.enemies.forEach(e => {
                    if (e.hp > 0 && (e.isBossShield || e.isBossTurret)) {
                        // Calculate distance to player
                        const dist = Math.sqrt((e.x - player.x) ** 2 + (e.y - player.y) ** 2);
                        
                        // Take if higher HP, or if same HP but closer
                        if (e.hp > highestHp || (e.hp === highestHp && dist < closestDistance)) {
                            highestHp = e.hp;
                            highestHpEnemy = e;
                            closestDistance = dist;
                        }
                    }
                });
                
                if (highestHpEnemy) return highestHpEnemy;
            }
            
            // Priority 2: Highest max HP enemy (no distance limit)
            // If tied, prioritize closest to player
            let highestMaxHpEnemy = null;
            let highestMaxHp = 0;
            let closestDistance = Infinity;
            
            entities.enemies.forEach(e => {
                if (e.hp > 0) {
                    // Calculate distance to player
                    const dist = Math.sqrt((e.x - player.x) ** 2 + (e.y - player.y) ** 2);
                    
                    // Take if higher max HP, or if same max HP but closer
                    if (e.maxHp > highestMaxHp || (e.maxHp === highestMaxHp && dist < closestDistance)) {
                        highestMaxHp = e.maxHp;
                        highestMaxHpEnemy = e;
                        closestDistance = dist;
                    }
                }
            });
            
            if (highestMaxHpEnemy) {
                console.log('‚úì Found target:', highestMaxHpEnemy.type, 'maxHP:', highestMaxHp, 'distance:', Math.floor(closestDistance));
            } else {
                console.log('‚úó No enemies found for targeting');
            }
            
            return highestMaxHpEnemy;
        }
        
        // Check if upgrades were queued during ultimate
        function checkQueuedUpgrades() {
            if (state.upgradeQueue && state.upgradeQueue.length > 0 && state.screen === 'game') {
                processNextUpgrade();
            }
        }
        
        // Pan camera to target for cinematic ultimate
        function panCameraToTarget(target, callback) {
            console.log('üé• Starting camera pan to target at', target.x, target.y);
            
            // Lock camera to prevent game loop from moving it
            state.cameraLocked = true;
            state.ultimateCameraTarget = target; // Store target for continuous tracking
            
            const startX = player.x; // Start from player position
            const startY = player.y;
            const targetX = target.x;
            const targetY = target.y;
            const duration = 500; // 0.5 seconds to pan
            const startTime = Date.now();
            
            // Short invulnerability during pan (0.5s)
            player.invulnTimer = Math.max(player.invulnTimer, 30);
            console.log('üõ°Ô∏è Player invulnerable for pan (30 frames)');
            
            const panInterval = setInterval(() => {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(1, elapsed / duration);
                
                // Smooth easing (ease-in-out)
                const eased = progress < 0.5 
                    ? 2 * progress * progress 
                    : 1 - Math.pow(-2 * progress + 2, 2) / 2;
                
                // Manually lerp camera during pan (after pan completes, game loop takes over tracking)
                const currentX = startX + (targetX - startX) * eased;
                const currentY = startY + (targetY - startY) * eased;
                state.camera.x = width/2 - currentX * state.zoom;
                state.camera.y = height/2 - currentY * state.zoom;
                
                if (progress >= 1) {
                    clearInterval(panInterval);
                    console.log('‚úÖ Camera reached target, firing ultimate');
                    // Camera is now at target and will continue tracking via game loop
                    callback(target);
                }
            }, 16); // 60fps
        }
        
        // Pan camera back to player (called when ultimate ends)
        function panCameraBackToPlayer() {
            console.log('üé• Panning camera back to player');
            
            // Calculate current camera position in world space
            // camera.x = width/2 - worldX * zoom
            // worldX = (width/2 - camera.x) / zoom
            const currentWorldX = (width/2 - state.camera.x) / state.zoom;
            const currentWorldY = (height/2 - state.camera.y) / state.zoom;
            
            const startX = currentWorldX;
            const startY = currentWorldY;
            const targetX = player.x;
            const targetY = player.y;
            const duration = 500; // 0.5 seconds to pan back
            const startTime = Date.now();
            
            // Clear target and locked position references
            state.ultimateCameraTarget = null;
            state.lockedWorldX = undefined;
            state.lockedWorldY = undefined;
            
            const panInterval = setInterval(() => {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(1, elapsed / duration);
                
                // Smooth easing
                const eased = progress < 0.5 
                    ? 2 * progress * progress 
                    : 1 - Math.pow(-2 * progress + 2, 2) / 2;
                
                // Lerp camera position
                const currentX = startX + (targetX - startX) * eased;
                const currentY = startY + (targetY - startY) * eased;
                state.camera.x = width/2 - currentX * state.zoom;
                state.camera.y = height/2 - currentY * state.zoom;
                
                if (progress >= 1) {
                    clearInterval(panInterval);
                    // Unlock camera so game loop can resume control
                    state.cameraLocked = false;
                    
                    // Give player 1s invulnerability after camera returns
                    player.invulnTimer = Math.max(player.invulnTimer, 60);
                    console.log('‚úÖ Camera returned, player has 1s invuln (60 frames)');
                }
            }, 16); // 60fps
        }
        
        // SKYFALL BEAM: 5-second orbital beam with ramping damage
        function executeSkyfallBeam(target) {
            console.log('‚ö° Skyfall Beam activating on target:', target.type);
            
            // Invulnerability for ultimate duration + linger + camera pan + 1s buffer
            // 5000ms ticks + 500ms linger + 500ms camera pan + 1000ms buffer = 7000ms = 420 frames
            player.invulnTimer = Math.max(player.invulnTimer, 420);
            
            const ultimateData = ULTIMATES.skyfall;
            let tickCount = 0;
            const totalTicks = 5;
            
            // Create beam visual
            player.ultimateData.skyfallBeam = {
                target: target,
                x: target.x,
                y: target.y,
                tickCount: 0,
                timer: 0,
                active: true
            };
            
            console.log('üìä Beam visual created:', player.ultimateData.skyfallBeam);
            
            // Function to execute a tick
            const executeTick = () => {
                // Check if target still exists
                if (!target || target.hp <= 0) {
                    console.log('‚ö†Ô∏è Skyfall target died, attempting to retarget...');
                    
                    // Try to find a new target using the same logic as initial targeting
                    const newTarget = findUltimateTarget();
                    
                    if (newTarget && newTarget.hp > 0) {
                        console.log(`‚úÖ Retargeted to new enemy: ${newTarget.type || 'unknown'}`);
                        target = newTarget;
                        
                        // Update camera to track new target
                        state.cameraLocked = true;
                        state.ultimateCameraTarget = newTarget;
                        
                        // Continue with the tick on the new target
                    } else {
                        console.log('‚ùå No valid targets remaining, ending beam');
                        if (player.ultimateData.skyfallBeam) {
                            player.ultimateData.skyfallBeam.active = false;
                        }
                        player.ultimateActive = false;
                        state.cameraLocked = false;
                        state.ultimateCameraTarget = null;
                        panCameraBackToPlayer();
                        checkQueuedUpgrades(); // Check for queued level ups
                        return false; // Stop ticking
                    }
                }
                
                // Update beam position to follow target
                player.ultimateData.skyfallBeam.x = target.x;
                player.ultimateData.skyfallBeam.y = target.y;
                player.ultimateData.skyfallBeam.tickCount = tickCount;
                
                // Deal damage
                const tickDamagePercent = ultimateData.tickDamage[tickCount];
                let damage = target.maxHp * (tickDamagePercent / 100);
                
                // Apply damage reduction based on enemy type
                if (target.isNexusPrime) {
                    damage *= ULTIMATE_DAMAGE_REDUCTION.nexusPrime;
                } else if (target.isChampion) {
                    damage *= ULTIMATE_DAMAGE_REDUCTION.titan;
                } else {
                    damage *= ULTIMATE_DAMAGE_REDUCTION.normal;
                }
                
                // Deal damage
                target.hp -= damage;
                target.flash = 5;
                
                console.log(`‚ö° Skyfall tick ${tickCount + 1}/5: ${Math.floor(damage)} damage to ${target.type}`);
                
                // Visual feedback
                createExplosion(target.x, target.y, '#00d4ff', 30 + (tickCount * 5));
                // Camera shake removed
                
                // Damage text - use FloatingText class (larger and longer for ultimates)
                const damageColor = tickCount === 4 ? '#ffdd57' : '#00d4ff'; // Gold for final tick
                const damageText = new FloatingText(
                    target.x + (Math.random() - 0.5) * 40,
                    target.y - 30,
                    Math.floor(damage),
                    damageColor,
                    tickCount === 4, // isCrit on final tick
                    'normal'
                );
                // Make ultimate damage text bigger and last longer
                damageText.fontSize = tickCount === 4 ? 32 : 24; // Bigger than normal (16px)
                damageText.life = 90; // 1.5 seconds (was 50 frames)
                if (tickCount === 4) {
                    damageText.life = 120; // Final tick lasts even longer (2 seconds)
                }
                entities.texts.push(damageText);
                
                tickCount++;
                
                // End after 5 ticks
                if (tickCount >= totalTicks) {
                    setTimeout(() => {
                        if (player.ultimateData.skyfallBeam) {
                            player.ultimateData.skyfallBeam.active = false;
                        }
                        player.ultimateActive = false;
                        
                        // Pan camera back to player
                        panCameraBackToPlayer();
                        
                        // Check for queued levelup
                        checkQueuedUpgrades();
                    }, 500); // Brief linger
                    return false; // Stop interval
                }
                
                return true; // Continue ticking
            };
            
            // Fire first tick immediately
            if (!executeTick()) return;
            
            // Then fire remaining ticks every 1 second
            const beamInterval = setInterval(() => {
                if (!player.ultimateData.skyfallBeam || !player.ultimateData.skyfallBeam.active) {
                    clearInterval(beamInterval);
                    return;
                }
                
                if (!executeTick()) {
                    clearInterval(beamInterval);
                }
            }, 1000); // 1 second per tick
        }
        
        // EVENT HORIZON: Singularity that pulls enemies then collapses
        function executeEventHorizon(target) {
            console.log('üåÄ Event Horizon activating');
            
            // Determine singularity location
            let singularityX, singularityY;
            if (!target || target.hp <= 0 || typeof target.x !== 'number' || typeof target.y !== 'number') {
                console.log('‚ö†Ô∏è No valid target, centering on player');
                singularityX = player.x;
                singularityY = player.y;
            } else {
                singularityX = target.x;
                singularityY = target.y;
                console.log('‚úÖ Singularity at target:', singularityX, singularityY);
            }
            
            const ultimateData = ULTIMATES.event_horizon;
            
            // Player invulnerability: 3.5s total (pan + pull + collapse + return)
            player.invulnTimer = Math.max(player.invulnTimer, 210);
            
            // SMOOTH camera pan to singularity (0.5s)
            const startCamX = state.camera.x;
            const startCamY = state.camera.y;
            const targetCamX = width/2 - singularityX * state.zoom;
            const targetCamY = height/2 - singularityY * state.zoom;
            const panDuration = 500;
            const panStartTime = Date.now();
            
            state.cameraLocked = true;
            
            const panInterval = setInterval(() => {
                const elapsed = Date.now() - panStartTime;
                const progress = Math.min(1, elapsed / panDuration);
                const eased = progress < 0.5 ? 2 * progress * progress : 1 - Math.pow(-2 * progress + 2, 2) / 2;
                
                state.camera.x = startCamX + (targetCamX - startCamX) * eased;
                state.camera.y = startCamY + (targetCamY - startCamY) * eased;
                
                if (progress >= 1) {
                    clearInterval(panInterval);
                    // Lock camera to world position
                    state.lockedWorldX = singularityX;
                    state.lockedWorldY = singularityY;
                    console.log('üé• Camera locked to singularity');
                }
            }, 16);
            
            // Wait for pan to complete, then start pull phase
            setTimeout(() => {
                // Create singularity
                player.ultimateData.eventHorizon = {
                    x: singularityX,
                    y: singularityY,
                    pullTimer: ultimateData.pullDuration,
                    active: true,
                    phase: 'pull'
                };
                
                console.log('üåÄ Event Horizon pull phase started');
                
                // Pull phase loop (runs every frame for 3 seconds)
                const pullInterval = setInterval(() => {
                    const eventHorizon = player.ultimateData.eventHorizon;
                    if (!eventHorizon || !eventHorizon.active) {
                        clearInterval(pullInterval);
                        return;
                    }
                    
                    eventHorizon.pullTimer -= 16;
                    
                    // Pull enemies toward singularity AND deal damage during pull
                    entities.enemies.forEach(e => {
                        if (e.hp <= 0) return;
                        
                        const dx = singularityX - e.x;
                        const dy = singularityY - e.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        
                        if (dist < ultimateData.pullRadius) {
                            let pullStrength = ultimateData.pullStrength;
                            if (e.isNexusPrime) pullStrength *= 0.3;
                            else if (e.isChampion) pullStrength *= 0.5;
                            
                            e.x += (dx / dist) * pullStrength;
                            e.y += (dy / dist) * pullStrength;
                            
                            if (!e.isNexusPrime && !e.isChampion) {
                                e.vx = 0;
                                e.vy = 0;
                            }
                            
                            // PULL DAMAGE: Deal damage every 100ms (6 frames)
                            if (!e.eventHorizonDamageTick) e.eventHorizonDamageTick = 0;
                            e.eventHorizonDamageTick += 16;
                            
                            if (e.eventHorizonDamageTick >= 100) {
                                e.eventHorizonDamageTick = 0;
                                
                                // 1% max HP damage per tick (10% total over 3s pull)
                                let pullDamage = e.maxHp * 0.01;
                                
                                if (e.isNexusPrime) pullDamage *= ULTIMATE_DAMAGE_REDUCTION.nexusPrime;
                                else if (e.isChampion) pullDamage *= ULTIMATE_DAMAGE_REDUCTION.titan;
                                else pullDamage *= ULTIMATE_DAMAGE_REDUCTION.normal;
                                
                                e.takeDamage(pullDamage, '#9400ff', false, 'normal');
                                
                                // Small damage text
                                const damageText = new FloatingText(e.x, e.y - 20, Math.floor(pullDamage), '#bb66ff');
                                damageText.fontSize = 16;
                                damageText.life = 60;
                                entities.texts.push(damageText);
                            }
                        }
                    });
                    
                    // Pull phase complete - trigger collapse
                    if (eventHorizon.pullTimer <= 0) {
                        clearInterval(pullInterval);
                        console.log('üí• Event Horizon collapsing');
                        eventHorizon.phase = 'collapse';
                        
                        // Collapse damage
                        setTimeout(() => {
                            entities.enemies.forEach(e => {
                                if (e.hp <= 0) return;
                                
                                const dx = singularityX - e.x;
                                const dy = singularityY - e.y;
                                const dist = Math.sqrt(dx * dx + dy * dy);
                                
                                let damagePercent = 0;
                                if (dist < 100) damagePercent = ultimateData.collapseDamage.center;
                                else if (dist < 200) damagePercent = ultimateData.collapseDamage.mid;
                                else if (dist < 300) damagePercent = ultimateData.collapseDamage.outer;
                                
                                if (damagePercent > 0) {
                                    let damage = e.maxHp * (damagePercent / 100);
                                    
                                    if (e.isNexusPrime) damage *= ULTIMATE_DAMAGE_REDUCTION.nexusPrime;
                                    else if (e.isChampion) damage *= ULTIMATE_DAMAGE_REDUCTION.titan;
                                    else damage *= ULTIMATE_DAMAGE_REDUCTION.normal;
                                    
                                    e.takeDamage(damage, '#9400ff', false, 'normal');
                                    e.flash = 8;
                                    
                                    const damageText = new FloatingText(e.x, e.y - 30, Math.floor(damage), '#9400ff');
                                    damageText.fontSize = 24;
                                    damageText.life = 90;
                                    entities.texts.push(damageText);
                                }
                            });
                            
                            createExplosion(singularityX, singularityY, '#9400ff', 80);
                            
                            // Cleanup
                            if (player.ultimateData.eventHorizon) {
                                player.ultimateData.eventHorizon.active = false;
                            }
                            
                            // SMOOTH camera return to player (0.5s)
                            setTimeout(() => {
                                const returnStartCamX = state.camera.x;
                                const returnStartCamY = state.camera.y;
                                const returnTargetCamX = width/2 - player.x * state.zoom;
                                const returnTargetCamY = height/2 - player.y * state.zoom;
                                const returnStartTime = Date.now();
                                
                                state.lockedWorldX = undefined;
                                state.lockedWorldY = undefined;
                                
                                const returnInterval = setInterval(() => {
                                    const elapsed = Date.now() - returnStartTime;
                                    const progress = Math.min(1, elapsed / panDuration);
                                    const eased = progress < 0.5 ? 2 * progress * progress : 1 - Math.pow(-2 * progress + 2, 2) / 2;
                                    
                                    state.camera.x = returnStartCamX + (returnTargetCamX - returnStartCamX) * eased;
                                    state.camera.y = returnStartCamY + (returnTargetCamY - returnStartCamY) * eased;
                                    
                                    if (progress >= 1) {
                                        clearInterval(returnInterval);
                                        state.cameraLocked = false;
                                        player.ultimateData.eventHorizon = null;
                                        player.ultimateActive = false;
                                        console.log('‚úÖ Event Horizon complete, camera returned');
                                        checkQueuedUpgrades();
                                    }
                                }, 16);
                            }, 200);
                        }, 100);
                    }
                }, 16);
            }, panDuration);
        }
        
        // SEISMIC BOMB: Find densest enemy cluster for bomb placement
        function findDensestCluster(nearTarget) {
            console.log('üí£ Finding densest enemy cluster for Seismic Bomb');
            
            let bestClusterX = nearTarget.x;
            let bestClusterY = nearTarget.y;
            let bestDensity = 0;
            
            const clusterRadius = 200; // Check for enemies within 200 units
            const aliveEnemies = entities.enemies.filter(e => e.hp > 0);
            
            aliveEnemies.forEach(e => {
                // Count nearby enemies to this potential center point
                const nearbyCount = aliveEnemies.filter(other => {
                    const dist = Math.sqrt((e.x - other.x)**2 + (e.y - other.y)**2);
                    return dist < clusterRadius;
                }).length;
                
                if (nearbyCount > bestDensity) {
                    bestDensity = nearbyCount;
                    bestClusterX = e.x;
                    bestClusterY = e.y;
                }
            });
            
            console.log(`üí£ Found cluster with ${bestDensity} enemies at (${Math.floor(bestClusterX)}, ${Math.floor(bestClusterY)})`);
            return { x: bestClusterX, y: bestClusterY, density: bestDensity };
        }
        
        // SEISMIC BOMB: Massive explosion with dual shockwaves and burning ground
        function executeSeismicBomb(clusterLocation) {
            console.log('üí£ Seismic Bomb executing');
            
            const bombX = clusterLocation.x;
            const bombY = clusterLocation.y;
            const ultimateData = ULTIMATES.seismic_bomb;
            
            // Player invulnerability: 4.5s total (faster sequence)
            player.invulnTimer = Math.max(player.invulnTimer, 270);
            
            // SMOOTH camera pan to bomb location (0.3s - faster)
            const startCamX = state.camera.x;
            const startCamY = state.camera.y;
            const targetCamX = width/2 - bombX * state.zoom;
            const targetCamY = height/2 - bombY * state.zoom;
            const panDuration = 300; // Reduced from 500ms
            const panStartTime = Date.now();
            
            state.cameraLocked = true;
            
            const panInterval = setInterval(() => {
                const elapsed = Date.now() - panStartTime;
                const progress = Math.min(1, elapsed / panDuration);
                const eased = progress < 0.5 ? 2 * progress * progress : 1 - Math.pow(-2 * progress + 2, 2) / 2;
                
                state.camera.x = startCamX + (targetCamX - startCamX) * eased;
                state.camera.y = startCamY + (targetCamY - startCamY) * eased;
                
                if (progress >= 1) {
                    clearInterval(panInterval);
                    // Lock camera to world position
                    state.lockedWorldX = bombX;
                    state.lockedWorldY = bombY;
                    console.log('üé• Camera locked to bomb location');
                }
            }, 16);
            
            // Wait for pan to complete, then start bomb sequence
            setTimeout(() => {
                // Create bomb (travels from player to target)
                player.ultimateData.seismicBomb = {
                    x: player.x,
                    y: player.y,
                    targetX: bombX,
                    targetY: bombY,
                    phase: 'travel',
                    timer: 0,
                    active: true
                };
                
                console.log('üí£ Bomb traveling to target');
                
                // Bomb travel animation (0.3s - faster)
                const travelDuration = 300; // Reduced from 500ms
                const travelInterval = setInterval(() => {
                    const bomb = player.ultimateData.seismicBomb;
                    if (!bomb || !bomb.active) {
                        clearInterval(travelInterval);
                        return;
                    }
                    
                    bomb.timer += 16;
                    const progress = Math.min(1, bomb.timer / travelDuration);
                    bomb.x = player.x + (bombX - player.x) * progress;
                    bomb.y = player.y + (bombY - player.y) * progress;
                    
                    // Travel complete - trigger explosion sequence
                    if (progress >= 1) {
                        clearInterval(travelInterval);
                        console.log('üí• Bomb impact - starting explosion phases');
                        bomb.phase = 'explode';
                        
                        // INITIAL BLAST
                        entities.enemies.forEach(e => {
                            if (e.hp <= 0) return;
                            const dist = Math.sqrt((bombX - e.x)**2 + (bombY - e.y)**2);
                            
                            if (dist < ultimateData.blastRadius) {
                                let damage = e.maxHp * (ultimateData.blastDamage.aoe / 100);
                                
                                if (e.isNexusPrime) damage *= ULTIMATE_DAMAGE_REDUCTION.nexusPrime;
                                else if (e.isChampion) damage *= ULTIMATE_DAMAGE_REDUCTION.titan;
                                else damage *= ULTIMATE_DAMAGE_REDUCTION.normal;
                                
                                e.takeDamage(damage, '#ff6600', false, 'normal');
                                e.flash = 10;
                                
                                if (!e.isNexusPrime && !e.isBossShield && !e.isBossTurret) {
                                    const angle = Math.atan2(e.y - bombY, e.x - bombX);
                                    e.pushX = Math.cos(angle) * 20;
                                    e.pushY = Math.sin(angle) * 20;
                                }
                                
                                const damageText = new FloatingText(e.x, e.y - 30, Math.floor(damage), '#ff6600');
                                damageText.fontSize = 24;
                                damageText.life = 90;
                                entities.texts.push(damageText);
                            }
                        });
                        
                        createExplosion(bombX, bombY, '#ff6600', 60);
                        
                        // Transition from 'explode' visual to 'shockwave1' visual (after 300ms)
                        setTimeout(() => {
                            if (player.ultimateData.seismicBomb) {
                                console.log('üé¨ Visual transition: explode -> shockwave1');
                            }
                        }, 300);
                        
                        // SHOCKWAVE 1 (after 0.5s)
                        setTimeout(() => {
                            if (!player.ultimateData.seismicBomb) return;
                            player.ultimateData.seismicBomb.phase = 'shockwave1';
                            console.log('üí• Shockwave 1');
                            
                            entities.enemies.forEach(e => {
                                if (e.hp <= 0) return;
                                const dist = Math.sqrt((bombX - e.x)**2 + (bombY - e.y)**2);
                                
                                if (dist < ultimateData.shockwave1.radius) {
                                    let damage = e.maxHp * (ultimateData.shockwave1.damage / 100);
                                    
                                    if (e.isNexusPrime) damage *= ULTIMATE_DAMAGE_REDUCTION.nexusPrime;
                                    else if (e.isChampion) damage *= ULTIMATE_DAMAGE_REDUCTION.titan;
                                    else damage *= ULTIMATE_DAMAGE_REDUCTION.normal;
                                    
                                    e.takeDamage(damage, '#ffaa00', false, 'normal');
                                    e.flash = 5;
                                    
                                    if (!e.isNexusPrime) {
                                        e.frozen = e.isChampion ? 60 : 120;
                                    }
                                    
                                    const damageText = new FloatingText(e.x, e.y - 20, Math.floor(damage), '#ffaa00');
                                    damageText.fontSize = 24;
                                    damageText.life = 90;
                                    entities.texts.push(damageText);
                                }
                            });
                            
                            entities.particles.push(new Shockwave(bombX, bombY, ultimateData.shockwave1.radius, '#ff6600'));
                        }, ultimateData.shockwave1.delay);
                        
                        // SHOCKWAVE 2 (after 1s)
                        setTimeout(() => {
                            if (!player.ultimateData.seismicBomb) return;
                            player.ultimateData.seismicBomb.phase = 'shockwave2';
                            console.log('üí• Shockwave 2');
                            
                            entities.enemies.forEach(e => {
                                if (e.hp <= 0) return;
                                const dist = Math.sqrt((bombX - e.x)**2 + (bombY - e.y)**2);
                                
                                if (dist < ultimateData.shockwave2.radius) {
                                    let damage = e.maxHp * (ultimateData.shockwave2.damage / 100);
                                    
                                    if (e.isNexusPrime) damage *= ULTIMATE_DAMAGE_REDUCTION.nexusPrime;
                                    else if (e.isChampion) damage *= ULTIMATE_DAMAGE_REDUCTION.titan;
                                    else damage *= ULTIMATE_DAMAGE_REDUCTION.normal;
                                    
                                    e.takeDamage(damage, '#ffcc00', false, 'normal');
                                    e.flash = 5;
                                    
                                    if (!e.isNexusPrime) {
                                        e.frozen = e.isChampion ? 60 : 120;
                                    }
                                    
                                    const damageText = new FloatingText(e.x, e.y - 20, Math.floor(damage), '#ffcc00');
                                    damageText.fontSize = 24;
                                    damageText.life = 90;
                                    entities.texts.push(damageText);
                                }
                            });
                            
                            entities.particles.push(new Shockwave(bombX, bombY, ultimateData.shockwave2.radius, '#ffaa00'));
                        }, ultimateData.shockwave2.delay);
                        
                        // BURNING GROUND - start after shockwaves, track with bomb.burningTimer for rendering
                        setTimeout(() => {
                            if (!player.ultimateData.seismicBomb) return;
                            
                            // Set up burning ground visual data
                            player.ultimateData.seismicBomb.phase = 'burning';
                            player.ultimateData.seismicBomb.burningX = bombX;
                            player.ultimateData.seismicBomb.burningY = bombY;
                            player.ultimateData.seismicBomb.burningTimer = ultimateData.burningGround.duration;
                            console.log('üî• Burning ground started');
                            
                            const burningInterval = setInterval(() => {
                                const bomb = player.ultimateData.seismicBomb;
                                if (!bomb || !bomb.active) {
                                    clearInterval(burningInterval);
                                    return;
                                }
                                
                                bomb.burningTimer -= 1000;
                                
                                // Burning damage every second
                                entities.enemies.forEach(e => {
                                    if (e.hp <= 0) return;
                                    const dist = Math.sqrt((bombX - e.x)**2 + (bombY - e.y)**2);
                                    
                                    if (dist < ultimateData.burningGround.radius) {
                                        let damage = e.maxHp * (ultimateData.burningGround.damagePerSecond / 100);
                                        
                                        if (e.isNexusPrime) damage *= ULTIMATE_DAMAGE_REDUCTION.nexusPrime;
                                        else if (e.isChampion) damage *= ULTIMATE_DAMAGE_REDUCTION.titan;
                                        else damage *= ULTIMATE_DAMAGE_REDUCTION.normal;
                                        
                                        e.takeDamage(damage, '#ff5722', false, 'normal');
                                        
                                        const damageText = new FloatingText(
                                            e.x + (Math.random() - 0.5) * 20,
                                            e.y - 10,
                                            Math.floor(damage),
                                            '#ff5722'
                                        );
                                        damageText.fontSize = 20;
                                        damageText.life = 60;
                                        entities.texts.push(damageText);
                                    }
                                });
                                
                                // Burning complete - cleanup and camera return
                                if (bomb.burningTimer <= 0) {
                                    clearInterval(burningInterval);
                                    console.log('‚úÖ Burning ground complete, returning camera');
                                    
                                    if (player.ultimateData.seismicBomb) {
                                        player.ultimateData.seismicBomb.active = false;
                                    }
                                    player.ultimateActive = false;
                                    
                                    // SMOOTH camera return to player (0.5s)
                                    const returnStartCamX = state.camera.x;
                                    const returnStartCamY = state.camera.y;
                                    const returnTargetCamX = width/2 - player.x * state.zoom;
                                    const returnTargetCamY = height/2 - player.y * state.zoom;
                                    const returnStartTime = Date.now();
                                    
                                    state.lockedWorldX = undefined;
                                    state.lockedWorldY = undefined;
                                    
                                    const returnInterval = setInterval(() => {
                                        const elapsed = Date.now() - returnStartTime;
                                        const progress = Math.min(1, elapsed / panDuration);
                                        const eased = progress < 0.5 ? 2 * progress * progress : 1 - Math.pow(-2 * progress + 2, 2) / 2;
                                        
                                        state.camera.x = returnStartCamX + (returnTargetCamX - returnStartCamX) * eased;
                                        state.camera.y = returnStartCamY + (returnTargetCamY - returnStartCamY) * eased;
                                        
                                        if (progress >= 1) {
                                            clearInterval(returnInterval);
                                            state.cameraLocked = false;
                                            console.log('‚úÖ Seismic Bomb complete, camera returned');
                                            checkQueuedUpgrades();
                                        }
                                    }, 16);
                                }
                            }, 1000);
                        }, ultimateData.shockwave2.delay + 100); // Start burning shortly after shockwave 2
                    }
                }, 16);
            }, panDuration);
        }
        
        // PHOENIX PROTOCOL: Player-centered expanding pulses
        function executePhoenixProtocol() {
            
            // Invulnerability for ultimate duration + camera return + 1s buffer
            // 4000ms pulses + 500ms camera + 1000ms buffer = 5500ms = 330 frames
            player.invulnTimer = Math.max(player.invulnTimer, 330);
            
            const ultimateData = ULTIMATES.phoenix_protocol;
            
            // Lock player position
            const phoenixX = player.x;
            const phoenixY = player.y;
            player.phoenixLocked = true;
            player.phoenixLockedX = phoenixX;
            player.phoenixLockedY = phoenixY;
            
            // Camera stays on player (no panning needed)
            state.cameraLocked = false; // Let normal follow continue
            
            // Store Phoenix Protocol state in player.ultimateData for game-time-based updates
            player.ultimateData = {
                phoenixX: phoenixX,
                phoenixY: phoenixY,
                pulseCount: 0,
                nextPulseTimer: 0, // Timer until next pulse (in milliseconds, game-time)
                pulseInterval: ultimateData.pulseInterval,
                totalPulses: ultimateData.pulseCount,
                burningGround: null // Will be set after final pulse
            };
            
            // Execute first pulse immediately
            executePhoenixPulse();
        }
        
        // Execute a single Phoenix Protocol pulse
        function executePhoenixPulse() {
            const ultimateData = ULTIMATES.phoenix_protocol;
            const data = player.ultimateData;
            
            if (!data || data.pulseCount >= data.totalPulses) {
                return; // All pulses done
            }
            
            const pulseInfo = ultimateData.pulseData[data.pulseCount];
            
            // Camera shake removed
            
            // Visual explosion
            createExplosion(data.phoenixX, data.phoenixY, ultimateData.color, 30 + (data.pulseCount * 10));
            
            // Add shockwave visual
            entities.particles.push(new Shockwave(data.phoenixX, data.phoenixY, pulseInfo.radius, ultimateData.color));
            
            // Final pulse extra effects
            if (data.pulseCount === data.totalPulses - 1) {
                // Massive flash (no shake)
                createExplosion(data.phoenixX, data.phoenixY, '#ffffff', 100);
                
                // Secondary explosion for impact (stored for next frame)
                player.ultimateData.pendingFinalExplosion = 6; // Will trigger in 6 frames (~100ms at 60fps)
            }
            
            // Deal damage to all enemies in radius
            entities.enemies.forEach(e => {
                if (e.hp <= 0) return;
                
                const dx = e.x - data.phoenixX;
                const dy = e.y - data.phoenixY;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                if (dist < pulseInfo.radius) {
                    // Calculate damage
                    let damage = e.maxHp * (pulseInfo.damage / 100);
                    
                    // Apply damage reduction
                    if (e.isNexusPrime) {
                        damage *= ULTIMATE_DAMAGE_REDUCTION.nexusPrime;
                    } else if (e.isChampion) {
                        damage *= ULTIMATE_DAMAGE_REDUCTION.titan;
                    } else {
                        damage *= ULTIMATE_DAMAGE_REDUCTION.normal;
                    }
                    
                    // Ensure minimum damage of 1
                    damage = Math.max(1, damage);
                    
                    // Deal damage
                    e.takeDamage(damage, ultimateData.color, false, 'normal');
                    
                    // Knockback (push away from player) - BOSS IMMUNE
                    if (dist > 0 && !e.isNexusPrime && !e.isBossShield && !e.isBossTurret) {
                        const knockbackAngle = Math.atan2(dy, dx);
                        e.pushX = Math.cos(knockbackAngle) * ultimateData.knockbackForce;
                        e.pushY = Math.sin(knockbackAngle) * ultimateData.knockbackForce;
                    }
                    
                    // Damage text
                    const damageText = new FloatingText(
                        e.x + (Math.random() - 0.5) * 30,
                        e.y - 20,
                        Math.floor(damage),
                        ultimateData.color
                    );
                    damageText.fontSize = 22;
                    damageText.life = 75;
                    entities.texts.push(damageText);
                }
            });
            
            // CRITICAL: Check if Phoenix Protocol destroyed all boss shields
            if (state.finalBoss && state.finalBoss.shields) {
                const activeShields = state.finalBoss.shields.filter(s => s.hp > 0).length;
                if (activeShields === 0 && !state.finalBoss.coreVulnerable) {
                    state.finalBoss.coreVulnerable = true;
                    state.finalBoss.shieldsActive = false;
                    state.finalBoss.vulnerabilityTimer = 900; // 15 seconds
                    state.finalBoss.isRegeneratingShields = false; // Cancel any regeneration
                }
            }
            
            data.pulseCount++;
            
            // Schedule next pulse or finish
            if (data.pulseCount >= data.totalPulses) {
                // All pulses done - start burning ground
                data.burningGround = {
                    x: data.phoenixX,
                    y: data.phoenixY,
                    radius: ultimateData.burningGround.radius,
                    timer: ultimateData.burningGround.duration,
                    tickTimer: 1000, // Next tick in 1 second
                    active: true
                };
                
                // Unlock player
                player.phoenixLocked = false;
                
            } else {
                // Schedule next pulse
                data.nextPulseTimer = data.pulseInterval;
            }
        }
        
        // Execute Adrenaline Surge ultimate
        function executeAdrenalineSurge() {
            console.log('‚ö° Adrenaline Surge activating!');
            
            const ultimateData = ULTIMATES.adrenaline_surge;
            
            // Invulnerability for ultimate duration + 1s buffer
            // 5000ms duration + 1000ms buffer = 6000ms = 360 frames
            player.invulnTimer = Math.max(player.invulnTimer, 360);
            
            // Camera stays on player (no panning needed)
            state.cameraLocked = false;
            
            // Initialize Adrenaline Surge state
            player.ultimateData = {
                duration: ultimateData.duration,
                timer: ultimateData.duration, // Countdown timer
                
                // Speed and fire rate multipliers
                speedMult: ultimateData.speedMultiplier,
                fireRateMult: ultimateData.fireRateMultiplier,
                
                // Contact damage system
                contactCooldowns: new Map(), // enemy.id -> lastHitTime
                contactDamage: ultimateData.contactDamage,
                contactCooldown: ultimateData.contactCooldown,
                
                // Trail system
                trail: [], // Array of {x, y, time}
                trailTickTimer: ultimateData.trailTickRate, // Timer for trail damage ticks
                trailDamage: ultimateData.trailDamage,
                trailTickRate: ultimateData.trailTickRate,
                trailWidth: ultimateData.trailWidth,
                trailDuration: 500, // Trail exists for 0.5s behind player
                
                color: ultimateData.color
            };
            
            // Visual feedback - screen flash
            // Camera shake removed
            createExplosion(player.x, player.y, ultimateData.color, 50);
            
            console.log('‚ö° Adrenaline Surge: 3x speed, 3x fire rate, invulnerable for 4 seconds');
        }
        
        class Enemy {
            constructor(type) {
                this.id = nextEnemyId++; // Assign unique ID
                
                // FIXED: Spawn enemies off-screen using world coordinates
                // Calculate visible world area (canvas size / zoom)
                const visibleWorldWidth = width / state.zoom;
                const visibleWorldHeight = height / state.zoom;
                
                // Spawn distance = half the diagonal of visible area + buffer
                const screenBuffer = 50; // Buffer to ensure fully offscreen
                const spawnDist = Math.sqrt(visibleWorldWidth**2 + visibleWorldHeight**2) / 2 + screenBuffer;
                
                // Random angle around player
                const angle = seededRandom() * Math.PI * 2;
                
                // Spawn at minimum distance to be off-screen in world space
                this.x = player.x + Math.cos(angle) * spawnDist;
                this.y = player.y + Math.sin(angle) * spawnDist;
                
                this.type = type; this.vx = 0; this.vy = 0; this.pushX = 0; this.pushY = 0;
                this.flash = 0; this.animTick = seededRandom() * 100;
                this.frozen = 0; this.burn = 0; this.disease = 0; this.lastShot = 0;


                this.pyroState = { active: false, timer: 0, level: 0, baseDmg: 0, sourceWeapon: null };
                this.cryoState = { 
                    slowed: false,        // Is enemy currently slowed?
                    slowDuration: 0,      // How long they've been slowed (counts up to 120 frames = 2s)
                    frozen: false,        // Are they frozen solid?
                    frozenTimer: 0,       // Freeze duration countdown
                    nearbyCheckTimer: 0,  // Timer for cached nearby check optimization
                    cachedNearbySlowed: 0 // Cached count of nearby slowed enemies
                };
                this.bioState = { active: false, timer: 0, level: 0, maxDmg: 0, jumpCount: 0, sourceWeapon: null };
                this.hackState = { active: false, timer: 0 };
                this.empState = { active: false, timer: 0 }; // EMP disables enemy
                this.ionState = { active: false, timer: 0 }; // Ion debuff: +30% damage taken
                this.lastHackTime = 0; 

                // BOSS AI STATE
                this.actionState = 'cooldown'; 
                this.actionTimer = 120;
                this.currentAttack = 0;
                this.phase = 1; // Track boss phase (1 or 2)
                this.phase2Triggered = false; // Ensure phase 2 only triggers once


                // Boss Ability Pool (Choose 2 for Phase 1, gain 2 more in Phase 2)
                this.abilities = [];
                this.phase2Abilities = []; // Additional abilities for phase 2
                this.abilityNames = ["VORTEX", "BURST", "BREAKER", "OPTIC", "HIVE", "SHOTGUN", "PULSE", "SEEKER", "BARRAGE", "METEOR"];
                
                if (type === 'boss') {
                    // 0: Spiral, 1: Nova, 2: Charge, 3: Laser, 4: Minion, 5: Shotgun, 6: Ring Pulse, 7: Homing
                    // 8: Barrage (new), 9: Meteor Rain (new)
                    
                    // Phase 1: Choose 2 abilities
                    while(this.abilities.length < 2) {
                        const r = Math.floor(seededRandom() * 10);
                        if(!this.abilities.includes(r)) this.abilities.push(r);
                    }
                    
                    // Phase 2: Choose 2 additional abilities (will be added at phase transition)
                    const allAbilities = [0,1,2,3,4,5,6,7,8,9];
                    const availablePhase2 = allAbilities.filter(a => !this.abilities.includes(a));
                    while(this.phase2Abilities.length < 2 && availablePhase2.length > 0) {
                        const idx = Math.floor(seededRandom() * availablePhase2.length);
                        this.phase2Abilities.push(availablePhase2[idx]);
                        availablePhase2.splice(idx, 1);
                    }
                }


                this.chargeState = 0; this.chargeTimer = 0; this.chargeTarget = {x:0,y:0}; this.chargeAngle = 0;
                
                // Splitter attack timer
                this.splitterAttackTimer = 0;
                this.splitterMaxAttackTimer = 150; // 2.5 seconds between shots


                const mins = state.gameTime / 60000;
                let speedMult = 1 + (mins * 0.02);
                
                // ASCENSION 5: ACCELERATED ENEMIES - All enemies move 15% faster
                if (state.activeAscension === 5) {
                    speedMult *= 1.15;
                }
                
                // SCALING: Post lvl 20 harder (reduced from 0.05 to 0.03 for smoother difficulty curve)
                // This prevents the damage spike at level 25+ that makes defenses feel inadequate
                let scaling = state.level > 20 ? 1.0 + (state.level-20)*0.03 : 1.0;
                
                // ASCENSION 5: EMPOWERED TITANS - Champions get +25% HP and damage
                let titanBonus = 1.0;
                if (state.activeAscension === 5 && type === 'champion') {
                    titanBonus = 1.25;
                }
                
                // ASCENSION 5: OVERCHARGED ENEMIES - All enemies deal +20% damage
                let damageBonus = 1.0;
                if (state.activeAscension === 5) {
                    damageBonus = 1.20;
                }


                // Enemy HP REBALANCED - SLIGHT INCREASE (1.8x)
                // TIER SYSTEM: basic (hackable), elite (hackable with mastery), boss (never hackable)
                if (type === 'boss') {
                    this.tier = 'boss'; // Never hackable
                    this.speed = 0.40 * speedMult; 
                    this.hp = (3000 + (state.level * 300)) * 1.6 * scaling; // Decreased from 2.5x (had 4.0x briefly) - armor gives ~37.5% reduction, so reduce base HP proportionally
                    this.radius = 60; this.color = '#ff0000'; this.xp = 0; this.dmg = 30 * scaling * damageBonus;
                    this.maxHp = this.hp;
                }
                else if (type === 'champion') {
                    // Champion: Mini-boss that spawns with regular enemies
                    this.tier = 'elite'; // Hackable with mastery
                    this.speed = 0.62 * speedMult; // Faster to be more threatening (was 0.5)
                    this.hp = (1200 + (state.level * 120)) * 1.45 * scaling * titanBonus; // Decreased from 2.0x - armor gives ~28.5% reduction, +25% if Empowered Titans
                    this.radius = 45; // Larger for visibility
                    this.color = '#ff3300'; // Bright red-orange
                    this.xp = 50; // Generous XP reward
                    this.dmg = 25 * scaling * titanBonus * damageBonus; // Contact damage, +25% if Empowered Titans, +20% if Overcharged
                    this.maxHp = this.hp;
                    this.isChampion = true; // Flag for special rendering
                    this.damageReduction = 0.35; // 35% damage reduction from all sources (reduced for better fight pace)
                    
                    // TITAN CHAMPION ATTACK SYSTEM
                    this.championType = 'TITAN'; // Zone 1 champion
                    this.championId = null; // Will be set when spawned (for multi-titan tracking)
                    this.attackState = 'idle'; // idle, telegraph, attacking, cooldown
                    this.attackTimer = 0;
                    this.currentAttack = null;
                    this.attackCooldown = 0;
                    
                    // Telegraph visuals
                    this.telegraphTimer = 0;
                    this.telegraphType = null; // 'cone', 'circle', 'none'
                    this.telegraphAngle = 0;
                    this.telegraphRadius = 0;
                }
                else if (type === 'drone') { 
                    this.tier = 'basic'; // Always hackable
                    this.speed = 0.57 * speedMult; this.hp = (20 + (state.level*5)) * 1.65 * scaling; this.radius = 12; this.color = '#ff3860'; this.xp = 2; this.dmg = (8 + state.level * 1.0) * scaling * damageBonus; // Reduced from 1.5 to 1.0 per level to tone down late game damage
                }
                else if (type === 'tank') { 
                    this.tier = 'elite'; // Hackable with mastery
                    this.speed = 0.70 * speedMult; this.hp = (150 + (state.level*30)) * 1.35 * scaling; this.radius = 28; this.color = '#ffaa00'; this.xp = 12; this.dmg = 40 * scaling * damageBonus; 
                } 
                else if (type === 'swarm') { 
                    this.tier = 'basic'; // Always hackable
                    this.speed = 1.32 * speedMult; this.hp = (10 + (state.level*2)) * 1.65 * 0.67 * scaling; this.radius = 8; this.color = '#bf5af2'; this.xp = 3; this.dmg = (6 + state.level * 1.2) * scaling * damageBonus; 
                }
                else if (type === 'splitter') { 
                    this.tier = 'basic'; // Always hackable
                    this.speed = 0.88 * speedMult; this.hp = (45 + (state.level*6)) * 1.65 * scaling; this.radius = 16; this.color = '#ff9500'; this.xp = 10; this.dmg = (12 + state.level * 2) * scaling * damageBonus; 
                } 
                else if (type === 'voidwalker') {
                    this.tier = 'elite'; // Hackable with mastery
                    this.speed = 0; // Doesn't walk, only teleports
                    this.hp = (60 + (state.level*5)) * 1.45 * scaling;
                    this.radius = 16; 
                    this.color = '#9933ff'; // Purple
                    this.xp = 4;
                    this.dmg = 50; // Base explosion damage to player (NOT scaled)
                    this.enemyDmg = 50 * scaling; // Explosion damage to enemies (reduced from 100)
                    this.blastRadius = 120;
                    
                    // Phase state machine
                    this.phaseState = 'phased'; // 'phased', 'materializing', 'countdown', 'detonating'
                    this.phaseTimer = 300; // 5 seconds phased (60fps √ó 5)
                    this.countdownTimer = 120; // 2 seconds countdown (60fps √ó 2)
                    this.materializeRange = [60, 80]; // Distance from target
                    
                    // Visual
                    this.pulsePhase = seededRandom() * Math.PI * 2;
                    this.opacity = 0.3; // Start semi-transparent
                    this.warningCircleRadius = 0;
                    
                    // Target tracking
                    this.driftTarget = null; // Where it's drifting toward
                    this.hasBeenHacked = false; // Track if hack teleport has triggered
                }
                
                // Set maxHp for all enemy types (needed for ultimate % damage calculations)
                if (!this.maxHp) {
                    this.maxHp = this.hp;
                }
                
                // ARMOR SYSTEM: Add armor based on enemy tier
                // Armor reduces damage: finalDamage = baseDamage * (1 - armorReduction)
                // armorReduction = armor / (armor + 100)
                // This creates diminishing returns: 50 armor = 33% reduction, 100 armor = 50% reduction
                if (type === 'boss') {
                    this.armor = 60; // ~37.5% damage reduction - very tanky
                } else if (type === 'champion') {
                    this.armor = 40; // ~28.5% damage reduction - tanky
                } else if (this.tier === 'elite') {
                    // Tank, Voidwalker, etc.
                    this.armor = 25; // ~20% damage reduction
                } else if (type === 'tank') {
                    // Extra armor for tanks specifically (overrides elite)
                    this.armor = 35; // ~25.9% damage reduction - they're tanks after all
                } else {
                    // Basic enemies: drone, swarm, splitter
                    this.armor = 10; // ~9% damage reduction
                }
            }
            
            triggerDetonation() {
                // VOIDWALKER DETONATION - Enhanced animation
                const explosionColor = this.hackState.active ? '#00ff00' : '#9933ff';
                const brightColor = this.hackState.active ? '#88ffcc' : '#ff66ff';
                
                // Multi-layered explosion
                createExplosion(this.x, this.y, explosionColor, 60); // More particles
                createExplosion(this.x, this.y, brightColor, 40); // Bright center
                createExplosion(this.x, this.y, '#ffffff', 20); // White core
                
                // Multiple shockwaves at different speeds
                entities.particles.push(new Shockwave(this.x, this.y, this.blastRadius, explosionColor));
                entities.particles.push(new Shockwave(this.x, this.y, this.blastRadius * 0.7, brightColor));
                entities.particles.push(new Shockwave(this.x, this.y, this.blastRadius * 0.4, '#ffffff'));
                
                // Radial burst effect
                for (let i = 0; i < 12; i++) {
                    const angle = (i / 12) * Math.PI * 2;
                    const speed = 8 + seededRandom() * 4;
                    entities.particles.push({
                        x: this.x,
                        y: this.y,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed,
                        life: 30,
                        color: explosionColor,
                        size: 4,
                        update: function(dt) {
                            this.x += this.vx * (dt/16);
                            this.y += this.vy * (dt/16);
                            this.life -= dt/16;
                            this.vx *= 0.95;
                            this.vy *= 0.95;
                            return this.life > 0;
                        },
                        draw: function(ctx) {
                            ctx.fillStyle = this.color;
                            ctx.globalAlpha = this.life / 30;
                            ctx.beginPath();
                            ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.globalAlpha = 1;
                        }
                    });
                }
                
                // Damage player (only if not hacked)
                if (!this.hackState.active) {
                    const distToPlayer = Math.sqrt((player.x - this.x)**2 + (player.y - this.y)**2);
                    if (distToPlayer < this.blastRadius && player.invulnTimer <= 0) {
                        const falloff = 1 - (distToPlayer / this.blastRadius) * 0.4; // 40% falloff at edge
                        player.takeHit(this.dmg * falloff, 'Voidwalker Detonation', 'VOIDWALKER');
                    }
                }
                
                // Damage enemies (always, including when not hacked)
                entities.enemies.forEach(e => {
                    if (e !== this && e.hp > 0) {
                        const dist = Math.sqrt((e.x - this.x)**2 + (e.y - this.y)**2);
                        if (dist < this.blastRadius) {
                            const falloff = 1 - (dist / this.blastRadius) * 0.4; // 40% falloff
                            e.takeDamage(this.enemyDmg * falloff, explosionColor, false, 'normal', 'voidwalker');
                        }
                    }
                });
            }
            
            takeDamage(amt, color = '#ffffff', isCrit = false, type = 'normal', sourceId = null, elementType = null) {
                // SAFETY: Validate entity coordinates
                if (this.x === null || this.x === undefined || this.y === null || this.y === undefined || isNaN(this.x) || isNaN(this.y)) {
                    console.error(`üêõ BUG: Entity has invalid coordinates! type=${this.type}, isNexusPrime=${this.isNexusPrime}, isBossTurret=${this.isBossTurret}, x=${this.x}, y=${this.y}`);
                    return; // Don't process damage for entities with invalid position
                }
                
                // NEXUS PRIME CORE PROTECTION: Core immune to damage while shields are active
                if (this.isNexusPrime && !this.coreVulnerable) {
                    // Show "IMMUNE" text
                    entities.texts.push(new FloatingText(this.x, this.y - 20, 'IMMUNE', '#ffaa00', false, 'immune'));
                    console.log(`üõ°Ô∏è Boss core IMMUNE - shields active, coreVulnerable=${this.coreVulnerable}`);
                    return; // No damage to core while shields up
                }
                
                // VOIDWALKER PHASE PROTECTION: Invulnerable while phased out
                if (this.type === 'voidwalker' && this.phaseState === 'phased') {
                    return; // No damage while phased
                }
                
                // HACK PROTECTION: Hacked enemies cannot die from player damage (except hack damage itself)
                // Voidwalkers when hacked are also immune until hack expires
                if (this.hackState.active && sourceId !== 'hack' && elementType !== 'hack') {
                    // Prevent death - set HP to minimum 1
                    if (this.hp - amt <= 0) {
                        this.hp = 1;
                        return; // Don't apply damage that would kill
                    }
                }
                
                // ARMOR SYSTEM: Apply armor damage reduction
                // Formula: armorReduction = armor / (armor + 100)
                // Player can reduce effective armor with armor piercing augment
                if (this.armor && this.armor > 0) {
                    const effectiveArmor = this.armor * (1 - (player.armorPiercing || 0));
                    const armorReduction = effectiveArmor / (effectiveArmor + 100);
                    amt *= (1 - armorReduction);
                    
                    // Debug logging - show for first 50 hits or occasionally
                    if (!this.armorLogCount) this.armorLogCount = 0;
                    if (this.armorLogCount < 50 || Math.random() < 0.05) {
                        // Calculate damage reduction from armor
                        const armorReduction = effectiveArmor / (effectiveArmor + 100);
                        this.armorLogCount++;
                    }
                }
                
                // CHAMPION DAMAGE REDUCTION: Champions have massive damage reduction (75%)
                if (this.isChampion && this.damageReduction) {
                    amt *= (1 - this.damageReduction); // Apply damage reduction percentage
                }
                
                // CHAMPION HACKED ENEMY MITIGATION: Titans take much less damage from hacked enemy attacks
                if (this.isChampion && sourceId === 'voidwalker') {
                    amt *= 0.2; // 80% reduction from hacked voidwalker explosions
                }
                
                // CHAMPION ELEMENTAL RESISTANCE: Champions have strong defense against elements
                // Cryo and Bio are especially reduced (70%), other elements moderately reduced (50%)
                if (this.isChampion && elementType && ['fire', 'ice', 'volt', 'bio', 'hack'].includes(elementType)) {
                    if (elementType === 'ice' || elementType === 'bio') {
                        amt *= 0.3; // 70% reduction for Cryo and Bio
                    } else {
                        amt *= 0.5; // 50% reduction for Fire, Volt, Hack
                    }
                }
                
                // Ionization: Enemies hit by Ion take +30% damage from all sources
                if (this.ionState.active) {
                    amt *= 1.3;
                }
                
                // Cryo Control: Frozen enemies take +50% damage
                if (player.elementalMasteries.ice && this.cryoState.frozen) {
                    amt *= 1.5;
                }
                
                // Weapon-specific colors (only for direct weapon hits, not DOTs)
                const weaponColors = {
                    'ion': '#ffffff',      // White (default weapon)
                    'tesla': '#ffeb3b',    // Yellow/electric
                    'beam': '#ff00ff',     // Magenta/plasma
                    'rad': '#00ff00',      // Green/radioactive
                    'seeker': '#ff5500',   // Orange/rocket
                    'whip': '#ff00ff',  // Magenta (plasma whip)
                    'meteor': '#ff8800',   // Orange/fire
                    'railgun': '#00aaff',  // Blue (matches beam)
                    'flak': '#ffaa00',     // Gold/explosive
                    'pylons': '#ff64ff',   // Magenta (matches pylon beams)
                    'mines': '#ff44cc',    // Brighter magenta (matches mine visuals)
                    'gas': '#99ff33',      // Toxic green
                    'ricochet': '#ff8800', // Orange (bouncing disc)
                    'drones': '#00aaff',   // Blue (drone shots)
                    'marker': '#ffaa00',   // Orange (matches targeting theme)
                    'barrier': '#8b9dc3',  // Steel blue (barrier reflection)
                };
                
                // Determine display color: 
                // Priority: crit > elemental DOT (keep original color) > weapon color > default
                let displayColor = color;
                if (isCrit) {
                    displayColor = '#ffdd00'; // Crit override
                } else if (type === 'dot' && elementType) {
                    // DOTs keep their elemental color (already passed in)
                    displayColor = color;
                } else if (sourceId && weaponColors[sourceId]) {
                    // Weapon hits get weapon color
                    displayColor = weaponColors[sourceId];
                }
                
                this.hp -= amt; this.flash = 2;
                
                // TRACK WEAPON DAMAGE
                if (sourceId && sourceId !== 'voidwalker' && sourceId !== 'kamikaze') {
                    if (!state.weaponStats[sourceId]) {
                        state.weaponStats[sourceId] = { damage: 0, kills: 0 };
                    }
                    state.weaponStats[sourceId].damage += amt;
                    // Log occasionally (1% of the time) to avoid spam
                    if (Math.random() < 0.01) {
                    }
                }
                
                // Always show DOT damage, or show regular damage if >= 1 or 10% chance
                if (type === 'dot' || amt >= 1 || seededRandom() < 0.1) {
                    entities.texts.push(new FloatingText(this.x, this.y - 20, Math.ceil(amt), displayColor, isCrit, type, sourceId, elementType));
                }
                if(this.hp <= 0) {
                    // FINAL BOSS: No pickups during boss fight
                    const allowPickups = !(state.finalBossActive && !state.finalBossDefeated);
                    
                    // REAPER ROUNDS: Heal 1 HP on kill (max 5 HP/sec = 5 kills per second)
                    if (player.hasReaper && player.reaperCooldown <= 0) {
                        player.heal(1, false);
                        player.reaperCooldown = 12; // 0.2 second cooldown (allows 5 heals per second)
                    }
                    
                    // NEARBY CHAMPION DAMAGE - Killing enemies near champions damages them
                    if (this.type !== 'boss' && !this.isChampion) {
                        const nearbyChampionRadius = 275; // Increased from 225 for more forgiving proximity range
                        let nearestChampion = null;
                        let nearestDist = Infinity;
                        
                        // Find nearest champion within radius
                        entities.enemies.forEach(e => {
                            if (e.isChampion && e.hp > 0) {
                                const dist = Math.sqrt((e.x - this.x)**2 + (e.y - this.y)**2);
                                if (dist < nearbyChampionRadius && dist < nearestDist) {
                                    nearestDist = dist;
                                    nearestChampion = e;
                                }
                            }
                        });
                        
                        if (nearestChampion) {
                            // Deal 8% of this enemy's max HP to the champion (increased from 5% for better kill contribution)
                            const damageToChampion = (this.maxHp || 100) * 0.08;
                            
                            // Create particle stream from enemy to champion - MORE NOTICEABLE
                            const particleCount = 16; // Increased from 8
                            for (let i = 0; i < particleCount; i++) {
                                const delay = i * 1.5; // Faster stagger (was 2)
                                setTimeout(() => {
                                    entities.particles.push({
                                        x: this.x,
                                        y: this.y,
                                        targetX: nearestChampion.x,
                                        targetY: nearestChampion.y,
                                        progress: 0,
                                        life: 25, // Slightly longer life
                                        maxLife: 25,
                                        color: '#ff0000',
                                        radius: 5, // Larger (was 3)
                                        trail: [], // Add trail
                                        update() {
                                            // Store trail position
                                            this.trail.push({ x: this.x, y: this.y });
                                            if (this.trail.length > 8) this.trail.shift(); // Longer trail (was 5)
                                            
                                            this.progress += 0.06; // Slower for more visibility (was 0.12)
                                            this.x = this.x + (this.targetX - this.x) * this.progress;
                                            this.y = this.y + (this.targetY - this.y) * this.progress;
                                            this.life--;
                                            return this.life > 0 && this.progress < 1;
                                        },
                                        draw(ctx) {
                                            const alpha = 1 - (this.progress * 0.3);
                                            
                                            // Draw trail
                                            for (let j = 0; j < this.trail.length; j++) {
                                                const trailAlpha = alpha * (j / this.trail.length) * 0.5;
                                                ctx.fillStyle = `rgba(255, 100, 0, ${trailAlpha})`;
                                                ctx.beginPath();
                                                ctx.arc(this.trail[j].x, this.trail[j].y, this.radius * 0.6, 0, Math.PI * 2);
                                                ctx.fill();
                                            }
                                            
                                            // Draw main particle with glow
                                            ctx.fillStyle = `rgba(255, 0, 0, ${alpha})`;
                                            ctx.shadowBlur = 20; // Stronger glow (was 10)
                                            ctx.shadowColor = '#ff3300';
                                            ctx.beginPath();
                                            ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                                            ctx.fill();
                                            
                                            // Bright inner core
                                            ctx.fillStyle = `rgba(255, 200, 100, ${alpha})`;
                                            ctx.beginPath();
                                            ctx.arc(this.x, this.y, this.radius * 0.5, 0, Math.PI * 2);
                                            ctx.fill();
                                            
                                            ctx.shadowBlur = 0;
                                        }
                                    });
                                }, delay);
                            }
                            
                            // Deal damage after particle animation
                            setTimeout(() => {
                                if (nearestChampion.hp > 0) {
                                    nearestChampion.takeDamage(damageToChampion, '#ff0000', false, 'normal', 'nearby_kill');
                                }
                            }, 20);
                        }
                    }
                    
                    // TRACK WEAPON KILLS
                    if (sourceId && sourceId !== 'voidwalker' && sourceId !== 'kamikaze') {
                        if (!state.weaponStats[sourceId]) {
                            state.weaponStats[sourceId] = { damage: 0, kills: 0 };
                        }
                        state.weaponStats[sourceId].kills++;
                        // Log every 10th kill to avoid spam
                        if (state.weaponStats[sourceId].kills % 10 === 0) {
                        }
                    }
                    
                    createExplosion(this.x, this.y, this.color, 6);
                    
                    // Elemental Detonator removed - synergies handle this now

                    // BIO SPREAD
                    if (this.bioState.active && this.bioState.jumpCount < 1) { 
                        let neighbor = entities.enemies.find(n => n !== this && n.hp > 0 && Math.sqrt((n.x-this.x)**2 + (n.y-this.y)**2) < 200);
                        if (neighbor) {
                            neighbor.bioState = { ...this.bioState, timer: 300, jumpCount: this.bioState.jumpCount + 1 }; 
                            // Spore Projectile Effect - PASS 'bio_spread' type to ensure it applies
                            entities.projectiles.push(new Projectile(this.x, this.y, 0,0, 0, 0, 'bio_spore', neighbor, 'bio'));
                        }
                    }
                    
                    // CRYO - Frozen enemies just die cleanly, no auto-shatter
                    // Shatter is now triggered by cryo weapons hitting frozen targets (see dealElementalDamage)
                    
                    // === SYNERGY EFFECTS ===
                    
                    // Thermal Shock (Pyro + Cryo): Enemy with both explodes for 50% HP AOE, freezes nearby
                    if (player.synergies.pyro_cryo && this.pyroState.active && (this.cryoState.slowed || this.cryoState.frozen)) {
                        createExplosion(this.x, this.y, '#ff00ff', 30);
                        const explosionDmg = (this.maxHp || 100) * 0.5;
                        const explosionRange = 100;
                        const explosionRangeSq = explosionRange * explosionRange;
                        
                        // OPTIMIZED: Only check enemies within rough distance first
                        entities.enemies.forEach(e => {
                            if (e === this || e.hp <= 0) return;
                            
                            // Quick distance check with squared distance (no sqrt needed)
                            const dx = e.x - this.x;
                            const dy = e.y - this.y;
                            const distSq = dx*dx + dy*dy;
                            
                            if (distSq < explosionRangeSq) {
                                e.takeDamage(explosionDmg, '#ff00ff');
                                // Apply freeze to nearby enemies
                                if (e.type !== 'boss') {
                                    e.cryoState.frozen = true;
                                    e.cryoState.frozenTimer = 120; // 2s freeze
                                    e.cryoState.slowed = false;
                                    e.cryoState.slowDuration = 0;
                                }
                            }
                        });
                    }
                    
                    // Meltdown (Pyro + Bio): Burning enemies spread bio on death
                    if (player.synergies.pyro_bio && this.pyroState.active) {
                        // OPTIMIZED: Limit search to reasonable distance
                        const searchRangeSq = 150 * 150;
                        let neighbor = null;
                        
                        for (let i = 0; i < entities.enemies.length; i++) {
                            const n = entities.enemies[i];
                            if (n === this || n.hp <= 0 || n.bioState.active) continue;
                            
                            const dx = n.x - this.x;
                            const dy = n.y - this.y;
                            const distSq = dx*dx + dy*dy;
                            
                            if (distSq < searchRangeSq) {
                                neighbor = n;
                                break; // Found one, stop searching
                            }
                        }
                        
                        if (neighbor) {
                            neighbor.bioState = { active: true, timer: 300, level: 1, jumpCount: 0, maxDmg: player.damage * 0.5 * 4 };
                            entities.projectiles.push(new Projectile(this.x, this.y, 0, 0, 0, 0, 'bio_spore', neighbor, 'bio'));
                        }
                    }
                    
                    if (this.type === 'boss' || this.isChampion) {
                        // TITAN SQUAD MECHANIC: When one Titan dies, damage remaining Titans
                        if (this.isChampion && this.championId) {
                            // Find all other living Titans
                            const otherTitans = entities.enemies.filter(e => 
                                e.isChampion && 
                                e.hp > 0 && 
                                e.championId && 
                                e.championId !== this.championId
                            );
                            
                            // Deal 10% max HP damage to each remaining Titan
                            otherTitans.forEach(titan => {
                                const squadDamage = titan.maxHp * 0.10;
                                titan.takeDamage(squadDamage, '#ff00ff', false, 'normal', 'titan_squad');
                                
                                // Visual effect - purple explosion on each remaining Titan
                                createExplosion(titan.x, titan.y, '#ff00ff', 25);
                                
                                // Floating text showing "SQUAD LOSS"
                                const squadLossText = new FloatingText(
                                    titan.x,
                                    titan.y - 40,
                                    'SQUAD LOSS',
                                    '#ff00ff',
                                    true // Display as crit for emphasis
                                );
                                squadLossText.life = 90;
                                entities.texts.push(squadLossText);
                            });
                            
                            if (otherTitans.length > 0) {
                                console.log(`üíÄ Titan killed! Remaining ${otherTitans.length} Titan(s) took 10% max HP damage`);
                            }
                        }
                        
                        // Remove this TITAN's health bar if it has one
                        if (this.isChampion && this.championId) {
                            const titanIndex = parseInt(this.championId.split('_')[1]);
                            const barWrapper = document.getElementById(`boss-bar-wrapper-${titanIndex}`);
                            if (barWrapper) {
                                barWrapper.remove();
                            }
                        }
                        
                        // Check if any other champions are still alive
                        const remainingChampions = entities.enemies.filter(e => e.isChampion && e.hp > 0 && e !== this).length;
                        
                        console.log(`üíÄ Champion died. Remaining champions: ${remainingChampions}`);
                        
                        // Remove this champion's health bar
                        if (this.championId) {
                            // Extract index from championId (e.g., "titan_0" -> 0)
                            const titanIndex = parseInt(this.championId.split('_')[1]);
                            const barWrapper = document.getElementById(`boss-bar-wrapper-${titanIndex}`);
                            if (barWrapper) {
                                barWrapper.remove();
                                console.log(`üóëÔ∏è Removed health bar for ${this.championId}`);
                            }
                        }
                        
                        if (remainingChampions === 0) {
                            // Last champion died - hide HUD
                            state.bossActive = false;
                            document.getElementById('boss-hud').classList.remove('active');
                            state.breathingRoomTimer = 300; // 5 seconds peace
                            
                            // ULTIMATE DROP: Offer ultimate selection
                            state.pendingUltimateSelection = true;
                            console.log('üéÅ Titan defeated! Ultimate selection pending...');
                            console.log('   state.pendingUltimateSelection set to:', state.pendingUltimateSelection);
                        }
                        
                        // Grant one save charge for defeating boss/champion
                        state.saveCharges++;
                        
                        // NEXUS CORE DROP - 1 per boss kill (auto-magnetizes)
                        if (allowPickups) {
                            const nexusCore = new Pickup(this.x - 20, this.y, 0, 'nexus_core');
                            nexusCore.magnetized = true; // Auto-magnetize titan drops
                            entities.pickups.push(nexusCore);
                            
                            // Data Core drop (also auto-magnetizes)
                            const dataCore = new Pickup(this.x+20, this.y, 0, 'core');
                            dataCore.magnetized = true; // Auto-magnetize titan drops
                            entities.pickups.push(dataCore);
                        }
                    } else if (this.type === 'splitter') {
                        // SPLITTER: Spawns 3 swarm enemies on death
                        for (let i = 0; i < 3; i++) {
                            const angle = (Math.PI * 2 / 3) * i;
                            const offsetDist = 30;
                            const newX = this.x + Math.cos(angle) * offsetDist;
                            const newY = this.y + Math.sin(angle) * offsetDist;
                            const swarm = new Enemy('swarm');
                            swarm.x = newX;
                            swarm.y = newY;
                            entities.enemies.push(swarm);
                        }
                        createExplosion(this.x, this.y, this.color, 12); // Bigger explosion for split effect
                        
                        // Still drop XP shards for the splitter itself
                        if (allowPickups) {
                            let shards = 5;
                            if (this.xp > 0) {
                                for(let i=0; i<shards; i++) {
                                    const sx = this.x + (seededRandom()-0.5)*20; const sy = this.y + (seededRandom()-0.5)*20;
                                    entities.pickups.push(new Pickup(sx, sy, this.xp / shards, 'xp'));
                                }
                            }
                        }
                    } else if (this.type === 'voidwalker') {
                        // VOIDWALKER: Explodes on death (if in countdown state)
                        if (this.phaseState === 'countdown' || this.phaseState === 'detonating') {
                            this.triggerDetonation();
                        }
                        
                        // Drop XP shards
                        if (allowPickups && this.xp > 0) {
                            for(let i=0; i<4; i++) {
                                const sx = this.x + (seededRandom()-0.5)*20; 
                                const sy = this.y + (seededRandom()-0.5)*20;
                                entities.pickups.push(new Pickup(sx, sy, this.xp / 4, 'xp'));
                            }
                        }
                    } else {
                        let shards = 1;
                        if(this.type === 'swarm') shards = 4; 
                        if(this.type === 'tank') shards = 10; 
                        if (allowPickups && this.xp > 0) {
                            for(let i=0; i<shards; i++) {
                                const sx = this.x + (seededRandom()-0.5)*20; const sy = this.y + (seededRandom()-0.5)*20;
                                entities.pickups.push(new Pickup(sx, sy, this.xp / shards, 'xp'));
                            }
                            // Magnet drop rate scales down over time as kill volume increases
                            // Starts at 0.2%, scales to 0.05% by 10 minutes
                            const timeMinutes = state.gameTime / 60000;
                            const timeScale = Math.max(0.25, 1 - (timeMinutes / 15)); // 1.0 ‚Üí 0.25 over 15 minutes
                            const magnetThreshold = 0.998 + (0.001 * (1 - timeScale)); // 0.998 ‚Üí 0.999
                            
                            const r = seededRandom() + (player.luck * 0.003); // Reduced from 0.005 (40% nerf)
                            
                            // Hard cap: Max 3 magnet pickups on ground at once
                            const magnetCount = entities.pickups.filter(p => p.type === 'magnet').length;
                            
                            if (r > magnetThreshold && magnetCount < 3) entities.pickups.push(new Pickup(this.x, this.y, 0, 'magnet')); // Scaled drop rate with cap
                            // No shield cells anymore - removed from game
                            else if (r > 0.9975) {} // Empty - was shield cell drop
                            else if (r > 0.99) entities.pickups.push(new Pickup(this.x, this.y, 0, 'health')); // 1% + luck
                        }
                    }
                    
                    this.xp = 0;
                }
            }
            
            update(dt) {
                this.animTick += 0.1 * (dt/16);
                
                if (this.pyroState.active) {
                    this.pyroState.timer -= dt/16;
                    
                    // Digital Inferno: Hacked enemies burn 2x faster
                    if (player.synergies.pyro_hack && this.hackState.active) {
                        this.pyroState.timer -= dt/16; // Double tick rate
                    }
                    
                    if (this.pyroState.timer <= 0) {
                        this.pyroState.active = false;
                    } else {
                        // OPTIMIZED: Only calculate damage on actual tick intervals
                        if (!this.pyroState.lastTick) this.pyroState.lastTick = this.pyroState.timer;
                        
                        const currentInterval = Math.floor(this.pyroState.timer / 20);
                        const lastInterval = Math.floor(this.pyroState.lastTick / 20);
                        
                        // Only do heavy calculations when actually ticking
                        if (currentInterval < lastInterval) {
                            // Crossed a 20-frame interval boundary - tick now
                            this.pyroState.lastTick = this.pyroState.timer;
                            
                            // Pyro: Sustained damage that ramps up over time
                            // Progress: 0 (start) ‚Üí 1 (end) as timer counts down
                            // When stacking refreshes timer, ramp RESETS (prevents infinite ramping)
                            const progress = 1 - (this.pyroState.timer / 360);
                            
                            // CRITICAL: Ensure maxHp exists
                            const enemyMaxHp = this.maxHp || this.hp || 100;
                            
                            let dmg;
                            
                            // BOSS/CHAMPION PROTECTION: Bosses and champions take flat damage instead of % max HP
                            if (this.type === 'boss' || this.isChampion || this.type === 'nexus_prime' || this.isNexusPrime) {
                                // Flat damage that scales with player power and ramps up
                            const baseFlatDmg = (this.pyroState.baseDmg || player.damage) * 2.0; // Increased from 1.2 for better TITAN damage
                            dmg = baseFlatDmg * (1 + progress * 0.5); // Slight ramp
                            
                            // Multiply by stack level (1-3)
                            dmg *= (this.pyroState.level || 1);
                            
                            // Mastery still applies but moderately
                            if (player.elementalMasteries.fire) {
                                dmg *= 1.3; // +30% instead of the % HP bonus
                            }
                        } else {
                            // Normal enemies: % max HP + weapon damage
                            // Base damage from weapon (scales with player damage AND progress)
                            const weaponDmg = (this.pyroState.baseDmg || 0) * (1 + progress); // Ramps up!
                            
                            // % max HP damage (1% ‚Üí 1.5% over time, +0.5% with mastery)
                            const basePercent = 0.01 * (1 + progress * 0.5); // 1% ‚Üí 1.5%
                            const masteryBonus = player.elementalMasteries.fire ? 0.005 : 0; // +0.5% with mastery
                            const hpPercent = basePercent + masteryBonus;
                            const hpDmg = enemyMaxHp * hpPercent;
                            
                            // Combine both sources
                            dmg = weaponDmg + hpDmg;
                        }
                        
                        // ABSOLUTE GUARANTEE: No NaN can pass
                        if (!dmg || isNaN(dmg) || dmg <= 0) {
                            dmg = player.damage * 0.6; // Fallback to flat damage
                        }
                        
                        this.takeDamage(dmg, '#ff5722', false, 'dot', this.pyroState.sourceWeapon, 'fire');
                        if(seededRandom()<0.3) entities.particles.push(new Particle(this.x, this.y, '#ff5722', 0.5));
                    }
                    }
                }
                let cryoSlow = 1.0;
                
                // EMP SLOW: Apply diminishing stacking slow from EMP fields
                let empSlow = 1.0;
                if (this.empSlowStacks > 0) {
                    // Diminishing returns on stacking (nerfed for balance)
                    // 1 field: 25% slow (move at 75%)
                    // 2 fields: 40% slow (move at 60%)
                    // 3 fields: 50% slow (move at 50%)
                    // 4+ fields: 55% slow (move at 45%) - hard cap
                    if (this.empSlowStacks === 1) empSlow = 0.75;
                    else if (this.empSlowStacks === 2) empSlow = 0.60;
                    else if (this.empSlowStacks === 3) empSlow = 0.50;
                    else empSlow = 0.45; // Hard cap with better diminishing returns
                }
                
                // CRYO: Slow duration tracking and freeze trigger
                if (this.cryoState.frozen) {
                    // Frozen solid - no movement
                    cryoSlow = 0.0;
                    this.cryoState.frozenTimer -= dt/16;
                    
                    // Unfreeze after 2 seconds (120 frames)
                    if (this.cryoState.frozenTimer <= 0) {
                        this.cryoState.frozen = false;
                        this.cryoState.slowed = false;
                        this.cryoState.slowDuration = 0;
                    }
                    
                    // Bosses and tanks can still move slowly when frozen
                    if (this.type === 'boss' || this.type === 'tank' || this.isChampion) cryoSlow = 0.5;
                    
                } else if (this.cryoState.slowed) {
                    // Count up slow duration
                    this.cryoState.slowDuration += dt/16;
                    
                    // Base 60% slow
                    let slowAmount = 0.40; // Move at 40% speed (60% slow)
                    
                    // OPTIMIZED: Check for nearby slowed enemies only every 10 frames (cache result)
                    if (!this.cryoState.nearbyCheckTimer) this.cryoState.nearbyCheckTimer = 0;
                    this.cryoState.nearbyCheckTimer++;
                    
                    if (this.cryoState.nearbyCheckTimer >= 10) {
                        this.cryoState.nearbyCheckTimer = 0;
                        
                        // Cache nearby slowed count
                        this.cryoState.cachedNearbySlowed = entities.enemies.filter(e => {
                            if (e === this || !e.cryoState.slowed) return false;
                            const dist = Math.sqrt((e.x - this.x)**2 + (e.y - this.y)**2);
                            return dist < 150;
                        }).length;
                    }
                    
                    // Use cached value
                    const nearbySlowed = this.cryoState.cachedNearbySlowed || 0;
                    
                    // 2+ slowed enemies nearby = 70% slow (move at 30%)
                    if (nearbySlowed >= 1) {
                        slowAmount = 0.30;
                    }
                    
                    cryoSlow = slowAmount;
                    
                    // Trigger freeze after 2 seconds (120 frames) of being slowed
                    if (this.cryoState.slowDuration >= 120 && this.type !== 'boss') {
                        this.cryoState.frozen = true;
                        this.cryoState.frozenTimer = 120; // 2s freeze
                        this.cryoState.slowed = false;
                        
                        // Shatter Protocol: Frozen enemies can be hacked instantly
                        const canHackInstantly = this.tier === 'basic' || 
                                                (this.tier === 'elite' && player.elementalMasteries.hack);
                        
                        if (player.synergies.cryo_hack && !this.hackState.active && canHackInstantly) {
                            const currentHackedCount = entities.enemies.filter(e => e.hackState.active).length;
                            if (currentHackedCount < 10) {
                                let hackDuration = 300;
                                if (this.tier === 'elite') hackDuration = 150;
                                if (player.elementalMasteries.hack && this.tier === 'basic') hackDuration += 120;
                                this.hackState = { active: true, timer: hackDuration, diesAfter: false };
                                this.lastHackTime = state.gameTime;
                            }
                        }
                    }
                    
                    // Slow naturally decays after 3 seconds without refreshing
                    if (state.gameTime % 180 === 0) {
                        this.cryoState.slowed = false;
                        this.cryoState.slowDuration = 0;
                    }
                }
                
                if (this.bioState.active) {
                    this.bioState.timer -= dt/16;
                    if (this.bioState.timer <= 0) this.bioState.active = false;
                    
                    // Bioshock: Volt chains double bio tick rate for 2s
                    if (this.bioState.voltBuff > 0) {
                        this.bioState.voltBuff -= dt/16;
                    }
                    
                    // OPTIMIZED: Only calculate damage on actual tick intervals
                    // Bio Accelerator: Ticks 50% faster (every 13 frames vs 20)
                    let tickInterval = player.elementalMasteries.bio ? 13 : 20;
                    // Bioshock buff: Double rate (half interval)
                    if (this.bioState.voltBuff > 0) {
                        tickInterval = Math.floor(tickInterval / 2);
                    }
                    
                    // Track last tick to prevent multiple ticks per interval
                    if (!this.bioState.lastTick) this.bioState.lastTick = this.bioState.timer;
                    
                    const currentInterval = Math.floor(this.bioState.timer / tickInterval);
                    const lastInterval = Math.floor(this.bioState.lastTick / tickInterval);
                    
                    // Only do heavy calculations when actually ticking
                    if (currentInterval < lastInterval) {
                        // Crossed an interval boundary - tick now
                        this.bioState.lastTick = this.bioState.timer;
                        
                        // Bio: High burst % max HP damage that decays
                        // Progress: 1 (start) ‚Üí 0 (end) as timer counts down
                        // When stacking refreshes timer, decay RESETS to high damage (prevents infinite decay)
                        const progress = (this.bioState.timer / 300); 
                        
                        // CRITICAL: Ensure maxHp exists
                        const enemyMaxHp = this.maxHp || this.hp || 100;
                        
                        let dmg;
                        
                        // BOSS/CHAMPION PROTECTION: Bosses and champions take flat damage instead of % max HP
                        if (this.type === 'boss' || this.isChampion || this.type === 'nexus_prime' || this.isNexusPrime) {
                            // Flat damage that scales with player power, not boss/champion HP
                            const baseFlatDmg = player.damage * 2.5; // Increased from 1.5 for better TITAN damage
                            dmg = baseFlatDmg * (1 + progress * 0.5); // Slightly stronger at start
                            
                            // Multiply by stack level (1-3)
                            dmg *= (this.bioState.level || 1);
                            
                            // Synergies still apply but with reduced effectiveness
                            if (player.synergies.bio_hack && this.hackState.active) {
                                dmg *= 1.5; // +50% instead of +100%
                            }
                            if (player.synergies.cryo_bio && this.cryoState.frozenTimer > 0) {
                                dmg *= 1.5; // +50% instead of +100%
                            }
                        } else {
                            // Normal enemies: % max HP damage
                            // Bio Accelerator: +2% starting damage (6% ‚Üí 8%)
                            const startPercent = player.elementalMasteries.bio ? 0.08 : 0.06;
                            const endPercent = 0.02; // Increased from 0.01
                            const currentPercent = endPercent + ((startPercent - endPercent) * progress);
                            
                            // % max HP damage + flat damage scaling with player power
                            const percentDmg = enemyMaxHp * currentPercent;
                            const flatDmg = (player.damage * 0.3) * (1 + progress); // More at start, scales with player
                            dmg = percentDmg + flatDmg;
                            
                            // Necrosis: Hacked enemies take double bio damage
                            if (player.synergies.bio_hack && this.hackState.active) {
                                dmg *= 2;
                            }
                            
                            // Frozen Plague: Frozen enemies take +100% bio damage
                            if (player.synergies.cryo_bio && this.cryoState.frozenTimer > 0) {
                                dmg *= 2;
                            }
                        }
                        
                        // ABSOLUTE GUARANTEE: No NaN can pass
                        if (!dmg || isNaN(dmg) || dmg <= 0) {
                            dmg = player.damage * 0.5; // Fallback to flat damage
                        }
                        
                        this.takeDamage(dmg, '#00cc44', false, 'dot', this.bioState.sourceWeapon, 'bio');
                        if(seededRandom()<0.3) entities.particles.push(new Particle(this.x, this.y, '#00cc44', 0.3));
                        
                        // Bio armor reduction: Each tick reduces armor by 2% (5s duration with ~12-16 ticks = 24-32% total reduction)
                        if (this.armor && this.armor > 0) {
                            this.armor = Math.max(0, this.armor * 0.98); // 2% reduction per tick
                        }
                        
                        // Bioshock: Every 3rd bio tick triggers volt chain
                        if (!this.bioState.tickCount) this.bioState.tickCount = 0;
                        this.bioState.tickCount++;
                        if (player.synergies.volt_bio && this.bioState.tickCount % 3 === 0) {
                            player.chainVolt(this, player.damage * 0.5, 0, 1);
                        }
                        
                        // Meltdown: Bio ticks apply 50% pyro
                        if (player.synergies.pyro_bio && !this.pyroState.active && seededRandom() < 0.3) {
                            this.pyroState.active = true;
                            this.pyroState.timer = player.elementalMasteries.fire ? 480 : 360;
                            this.pyroState.level = 1;
                            this.pyroState.baseDmg = player.damage * 0.2; // 50% of normal
                        }
                    }
                }
                if (this.hackState.active) {
                    this.hackState.timer -= dt/16;
                    if (this.hackState.timer <= 0) {
                        this.hackState.active = false;
                        
                        // Reset voidwalker hack flag
                        if (this.type === 'voidwalker') {
                            this.hasBeenHacked = false;
                        }
                        
                        // Necrosis: Hack end resets bio duration
                        if (player.synergies.bio_hack && this.bioState.active) {
                            this.bioState.timer = 300; // Reset to full duration
                        }
                        
                        // 25% chance to self-destruct when hack ends
                        if (Math.random() < 0.25) {
                            const explosionRadius = 70;
                            const explosionDamage = this.maxHp * 0.1;
                            
                            // Store position before enemy is destroyed
                            const explodeX = this.x;
                            const explodeY = this.y;
                            
                            // Create explosion visual effect with more particles
                            createExplosion(explodeX, explodeY, '#00ffff', 50);
                            
                            // Add multiple expanding shockwaves for emphasis
                            entities.particles.push(new Shockwave(explodeX, explodeY, explosionRadius * 1.5, '#00ffff'));
                            setTimeout(() => {
                                entities.particles.push(new Shockwave(explodeX, explodeY, explosionRadius * 1.2, '#88ffff'));
                            }, 50);
                            setTimeout(() => {
                                entities.particles.push(new Shockwave(explodeX, explodeY, explosionRadius, '#ffffff'));
                            }, 100);
                            
                            // Add white flash particles for extra impact
                            for (let i = 0; i < 15; i++) {
                                entities.particles.push(particlePool.spawn(explodeX, explodeY, '#ffffff', 2.0));
                            }
                            
                            // ‚ö†Ô∏è REMOVED: Camera shake on self-destruct (was causing screen shake spam)
                            // state.shake = 12;
                            
                            // Damage and knockback all nearby enemies
                            entities.enemies.forEach(enemy => {
                                if (enemy === this || enemy.hp <= 0) return;
                                
                                const dx = enemy.x - explodeX;
                                const dy = enemy.y - explodeY;
                                const distance = Math.sqrt(dx * dx + dy * dy);
                                
                                if (distance < explosionRadius) {
                                    // Apply damage
                                    enemy.takeDamage(explosionDamage, '#00ffff');
                                    
                                    // Apply knockback
                                    const knockbackForce = 8;
                                    const angle = Math.atan2(dy, dx);
                                    enemy.x += Math.cos(angle) * knockbackForce;
                                    enemy.y += Math.sin(angle) * knockbackForce;
                                    
                                    // Enemies move in world space - no clamping needed
                                }
                            });
                            
                            // Kill the self-destructing enemy
                            this.hp = 0;
                            this.takeDamage(0, '#00ffff');
                        }
                        
                        // If enemy was marked to die after hack, kill it now
                        if (this.hackState.diesAfter) {
                            this.hp = 0;
                            this.takeDamage(0, '#00ffff'); // Trigger death
                        }
                    }
                    else {
                        // Splitter hack behavior - ranged attack targeting enemy clusters
                        if (this.type === 'splitter') {
                            // OPTIMIZED: Cache cluster finding - only update every 15 frames
                            if (!this.splitterTargetCache) this.splitterTargetCache = { timer: 0, target: null };
                            this.splitterTargetCache.timer++;
                            
                            if (this.splitterTargetCache.timer >= 15 || !this.splitterTargetCache.target || this.splitterTargetCache.target.hp <= 0) {
                                this.splitterTargetCache.timer = 0;
                                
                                // Find densest enemy cluster (similar to gas grenade/mines)
                                let bestTarget = null;
                                let bestCount = 0;
                                const maxSearchRadius = 400;
                                
                                entities.enemies.forEach(e => {
                                    if (e !== this && e.hp > 0 && !e.hackState.active) {
                                        const distToSplitter = Math.sqrt((e.x - this.x)**2 + (e.y - this.y)**2);
                                        if (distToSplitter > maxSearchRadius) return;
                                        
                                        // Count nearby enemies to this potential target
                                        const nearbyCount = entities.enemies.filter(ne => {
                                            if (ne === this || ne === e || ne.hackState.active || ne.hp <= 0) return false;
                                            const dist = Math.sqrt((ne.x - e.x)**2 + (ne.y - e.y)**2);
                                            return dist < 150; // Cluster detection radius
                                        }).length;
                                        
                                        // Prefer denser clusters, then closer targets
                                        if (nearbyCount > bestCount || 
                                            (nearbyCount === bestCount && (!bestTarget || distToSplitter < Math.sqrt((bestTarget.x - this.x)**2 + (bestTarget.y - this.y)**2)))) {
                                            bestCount = nearbyCount;
                                            bestTarget = e;
                                        }
                                    }
                                });
                                
                                this.splitterTargetCache.target = bestTarget;
                            }
                            
                            const bestTarget = this.splitterTargetCache.target;
                            
                            if (bestTarget) {
                                const dx = bestTarget.x - this.x;
                                const dy = bestTarget.y - this.y;
                                const dist = Math.sqrt(dx*dx + dy*dy);
                                
                                // Keep distance (200-300 range), kite backwards if too close
                                const idealDist = 250;
                                const tooClose = 180;
                                
                                if (dist > idealDist) {
                                    // Move closer
                                    if (dist > 0) { 
                                        this.vx = (dx/dist) * this.speed * 0.8; 
                                        this.vy = (dy/dist) * this.speed * 0.8; 
                                    }
                                } else if (dist < tooClose) {
                                    // Kite backwards
                                    if (dist > 0) { 
                                        this.vx = -(dx/dist) * this.speed * 0.6; 
                                        this.vy = -(dy/dist) * this.speed * 0.6; 
                                    }
                                } else {
                                    // In ideal range - slow down
                                    this.vx *= 0.9;
                                    this.vy *= 0.9;
                                }
                                
                                // Fire projectile at other enemies (FASTER when hacked)
                                this.splitterAttackTimer += dt/16;
                                const hackedFireRate = this.splitterMaxAttackTimer * 0.5; // 2x faster when hacked
                                if (this.splitterAttackTimer >= hackedFireRate && dist < 350) {
                                    const angle = Math.atan2(dy, dx);
                                    
                                    // Create PIERCING projectile targeting enemy cluster
                                    entities.enemyProjectiles.push({
                                        x: this.x,
                                        y: this.y,
                                        vx: Math.cos(angle) * 2.5,
                                        vy: Math.sin(angle) * 2.5,
                                        radius: 9,
                                        color: '#00ffff', // Hacked color (cyan/green)
                                        life: 150,
                                        splitterShot: true,
                                        glowPhase: 0,
                                        targetWasPlayer: false, // Flag: this targets enemies
                                        piercing: true, // NEW: Pierces through all enemies
                                        hitEnemies: new Set(), // Track which enemies we've hit
                                        shooter: this // Track origin enemy for whip deflection
                                    });
                                    
                                    // Visual feedback
                                    for(let i=0; i<8; i++) {
                                        const particleAngle = (Math.PI * 2 / 8) * i;
                                        entities.particles.push(new Particle(
                                            this.x + Math.cos(particleAngle) * 15,
                                            this.y + Math.sin(particleAngle) * 15,
                                            '#00ffff',
                                            1.2
                                        ));
                                    }
                                    
                                    this.splitterAttackTimer = 0;
                                }
                            } else {
                                // No target - wander
                                const dx = player.x - this.x;
                                const dy = player.y - this.y;
                                const dist = Math.sqrt(dx*dx + dy*dy);
                                if (dist > 0) { 
                                    this.vx = (dx/dist) * this.speed * 0.5; 
                                    this.vy = (dy/dist) * this.speed * 0.5; 
                                }
                            }
                            
                            // Move
                            this.x += this.vx * (dt/16);
                            this.y += this.vy * (dt/16);
                            return;
                        }
                        
                        // Special behavior for hacked tanks - charge attack
                        if (this.type === 'tank') {
                            // OPTIMIZED: Cache nearest enemy check - update every 10 frames
                            if (!this.tankTargetCache) this.tankTargetCache = { timer: 0, target: null };
                            this.tankTargetCache.timer++;
                            
                            if (this.tankTargetCache.timer >= 10 || !this.tankTargetCache.target || this.tankTargetCache.target.hp <= 0) {
                                this.tankTargetCache.timer = 0;
                                
                                // Find nearest non-hacked enemy
                                let nearest = null;
                                let nearestDist = Infinity;
                                
                                entities.enemies.forEach(e => {
                                    if (e !== this && e.hp > 0 && !e.hackState.active) {
                                        const dist = Math.sqrt((e.x-this.x)**2 + (e.y-this.y)**2);
                                        if (dist < nearestDist && dist < 600) { // Longer detection range
                                            nearest = e;
                                            nearestDist = dist;
                                        }
                                    }
                                });
                                
                                this.tankTargetCache.target = nearest;
                            }
                            
                            const nearest = this.tankTargetCache.target;
                            
                            if (nearest) {
                                // Initialize charge state if needed
                                if (!this.hackChargeState) this.hackChargeState = 0;
                                
                                if (this.hackChargeState === 0) {
                                    // Start windup
                                    this.hackChargeState = 1;
                                    this.chargeTimer = 15; // 0.25s windup
                                    this.chargeAngle = Math.atan2(nearest.y-this.y, nearest.x-this.x);
                                    this.vx = 0; this.vy = 0;
                                    this.chargeHitEnemies = []; // Track enemies hit in this charge
                                } else if (this.hackChargeState === 1) {
                                    // Windup - track target perfectly
                                    this.chargeTimer -= (dt/16);
                                    this.chargeAngle = Math.atan2(nearest.y - this.y, nearest.x - this.x);
                                    
                                    if (this.chargeTimer <= 0) {
                                        this.hackChargeState = 2;
                                        this.chargeTimer = 25; // Dash duration
                                        const dashSpeed = 16; // Very fast
                                        this.vx = Math.cos(this.chargeAngle) * dashSpeed;
                                        this.vy = Math.sin(this.chargeAngle) * dashSpeed;
                                    }
                                } else if (this.hackChargeState === 2) {
                                    // Dashing - deal collision damage to ALL enemies in path
                                    this.chargeTimer -= (dt/16);
                                    
                                    // Dash trail particles (2 frames = ~0.033s at 60fps)
                                    if (!this.dashParticleTimer) this.dashParticleTimer = 0;
                                    this.dashParticleTimer += dt/16;
                                    if (this.dashParticleTimer >= 2) {
                                        this.dashParticleTimer -= 2;
                                        entities.particles.push(new Particle(this.x, this.y, '#00ffff', 0.6));
                                    }
                                    
                                    // Check collision with all non-hacked enemies
                                    entities.enemies.forEach(e => {
                                        if (e !== this && e.hp > 0 && !e.hackState.active) {
                                            const dist = Math.sqrt((e.x - this.x)**2 + (e.y - this.y)**2);
                                            if (dist < this.radius + e.radius + 10) {
                                                // Only hit each enemy once per charge
                                                if (!this.chargeHitEnemies) this.chargeHitEnemies = [];
                                                if (this.chargeHitEnemies.includes(e)) return; // Already hit this enemy
                                                this.chargeHitEnemies.push(e);
                                                
                                                // Deal collision damage based on target's max HP
                                                const targetMaxHp = e.maxHp || e.hp || 100;
                                                let collisionDmg = targetMaxHp * 0.15; // 15% max HP base (reduced from 20%)
                                                
                                                // MITIGATION: Reduce damage against titans/bosses
                                                if (e.isNexusPrime) {
                                                    collisionDmg *= 0.15; // Only 2.25% max HP against final boss (15% √ó 0.15)
                                                } else if (e.isChampion || e.tier === 'titan') {
                                                    collisionDmg *= 0.30; // Only 4.5% max HP against champions/titans (15% √ó 0.30)
                                                }
                                                
                                                e.takeDamage(collisionDmg, '#00ffff', false, 'normal', null, 'hack');
                                                createExplosion(e.x, e.y, '#00ffff', 10);
                                                entities.particles.push(new Shockwave(e.x, e.y, 80, '#00ffff'));
                                            }
                                        }
                                    });
                                    
                                    // Move during dash
                                    this.x += this.vx * (dt/16);
                                    this.y += this.vy * (dt/16);
                                    
                                    if (this.chargeTimer <= 0) {
                                        this.hackChargeState = 0; // Reset to find new target
                                        this.vx = 0; this.vy = 0;
                                    }
                                }
                            } else {
                                // No target - wander
                                this.hackChargeState = 0;
                                if (seededRandom() < 0.1) {
                                    const angle = seededRandom() * Math.PI * 2;
                                    this.vx = Math.cos(angle) * this.speed;
                                    this.vy = Math.sin(angle) * this.speed;
                                }
                                this.x += this.vx * (dt/16);
                                this.y += this.vy * (dt/16);
                            }
                        } else {
                            // Standard hack behavior for non-tank enemies
                            // Corrupted Circuitry: Hacked enemies emit volt chains every 2s
                            if (player.synergies.volt_hack) {
                                if (!this.hackState.chainTimer) this.hackState.chainTimer = 0;
                                this.hackState.chainTimer += dt/16;
                                if (this.hackState.chainTimer >= 120) { // Every 2 seconds
                                    player.chainVolt(this, player.damage * 0.5, 0, 1);
                                    this.hackState.chainTimer -= 120;
                                }
                            }
                            
                            // Shatter Protocol: Hacked enemies emit freeze pulses every 2s
                            if (player.synergies.cryo_hack) {
                                if (!this.hackState.freezeTimer) this.hackState.freezeTimer = 0;
                                this.hackState.freezeTimer += dt/16;
                                if (this.hackState.freezeTimer >= 120) { // Every 2 seconds
                                    const freezeRangeSq = 100 * 100;
                                    entities.enemies.forEach(e => {
                                        if (e === this || e.hp <= 0 || e.type === 'boss') return;
                                        
                                        // Use squared distance for faster check
                                        const dx = e.x - this.x;
                                        const dy = e.y - this.y;
                                        const distSq = dx*dx + dy*dy;
                                        
                                        if (distSq < freezeRangeSq) {
                                            e.cryoState.frozenTimer = 60; // 1s freeze pulse
                                        }
                                    });
                                    this.hackState.freezeTimer -= 120;
                                }
                            }
                            
                            // Find CLOSEST enemy that's not hacked
                            let nearest = null;
                            let nearestDist = 400; // Max detection range
                        
                        entities.enemies.forEach(e => {
                            if (e !== this && e.hp > 0 && !e.hackState.active) {
                                const dist = Math.sqrt((e.x-this.x)**2 + (e.y-this.y)**2);
                                if (dist < nearestDist) {
                                    nearest = e;
                                    nearestDist = dist;
                                }
                            }
                        });
                        
                        if (nearest) {
                            const dx = nearest.x - this.x; const dy = nearest.y - this.y;
                            const attackRange = this.radius + nearest.radius + 15;
                            
                            // If in attack range, stop and attack
                            if (nearestDist < attackRange) {
                                this.vx = 0;
                                this.vy = 0;
                                // Deal damage every 20 frames (~0.33s at 60fps)
                                if (!this.hackAttackTimer) this.hackAttackTimer = 0;
                                this.hackAttackTimer += dt/16;
                                
                                if (this.hackAttackTimer >= 20) {
                                    // Scale damage to target's max HP: 5% per tick (7.5% with mastery)
                                    const targetMaxHp = nearest.maxHp || nearest.hp || 100;
                                    const hpPercent = player.elementalMasteries.hack ? 0.075 : 0.05;
                                    const hackDmg = targetMaxHp * hpPercent;
                                    nearest.takeDamage(hackDmg, '#00ffff', false, 'normal', null, 'hack'); // Add hack element icon
                                    this.hackAttackTimer -= 20;
                                }
                                
                                // Visual feedback (4 frames = ~0.067s at 60fps)
                                if (!this.hackParticleTimer) this.hackParticleTimer = 0;
                                this.hackParticleTimer += dt/16;
                                if (this.hackParticleTimer >= 4) {
                                    this.hackParticleTimer -= 4;
                                    entities.particles.push(new Particle(nearest.x, nearest.y, '#00ffff', 1.0));
                                }
                            } else {
                                // Reset attack timer when moving
                                this.hackAttackTimer = 0;
                                // Move toward target
                                this.vx = (dx/nearestDist) * this.speed * 2.0;
                                this.vy = (dy/nearestDist) * this.speed * 2.0;
                            }
                        } else {
                            // Random wander if no target
                            if (seededRandom() < 0.1) { 
                                const angle = seededRandom() * Math.PI * 2; 
                                this.vx = Math.cos(angle) * this.speed; 
                                this.vy = Math.sin(angle) * this.speed; 
                            }
                        }
                        this.x += this.vx * (dt/16); this.y += this.vy * (dt/16);
                        } // Close else block for non-tank hack behavior
                        return;
                    }
                }

                // EMP State: Enemy is completely disabled
                if (this.empState.active) {
                    this.empState.timer -= dt/16;
                    if (this.empState.timer <= 0) {
                        this.empState.active = false;
                    } else {
                        // Completely immobilized - don't move at all
                        return;
                    }
                }
                
                // Ion State: Enemy takes +30% damage from all sources
                if (this.ionState.active) {
                    this.ionState.timer -= dt/16;
                    if (this.ionState.timer <= 0) {
                        this.ionState.active = false;
                    }
                }

                // Repulser: Strong push away from player
                if (player.repulserActive) {
                    const dx = this.x - player.x;
                    const dy = this.y - player.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    if (dist < 300) { // Push radius
                        const pushStrength = (300 - dist) / 300; // Stronger when closer
                        const pushForce = 20 * pushStrength; // Very strong push
                        this.pushX = (dx/dist) * pushForce;
                        this.pushY = (dy/dist) * pushForce;
                    }
                }

                // VOIDWALKER BEHAVIOR - Phase-based teleporting bomb
                if (this.type === 'voidwalker') {
                    this.pulsePhase += 0.15 * (dt/16);
                    
                    // IMMEDIATE TELEPORT WHEN HACKED
                    if (this.hackState.active && !this.hasBeenHacked) {
                        this.hasBeenHacked = true; // Flag to prevent repeated teleports
                        
                        // Find densest enemy cluster
                        let bestTarget = null;
                        let bestCount = 0;
                        
                        entities.enemies.forEach(e => {
                            if (e !== this && e.hp > 0 && !e.hackState.active) {
                                const nearbyCount = entities.enemies.filter(ne => {
                                    if (ne === this || ne === e || ne.hackState.active || ne.hp <= 0) return false;
                                    const dist = Math.sqrt((ne.x - e.x)**2 + (ne.y - e.y)**2);
                                    return dist < 120;
                                }).length;
                                
                                if (nearbyCount > bestCount) {
                                    bestCount = nearbyCount;
                                    bestTarget = e;
                                }
                            }
                        });
                        
                        if (bestTarget) {
                            // Teleport to cluster center
                            const angle = seededRandom() * Math.PI * 2;
                            this.x = bestTarget.x + Math.cos(angle) * 20;
                            this.y = bestTarget.y + Math.sin(angle) * 20;
                            
                            // Force countdown state
                            this.phaseState = 'countdown';
                            this.countdownTimer = 60; // 1 second
                            this.opacity = 1.0;
                            this.warningCircleRadius = 0;
                            this.driftTarget = bestTarget;
                            
                            // Visual feedback
                            createExplosion(this.x, this.y, '#00ff00', 30);
                            entities.particles.push(new Shockwave(this.x, this.y, 80, '#00ff00'));
                        }
                    }
                    
                    // PHASE STATE MACHINE
                    if (this.phaseState === 'phased') {
                        // PHASED OUT - Invulnerable, drifting toward target
                        this.opacity = 0.3; // Semi-transparent
                        
                        // Determine target (player or enemy cluster if hacked)
                        let target = player;
                        if (this.hackState.active) {
                            // Find densest enemy cluster
                            let bestTarget = null;
                            let bestCount = 0;
                            
                            entities.enemies.forEach(e => {
                                if (e !== this && e.hp > 0 && !e.hackState.active) {
                                    const nearbyCount = entities.enemies.filter(ne => {
                                        if (ne === this || ne === e || ne.hackState.active || ne.hp <= 0) return false;
                                        const dist = Math.sqrt((ne.x - e.x)**2 + (ne.y - e.y)**2);
                                        return dist < 120;
                                    }).length;
                                    
                                    if (nearbyCount > bestCount) {
                                        bestCount = nearbyCount;
                                        bestTarget = e;
                                    }
                                }
                            });
                            
                            if (bestTarget) target = bestTarget;
                        }
                        
                        this.driftTarget = target;
                        
                        // Slow drift toward target
                        const dx = target.x - this.x;
                        const dy = target.y - this.y;
                        const dist = Math.sqrt(dx*dx + dy*dy);
                        if (dist > 0) {
                            const driftSpeed = 0.4;
                            this.vx = (dx/dist) * driftSpeed;
                            this.vy = (dy/dist) * driftSpeed;
                        }
                        
                        // Count down phase timer
                        this.phaseTimer -= dt/16;
                        
                        if (this.phaseTimer <= 0) {
                            // MATERIALIZE!
                            this.phaseState = 'countdown';
                            
                            // Materialize at random point within range of target
                            const angle = seededRandom() * Math.PI * 2;
                            const distance = this.materializeRange[0] + seededRandom() * (this.materializeRange[1] - this.materializeRange[0]);
                            
                            // For hacked voidwalkers, materialize closer (center of cluster)
                            if (this.hackState.active && target !== player) {
                                this.x = target.x + Math.cos(angle) * 20; // Very close to cluster center
                                this.y = target.y + Math.sin(angle) * 20;
                                this.countdownTimer = 60; // 1 second for hacked
                            } else {
                                this.x = target.x + Math.cos(angle) * distance;
                                this.y = target.y + Math.sin(angle) * distance;
                                this.countdownTimer = 120; // 2 seconds for normal
                            }
                            
                            this.opacity = 1.0; // Fully visible
                            this.warningCircleRadius = 0;
                            
                            // Visual/audio feedback
                            createExplosion(this.x, this.y, this.hackState.active ? '#00ff00' : '#9933ff', 20);
                            entities.particles.push(new Shockwave(this.x, this.y, 60, this.hackState.active ? '#00ff00' : '#9933ff'));
                        }
                    } 
                    
                    // COUNTDOWN STATE (note: not else if, so it can run same frame after hack teleport)
                    if (this.phaseState === 'countdown') {
                        // COUNTDOWN - Vulnerable, drifting toward target, warning circle
                        this.opacity = 1.0; // Fully visible and vulnerable
                        
                        // Slow drift toward target
                        if (this.driftTarget) {
                            const dx = this.driftTarget.x - this.x;
                            const dy = this.driftTarget.y - this.y;
                            const dist = Math.sqrt(dx*dx + dy*dy);
                            if (dist > 0) {
                                const driftSpeed = 0.6;
                                this.vx = (dx/dist) * driftSpeed;
                                this.vy = (dy/dist) * driftSpeed;
                            }
                        }
                        
                        // Animate warning circle
                        const maxTimer = this.hackState.active ? 60 : 120;
                        const progress = 1 - (this.countdownTimer / maxTimer);
                        this.warningCircleRadius = this.blastRadius * (0.8 + Math.sin(progress * Math.PI * 8) * 0.2);
                        
                        // Countdown
                        this.countdownTimer -= dt/16;
                        
                        if (this.countdownTimer <= 0) {
                            // DETONATE!
                            this.triggerDetonation();
                            this.hp = 0; // Kill self
                            return; // Don't continue update
                        }
                    }
                }

                if (this.type === 'tank' || (this.type === 'boss' && this.chargeState > 0)) {
                    if (this.chargeState === 0) {
                        // TANK MOVEMENT (Slow chase)
                        const dist = Math.sqrt((player.x - this.x)**2 + (player.y - this.y)**2);
                        this.vx = ((player.x - this.x)/dist) * this.speed;
                        this.vy = ((player.y - this.y)/dist) * this.speed;
                        
                        const triggerDist = this.type === 'boss' ? 500 : 400;
                        const chance = this.type === 'boss' ? 0.05 : 0.01;
                        if (dist < triggerDist && dist > 100 && seededRandom() < chance) {
                            this.chargeState = 1; this.chargeTimer = (this.type==='boss') ? 60 : 40; // Boss: 60 frames (1s), Tank: 40 frames - increased for more reaction time
                            this.chargeTarget = {x:player.x, y:player.y};
                            this.chargeAngle = Math.atan2(player.y-this.y, player.x-this.x);
                            this.vx=0; this.vy=0;
                        }
                    }
                    else if (this.chargeState === 1) {
                        this.chargeTimer -= (dt/16);
                        const targetAngle = Math.atan2(player.y - this.y, player.x - this.x);
                        let diff = targetAngle - this.chargeAngle;
                        while (diff <= -Math.PI) diff += Math.PI*2; while (diff > Math.PI) diff -= Math.PI*2;
                        
                        // Decay Tracking (Lazy Lock)
                        const maxTimer = (this.type==='boss') ? 60 : 40; // Updated boss timer
                        const trackCutoff = maxTimer * 0.3; 
                        let trackStrength = 0;
                        if(this.chargeTimer > trackCutoff) {
                            trackStrength = 0.1 * ((this.chargeTimer - trackCutoff) / (maxTimer - trackCutoff));
                        }
                        this.chargeAngle += diff * trackStrength;


                        if (this.chargeTimer <= 0) {
                            this.chargeState = 2; this.chargeTimer = (this.type === 'boss') ? 20 : 30; // Boss: 20 frames (reduced from 30 to prevent off-screen)
                            const dashSpeed = this.type === 'boss' ? 24 : 12; // Boss speed: 24 (reduced from 28 for more forgiving dodging)
                            this.vx = Math.cos(this.chargeAngle)*dashSpeed; this.vy = Math.sin(this.chargeAngle)*dashSpeed;
                        }
                    }
                    else if (this.chargeState === 2) {
                        this.chargeTimer -= (dt/16);
                        // Spawn particles every ~50ms (3 frames at 60fps)
                        if (!this.particleSpawnTimer) this.particleSpawnTimer = 0;
                        this.particleSpawnTimer += (dt/16);
                        if (this.particleSpawnTimer >= 3) {
                            this.particleSpawnTimer -= 3;
                            entities.particles.push(new Particle(this.x, this.y, '#ffaa00', 0.5));
                        }
                        if (this.chargeTimer <= 0) { 
                            this.chargeState = 3; 
                            this.chargeTimer = 420; // 7s CD
                            this.vx=0; this.vy=0; 
                        }
                    }
                    else if (this.chargeState === 3) {
                        this.chargeTimer -= (dt/16);
                        // MOVEMENT DURING COOLDOWN
                        const dist = Math.sqrt((player.x - this.x)**2 + (player.y - this.y)**2);
                        this.vx = ((player.x - this.x)/dist) * this.speed;
                        this.vy = ((player.y - this.y)/dist) * this.speed;
                        if (this.chargeTimer <= 0) this.chargeState = 0;
                    }
                } 
                
                if (this.type === 'boss' || this.isChampion) {
                    state.bossTimer += dt/16;
                    
                    // Update individual health bar for this champion
                    if (this.isChampion && this.championId) {
                        const titanIndex = parseInt(this.championId.split('_')[1]);
                        const barElement = document.getElementById(`boss-bar-${titanIndex}`);
                        if (barElement) {
                            const hpPercent = (this.hp / this.maxHp * 100);
                            barElement.style.width = hpPercent + '%';
                        }
                    }
                    
                    // Champions have orange health bar, bosses have red/magenta
                    if (this.isChampion) {
                        // TITAN CHAMPION AI
                        if (this.championType === 'TITAN') {
                            const distToPlayer = Math.sqrt((player.x - this.x)**2 + (player.y - this.y)**2);
                            
                            // Attack cooldown ticker
                            if (this.attackCooldown > 0) {
                                this.attackCooldown -= dt/16;
                            }
                            
                            // STATE MACHINE
                            if (this.attackState === 'idle') {
                                // Calculate movement toward player
                                let moveX = 0, moveY = 0;
                                
                                // CATCHUP MECHANIC: Speed boost when too far from player
                                let speedMultiplier = 1.0;
                                const maxComfortableDistance = 800; // Max distance before catching up
                                const urgentDistance = 1200; // Very far - need to catch up fast
                                
                                if (distToPlayer > urgentDistance) {
                                    speedMultiplier = 3.0; // 3x speed when very far
                                } else if (distToPlayer > maxComfortableDistance) {
                                    // Gradual speed increase from 1x to 3x
                                    const ratio = (distToPlayer - maxComfortableDistance) / (urgentDistance - maxComfortableDistance);
                                    speedMultiplier = 1.0 + (ratio * 2.0); // 1x ‚Üí 3x
                                }
                                
                                if (distToPlayer > 0) {
                                    moveX = ((player.x - this.x) / distToPlayer) * this.speed * speedMultiplier;
                                    moveY = ((player.y - this.y) / distToPlayer) * this.speed * speedMultiplier;
                                }
                                
                                // TITAN-TO-TITAN REPULSION - Spread out to surround player
                                // Only apply repulsion when not too far from player
                                let repelX = 0, repelY = 0;
                                if (distToPlayer < maxComfortableDistance) {
                                    const minTitanDistance = 200; // TITANs try to stay this far apart
                                    
                                    // OPTIMIZED: Cache titan repulsion check - only update every 5 frames
                                    if (!this.titanRepulsionCache) this.titanRepulsionCache = { timer: 0, repelX: 0, repelY: 0 };
                                    this.titanRepulsionCache.timer++;
                                    
                                    if (this.titanRepulsionCache.timer >= 5) {
                                        this.titanRepulsionCache.timer = 0;
                                        let cachedRepelX = 0, cachedRepelY = 0;
                                        
                                        entities.enemies.forEach(other => {
                                            if (other === this || !other.isChampion || other.hp <= 0) return;
                                            
                                            const dx = this.x - other.x;
                                            const dy = this.y - other.y;
                                            const dist = Math.sqrt(dx*dx + dy*dy);
                                            
                                            if (dist < minTitanDistance && dist > 0) {
                                                // Push away from other TITANs
                                                const repelStrength = (minTitanDistance - dist) / minTitanDistance;
                                                cachedRepelX += (dx / dist) * repelStrength * this.speed * 2.0;
                                                cachedRepelY += (dy / dist) * repelStrength * this.speed * 2.0;
                                            }
                                        });
                                        
                                        this.titanRepulsionCache.repelX = cachedRepelX;
                                        this.titanRepulsionCache.repelY = cachedRepelY;
                                    }
                                    
                                    repelX = this.titanRepulsionCache.repelX;
                                    repelY = this.titanRepulsionCache.repelY;
                                }
                                
                                // Combine movement toward player + repulsion from other TITANs
                                this.vx = moveX + repelX;
                                this.vy = moveY + repelY;
                                
                                // Pick next attack when ready and close enough to player
                                if (this.attackCooldown <= 0 && distToPlayer < 500) {
                                    // Choose random attack
                                    const attacks = ['charge', 'slam', 'spin'];
                                    this.currentAttack = attacks[Math.floor(seededRandom() * attacks.length)];
                                    this.attackState = 'telegraph';
                                    
                                    // Set telegraph duration and type
                                    if (this.currentAttack === 'charge') {
                                        this.telegraphTimer = 60; // 1 second (reduced from 90 for harder dodging)
                                        this.telegraphType = 'line'; // Changed from cone to line
                                        this.telegraphAngle = Math.atan2(player.y - this.y, player.x - this.x);
                                        this.telegraphRadius = 220; // Charge distance (reduced from 300)
                                    } else if (this.currentAttack === 'slam') {
                                        this.telegraphTimer = 90; // 1.5 seconds (increased from 60 for more warning)
                                        this.telegraphType = 'circle';
                                        this.telegraphRadius = 190; // Show max radius (increased from 180)
                                        this.slamHitCount = 0; // Track which slam we're on (0, 1, 2)
                                    } else if (this.currentAttack === 'spin') {
                                        this.telegraphTimer = 75; // 1.25 seconds (increased from 48 for charge-up feeling)
                                        this.telegraphType = 'circle';
                                        this.telegraphRadius = 140; // Spin range (increased from 120)
                                    }
                                    
                                    this.vx = 0;
                                    this.vy = 0;
                                }
                            }
                            else if (this.attackState === 'telegraph') {
                                // Show warning, don't move
                                this.vx = 0;
                                this.vy = 0;
                                
                                this.telegraphTimer -= dt/16;
                                
                                // Execute attack when telegraph ends
                                if (this.telegraphTimer <= 0) {
                                    this.attackState = 'attacking';
                                    
                                    // Store radius before clearing telegraph type
                                    this.attackRadius = this.telegraphRadius;
                                    
                                    // DON'T clear telegraph for slam - keep rings visible during execution
                                    if (this.currentAttack !== 'slam') {
                                        this.telegraphType = null;
                                    }
                                    
                                    // Execute attack
                                    if (this.currentAttack === 'charge') {
                                        // Dash forward - ignore collision during charge
                                        this.attackTimer = 30; // Dash duration (0.5s)
                                        const dashSpeed = 18;
                                        this.vx = Math.cos(this.telegraphAngle) * dashSpeed;
                                        this.vy = Math.sin(this.telegraphAngle) * dashSpeed;
                                        this.ignoreCollision = true; // Pass through enemies
                                    } else if (this.currentAttack === 'slam') {
                                        // Ground slam - 3 HITS with increasing radius
                                        this.attackTimer = 80; // Total duration for all 3 slams (was 30)
                                        this.slamHitCount = 0; // Start with first slam
                                        
                                        // Execute first slam immediately
                                        this.executeSlamHit(distToPlayer);
                                        
                                        // Schedule second and third slams
                                        setTimeout(() => {
                                            if (this.hp > 0 && this.currentAttack === 'slam') {
                                                this.slamHitCount = 1;
                                                const dist = Math.sqrt((player.x - this.x)**2 + (player.y - this.y)**2);
                                                this.executeSlamHit(dist);
                                            }
                                        }, 400); // 0.4s after first
                                        
                                        setTimeout(() => {
                                            if (this.hp > 0 && this.currentAttack === 'slam') {
                                                this.slamHitCount = 2;
                                                const dist = Math.sqrt((player.x - this.x)**2 + (player.y - this.y)**2);
                                                this.executeSlamHit(dist);
                                            }
                                        }, 800); // 0.8s after first
                                        
                                    } else if (this.currentAttack === 'spin') {
                                        // Spin attack - extended duration, moves through enemies
                                        this.attackTimer = 90; // Spin duration (1.5 seconds - was 60)
                                        this.spinAngle = 0; // Track spin rotation
                                        this.ignoreCollision = true; // Pass through enemies while spinning
                                        
                                        // Initial damage
                                        entities.enemies.forEach(e => {
                                            if (e === this) return;
                                            const dist = Math.sqrt((e.x - this.x)**2 + (e.y - this.y)**2);
                                            if (dist < this.attackRadius) {
                                                e.takeDamage(this.dmg, '#ff3300', false, 'normal');
                                            }
                                        });
                                        
                                        if (distToPlayer < this.attackRadius) {
                                            player.takeHit(this.dmg, 'Champion Spin Attack', 'TITAN');
                                        }
                                    }
                                }
                            }
                            else if (this.attackState === 'attacking') {
                                this.attackTimer -= dt/16;
                                
                                // Movement during attacks
                                if (this.currentAttack === 'charge') {
                                    // Charge dash continues at full speed
                                } else if (this.currentAttack === 'spin') {
                                    // Spin: Move toward player at 130% speed while spinning - faster than normal!
                                    const dx = player.x - this.x;
                                    const dy = player.y - this.y;
                                    const dist = Math.sqrt(dx*dx + dy*dy);
                                    if (dist > 0) {
                                        this.vx = (dx / dist) * this.speed * 1.3;
                                        this.vy = (dy / dist) * this.speed * 1.3;
                                    }
                                } else {
                                    // Slam is stationary
                                    this.vx = 0;
                                    this.vy = 0;
                                }
                                
                                // SPIN ATTACK - Continuous visual and damage
                                if (this.currentAttack === 'spin') {
                                    // Update spin angle for visual (faster spin - was 0.5)
                                    this.spinAngle += 1.2;
                                    
                                    // Continuous damage ticks every 5 frames
                                    if (Math.floor(this.attackTimer) % 5 === 0) {
                                        if (distToPlayer < this.attackRadius) {
                                            player.takeHit(this.dmg * 0.3, 'Champion Spin Attack (DoT)', 'TITAN');
                                        }
                                        
                                        // Spawn spinning blade particles continuously
                                        for (let i = 0; i < 6; i++) {
                                            const angle = (Math.PI * 2 / 6) * i + this.spinAngle;
                                            entities.particles.push(new Particle(
                                                this.x + Math.cos(angle) * this.attackRadius,
                                                this.y + Math.sin(angle) * this.attackRadius,
                                                '#ff3300',
                                                1.5
                                            ));
                                        }
                                    }
                                }
                                
                                if (this.attackTimer <= 0) {
                                    this.attackState = 'idle';
                                    this.vx = 0;
                                    this.vy = 0;
                                    
                                    // Clear attack flags
                                    this.telegraphType = null;
                                    this.ignoreCollision = false; // Re-enable collision
                                    
                                    // Set cooldown based on attack (MUCH SHORTER - 2-4 seconds)
                                    if (this.currentAttack === 'charge') this.attackCooldown = 120; // 2s (was 5s)
                                    else if (this.currentAttack === 'slam') this.attackCooldown = 180; // 3s (was 8s)
                                    else if (this.currentAttack === 'spin') this.attackCooldown = 240; // 4s (was 12s)
                                }
                            }
                        }
                    } else {
                        // Change health bar color in phase 2 (boss only)
                        if (this.phase === 2) {
                            document.getElementById('boss-bar').style.background = '#ff00ff';
                            document.getElementById('boss-bar').style.boxShadow = '0 0 20px #ff00ff';
                        }
                    }
                    
                    // PHASE 2 TRANSITION at 50% HP (boss only, not champion)
                    if (!this.isChampion && this.hp <= this.maxHp * 0.5 && !this.phase2Triggered) {
                        this.phase2Triggered = true;
                        this.phase = 2;
                        this.color = '#ff00ff'; // Change to magenta in phase 2
                        
                        // Add phase 2 abilities to pool
                        this.abilities = [...this.abilities, ...this.phase2Abilities];
                        
                        // Summon 5 elite drones
                        for (let i = 0; i < 5; i++) {
                            const angle = (i / 5) * Math.PI * 2;
                            const spawnDist = 150;
                            const spawnX = this.x + Math.cos(angle) * spawnDist;
                            const spawnY = this.y + Math.sin(angle) * spawnDist;
                            const elite = new Enemy('drone');
                            elite.x = spawnX;
                            elite.y = spawnY;
                            elite.hp *= 1.5; // Elite drones are 50% tougher
                            elite.maxHp = elite.hp;
                            elite.color = '#ff00ff'; // Match boss phase 2 color
                            entities.enemies.push(elite);
                        }
                        
                        // Visual effect
                        for (let i = 0; i < 30; i++) {
                            entities.particles.push(new Particle(this.x, this.y, '#ff00ff', 2.0));
                        }
                        createExplosion(this.x, this.y, '#ff00ff', 60);
                    }
                    
                    // State Machine (BOSS ONLY - not champions)
                    if (!this.isChampion && this.actionState === 'cooldown') {
                        // Movement during cooldown: Chase slowly
                        const dx = player.x - this.x; const dy = player.y - this.y;
                        const dist = Math.sqrt(dx*dx + dy*dy);
                        this.vx = (dx/dist) * this.speed * 0.5; 
                        this.vy = (dy/dist) * this.speed * 0.5;
                        
                        this.actionTimer -= (dt/16);
                        if (this.actionTimer <= 0) {
                            // Pick Attack from Random Pool
                            this.actionState = 'attacking';
                            this.currentAttack = this.abilities[Math.floor(seededRandom() * this.abilities.length)];


                            if (this.currentAttack === 2) { // Charge
                                this.chargeState = 1; this.chargeTimer = 60; // Updated to match new timing
                                this.chargeAngle = Math.atan2(player.y-this.y, player.x-this.x);
                                this.vx = 0; this.vy = 0;
                                this.actionTimer = 200; 
                            } else {
                                this.actionTimer = 240; // Attack Duration
                            }
                        }
                    } else if (!this.isChampion && this.actionState === 'attacking') {
                        this.actionTimer -= (dt/16);
                        
                        if (this.currentAttack === 0) { // Spiral - Reduced density
                            this.vx *= 0.9; this.vy *= 0.9;
                            if (Math.floor(this.actionTimer) % 12 === 0) {
                                const spiralAngle = this.actionTimer * 0.2;
                                for(let k=0; k<2; k++) {
                                     const ang = spiralAngle + (k * (Math.PI*2/2));
                                     entities.enemyProjectiles.push({ x: this.x, y: this.y, vx: Math.cos(ang)*5, vy: Math.sin(ang)*5, radius: 8, color: '#ff00ff', life: 200, shooter: this });
                                }
                            }
                        } else if (this.currentAttack === 1) { // Nova - Reduced frequency
                            this.vx = 0; this.vy = 0;
                            if (Math.floor(this.actionTimer) % 100 === 0) {
                                for(let k=0; k<12; k++) {
                                    const ang = (k * (Math.PI*2/12));
                                    entities.enemyProjectiles.push({ x: this.x, y: this.y, vx: Math.cos(ang)*4, vy: Math.sin(ang)*4, radius: 10, color: '#ff5500', life: 200, shooter: this });
                                }
                            }
                        } else if (this.currentAttack === 2) { // Charge
                            if (this.chargeState === 0) this.actionTimer = 0;
                        } else if (this.currentAttack === 3) { // Laser Sweep
                             this.vx = 0; this.vy = 0;
                             if (Math.floor(this.actionTimer) % 8 === 0) {
                                 const ang = Math.sin(this.actionTimer * 0.1) + Math.atan2(player.y-this.y, player.x-this.x);
                                 entities.enemyProjectiles.push({ x: this.x, y: this.y, vx: Math.cos(ang)*8, vy: Math.sin(ang)*8, radius: 6, color: '#00ffff', life: 150, shooter: this });
                             }
                        } else if (this.currentAttack === 4) { // Minion Summon
                             if (Math.floor(this.actionTimer) % 60 === 0) {
                                 entities.enemies.push(new Enemy('drone'));
                                 entities.enemies.push(new Enemy('drone'));
                             }
                        } else if (this.currentAttack === 5) { // Shotgun Burst (fair - telegraphed)
                             this.vx *= 0.95; this.vy *= 0.95;
                             if (Math.floor(this.actionTimer) % 40 === 0) { // Every 40 frames
                                 const toPlayer = Math.atan2(player.y - this.y, player.x - this.x);
                                 for(let k=-2; k<=2; k++) { // 5-way spread
                                     const spread = k * 0.3; // 0.3 rad spread
                                     const ang = toPlayer + spread;
                                     entities.enemyProjectiles.push({ x: this.x, y: this.y, vx: Math.cos(ang)*6, vy: Math.sin(ang)*6, radius: 8, color: '#ff9900', life: 180, shooter: this });
                                 }
                             }
                        } else if (this.currentAttack === 6) { // Ring Pulse (fair - expands outward)
                             this.vx = 0; this.vy = 0;
                             if (Math.floor(this.actionTimer) % 80 === 0) { // Less frequent
                                 for(let k=0; k<8; k++) { // 8 bullets in ring
                                     const ang = (k * (Math.PI*2/8));
                                     entities.enemyProjectiles.push({ x: this.x, y: this.y, vx: Math.cos(ang)*3, vy: Math.sin(ang)*3, radius: 9, color: '#00ffff', life: 200 });
                                 }
                             }
                        } else if (this.currentAttack === 7) { // Homing Shots (fair - slow)
                             this.vx *= 0.9; this.vy *= 0.9;
                             if (Math.floor(this.actionTimer) % 50 === 0) {
                                 const toPlayer = Math.atan2(player.y - this.y, player.x - this.x);
                                 entities.enemyProjectiles.push({ 
                                     x: this.x, y: this.y, 
                                     vx: Math.cos(toPlayer)*2, vy: Math.sin(toPlayer)*2, 
                                     radius: 7, color: '#ff00aa', life: 250,
                                     homing: true // Flag for homing behavior
                                 });
                             }
                        } else if (this.currentAttack === 8) { // Barrage - Rapid fire straight at player
                             this.vx = 0; this.vy = 0;
                             if (Math.floor(this.actionTimer) % 6 === 0) { // Very rapid
                                 const toPlayer = Math.atan2(player.y - this.y, player.x - this.x);
                                 const spread = (seededRandom() - 0.5) * 0.2; // Small random spread
                                 entities.enemyProjectiles.push({ 
                                     x: this.x, y: this.y, 
                                     vx: Math.cos(toPlayer + spread)*7, 
                                     vy: Math.sin(toPlayer + spread)*7, 
                                     radius: 6, color: '#ffff00', life: 150
                                 });
                             }
                        } else if (this.currentAttack === 9) { // Meteor Rain - Telegraphed danger zones
                             this.vx *= 0.95; this.vy *= 0.95;
                             if (Math.floor(this.actionTimer) % 50 === 0) { // Reduced frequency (was 30, now 50)
                                 // Spawn 2 meteors instead of constant spam
                                 for(let m = 0; m < 2; m++) {
                                     const targetX = player.x + (seededRandom() - 0.5) * 250;
                                     const targetY = player.y + (seededRandom() - 0.5) * 250;
                                     
                                     // Create warning marker that persists
                                     const warningMarker = {
                                         x: targetX,
                                         y: targetY,
                                         life: 60, // 1 second warning (increased from 500ms)
                                         maxLife: 60,
                                         radius: 50, // Impact radius
                                         isMeteorWarning: true
                                     };
                                     
                                     entities.enemyProjectiles.push(warningMarker);
                                     
                                     // After warning, create impact
                                     setTimeout(() => {
                                         // Only 4 projectiles instead of 8 (50% reduction)
                                         for(let k=0; k<4; k++) {
                                             const ang = (k * (Math.PI*2/4));
                                             entities.enemyProjectiles.push({ 
                                                 x: targetX, y: targetY, 
                                                 vx: Math.cos(ang)*3, // Slower (was 4)
                                                 vy: Math.sin(ang)*3, 
                                                 radius: 8, // Smaller (was 10)
                                                 color: '#ff8800', 
                                                 life: 120 // Shorter range (was 180)
                                             });
                                         }
                                         // Impact explosion visual
                                         createExplosion(targetX, targetY, '#ff8800', 12);
                                     }, 1000); // Full 1 second warning (was 500ms)
                                 }
                             }
                        }


                        if (this.actionTimer <= 0) {
                            this.actionState = 'cooldown';
                            this.actionTimer = 120; // 2s Cooldown
                        }
                    }
                } else if (this.type !== 'tank') {
                    // SPLITTER: Ranged attacker - stops and fires
                    if (this.type === 'splitter') {
                        // BARRIER STUN: Stunned splitters don't move or attack
                        if (this.barrierStunTimer && this.barrierStunTimer > 0) {
                            this.barrierStunTimer -= dt/16;
                            if (this.barrierStunTimer < 0) this.barrierStunTimer = 0;
                            this.vx = 0;
                            this.vy = 0;
                        } else {
                            const targetIsPlayer = !this.hackState.active;
                            let target = targetIsPlayer ? player : null;
                            
                            // If hacked, find nearest non-hacked enemy
                            if (!targetIsPlayer) {
                                target = entities.enemies.find(e => 
                                    e !== this && 
                                    e.hp > 0 && 
                                    !e.hackState.active &&
                                    Math.sqrt((e.x - this.x)**2 + (e.y - this.y)**2) < 400
                                );
                            }
                        
                        if (target) {
                            const dx = target.x - this.x;
                            const dy = target.y - this.y;
                            const dist = Math.sqrt(dx*dx + dy*dy);
                            
                            // Keep distance (200-300 range), kite backwards if too close
                            const idealDist = 250;
                            const tooClose = 180;
                            
                            if (dist > idealDist) {
                                // Move closer
                                if (dist > 0) { 
                                    this.vx = (dx/dist) * this.speed * 0.8; 
                                    this.vy = (dy/dist) * this.speed * 0.8; 
                                }
                            } else if (dist < tooClose) {
                                // Kite backwards
                                if (dist > 0) { 
                                    this.vx = -(dx/dist) * this.speed * 0.6; 
                                    this.vy = -(dy/dist) * this.speed * 0.6; 
                                }
                            } else {
                                // In ideal range - slow down
                                this.vx *= 0.9;
                                this.vy *= 0.9;
                            }
                            
                            // Fire projectile
                            this.splitterAttackTimer += dt/16;
                            if (this.splitterAttackTimer >= this.splitterMaxAttackTimer && dist < 350) {
                                const angle = Math.atan2(dy, dx);
                                
                                // Create a large, slow, VERY visible projectile
                                entities.enemyProjectiles.push({
                                    x: this.x,
                                    y: this.y,
                                    vx: Math.cos(angle) * 2.5, // Slow speed for reaction time (reduced from 3.5)
                                    vy: Math.sin(angle) * 2.5,
                                    radius: 9, // Reduced from 14 - still visible but not confusing
                                    color: '#ff9500', // Matches splitter orange color
                                    life: 150, // Reduced from 250 - travels less distance
                                    splitterShot: true, // Flag for special rendering
                                    glowPhase: 0, // For pulsing glow effect
                                    targetWasPlayer: targetIsPlayer, // Track what it was shot at
                                    shooter: this // Track origin enemy for whip deflection
                                });
                                
                                // Visual feedback - charging effect
                                for(let i=0; i<8; i++) {
                                    const particleAngle = (Math.PI * 2 / 8) * i;
                                    entities.particles.push(new Particle(
                                        this.x + Math.cos(particleAngle) * 15,
                                        this.y + Math.sin(particleAngle) * 15,
                                        '#ff9500',
                                        1.2
                                    ));
                                }
                                
                                this.splitterAttackTimer = 0;
                            }
                        } else {
                            // No target - wander
                            const dx = player.x - this.x;
                            const dy = player.y - this.y;
                            const dist = Math.sqrt(dx*dx + dy*dy);
                            if (dist > 0) { 
                                this.vx = (dx/dist) * this.speed * 0.5; 
                                this.vy = (dy/dist) * this.speed * 0.5; 
                            }
                        }
                        } // End stun check
                    } else {
                        // Regular enemy movement (drone, swarm)
                        // BARRIER STUN: Stunned enemies don't move toward player
                        if (this.barrierStunTimer && this.barrierStunTimer > 0) {
                            this.barrierStunTimer -= dt/16;
                            // Clamp to 0 when expired
                            if (this.barrierStunTimer < 0) this.barrierStunTimer = 0;
                            this.vx = 0;
                            this.vy = 0;
                        } else {
                            const dx = player.x - this.x; const dy = player.y - this.y;
                            const dist = Math.sqrt(dx*dx + dy*dy);
                            if (dist > 0) { this.vx = (dx/dist)*this.speed; this.vy = (dy/dist)*this.speed; }
                        }
                    }
                }


                // Swarmers have Flight
                if(this.type === 'swarm') {
                    this.x += (this.vx * cryoSlow * empSlow) * (dt/16);
                    this.y += (this.vy * cryoSlow * empSlow) * (dt/16);
                } else {
                    if (this.type !== 'tank' && !(this.type==='boss' && this.currentAttack===2 && this.actionState === 'attacking')) {
                        this.x += (this.vx * cryoSlow * empSlow) * (dt/16);
                        this.y += (this.vy * cryoSlow * empSlow) * (dt/16);
                    }
                    
                    if ((this.type === 'tank' || (this.type === 'boss' && this.currentAttack===2)) && (this.chargeState === 2 || this.chargeState === 0 || this.chargeState === 3)) {
                          this.x += (this.vx * cryoSlow * empSlow) * (dt/16);
                          this.y += (this.vy * cryoSlow * empSlow) * (dt/16);
                    }


                    let sepX = 0, sepY = 0;
                    
                    // OPTIMIZED: Cache separation checks - only calculate every 3 frames
                    if (!this.separationCache) this.separationCache = { timer: 0, sepX: 0, sepY: 0 };
                    this.separationCache.timer++;
                    
                    // Skip collision if TITAN is charging or spinning
                    if (!this.ignoreCollision) {
                        if (this.separationCache.timer >= 3) {
                            this.separationCache.timer = 0;
                            let cachedSepX = 0, cachedSepY = 0;
                            
                            for (let other of entities.enemies) {
                                if (other === this || other.type === 'swarm') continue; // Ignore swarms
                                if (this.hackState.active || other.hackState.active) continue; // Hacked enemies ignore separation
                                
                                // TITANs ignore collision with other TITANs (they have their own repulsion system)
                                if (this.isChampion && other.isChampion) continue;
                                
                                // Frozen enemies act as solid obstacles
                                const treatAsSolid = other.cryoState.frozen;
                                
                                const odx = this.x - other.x; const ody = this.y - other.y;
                                const odist = Math.sqrt(odx*odx + ody*ody);
                                const minSep = this.radius + other.radius + (treatAsSolid ? 10 : 5); // Extra space around frozen
                                
                                if (odist < minSep && odist > 0) { 
                                    const f = (minSep - odist) / odist * (treatAsSolid ? 3.0 : 1.0); // Stronger push from frozen
                                    cachedSepX += odx * f; 
                                    cachedSepY += ody * f; 
                                }
                            }
                            
                            this.separationCache.sepX = cachedSepX;
                            this.separationCache.sepY = cachedSepY;
                        }
                        
                        sepX = this.separationCache.sepX;
                        sepY = this.separationCache.sepY;
                    }
                    
                    if (this.type !== 'tank' && !(this.type==='boss' && this.currentAttack===2 && this.actionState === 'attacking') && !this.ignoreCollision) {
                        this.x += (sepX * 2.0 * cryoSlow) * (dt/16);
                        this.y += (sepY * 2.0 * cryoSlow) * (dt/16);
                    }
                }


                this.x += this.pushX * (dt/16); this.y += this.pushY * (dt/16);
                this.pushX *= 0.8; this.pushY *= 0.8;
                
                // Apply barrier knockback velocity (smooth animation)
                if (this.knockbackVx || this.knockbackVy) {
                    if (!this.knockbackVx) this.knockbackVx = 0;
                    if (!this.knockbackVy) this.knockbackVy = 0;
                    
                    this.x += this.knockbackVx * (dt/16);
                    this.y += this.knockbackVy * (dt/16);
                    
                    // Decay knockback velocity over time (smooth slowdown)
                    this.knockbackVx *= 0.88; // Slower decay for smoother animation
                    this.knockbackVy *= 0.88;
                    
                    // Clear very small velocities
                    if (Math.abs(this.knockbackVx) < 0.1) this.knockbackVx = 0;
                    if (Math.abs(this.knockbackVy) < 0.1) this.knockbackVy = 0;
                }
                
                if (this.flash > 0) this.flash -= (dt/16);


                const dist = Math.sqrt((player.x - this.x)**2 + (player.y - this.y)**2);
                if (dist < this.radius + player.radius && this.type !== 'splitter') { // Splitters don't do melee damage
                    // HACK: Hacked enemies attack other enemies instead of player
                    if (this.hackState.active && this.type !== 'boss') {
                        // Initialize hack attack timer if it doesn't exist
                        if (!this.hackAttackTimer) this.hackAttackTimer = 0;
                        
                        // Only attack once every 20 frames (same as global DoT rate)
                        if (this.hackAttackTimer <= 0) {
                            const nearestEnemy = entities.enemies.find(e => 
                                e !== this && 
                                e.hp > 0 && 
                                !e.hackState.active &&
                                Math.sqrt((e.x - this.x)**2 + (e.y - this.y)**2) < 200
                            );
                            if (nearestEnemy) {
                                // Normalized damage based on player damage (not enemy dmg)
                                // This ensures consistent damage regardless of which enemy is hacked
                                let hackDamage = player.damage * 1.0; // Balanced base damage (reduced from 1.5)
                                
                                // Apply damage reduction for bosses/titans
                                if (nearestEnemy.isNexusPrime) {
                                    hackDamage *= 0.25; // 75% reduction for final boss
                                } else if (nearestEnemy.isChampion) {
                                    hackDamage *= 0.15; // 85% reduction for titans (was 0.35) - prevents melting
                                }
                                
                                nearestEnemy.takeDamage(hackDamage, '#00ffff', false, 'normal');
                                for (let i=0; i<8; i++) entities.particles.push(new Particle(nearestEnemy.x, nearestEnemy.y, '#00ffff', 1.5));
                                entities.lightnings.push(new LightningBolt(this.x, this.y, nearestEnemy.x, nearestEnemy.y, '#00ffff'));
                                this.hackAttackTimer = 20; // Reset cooldown to 20 frames
                            }
                        } else {
                            this.hackAttackTimer -= dt/16; // Count down
                        }
                    } else {
                        player.takeHit(this.dmg, 'Contact Damage', this.type.toUpperCase());
                    }
                }
            }
            
            // TITAN SLAM HIT EXECUTION - Called for each of the 3 slams
            executeSlamHit(distToPlayer) {
                const slamRadii = [95, 145, 190]; // Small, medium, large (slightly increased from 90, 135, 180)
                const currentRadius = slamRadii[this.slamHitCount];
                const shakeIntensity = [3, 5, 7]; // Subtle shake: 3, 5, 7 (was 10, 13, 18 - too intense)
                
                // Subtle camera shake for impact feedback
                state.shake = shakeIntensity[this.slamHitCount];
                
                // Damage all enemies in radius
                entities.enemies.forEach(e => {
                    if (e === this) return;
                    const dist = Math.sqrt((e.x - this.x)**2 + (e.y - this.y)**2);
                    if (dist < currentRadius) {
                        e.takeDamage(this.dmg * 1.5, '#ff3300', false, 'normal');
                    }
                });
                
                // Damage player
                if (distToPlayer < currentRadius) {
                    player.takeHit(this.dmg, 'Champion Ground Slam', 'TITAN');
                    // Knockback (reduced from 25/40/55 to 8/12/16 - much more manageable)
                    const angle = Math.atan2(player.y - this.y, player.x - this.x);
                    const knockbackDist = 8 + (this.slamHitCount * 4); // 8, 12, 16 (was 25, 40, 55)
                    player.x += Math.cos(angle) * knockbackDist;
                    player.y += Math.sin(angle) * knockbackDist;
                }
                
                // Visual effects
                const colors = ['#ff0000', '#ff6600', '#ffaa00'];
                createExplosion(this.x, this.y, colors[this.slamHitCount], 30 + this.slamHitCount * 10);
                
                // Shockwave matching this slam's radius
                entities.particles.push(new Shockwave(this.x, this.y, currentRadius, colors[this.slamHitCount]));
                
                // Ground impact particles (more on later hits)
                const particleCount = 20 + this.slamHitCount * 10;
                for (let i = 0; i < particleCount; i++) {
                    const angle = (Math.PI * 2 / particleCount) * i;
                    const speed = 4 + Math.random() * 3;
                    entities.particles.push(new Particle(
                        this.x + Math.cos(angle) * currentRadius * 0.5,
                        this.y + Math.sin(angle) * currentRadius * 0.5,
                        colors[this.slamHitCount],
                        1.5
                    ));
                }
            }
            
            draw(ctx) {
                // TITAN CHAMPION TELEGRAPHS - Draw before everything else
                if (this.isChampion && this.championType === 'TITAN' && this.telegraphType) {
                    ctx.save();
                    ctx.translate(this.x, this.y);
                    
                    // Pulsing alpha for warning effect
                    const pulseAlpha = 0.3 + Math.sin(this.telegraphTimer * 0.2) * 0.15;
                    
                    if (this.telegraphType === 'line') {
                        // Charge line telegraph - shows dash path
                        ctx.rotate(this.telegraphAngle);
                        
                        // Draw thick warning line
                        ctx.strokeStyle = `rgba(255, 50, 0, ${pulseAlpha + 0.3})`;
                        ctx.lineWidth = this.radius * 2; // Width = champion diameter
                        ctx.lineCap = 'round';
                        
                        ctx.beginPath();
                        ctx.moveTo(0, 0);
                        ctx.lineTo(this.telegraphRadius, 0);
                        ctx.stroke();
                        
                        // Draw semi-transparent fill
                        ctx.fillStyle = `rgba(255, 0, 0, ${pulseAlpha * 0.5})`;
                        ctx.fillRect(0, -this.radius, this.telegraphRadius, this.radius * 2);
                        
                        // Draw arrowhead at end
                        ctx.fillStyle = `rgba(255, 50, 0, ${pulseAlpha + 0.4})`;
                        ctx.beginPath();
                        ctx.moveTo(this.telegraphRadius, 0);
                        ctx.lineTo(this.telegraphRadius - 20, -15);
                        ctx.lineTo(this.telegraphRadius - 20, 15);
                        ctx.closePath();
                        ctx.fill();
                        
                    } else if (this.telegraphType === 'circle') {
                        // Different visuals for slam vs spin
                        if (this.currentAttack === 'spin') {
                            // SPIN: Particle sucking effect (charging up)
                            const chargeProgress = 1 - (this.telegraphTimer / 75); // 0 to 1
                            
                            // Draw outer danger zone
                            ctx.strokeStyle = `rgba(255, 50, 0, ${pulseAlpha + 0.3})`;
                            ctx.lineWidth = 4;
                            ctx.beginPath();
                            ctx.arc(0, 0, this.telegraphRadius, 0, Math.PI * 2);
                            ctx.stroke();
                            
                            // Draw particles being pulled in
                            const particleCount = 20;
                            for (let i = 0; i < particleCount; i++) {
                                const angle = (Math.PI * 2 / particleCount) * i + state.frameCount * 0.05;
                                // Particles start at radius and move inward as charge builds
                                const startDist = this.telegraphRadius * 1.2;
                                const currentDist = startDist - (startDist - this.radius) * chargeProgress;
                                
                                const px = Math.cos(angle) * currentDist;
                                const py = Math.sin(angle) * currentDist;
                                
                                ctx.fillStyle = `rgba(255, 100, 0, ${0.6 + chargeProgress * 0.4})`;
                                ctx.beginPath();
                                ctx.arc(px, py, 3 + chargeProgress * 2, 0, Math.PI * 2);
                                ctx.fill();
                            }
                            
                            // Inner glow gets brighter as charge builds
                            ctx.fillStyle = `rgba(255, 0, 0, ${pulseAlpha * chargeProgress})`;
                            ctx.beginPath();
                            ctx.arc(0, 0, this.radius + 10, 0, Math.PI * 2);
                            ctx.fill();
                            
                        } else if (this.currentAttack === 'slam') {
                            // SLAM: Sequential ring warnings - each ring glows THEN slams
                            
                            const radii = [95, 145, 190]; // Match actual slam radii (slightly increased)
                            
                            // Calculate time progress through the entire slam sequence
                            // Telegraph: 0.0 to 1.5s (90 frames)
                            // Slam 1: at 1.5s
                            // Slam 2: at 1.9s (0.4s after slam 1)
                            // Slam 3: at 2.3s (0.8s after slam 1)
                            
                            let timeInSeconds;
                            if (this.attackState === 'telegraph') {
                                // During telegraph: 0 to 1.5s
                                timeInSeconds = (90 - this.telegraphTimer) / 60; // Convert frames to seconds
                            } else {
                                // During attacking: 1.5s onward
                                // attackTimer starts at 80 and counts down
                                timeInSeconds = 1.5 + ((80 - this.attackTimer) / 60);
                            }
                            
                            // Each ring glows for 0.6s before its slam
                            const slamTimes = [1.5, 1.9, 2.3]; // When each slam actually hits
                            
                            for (let i = 0; i < 3; i++) {
                                const slamTime = slamTimes[i];
                                const glowStartTime = slamTime - 0.6; // Start glowing 0.6s before slam
                                const glowDuration = 0.6;
                                
                                // How far through this ring's glow cycle are we?
                                const timeSinceGlowStart = timeInSeconds - glowStartTime;
                                const glowProgress = Math.max(0, Math.min(1, timeSinceGlowStart / glowDuration));
                                
                                // Ring gets brighter as slam approaches
                                const ringAlpha = glowProgress * (0.5 + pulseAlpha * 0.5);
                                
                                if (glowProgress > 0 && timeSinceGlowStart < glowDuration + 0.1) { // Show slightly after for flash
                                    // Outer ring (stroke)
                                    ctx.strokeStyle = `rgba(255, ${50 + i * 40}, 0, ${ringAlpha + 0.2})`;
                                    ctx.lineWidth = 3 + i + glowProgress * 4; // Gets thicker as it glows
                                    ctx.shadowColor = `rgba(255, ${50 + i * 40}, 0, ${glowProgress})`;
                                    ctx.shadowBlur = glowProgress * 25; // Intense glow when about to hit
                                    ctx.beginPath();
                                    ctx.arc(0, 0, radii[i], 0, Math.PI * 2);
                                    ctx.stroke();
                                    ctx.shadowBlur = 0;
                                    
                                    // Fill (gets more intense as slam approaches)
                                    if (glowProgress > 0.3) {
                                        const colors = ['255, 0, 0', '255, 100, 0', '255, 170, 0'];
                                        ctx.fillStyle = `rgba(${colors[i]}, ${(glowProgress - 0.3) * 0.5})`;
                                        ctx.beginPath();
                                        ctx.arc(0, 0, radii[i], 0, Math.PI * 2);
                                        ctx.fill();
                                    }
                                }
                            }
                        }
                    }
                    
                    ctx.restore();
                }
                
                if ((this.type === 'tank' || (this.type==='boss' && this.currentAttack===2)) && this.chargeState === 1) {
                    ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(this.chargeAngle);
                    ctx.fillStyle = `rgba(255,0,0,${0.4+Math.sin(state.frameCount*0.5)*0.2})`; // BRIGHT RED
                    ctx.fillRect(0, -this.radius, 400, this.radius*2);
                    ctx.restore();
                }


                ctx.save(); ctx.translate(this.x, this.y);
                ctx.fillStyle = this.flash > 0 ? '#fff' : this.color;
                
                // BARRIER STUN VISUAL - spinning stars above enemy
                if (this.barrierStunTimer && this.barrierStunTimer > 0) {
                    const numStars = 3;
                    const orbitRadius = this.radius + 12;
                    const spinSpeed = state.frameCount * 0.15;
                    
                    // Only show stars if stun is actually active
                    if (this.barrierStunTimer > 0) {
                        for (let i = 0; i < numStars; i++) {
                            const angle = (Math.PI * 2 * i / numStars) + spinSpeed;
                            const sx = Math.cos(angle) * orbitRadius;
                            const sy = Math.sin(angle) * orbitRadius - 5; // Slightly above
                            
                            // Draw star
                            ctx.save();
                            ctx.translate(sx, sy);
                            ctx.rotate(angle);
                            
                            ctx.fillStyle = '#ffdd00';
                            ctx.shadowColor = '#ffdd00';
                            ctx.shadowBlur = 8;
                            
                            // 5-pointed star
                            ctx.beginPath();
                            for (let p = 0; p < 5; p++) {
                                const starAngle = (Math.PI * 2 * p / 5) - Math.PI / 2;
                                const r = p % 2 === 0 ? 4 : 2;
                                const px = Math.cos(starAngle) * r;
                                const py = Math.sin(starAngle) * r;
                                if (p === 0) ctx.moveTo(px, py);
                                else ctx.lineTo(px, py);
                            }
                            ctx.closePath();
                            ctx.fill();
                            
                            ctx.restore();
                        }
                        
                        ctx.shadowBlur = 0;
                    }
                }
                
                // Color Override for Elements
                if (this.cryoState.frozen) {
                    // Frozen solid - bright ice blue with glow
                    ctx.fillStyle = '#88d8ff';
                    ctx.shadowColor = '#88d8ff';
                    ctx.shadowBlur = 15;
                    
                    // Draw ice crystal shards radiating outward
                    ctx.strokeStyle = 'rgba(179, 245, 255, 0.9)';
                    ctx.fillStyle = 'rgba(179, 245, 255, 0.6)';
                    ctx.lineWidth = 2;
                    
                    const shardCount = 6;
                    const shardLength = this.radius * 0.8;
                    const shardWidth = this.radius * 0.3;
                    
                    for (let i = 0; i < shardCount; i++) {
                        const angle = (Math.PI * 2 * i / shardCount) + (this.animTick * 0.01);
                        const baseRadius = this.radius * 0.5; // Closer to enemy center for tighter jagged look
                        
                        ctx.save();
                        ctx.rotate(angle);
                        
                        // Draw diamond-shaped ice shard
                        ctx.beginPath();
                        ctx.moveTo(baseRadius, 0);
                        ctx.lineTo(baseRadius + shardLength * 0.5, -shardWidth);
                        ctx.lineTo(baseRadius + shardLength, 0);
                        ctx.lineTo(baseRadius + shardLength * 0.5, shardWidth);
                        ctx.closePath();
                        
                        ctx.fill();
                        ctx.stroke();
                        ctx.restore();
                    }
                    
                    // Add frozen core glow
                    ctx.fillStyle = 'rgba(136, 216, 255, 0.3)';
                    ctx.beginPath();
                    ctx.arc(0, 0, this.radius + 4, 0, Math.PI * 2);
                    ctx.fill();
                } else if (this.cryoState.slowed) {
                    // Slowed - light frost overlay
                    ctx.fillStyle = '#cce6ff';
                    
                    // Add occasional frost particles for visual feedback
                    if (seededRandom() < 0.05 && this.animTick % 10 < 1) {
                        entities.particles.push(new Particle(
                            this.x + (seededRandom() - 0.5) * this.radius,
                            this.y + (seededRandom() - 0.5) * this.radius,
                            '#cce6ff',
                            0.8
                        ));
                    }
                } else if (this.bioState.active) {
                    ctx.fillStyle = '#00cc44';
                } else if (this.pyroState.active) {
                    ctx.fillStyle = '#ffaa00';
                } else if (this.hackState.active) {
                    ctx.fillStyle = '#00ffff';
                }

                // CHAMPION GLOW - orange pulsing aura
                if (this.isChampion) {
                    const pulseIntensity = 0.5 + Math.sin(state.frameCount * 0.1) * 0.3;
                    ctx.shadowColor = '#ff6600';
                    ctx.shadowBlur = 25 * pulseIntensity;
                    
                    // Draw outer glow ring
                    ctx.strokeStyle = `rgba(255, 102, 0, ${0.6 * pulseIntensity})`;
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.arc(0, 0, this.radius + 8, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    // SPIN ATTACK VISUAL - Spinning red blades
                    if (this.attackState === 'attacking' && this.currentAttack === 'spin') {
                        ctx.shadowColor = '#ff0000';
                        ctx.shadowBlur = 20;
                        
                        const bladeCount = 4;
                        for (let i = 0; i < bladeCount; i++) {
                            const angle = (Math.PI * 2 / bladeCount) * i + (this.spinAngle || 0);
                            
                            ctx.save();
                            ctx.rotate(angle);
                            
                            // Draw spinning blade
                            ctx.fillStyle = '#ff0000';
                            ctx.strokeStyle = '#ffffff';
                            ctx.lineWidth = 2;
                            
                            ctx.beginPath();
                            ctx.moveTo(this.radius * 0.5, 0);
                            ctx.lineTo(this.attackRadius * 0.9, -8);
                            ctx.lineTo(this.attackRadius * 1.0, 0);
                            ctx.lineTo(this.attackRadius * 0.9, 8);
                            ctx.closePath();
                            ctx.fill();
                            ctx.stroke();
                            
                            ctx.restore();
                        }
                    }
                }

                if (this.type === 'boss') {
                    // Boss color changes based on state
                    let bossColor = this.color; // Base color (red in P1, magenta in P2)
                    
                    // Attacking: Brighten and add glow
                    if (this.actionState === 'attacking') {
                        if (this.phase === 2) {
                            bossColor = '#ff00ff'; // Bright magenta when attacking in phase 2
                            ctx.shadowColor = '#ff00ff';
                            ctx.shadowBlur = 20;
                        } else {
                            bossColor = '#ff5555'; // Bright red when attacking
                            ctx.shadowColor = '#ff0000';
                            ctx.shadowBlur = 20;
                        }
                    } 
                    // Cooldown: Darker
                    else if (this.actionState === 'cooldown') {
                        if (this.phase === 2) {
                            bossColor = '#990099'; // Dark magenta during cooldown
                        } else {
                            bossColor = '#990000'; // Dark red during cooldown
                        }
                    }
                    
                    ctx.fillStyle = bossColor;
                    ctx.rotate(this.animTick * 0.5);
                    ctx.beginPath(); ctx.moveTo(this.radius, 0); ctx.lineTo(-this.radius/2, this.radius); ctx.lineTo(-this.radius/2, -this.radius); ctx.fill();
                    
                    // Outline color matches phase
                    ctx.strokeStyle = this.phase === 2 ? '#ff00ff' : '#ff0000'; 
                    ctx.lineWidth = 4; 
                    ctx.stroke();
                } else if (this.type === 'drone') {
                    const droneColor = this.hackState.active ? '#00ffff' : this.color;
                    ctx.rotate(this.animTick); ctx.strokeStyle = droneColor; ctx.lineWidth = 2;
                    ctx.beginPath(); ctx.moveTo(this.radius, 0); ctx.lineTo(-this.radius/2, this.radius/2); ctx.lineTo(-this.radius/2, -this.radius/2); ctx.closePath(); ctx.stroke();
                    ctx.fillStyle = droneColor;
                    ctx.beginPath(); ctx.arc(0,0, 4, 0, Math.PI*2); ctx.fill();
                } else if (this.type === 'tank') {
                    if (this.chargeState === 1) ctx.translate((seededRandom()-0.5)*4, (seededRandom()-0.5)*4);
                    const tankColor = this.hackState.active ? '#00ffff' : this.color;
                    ctx.fillStyle = tankColor;
                    ctx.shadowColor = tankColor; ctx.shadowBlur = 10;
                    ctx.fillRect(-this.radius, -this.radius, this.radius*2, this.radius*2);
                    const scale = 0.8 + Math.sin(this.animTick)*0.1;
                    ctx.fillStyle = '#000'; ctx.fillRect(-this.radius*scale, -this.radius*scale, this.radius*2*scale, this.radius*2*scale);
                } else if (this.type === 'splitter') {
                    // Splitter: pulsing hexagon to indicate it will split
                    const pulse = 1 + Math.sin(this.animTick * 3) * 0.15; // Faster pulse
                    const splitterColor = this.hackState.active ? '#00ffff' : this.color;
                    ctx.fillStyle = splitterColor;
                    ctx.scale(pulse, pulse);
                    ctx.shadowColor = splitterColor; ctx.shadowBlur = 15;
                    ctx.beginPath();
                    for (let i = 0; i < 6; i++) {
                        const angle = (Math.PI / 3) * i;
                        const x = Math.cos(angle) * this.radius;
                        const y = Math.sin(angle) * this.radius;
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.closePath();
                    ctx.fill();
                    // Inner core
                    ctx.fillStyle = 'rgba(255,255,255,0.3)';
                    ctx.beginPath();
                    ctx.arc(0, 0, this.radius * 0.4, 0, Math.PI * 2);
                    ctx.fill();
                } else if (this.type === 'voidwalker') {
                    // Voidwalker: Rotating crystal/diamond with phase-based appearance
                    const isHacked = this.hackState.active;
                    const baseColor = isHacked ? '#00ff00' : '#9933ff';
                    const glowColor = isHacked ? '#00ff88' : '#cc66ff';
                    
                    // Apply opacity based on phase state
                    ctx.globalAlpha = this.opacity;
                    
                    // Warning circle on ground (during countdown)
                    if (this.phaseState === 'countdown' && this.warningCircleRadius > 0) {
                        const maxTimer = isHacked ? 60 : 120;
                        const progress = 1 - (this.countdownTimer / maxTimer);
                        
                        // Pulsing warning circle
                        ctx.strokeStyle = isHacked ? 'rgba(0, 255, 0, 0.4)' : 'rgba(153, 51, 255, 0.4)';
                        ctx.lineWidth = 3;
                        ctx.setLineDash([10, 5]);
                        ctx.beginPath();
                        ctx.arc(0, 0, this.warningCircleRadius, 0, Math.PI*2);
                        ctx.stroke();
                        ctx.setLineDash([]);
                        
                        // Inner fill
                        const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, this.warningCircleRadius);
                        gradient.addColorStop(0, isHacked ? 'rgba(0, 255, 0, 0.05)' : 'rgba(153, 51, 255, 0.05)');
                        gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
                        ctx.fillStyle = gradient;
                        ctx.beginPath();
                        ctx.arc(0, 0, this.warningCircleRadius, 0, Math.PI*2);
                        ctx.fill();
                    }
                    
                    // Pulse based on state
                    let pulseSpeed = this.phaseState === 'phased' ? 2 : 8;
                    let pulseIntensity = this.phaseState === 'phased' ? 0.1 : 0.25;
                    
                    if (this.phaseState === 'countdown') {
                        const maxTimer = isHacked ? 60 : 120;
                        const countdown = this.countdownTimer / maxTimer;
                        pulseSpeed = 8 + (1 - countdown) * 12; // Accelerates to 20
                        pulseIntensity = 0.25 + (1 - countdown) * 0.2;
                    }
                    
                    const pulse = 1 + Math.sin(this.pulsePhase * pulseSpeed) * pulseIntensity;
                    ctx.scale(pulse, pulse);
                    
                    // Rotation (faster when counting down)
                    const rotationSpeed = this.phaseState === 'countdown' ? 0.08 : 0.03;
                    ctx.rotate(this.animTick * rotationSpeed);
                    
                    // Shadow/glow
                    ctx.shadowColor = glowColor;
                    ctx.shadowBlur = this.phaseState === 'countdown' ? 30 : 20;
                    
                    // Draw diamond/crystal shape (4-pointed star)
                    const size = this.radius * 1.2;
                    
                    // Outer diamond
                    ctx.fillStyle = baseColor;
                    ctx.beginPath();
                    ctx.moveTo(0, -size);
                    ctx.lineTo(size * 0.5, 0);
                    ctx.lineTo(0, size);
                    ctx.lineTo(-size * 0.5, 0);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Inner crystal layers
                    if (this.phaseState === 'countdown') {
                        // Bright pulsing inner diamond
                        ctx.fillStyle = isHacked ? '#88ffcc' : '#ff66ff';
                        ctx.shadowBlur = 20;
                        ctx.beginPath();
                        ctx.moveTo(0, -size * 0.6);
                        ctx.lineTo(size * 0.3, 0);
                        ctx.lineTo(0, size * 0.6);
                        ctx.lineTo(-size * 0.3, 0);
                        ctx.closePath();
                        ctx.fill();
                        
                        // Bright center core
                        ctx.fillStyle = '#ffffff';
                        ctx.shadowBlur = 15;
                        ctx.beginPath();
                        ctx.moveTo(0, -size * 0.3);
                        ctx.lineTo(size * 0.15, 0);
                        ctx.lineTo(0, size * 0.3);
                        ctx.lineTo(-size * 0.15, 0);
                        ctx.closePath();
                        ctx.fill();
                    } else {
                        // Dim core when phased
                        ctx.fillStyle = baseColor;
                        ctx.globalAlpha = this.opacity * 0.6;
                        ctx.beginPath();
                        ctx.moveTo(0, -size * 0.5);
                        ctx.lineTo(size * 0.25, 0);
                        ctx.lineTo(0, size * 0.5);
                        ctx.lineTo(-size * 0.25, 0);
                        ctx.closePath();
                        ctx.fill();
                    }
                    
                    // Energy particles orbiting (during countdown)
                    if (this.phaseState === 'countdown') {
                        ctx.globalAlpha = 1.0;
                        const particleCount = 4;
                        for (let i = 0; i < particleCount; i++) {
                            const angle = (this.animTick * 0.1) + (i * Math.PI * 2 / particleCount);
                            const dist = size * 0.8;
                            const px = Math.cos(angle) * dist;
                            const py = Math.sin(angle) * dist;
                            
                            ctx.fillStyle = glowColor;
                            ctx.beginPath();
                            ctx.arc(px, py, 2, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    }
                    
                    ctx.globalAlpha = 1.0; // Reset opacity
                } else if (this.isChampion && this.championType === 'TITAN') {
                    // TITAN: Mechanical boss design with armor plates and glowing core
                    const pulse = 0.8 + Math.sin(state.frameCount * 0.08) * 0.2;
                    
                    // Main body - hexagonal armored shell
                    ctx.fillStyle = '#442200';
                    ctx.strokeStyle = '#ff6600';
                    ctx.lineWidth = 3;
                    ctx.shadowColor = '#ff6600';
                    ctx.shadowBlur = 15 * pulse;
                    
                    ctx.beginPath();
                    for (let i = 0; i < 6; i++) {
                        const angle = (Math.PI / 3) * i + this.animTick * 0.02;
                        const x = Math.cos(angle) * this.radius;
                        const y = Math.sin(angle) * this.radius;
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                    
                    // Armor plates (4 directional)
                    ctx.fillStyle = '#663300';
                    ctx.strokeStyle = '#ff8800';
                    ctx.lineWidth = 2;
                    for (let i = 0; i < 4; i++) {
                        const angle = (Math.PI / 2) * i;
                        ctx.save();
                        ctx.rotate(angle);
                        ctx.beginPath();
                        ctx.moveTo(this.radius * 0.7, 0);
                        ctx.lineTo(this.radius * 0.4, -this.radius * 0.3);
                        ctx.lineTo(this.radius * 0.4, this.radius * 0.3);
                        ctx.closePath();
                        ctx.fill();
                        ctx.stroke();
                        ctx.restore();
                    }
                    
                    // Glowing energy core
                    const coreGlow = 0.6 + Math.sin(state.frameCount * 0.15) * 0.4;
                    ctx.shadowBlur = 25 * coreGlow;
                    ctx.shadowColor = '#ff3300';
                    ctx.fillStyle = `rgba(255, 51, 0, ${coreGlow})`;
                    ctx.beginPath();
                    ctx.arc(0, 0, this.radius * 0.35, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Bright inner core
                    ctx.fillStyle = `rgba(255, 200, 100, ${coreGlow})`;
                    ctx.beginPath();
                    ctx.arc(0, 0, this.radius * 0.2, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.shadowBlur = 0;
                } else {
                    const swarmColor = this.hackState.active ? '#00ffff' : ctx.fillStyle;
                    ctx.fillStyle = swarmColor;
                    const pulse = 1 + Math.sin(this.animTick * 2) * 0.2;
                    ctx.scale(pulse, pulse); ctx.beginPath(); ctx.moveTo(0, -this.radius); ctx.lineTo(this.radius, this.radius); ctx.lineTo(-this.radius, this.radius); ctx.fill();
                }
                
                ctx.restore();
            }
        }


        class Projectile {
            constructor(x, y, vx, vy, damage, pierce, type, target, source, detectionRadius) {
                this.x = x; this.y = y; this.vx = vx; this.vy = vy;
                this.damage = damage; this.pierce = pierce; this.type = type; this.source = source;
                this.life = type === 'seeker' ? 180 : type === 'mine' ? 600 : type === 'gas_grenade' ? 90 : type === 'railgun' ? 45 : type === 'ricochet' ? 180 : 70; // Ricochet now lasts 3 seconds 
                this.trail = []; this.target = target;
                
                // Mine-specific properties
                if (type === 'mine') {
                    this.detectionRadius = detectionRadius || 60;
                    this.blastRadius = pierce; // Use pierce as blast radius for mines
                    this.triggered = false;
                    this.detonationTimer = 60; // 1 second countdown after trigger
                    this.pulsePhase = 0;
                }
                
                if (type === 'railgun' && typeof target === 'object' && target.level) {
                    this.railLevel = target.level;
                } else {
                    this.railLevel = 1;
                }
                if(type === 'railgun') {
                    this.origX = x; this.origY = y;
                    this.animProgress = 0; // Animation progress 0 to 1
                    this.maxAnimFrames = 8; // Frames to fully extend
                }


                if (type === 'flak_shell') {
                    this.life = 60; 
                    this.flakData = target; 
                    this.distTraveled = 0;
                }


                if (type === 'bio_spore') {
                      this.life = 60;
                      const angle = Math.atan2(target.y-y, target.x-x);
                      this.vx = Math.cos(angle)*6; this.vy = Math.sin(angle)*6;
                }


                this.speed = 12; 
                this.warmup = 15;
                this.triggering = false; this.triggerTimer = 30; 
                this.hasDamaged = false; 
                this.hitList = []; 
                
                if (type === 'meteor_warning') {
                    this.life = 40; // Reduced from 60 frames (~0.67s vs 1s)
                    this.maxLife = 40;
                }
            }
            update(dt) {
                if (this.type === 'flak_shell') {
                    this.x += this.vx * (dt/16);
                    this.y += this.vy * (dt/16);
                    this.distTraveled += Math.sqrt(this.vx*this.vx + this.vy*this.vy) * (dt/16);
                    
                    let hit = false;
                    for(let e of entities.enemies) {
                        if(Math.sqrt((e.x-this.x)**2 + (e.y-this.y)**2) < e.radius + 15) { hit = true; break; }
                    }


                    if (hit || this.distTraveled > this.flakData.range) {
                        createExplosion(this.x, this.y, '#ffff00', 10);
                        const baseAngle = Math.atan2(this.vy, this.vx);
                        const range = 250; 
                        const rangeSq = range * range;
                        const coneHalfAngle = Math.PI/6; // Widened from œÄ/8 (50% wider cone) 
                        
                        // Buffed damage per pellet burst to compete with other weapons
                        const flakDmg = 45 * (1 + (this.flakData.level-1)*0.3) * (player.damage/15); // Increased from 30, better scaling 


                        // ‚ö° OPTIMIZED: Use spatial grid for flak cone damage
                        const flakNearby = spatialGrid.getNearby(this.x, this.y, range);
                        flakNearby.forEach(e => {
                            const dx = e.x - this.x; const dy = e.y - this.y;
                            const distSq = dx*dx + dy*dy;
                            if (distSq < rangeSq) {
                                const angleToEnemy = Math.atan2(dy, dx);
                                let diff = angleToEnemy - baseAngle;
                                while (diff <= -Math.PI) diff += Math.PI*2; while (diff > Math.PI) diff -= Math.PI*2;
                                if (Math.abs(diff) < coneHalfAngle) { 
                                    player.dealElementalDamage(e, flakDmg, 'flak', '#ffffff');
                                }
                            }
                        });

                        // Reduce shrapnel particles if many enemies present to prevent lag
                        const enemyCount = entities.enemies.length;
                        const shrapnelCount = enemyCount > 30 ? 10 : (enemyCount > 15 ? 15 : 20);
                        
                        for(let i=0; i<shrapnelCount; i++) {
                             const spread = (seededRandom() - 0.5) * coneHalfAngle * 2;
                             const ang = baseAngle + spread;
                             const speed = 5 + seededRandom() * 8;
                             entities.particles.push(new ShrapnelSpark(this.x, this.y, ang, speed)); 
                        }
                        
                        return false; 
                    }
                    this.life -= dt/16;
                    return this.life > 0;
                }


                if (this.type === 'bio_spore') {
                    this.x += this.vx * (dt/16);
                    this.y += this.vy * (dt/16);
                    if(this.target && this.target.hp > 0) {
                        const angle = Math.atan2(this.target.y-this.y, this.target.x-this.x);
                        this.vx += (Math.cos(angle)*8 - this.vx)*0.1;
                        this.vy += (Math.sin(angle)*8 - this.vy)*0.1;
                        if (Math.sqrt((this.x-this.target.x)**2 + (this.y-this.target.y)**2) < 20) {
                            player.dealElementalDamage(this.target, 0, 'bio', '#00cc44', false, 'bio_spread');
                            return false; 
                        }
                    }
                    this.life -= dt/16;
                    return this.life > 0;
                }


                if (this.type === 'railgun') {
                    const steps = 10; 
                    const len = 375 + (this.railLevel * 25); // Increased base from 250 (50% longer range) 
                    
                    // Animate extension
                    if (this.animProgress < 1) {
                        this.animProgress += (1 / this.maxAnimFrames);
                        if (this.animProgress > 1) this.animProgress = 1;
                    }
                    
                    // Keep static firing position - do NOT update with player movement
                    // origX and origY are set once in constructor


                    if (!this.hasDamaged && this.animProgress >= 0.3) { // Damage after 30% extension
                         this.hasDamaged = true;
                         const p1 = {x: this.origX, y: this.origY};
                         const p2 = {x: this.origX + this.vx*len, y: this.origY + this.vy*len}; 
                         
                         entities.enemies.forEach(e => {
                            const l2 = (p1.x-p2.x)**2 + (p1.y-p2.y)**2;
                            if (l2 == 0) return;
                            let t = ((e.x - p1.x) * (p2.x - p1.x) + (e.y - p1.y) * (p2.y - p1.y)) / l2;
                            t = Math.max(0, Math.min(1, t));
                            const px = p1.x + t * (p2.x - p1.x);
                            const py = p1.y + t * (p2.y - p1.y);
                            const dist = Math.sqrt((e.x - px)**2 + (e.y - py)**2);
                            
                            const hitbox = 30 + (this.railLevel * 5);
                            if(dist < e.radius + hitbox) {
                                 if(!this.hitList.includes(e)) {
                                     const distFromOrigin = Math.sqrt((e.x - this.origX)**2 + (e.y - this.origY)**2);
                                     const falloff = Math.max(0.1, 1.0 - (distFromOrigin / 400)); 
                                     
                                     const scaler = 1 + (this.railLevel * 0.2);
                                     player.dealElementalDamage(e, 100 * scaler * falloff, 'railgun', '#ffffff');
                                     this.hitList.push(e);
                                     entities.particles.push(new Particle(e.x, e.y, '#3c8cff', 1.0));
                                 }
                            }
                         });
                    }


                    this.life -= dt/16;
                    return this.life > 0;
                }


                if (this.type === 'meteor_warning') {
                    this.life -= dt/16;
                    if (this.life <= 0) {
                        createExplosion(this.x, this.y, '#00ffcc', 30);
                        entities.particles.push(new Shockwave(this.x, this.y, this.target.radius + 50));
                        entities.enemies.forEach(e => {
                            const dist = Math.sqrt((e.x-this.x)**2 + (e.y-this.y)**2);
                            if(dist < this.target.radius) {
                                // Full damage in main zone
                                player.dealElementalDamage(e, this.damage, 'meteor', '#00ffcc');
                            } else if (dist < this.target.radius * 1.5) {
                                // 50% splash damage in outer zone (50% larger than main zone)
                                player.dealElementalDamage(e, this.damage * 0.5, 'meteor', '#00ffcc');
                            }
                        });
                        return false;
                    }
                    return true;
                }

                // PROXIMITY MINES
                if (this.type === 'mine') {
                    this.pulsePhase += dt/16 * 0.1;
                    
                    // TRAVEL PHASE - fly toward target location (much longer travel time)
                    if (this.life > 480) { // Extended from 570 to allow longer travel (90 frames = 1.5 seconds travel)
                        // Move toward target
                        this.x += this.vx * (dt/16);
                        this.y += this.vy * (dt/16);
                        
                        // Slow down as we approach target - gradual deceleration
                        const slowdown = Math.pow(0.97, dt/16); // Exponential decay
                        this.vx *= slowdown;
                        this.vy *= slowdown;
                        
                        // Check if reached target or close enough (works with virtual target points)
                        if (this.target) {
                            const dist = Math.sqrt((this.x - this.target.x)**2 + (this.y - this.target.y)**2);
                            if (dist < 80 || (this.vx*this.vx + this.vy*this.vy) < 0.3) {
                                // Arrived! Stop moving and start settling
                                this.vx = 0;
                                this.vy = 0;
                                this.life = 480; // Jump to settling phase
                            }
                        } else if ((this.vx*this.vx + this.vy*this.vy) < 0.3) {
                            // No target but velocity is low - settle anyway
                            this.vx = 0;
                            this.vy = 0;
                            this.life = 480;
                        }
                        
                        this.life -= dt/16;
                        return true;
                    }
                    
                    // SETTLING PHASE - mine arms and becomes active (30 frames = 0.5 seconds)
                    if (this.life > 450) {
                        this.life -= dt/16;
                        return true;
                    }
                    
                    // ARMED - slowly gravitate toward nearest enemy
                    if (!this.triggered) {
                        // Find nearest enemy and drift toward them slowly
                        let nearestEnemy = null;
                        let nearestDist = Infinity;
                        
                        for (let e of entities.enemies) {
                            const dist = Math.sqrt((e.x - this.x)**2 + (e.y - this.y)**2);
                            if (dist < nearestDist && dist < 300) { // Only drift toward enemies within 300 units
                                nearestDist = dist;
                                nearestEnemy = e;
                            }
                        }
                        
                        // Slow gravitational drift toward nearest enemy
                        if (nearestEnemy) {
                            const dx = nearestEnemy.x - this.x;
                            const dy = nearestEnemy.y - this.y;
                            const dist = Math.sqrt(dx*dx + dy*dy);
                            if (dist > 0) {
                                const driftSpeed = 0.3; // Very slow drift
                                this.x += (dx/dist) * driftSpeed * (dt/16);
                                this.y += (dy/dist) * driftSpeed * (dt/16);
                            }
                        }
                        
                        // Check for nearby enemies to trigger
                        for (let e of entities.enemies) {
                            const dist = Math.sqrt((e.x - this.x)**2 + (e.y - this.y)**2);
                            if (dist < this.detectionRadius) {
                                this.triggered = true;
                                this.detonationTimer = 60; // 1 second countdown
                                break;
                            }
                        }
                    }
                    
                    if (this.triggered) {
                        // Countdown to detonation with GRAVITY PULL
                        this.detonationTimer -= dt/16;
                        
                        // Pull enemies toward mine (extends beyond blast radius)
                        const gravityRadius = this.blastRadius * 1.6; // 60% beyond blast radius (increased from 30%)
                        entities.enemies.forEach(e => {
                            // Boss entities immune to pull effects
                            if (e.isNexusPrime || e.isBossShield || e.isBossTurret) return;
                            
                            const dx = this.x - e.x;
                            const dy = this.y - e.y;
                            const dist = Math.sqrt(dx*dx + dy*dy);
                            
                            if (dist < gravityRadius && dist > 0) {
                                // Pull strength increases as detonation approaches
                                const detProgress = 1 - (this.detonationTimer / 60);
                                const distRatio = 1 - (dist / gravityRadius);
                                const pullStrength = 1.2 * detProgress * distRatio * (dt/16); // Increased from 0.8 to 1.2 (+50% pull)
                                
                                e.pushX += (dx/dist) * pullStrength;
                                e.pushY += (dy/dist) * pullStrength;
                                
                                // Visual feedback - particles being pulled (4 frames = ~0.067s at 60fps)
                                if (!this.gravityParticleTimer) this.gravityParticleTimer = 0;
                                this.gravityParticleTimer += dt/16;
                                if (this.gravityParticleTimer >= 4) {
                                    this.gravityParticleTimer -= 4;
                                    entities.particles.push(new Particle(
                                        e.x + (seededRandom() - 0.5) * e.radius,
                                        e.y + (seededRandom() - 0.5) * e.radius,
                                        '#ff44cc', // Brighter magenta particles
                                        0.5
                                    ));
                                }
                            }
                        });
                        
                        if (this.detonationTimer <= 0) {
                            // Detonate!
                            createExplosion(this.x, this.y, '#ff44cc', 30); // Brighter magenta explosion
                            entities.particles.push(new Shockwave(this.x, this.y, this.blastRadius, '#ff44cc')); // Brighter magenta shockwave
                            
                            // Damage all enemies in blast radius
                            entities.enemies.forEach(e => {
                                const dist = Math.sqrt((e.x - this.x)**2 + (e.y - this.y)**2);
                                if (dist < this.blastRadius) {
                                    const falloff = 1 - (dist / this.blastRadius) * 0.3; // 30% falloff at edge
                                    player.dealElementalDamage(e, this.damage * falloff, 'mines', '#ff44cc'); // Brighter magenta damage numbers
                                }
                            });
                            
                            return false; // Mine destroyed
                        }
                    }
                    
                    this.life -= dt/16;
                    return this.life > 0;
                }

                // GAS GRENADE - Lob and create toxic cloud
                if (this.type === 'gas_grenade') {
                    this.x += this.vx * (dt/16);
                    this.y += this.vy * (dt/16);
                    
                    // Check if reached target or life expired
                    let shouldDetonate = false;
                    
                    if (this.target && this.target.hp > 0) {
                        const dist = Math.sqrt((this.x - this.target.x)**2 + (this.y - this.target.y)**2);
                        if (dist < 30) shouldDetonate = true;
                    }
                    
                    this.life -= dt/16;
                    if (this.life <= 0) shouldDetonate = true;
                    
                    if (shouldDetonate) {
                        // Create toxic gas cloud
                        createExplosion(this.x, this.y, '#99ff33', 15);
                        const level = player.weapons.gas;
                        entities.gasClouds.push(new GasCloud(this.x, this.y, this.pierce, this.damage, level));
                        return false;
                    }
                    
                    return true;
                }


                // Add trail point with timestamp for framerate-independent length
                this.trail.push({x: this.x, y: this.y, time: Date.now()});
                
                // Remove old trail points based on time (not count)
                // Seeker: 0.25s trail, Ricochet: 0.4s trail (subtle glowing line with fade), Others: 0.1s trail
                const maxAge = this.type === 'seeker' ? 250 : this.type === 'ricochet' ? 400 : 100;
                const now = Date.now();
                while (this.trail.length > 0 && (now - this.trail[0].time) > maxAge) {
                    this.trail.shift();
                }


                if (this.type === 'seeker') {
                    if(Math.abs(this.x - player.x) > 2000 || Math.abs(this.y - player.y) > 2000) return false;
                    this.warmup -= (dt/16);
                    if (this.warmup <= 0) {
                        if (this.target && this.target.hp <= 0) this.target = entities.enemies[Math.floor(seededRandom()*entities.enemies.length)];
                        if (this.target) {
                            this.speed = Math.min(this.speed + 0.2 * (dt/16), 14); 
                            const angle = Math.atan2(this.target.y-this.y, this.target.x-this.x);
                            const steerStrength = 0.08 * (dt/16); // dt-scaled steering
                            const targetVx = Math.cos(angle) * this.speed;
                            const targetVy = Math.sin(angle) * this.speed;
                            this.vx = this.vx + (targetVx - this.vx) * steerStrength;
                            this.vy = this.vy + (targetVy - this.vy) * steerStrength;
                        }
                    }
                }
                
                // RICOCHET DISC - Bounces between enemies (works like seeker)
                if (this.type === 'ricochet') {
                    // Initialize
                    if (this.bounces === undefined) this.bounces = 0;
                    if (this.maxBounces === undefined) this.maxBounces = 8;
                    if (this.hitEnemies === undefined) this.hitEnemies = new Set();
                    
                    // PERFORMANCE: Only check collision when near target (not every frame for all enemies)
                    if (this.target && this.target.hp > 0 && !this.hitEnemies.has(this.target)) {
                        const dx = this.target.x - this.x;
                        const dy = this.target.y - this.y;
                        const dist = Math.sqrt(dx*dx + dy*dy);
                        
                        if (dist < this.target.radius + 15) {
                            // HIT!
                            this.hitEnemies.add(this.target);
                            player.dealElementalDamage(this.target, this.damage, 'ricochet', '#ff8800'); // Same damage for all bounces
                            createExplosion(this.x, this.y, '#ff8800', 15);
                            this.bounces++;
                            
                            // Max bounces?
                            if (this.bounces >= this.maxBounces) {
                                return false;
                            }
                            
                            // Find new target in ONE combined loop
                            this.target = null;
                            let nearestDist = Infinity;
                            let foundUnhit = false;
                            
                            for (let j = 0; j < entities.enemies.length; j++) {
                                const candidate = entities.enemies[j];
                                if (candidate === this.target || candidate.hp <= 0) continue;
                                
                                const cdx = candidate.x - this.x;
                                const cdy = candidate.y - this.y;
                                const d = Math.sqrt(cdx*cdx + cdy*cdy);
                                
                                // Check unhit enemies first
                                if (!this.hitEnemies.has(candidate)) {
                                    foundUnhit = true;
                                    if (d < nearestDist) {
                                        nearestDist = d;
                                        this.target = candidate;
                                    }
                                }
                            }
                            
                            // No unhit enemies? Clear list and find nearest ANY enemy
                            if (!foundUnhit) {
                                this.hitEnemies.clear();
                                nearestDist = Infinity;
                                for (let j = 0; j < entities.enemies.length; j++) {
                                    const candidate = entities.enemies[j];
                                    if (candidate.hp <= 0) continue;
                                    
                                    const cdx = candidate.x - this.x;
                                    const cdy = candidate.y - this.y;
                                    const d = Math.sqrt(cdx*cdx + cdy*cdy);
                                    if (d < nearestDist) {
                                        nearestDist = d;
                                        this.target = candidate;
                                    }
                                }
                            }
                            
                            // SHARP BOUNCE: Snap velocity to new target
                            if (this.target) {
                                const bounceAngle = Math.atan2(this.target.y - this.y, this.target.x - this.x);
                                this.vx = Math.cos(bounceAngle) * 12;
                                this.vy = Math.sin(bounceAngle) * 12;
                            } else {
                                // No target at all - only 1 enemy left, disc dies
                                return false;
                            }
                        }
                    }
                    
                    // Steer toward target (subtle correction only) - always runs
                    if (this.target && this.target.hp > 0) {
                        const angle = Math.atan2(this.target.y - this.y, this.target.x - this.x);
                        const steerStrength = 0.05 * (dt/16); // Reduced from 0.15 - less curving
                        const targetVx = Math.cos(angle) * 12;
                        const targetVy = Math.sin(angle) * 12;
                        this.vx = this.vx + (targetVx - this.vx) * steerStrength;
                        this.vy = this.vy + (targetVy - this.vy) * steerStrength;
                    } else {
                        // No target - find nearest (optimized)
                        let nearest = null;
                        let nearestDist = Infinity;
                        for (let i = 0; i < entities.enemies.length; i++) {
                            const e = entities.enemies[i];
                            if (e.hp > 0) {
                                const dx = e.x - this.x;
                                const dy = e.y - this.y;
                                const roughDist = Math.abs(dx) + Math.abs(dy);
                                if (roughDist < nearestDist * 1.5) { // Quick rejection
                                    const d = Math.sqrt(dx*dx + dy*dy);
                                    if (d < nearestDist) {
                                        nearestDist = d;
                                        nearest = e;
                                    }
                                }
                            }
                        }
                        this.target = nearest;
                    }
                }
                
                // DRONE SHOT - Simple homing projectile
                if (this.type === 'drone_shot') {
                    if (this.target && this.target.hp > 0) {
                        const angle = Math.atan2(this.target.y - this.y, this.target.x - this.x);
                        const steerStrength = 0.1 * (dt/16); // dt-scaled steering
                        const targetVx = Math.cos(angle) * 10;
                        const targetVy = Math.sin(angle) * 10;
                        this.vx = this.vx + (targetVx - this.vx) * steerStrength;
                        this.vy = this.vy + (targetVy - this.vy) * steerStrength;
                    }
                }
                
                // TURRET SHOT - Basic homing projectile
                if (this.type === 'turret_shot') {
                    if (this.target && this.target.hp > 0) {
                        const angle = Math.atan2(this.target.y - this.y, this.target.x - this.x);
                        const steerStrength = 0.08 * (dt/16); // dt-scaled steering
                        const targetVx = Math.cos(angle) * 10;
                        const targetVy = Math.sin(angle) * 10;
                        this.vx = this.vx + (targetVx - this.vx) * steerStrength;
                        this.vy = this.vy + (targetVy - this.vy) * steerStrength;
                    }
                    
                    // Hit detection
                    for (let e of entities.enemies) {
                        if (e.hp > 0) {
                            const dist = Math.sqrt((e.x - this.x)**2 + (e.y - this.y)**2);
                            if (dist < e.radius + 8) {
                                player.dealElementalDamage(e, this.damage, 'turret', '#ff8800');
                                return false;
                            }
                        }
                    }
                }
                
                // EMP PULSE - Slow projectile that creates field on hit
                if (this.type === 'emp_pulse') {
                    if (this.target && this.target.hp > 0) {
                        const angle = Math.atan2(this.target.y - this.y, this.target.x - this.x);
                        const steerStrength = 0.05;
                        const targetVx = Math.cos(angle) * 8;
                        const targetVy = Math.sin(angle) * 8;
                        this.vx = this.vx + (targetVx - this.vx) * steerStrength;
                        this.vy = this.vy + (targetVy - this.vy) * steerStrength;
                    }
                    
                    // Hit detection
                    for (let e of entities.enemies) {
                        if (e.hp > 0) {
                            const dist = Math.sqrt((e.x - this.x)**2 + (e.y - this.y)**2);
                            if (dist < e.radius + 10) {
                                // Deal full damage to main target
                                player.dealElementalDamage(e, this.damage, 'emp', '#a855f7');
                                
                                // Create EMP field at impact point - use radius from weapon calculation
                                const fieldRadius = this.pierce; // Use pierce which holds the field radius
                                player.empFields.push({
                                    x: this.x,
                                    y: this.y,
                                    radius: fieldRadius,
                                    life: 150 // 2.5 seconds
                                });
                                
                                // Deal 50% damage to all OTHER enemies in the field area (not the main target)
                                // OPTIMIZATION: Only check enemies within field radius (avoid full loop)
                                const fieldRadiusSq = fieldRadius * fieldRadius;
                                entities.enemies.forEach(enemy => {
                                    if (enemy !== e && enemy.hp > 0) { // Already excludes main target
                                        const dx = enemy.x - this.x;
                                        const dy = enemy.y - this.y;
                                        const distSq = dx * dx + dy * dy;
                                        if (distSq < fieldRadiusSq) { // Use squared distance for speed
                                            player.dealElementalDamage(enemy, this.damage * 0.5, 'emp', '#a855f7');
                                        }
                                    }
                                });
                                
                                createExplosion(this.x, this.y, '#a855f7', 20);
                                return false;
                            }
                        }
                    }
                }
                
                this.x += this.vx * (dt/16); this.y += this.vy * (dt/16);
                this.life -= (dt/16); 
                return this.life > 0;
            }
            draw(ctx) {
                if (this.type === 'flak_shell') {
                    // Draw explosive flak shell with rotating segments and glowing trail
                    ctx.save();
                    ctx.translate(this.x, this.y);
                    
                    // Rotation based on travel
                    const angle = Math.atan2(this.vy, this.vx);
                    const spin = (Date.now() * 0.01) % (Math.PI * 2);
                    ctx.rotate(angle + spin);
                    
                    // Outer explosive glow (pulsing)
                    const pulse = 0.7 + Math.sin(Date.now() * 0.008) * 0.3;
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = '#ffaa00';
                    ctx.fillStyle = `rgba(255, 170, 0, ${pulse * 0.4})`;
                    ctx.beginPath();
                    ctx.arc(0, 0, 10, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Main shell body (hexagonal for shrapnel look)
                    ctx.shadowBlur = 8;
                    ctx.fillStyle = '#ffff00';
                    ctx.beginPath();
                    for (let i = 0; i < 6; i++) {
                        const a = (i / 6) * Math.PI * 2;
                        const x = Math.cos(a) * 6;
                        const y = Math.sin(a) * 6;
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.closePath();
                    ctx.fill();
                    
                    // Dark shrapnel segments
                    ctx.fillStyle = '#cc8800';
                    ctx.shadowBlur = 0;
                    for (let i = 0; i < 6; i++) {
                        const a = (i / 6) * Math.PI * 2;
                        ctx.beginPath();
                        ctx.moveTo(0, 0);
                        ctx.lineTo(Math.cos(a) * 6, Math.sin(a) * 6);
                        ctx.lineTo(Math.cos(a + Math.PI/6) * 6, Math.sin(a + Math.PI/6) * 6);
                        ctx.closePath();
                        if (i % 2 === 0) ctx.fill();
                    }
                    
                    // Bright core
                    ctx.fillStyle = '#ffffff';
                    ctx.shadowBlur = 6;
                    ctx.shadowColor = '#ffff00';
                    ctx.beginPath();
                    ctx.arc(0, 0, 3, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.restore();
                    
                    // Trailing particles (smoke trail) - PERFORMANCE OPTIMIZED
                    if (!this.trailTimer) this.trailTimer = 0;
                    this.trailTimer += 1;
                    
                    // Performance-based smoke interval
                    const perfMode = typeof state !== 'undefined' && state.performanceMode ? state.performanceMode : 'normal';
                    const smokeInterval = perfMode === 'minimal' ? 0 : perfMode === 'reduced' ? 6 : 4; // Every 4 frames (reduced from 3)
                    
                    if (smokeInterval > 0 && this.trailTimer >= smokeInterval) {
                        this.trailTimer = 0;
                        entities.particles.push({
                            x: this.x,
                            y: this.y,
                            vx: -this.vx * 0.2,
                            vy: -this.vy * 0.2,
                            color: '#ffaa00',
                            life: 20,
                            size: 4,
                            update: function(dt) {
                                this.x += this.vx * (dt/16);
                                this.y += this.vy * (dt/16);
                                this.life -= dt/16;
                                this.size *= 0.96;
                                return this.life > 0;
                            },
                            draw: function(ctx) {
                                ctx.fillStyle = this.color;
                                ctx.shadowBlur = 4;
                                ctx.shadowColor = this.color;
                                ctx.globalAlpha = this.life / 20;
                                ctx.beginPath();
                                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                                ctx.fill();
                                ctx.globalAlpha = 1;
                                ctx.shadowBlur = 0;
                            }
                        });
                    }
                    return;
                }
                if (this.type === 'bio_spore') {
                    ctx.fillStyle = '#00cc44'; ctx.beginPath(); ctx.arc(this.x,this.y,3,0,Math.PI*2); ctx.fill();
                    return;
                }
                if (this.type === 'gas_grenade') {
                    // Draw gas canister with toxic glow
                    ctx.save();
                    ctx.translate(this.x, this.y);
                    
                    const angle = Math.atan2(this.vy, this.vx);
                    ctx.rotate(angle);
                    
                    // Glow
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = '#99ff33';
                    
                    // Canister body
                    ctx.fillStyle = '#99ff33';
                    ctx.fillRect(-6, -4, 12, 8);
                    
                    // Dark center band
                    ctx.fillStyle = '#336600';
                    ctx.fillRect(-4, -3, 8, 6);
                    
                    // Trail particles
                    const trailLength = 5;
                    for (let i = 0; i < trailLength; i++) {
                        const t = i / trailLength;
                        const tx = -8 - (i * 4);
                        const alpha = (1 - t) * 0.5;
                        ctx.fillStyle = `rgba(153, 255, 51, ${alpha})`;
                        ctx.beginPath();
                        ctx.arc(tx, 0, 2, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    
                    ctx.restore();
                    return;
                }
                if (this.type === 'railgun') {
                    // Calculate end position first for viewport culling
                    const len = (375 + (this.railLevel * 25)) * this.animProgress;
                    const endX = this.origX + this.vx*len;
                    const endY = this.origY + this.vy*len;
                    
                    // VIEWPORT CULLING: Skip if entirely off-screen
                    const hasHelpers = typeof inViewport !== 'undefined';
                    if (hasHelpers && !inViewport(this.origX, this.origY) && !inViewport(endX, endY)) {
                        return; // Skip entire railgun rendering
                    }
                    
                    // Performance mode detection
                    const perfMode = typeof state !== 'undefined' && state.performanceMode ? state.performanceMode : 'normal';
                    const useShadows = perfMode === 'normal';
                    
                    ctx.save();
                    const baseAlpha = this.life / 45;
                    
                    // Draw multiple layers for a more dramatic pulse effect
                    
                    // Layer 1: Outer energy glow (widest, most diffuse)
                    const outerGlow = ctx.createLinearGradient(this.origX, this.origY, endX, endY);
                    outerGlow.addColorStop(0, `rgba(30, 100, 200, ${baseAlpha * 0.3})`);
                    outerGlow.addColorStop(0.15, `rgba(40, 120, 220, ${baseAlpha * 0.25})`);
                    outerGlow.addColorStop(0.5, `rgba(20, 80, 180, ${baseAlpha * 0.15})`);
                    outerGlow.addColorStop(1, `rgba(10, 60, 150, 0)`);
                    
                    ctx.strokeStyle = outerGlow;
                    ctx.lineWidth = 20 + (this.railLevel * 3);
                    ctx.lineCap = 'round';
                    ctx.beginPath(); 
                    ctx.moveTo(this.origX, this.origY); 
                    ctx.lineTo(endX, endY); 
                    ctx.stroke();
                    
                    // Layer 2: Mid energy beam
                    const midGlow = ctx.createLinearGradient(this.origX, this.origY, endX, endY);
                    midGlow.addColorStop(0, `rgba(60, 140, 255, ${baseAlpha * 0.7})`);
                    midGlow.addColorStop(0.2, `rgba(50, 120, 240, ${baseAlpha * 0.6})`);
                    midGlow.addColorStop(0.6, `rgba(40, 100, 220, ${baseAlpha * 0.4})`);
                    midGlow.addColorStop(1, `rgba(30, 80, 200, 0)`);
                    
                    ctx.strokeStyle = midGlow;
                    ctx.lineWidth = 10 + (this.railLevel * 2);
                    ctx.beginPath(); 
                    ctx.moveTo(this.origX, this.origY); 
                    ctx.lineTo(endX, endY); 
                    ctx.stroke();
                    
                    // Layer 3: Core beam (bright white center)
                    const coreGradient = ctx.createLinearGradient(this.origX, this.origY, endX, endY);
                    coreGradient.addColorStop(0, `rgba(255, 255, 255, ${baseAlpha})`);
                    coreGradient.addColorStop(0.25, `rgba(255, 255, 255, ${baseAlpha * 0.85})`);
                    coreGradient.addColorStop(0.7, `rgba(180, 200, 255, ${baseAlpha * 0.5})`);
                    coreGradient.addColorStop(1, `rgba(120, 160, 230, 0)`);
                    
                    ctx.strokeStyle = coreGradient;
                    ctx.lineWidth = 3 + (this.railLevel * 0.5);
                    ctx.beginPath(); 
                    ctx.moveTo(this.origX, this.origY); 
                    ctx.lineTo(endX, endY); 
                    ctx.stroke();
                    
                    // Layer 4: Muzzle flash at origin
                    if (this.life > 40) {
                        const flashAlpha = (this.life - 40) / 5;
                        ctx.fillStyle = `rgba(255, 255, 255, ${flashAlpha * 0.8})`;
                        if (useShadows) {
                            ctx.shadowBlur = 20;
                            ctx.shadowColor = '#3c8cff';
                        }
                        ctx.beginPath();
                        ctx.arc(this.origX, this.origY, 8 + (this.railLevel), 0, Math.PI*2);
                        ctx.fill();
                        if (useShadows) ctx.shadowBlur = 0;
                    }
                    
                    // Layer 5: Energy particles along the beam for texture (PERFORMANCE OPTIMIZED)
                    if (this.life > 30 && this.animProgress > 0.5 && perfMode !== 'minimal') {
                        const fullLen = 375 + (this.railLevel * 25);
                        const particleCount = perfMode === 'reduced' ? 2 : 3; // Reduced from 5
                        for (let i = 0; i < particleCount; i++) {
                            const t = (i / particleCount) * this.animProgress + (Math.sin(state.frameCount * 0.1 + i) * 0.05);
                            const px = this.origX + this.vx * fullLen * t;
                            const py = this.origY + this.vy * fullLen * t;
                            const particleAlpha = baseAlpha * (1 - t) * 0.6;
                            
                            ctx.fillStyle = `rgba(60, 140, 255, ${particleAlpha})`;
                            ctx.beginPath();
                            ctx.arc(px, py, 2 + this.railLevel * 0.3, 0, Math.PI*2);
                            ctx.fill();
                        }
                    }
                    
                    // Layer 6: MASSIVE swirling energy double-helix (PERFORMANCE OPTIMIZED)
                    if (this.life > 25 && this.animProgress > 0.2 && perfMode !== 'minimal') {
                        const fullLen = 375 + (this.railLevel * 25);
                        
                        // PARTICLE REDUCTION - Reduced base count for better performance
                        const baseSwirls = 11 + (this.railLevel * 2); // Reduced from 16+3 to 11+2
                        const numSwirls = Math.floor(baseSwirls * (perfMode === 'reduced' ? 0.6 : 1.0));
                        
                        // Calculate perpendicular directions for dual helix
                        const perpX = -this.vy;
                        const perpY = this.vx;
                        
                        // Draw TWO counter-rotating helixes
                        for (let helixNum = 0; helixNum < 2; helixNum++) {
                            const helixDir = helixNum === 0 ? 1 : -1; // Opposite rotation
                            
                            for (let i = 0; i < numSwirls; i++) {
                                const progress = (i / numSwirls) * this.animProgress;
                                const spiralOffset = (state.frameCount * 0.2 * helixDir + i * 1.2) % (Math.PI * 2);
                                
                                // Position along beam
                                const beamX = this.origX + this.vx * fullLen * progress;
                                const beamY = this.origY + this.vy * fullLen * progress;
                                
                                // Spiral radius - MUCH TIGHTER, stays close to core
                                const spiralRadius = (3 + progress * 5) * (1 + this.railLevel * 0.2);
                                
                                // Spiral position
                                const offsetDist = Math.sin(spiralOffset) * spiralRadius;
                                const px = beamX + perpX * offsetDist;
                                const py = beamY + perpY * offsetDist;
                                
                                // Fade MORE with distance - exponential falloff
                                const distanceFade = Math.pow(1 - progress, 1.5);
                                const fadeByLife = baseAlpha;
                                const particleAlpha = distanceFade * fadeByLife * 0.9;
                                
                                // Electric blue to cyan gradient
                                const intensity = Math.abs(Math.sin(spiralOffset));
                                const r = 80 + intensity * 175;
                                const g = 160 + intensity * 95;
                                const b = 255;
                                
                                // Particle size also shrinks with distance
                                const sizeScale = 1 - progress * 0.4;
                                
                                // Large outer glow with conditional shadow
                                ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${particleAlpha * 0.4})`;
                                if (useShadows) {
                                    ctx.shadowBlur = 15 * sizeScale;
                                    ctx.shadowColor = `rgba(${r}, ${g}, ${b}, ${particleAlpha * 0.8})`;
                                }
                                ctx.beginPath();
                                ctx.arc(px, py, (4 + this.railLevel * 0.6) * sizeScale, 0, Math.PI*2);
                                ctx.fill();
                                
                                // Bright white core
                                ctx.fillStyle = `rgba(255, 255, 255, ${particleAlpha})`;
                                if (useShadows) {
                                    ctx.shadowBlur = 6 * sizeScale;
                                    ctx.shadowColor = '#ffffff';
                                }
                                ctx.beginPath();
                                ctx.arc(px, py, 2 * sizeScale, 0, Math.PI*2);
                                ctx.fill();
                            }
                        }
                        if (useShadows) ctx.shadowBlur = 0;
                    }
                    
                    // Layer 7: Energy distortion waves (PERFORMANCE OPTIMIZED)
                    if (this.life > 35 && this.animProgress > 0.3 && perfMode !== 'minimal') {
                        const fullLen = 375 + (this.railLevel * 25);
                        const perpX = -this.vy;
                        const perpY = this.vx;
                        
                        // Reduce wave count across all modes
                        const waveCount = perfMode === 'reduced' ? 1 : 2; // Reduced from 3
                        
                        // 3 expanding energy rings along the beam
                        for (let i = 0; i < waveCount; i++) {
                            const waveProgress = (state.frameCount * 0.1 + i * 1.5) % 3;
                            const wavePos = (waveProgress / 3) * this.animProgress;
                            const distanceFade = 1 - wavePos; // Fade with distance
                            const waveSize = (8 + waveProgress * 6) * (1 - wavePos * 0.3); // Shrink with distance
                            const waveAlpha = baseAlpha * (1 - waveProgress / 3) * 0.5 * distanceFade;
                            
                            if (wavePos < this.animProgress) {
                                const wx = this.origX + this.vx * fullLen * wavePos;
                                const wy = this.origY + this.vy * fullLen * wavePos;
                                
                                ctx.strokeStyle = `rgba(100, 180, 255, ${waveAlpha})`;
                                ctx.lineWidth = 2 * (1 - wavePos * 0.4);
                                if (useShadows) {
                                    ctx.shadowBlur = 10 * distanceFade;
                                    ctx.shadowColor = `rgba(100, 180, 255, ${waveAlpha})`;
                                }
                                
                                // Draw ring perpendicular to beam
                                ctx.beginPath();
                                ctx.ellipse(wx, wy, waveSize, waveSize * 0.3, Math.atan2(this.vy, this.vx), 0, Math.PI * 2);
                                ctx.stroke();
                            }
                        }
                        if (useShadows) ctx.shadowBlur = 0;
                    }
                    
                    // Layer 8: Charge-up effect at origin (NEW!)
                    if (this.life > 42) { // First 3 frames
                        const chargeProgress = (45 - this.life) / 3;
                        const chargeSize = 15 * chargeProgress * (1 + this.railLevel * 0.2);
                        const chargeAlpha = chargeProgress * 0.8;
                        
                        // Imploding energy ring (clamp radius to prevent negative)
                        const ringRadius = Math.max(1, 30 - chargeSize);
                        ctx.strokeStyle = `rgba(100, 200, 255, ${chargeAlpha})`;
                        ctx.lineWidth = 3;
                        ctx.shadowBlur = 20;
                        ctx.shadowColor = '#3c8cff';
                        ctx.beginPath();
                        ctx.arc(this.origX, this.origY, ringRadius, 0, Math.PI * 2);
                        ctx.stroke();
                        
                        // Inner particles converging (also clamp dist)
                        for (let i = 0; i < 8; i++) {
                            const angle = (i / 8) * Math.PI * 2;
                            const dist = Math.max(1, ringRadius * 0.8);
                            const px = this.origX + Math.cos(angle) * dist;
                            const py = this.origY + Math.sin(angle) * dist;
                            
                            ctx.fillStyle = `rgba(150, 220, 255, ${chargeAlpha})`;
                            ctx.shadowBlur = 8;
                            ctx.beginPath();
                            ctx.arc(px, py, 2, 0, Math.PI * 2);
                            ctx.fill();
                        }
                        ctx.shadowBlur = 0;
                    }
                    
                    // Layer 9: Impact explosion at beam end (NEW!)
                    if (this.life > 38 && this.animProgress > 0.9) {
                        const len = (375 + (this.railLevel * 25)) * this.animProgress;
                        const endX = this.origX + this.vx * len;
                        const endY = this.origY + this.vy * len;
                        const impactProgress = (45 - this.life) / 7;
                        const impactSize = 10 + impactProgress * 25 * (1 + this.railLevel * 0.3);
                        const impactAlpha = baseAlpha * (1 - impactProgress) * 0.7;
                        
                        // Expanding shockwave
                        ctx.strokeStyle = `rgba(150, 220, 255, ${impactAlpha})`;
                        ctx.lineWidth = 3;
                        ctx.shadowBlur = 20;
                        ctx.shadowColor = '#3c8cff';
                        ctx.beginPath();
                        ctx.arc(endX, endY, impactSize, 0, Math.PI * 2);
                        ctx.stroke();
                        
                        // Bright flash
                        ctx.fillStyle = `rgba(255, 255, 255, ${impactAlpha * 0.8})`;
                        ctx.shadowBlur = 25;
                        ctx.shadowColor = '#ffffff';
                        ctx.beginPath();
                        ctx.arc(endX, endY, impactSize * 0.3, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Radiating sparks
                        for (let i = 0; i < 12; i++) {
                            const angle = (i / 12) * Math.PI * 2 + impactProgress;
                            const sparkDist = impactSize * 0.7;
                            const sx = endX + Math.cos(angle) * sparkDist;
                            const sy = endY + Math.sin(angle) * sparkDist;
                            
                            ctx.fillStyle = `rgba(180, 230, 255, ${impactAlpha})`;
                            ctx.beginPath();
                            ctx.arc(sx, sy, 2, 0, Math.PI * 2);
                            ctx.fill();
                        }
                        ctx.shadowBlur = 0;
                    }
                    
                    ctx.restore();
                    return;
                }


                if (this.type === 'meteor_warning') {
                    const progress = 1 - (this.life / this.maxLife);
                    ctx.save(); ctx.translate(this.x, this.y);
                    
                    // Multiple pulsing warning rings
                    for (let i = 0; i < 3; i++) {
                        const ringProgress = (progress + (i * 0.15)) % 1;
                        const ringAlpha = 0.4 * (1 - ringProgress);
                        const ringRadius = this.target.radius * (0.5 + ringProgress * 0.5);
                        ctx.strokeStyle = `rgba(255, 120, 50, ${ringAlpha})`;
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.arc(0, 0, ringRadius, 0, Math.PI*2);
                        ctx.stroke();
                    }
                    
                    // Impact zone fill - intensifies as meteor approaches
                    const fillAlpha = 0.2 + (progress * 0.3);
                    const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, this.target.radius * progress);
                    gradient.addColorStop(0, `rgba(255, 100, 0, ${fillAlpha})`);
                    gradient.addColorStop(0.6, `rgba(255, 150, 50, ${fillAlpha * 0.5})`);
                    gradient.addColorStop(1, 'rgba(255, 200, 100, 0)');
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(0, 0, this.target.radius * progress, 0, Math.PI*2);
                    ctx.fill();
                    
                    // Outer danger ring - solid line instead of dashed
                    ctx.strokeStyle = `rgba(255, 100, 0, ${0.8 + Math.sin(progress * 20) * 0.2})`;
                    ctx.lineWidth = 3;
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = 'rgba(255, 100, 0, 0.5)';
                    ctx.beginPath();
                    ctx.arc(0, 0, this.target.radius, 0, Math.PI*2);
                    ctx.stroke();
                    ctx.shadowBlur = 0;
                    
                    // Falling meteor with trail - comes in at 45 degree angle
                    const h = (this.life / this.maxLife) * 600;
                    const angleOffset = h * 0.7; // Diagonal approach
                    const meteorSize = 10 + (1 - this.life / this.maxLife) * 8; // Grows as it approaches
                    
                    // Meteor trail
                    for (let j = 0; j < 5; j++) {
                        const trailOffset = j * 15;
                        const trailAlpha = (1 - j / 5) * 0.6;
                        const trailSize = meteorSize * (1 - j / 6);
                        const trailAngleOffset = (h + trailOffset) * 0.7;
                        ctx.fillStyle = `rgba(255, 150, 50, ${trailAlpha})`;
                        ctx.shadowBlur = 15;
                        ctx.shadowColor = '#ff6600';
                        ctx.beginPath();
                        ctx.arc(-trailAngleOffset, -h - trailOffset, trailSize * 0.7, 0, Math.PI*2);
                        ctx.fill();
                    }
                    
                    // Main meteor body
                    const meteorGradient = ctx.createRadialGradient(-angleOffset, -h, 0, -angleOffset, -h, meteorSize);
                    meteorGradient.addColorStop(0, '#ffffff');
                    meteorGradient.addColorStop(0.3, '#ffaa00');
                    meteorGradient.addColorStop(0.7, '#ff6600');
                    meteorGradient.addColorStop(1, '#cc3300');
                    ctx.fillStyle = meteorGradient;
                    ctx.shadowColor = '#ff8800';
                    ctx.shadowBlur = 25;
                    ctx.beginPath();
                    ctx.arc(-angleOffset, -h, meteorSize, 0, Math.PI*2);
                    ctx.fill();
                    
                    // Fiery glow around meteor
                    ctx.fillStyle = `rgba(255, 100, 0, ${0.3})`;
                    ctx.shadowBlur = 35;
                    ctx.beginPath();
                    ctx.arc(-angleOffset, -h, meteorSize * 1.8, 0, Math.PI*2);
                    ctx.fill();
                    
                    ctx.shadowBlur = 0;
                    ctx.restore();
                    return;
                }


                if (this.type === 'seeker') {
                    const angle = Math.atan2(this.vy, this.vx);
                    ctx.save(); 
                    ctx.translate(this.x, this.y); 
                    ctx.rotate(angle);
                    
                    // Animated exhaust flame - flickering length and intensity
                    const flicker1 = Math.sin(state.frameCount * 0.4) * 0.15;
                    const flicker2 = Math.sin(state.frameCount * 0.6 + 1.5) * 0.1;
                    const flamePulse = 0.75 + flicker1 + flicker2; // 0.5 to 1.0
                    const flameLength = 35 * flamePulse; // Increased from 28 to 35
                    
                    // Outer flame (orange glow) - diffused edges
                    const outerFlameGradient = ctx.createLinearGradient(-5, 0, -5 - flameLength, 0);
                    outerFlameGradient.addColorStop(0, 'rgba(255, 100, 0, 0.9)');
                    outerFlameGradient.addColorStop(0.3, 'rgba(255, 85, 0, 0.7)');
                    outerFlameGradient.addColorStop(0.7, 'rgba(255, 60, 0, 0.3)');
                    outerFlameGradient.addColorStop(1, 'rgba(255, 85, 0, 0)');
                    
                    ctx.fillStyle = outerFlameGradient;
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = '#ff5500';
                    ctx.beginPath();
                    ctx.moveTo(-5, 0);
                    ctx.lineTo(-5 - flameLength, -5 * flamePulse);
                    ctx.lineTo(-5 - flameLength * 1.1, 0);
                    ctx.lineTo(-5 - flameLength, 5 * flamePulse);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Inner flame (hot yellow core)
                    const innerFlameGradient = ctx.createLinearGradient(-5, 0, -5 - flameLength * 0.6, 0);
                    innerFlameGradient.addColorStop(0, 'rgba(255, 220, 100, 1)');
                    innerFlameGradient.addColorStop(0.5, 'rgba(255, 150, 50, 0.8)');
                    innerFlameGradient.addColorStop(1, 'rgba(255, 100, 0, 0)');
                    
                    ctx.fillStyle = innerFlameGradient;
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = '#ffaa00';
                    ctx.beginPath();
                    ctx.moveTo(-5, 0);
                    ctx.lineTo(-5 - flameLength * 0.6, -2.5 * flamePulse);
                    ctx.lineTo(-5 - flameLength * 0.7, 0);
                    ctx.lineTo(-5 - flameLength * 0.6, 2.5 * flamePulse);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Missile body (small cylinder behind warhead)
                    ctx.shadowBlur = 8;
                    ctx.shadowColor = '#666';
                    ctx.fillStyle = '#888';
                    ctx.fillRect(-5, -3, 9, 6); // Increased from 8x5 to 9x6
                    
                    // Warhead (nose cone) - sleek
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = '#ffaa00';
                    ctx.fillStyle = '#ffaa00'; 
                    ctx.beginPath(); 
                    ctx.moveTo(6, 0); // Extended from 5 to 6
                    ctx.lineTo(-5, -4.5); // Increased from -4 to -4.5
                    ctx.lineTo(-5, 4.5); // Increased from 4 to 4.5
                    ctx.fill();
                    
                    // Bright tip
                    ctx.fillStyle = '#fff'; 
                    ctx.shadowBlur = 10;
                    ctx.beginPath(); 
                    ctx.moveTo(6, 0); // Extended from 5 to 6
                    ctx.lineTo(-2, -2.5); // Slightly larger
                    ctx.lineTo(-2, 2.5); // Slightly larger
                    ctx.fill();
                    
                    ctx.shadowBlur = 0;
                    ctx.restore();
                } else if (this.type === 'drone_shot') {
                    // Enhanced cyan energy bolt with trail effect
                    ctx.save();
                    
                    // Energy trail particles (very light weight)
                    const angle = Math.atan2(this.vy, this.vx);
                    for (let i = 1; i <= 3; i++) {
                        const trailOffset = i * 6;
                        const trailAlpha = (4 - i) / 4; // Fades from 0.75 to 0.25
                        const trailSize = 3 + (4 - i);
                        
                        const trailX = this.x - Math.cos(angle) * trailOffset;
                        const trailY = this.y - Math.sin(angle) * trailOffset;
                        
                        ctx.fillStyle = `rgba(0, 221, 255, ${trailAlpha * 0.4})`;
                        ctx.shadowBlur = 8;
                        ctx.shadowColor = '#00aaff';
                        ctx.beginPath();
                        ctx.arc(trailX, trailY, trailSize, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    
                    // Main energy bolt (brighter and larger)
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = '#00ddff';
                    ctx.fillStyle = '#00ddff';
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, 5, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Bright white core
                    ctx.fillStyle = '#ffffff';
                    ctx.shadowBlur = 10;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, 2.5, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.shadowBlur = 0;
                    ctx.restore();
                } else if (this.type === 'ricochet') {
                    // Draw solid glowing trail with fade based on age (draw FIRST, before disc)
                    if (this.trail.length > 1) {
                        const now = Date.now();
                        const maxAge = 400; // 0.4 seconds (reduced from 1 second)
                        
                        ctx.save();
                        ctx.lineCap = 'round';
                        ctx.lineJoin = 'round';
                        
                        // Draw trail segments with fading opacity
                        for (let i = 1; i < this.trail.length; i++) {
                            const p1 = this.trail[i - 1];
                            const p2 = this.trail[i];
                            const age = now - p2.time;
                            const fadeRatio = 1 - (age / maxAge); // Newer = 1.0, older = 0.0
                            
                            if (fadeRatio > 0) {
                                // Outer glow - subtle
                                ctx.strokeStyle = `rgba(255, 136, 0, ${fadeRatio * 0.25})`; // Reduced from 0.8
                                ctx.lineWidth = 5; // Reduced from 10
                                ctx.shadowBlur = 8; // Reduced from 15
                                ctx.shadowColor = '#ff8800';
                                ctx.beginPath();
                                ctx.moveTo(p1.x, p1.y);
                                ctx.lineTo(p2.x, p2.y);
                                ctx.stroke();
                                
                                // Inner bright line
                                ctx.strokeStyle = `rgba(255, 170, 0, ${fadeRatio * 0.5})`; // Reduced from white/1.0
                                ctx.lineWidth = 2; // Reduced from 4
                                ctx.shadowBlur = 4; // Reduced from 8
                                ctx.shadowColor = '#ffaa00';
                                ctx.beginPath();
                                ctx.moveTo(p1.x, p1.y);
                                ctx.lineTo(p2.x, p2.y);
                                ctx.stroke();
                            }
                        }
                        
                        ctx.restore();
                    }
                    
                    // NOW draw the bright orange spinning disc (in its own transform)
                    ctx.save();
                    ctx.translate(this.x, this.y);
                    
                    // Rotation based on time
                    const spinAngle = state.frameCount * 0.3;
                    ctx.rotate(spinAngle);
                    
                    // Outer glow
                    ctx.shadowBlur = 25;
                    ctx.shadowColor = '#ff8800';
                    ctx.fillStyle = 'rgba(255, 136, 0, 0.6)';
                    ctx.beginPath();
                    ctx.arc(0, 0, 12, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Bright core disc
                    ctx.shadowBlur = 15;
                    ctx.fillStyle = '#ff8800';
                    ctx.beginPath();
                    ctx.arc(0, 0, 8, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Inner highlight
                    ctx.shadowBlur = 0;
                    ctx.fillStyle = '#ffaa00';
                    ctx.beginPath();
                    ctx.arc(0, 0, 4, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Spinning blade lines for visual motion
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 2;
                    ctx.shadowBlur = 8;
                    ctx.shadowColor = '#ffffff';
                    for (let i = 0; i < 4; i++) {
                        const angle = (Math.PI / 2) * i;
                        ctx.beginPath();
                        ctx.moveTo(Math.cos(angle) * 3, Math.sin(angle) * 3);
                        ctx.lineTo(Math.cos(angle) * 7, Math.sin(angle) * 7);
                        ctx.stroke();
                    }
                    
                    ctx.restore();
                } else if (this.type === 'drone_rocket') {
                    // Magenta plasma ball with spiraling energy
                    ctx.save();
                    ctx.translate(this.x, this.y);
                    
                    // Rotation for spiral effect
                    const rotation = state.frameCount * 0.2;
                    
                    // Outer plasma glow (magenta)
                    ctx.shadowBlur = 30;
                    ctx.shadowColor = '#ff00ff';
                    ctx.fillStyle = 'rgba(255, 0, 255, 0.5)';
                    ctx.beginPath();
                    ctx.arc(0, 0, 9, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Bright magenta core
                    ctx.shadowBlur = 20;
                    ctx.fillStyle = '#ff00ff';
                    ctx.beginPath();
                    ctx.arc(0, 0, 6, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // White hot center
                    ctx.shadowBlur = 0;
                    ctx.fillStyle = '#ffffff';
                    ctx.beginPath();
                    ctx.arc(0, 0, 3, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Spiraling energy trails (3 spirals)
                    ctx.strokeStyle = '#ff88ff';
                    ctx.lineWidth = 2;
                    ctx.shadowBlur = 8;
                    ctx.shadowColor = '#ff00ff';
                    for (let i = 0; i < 3; i++) {
                        const spiralOffset = (i * Math.PI * 2 / 3);
                        const spiralAngle = rotation + spiralOffset;
                        const spiralRadius = 7;
                        
                        ctx.beginPath();
                        ctx.moveTo(0, 0);
                        ctx.quadraticCurveTo(
                            Math.cos(spiralAngle - 0.5) * spiralRadius * 0.5,
                            Math.sin(spiralAngle - 0.5) * spiralRadius * 0.5,
                            Math.cos(spiralAngle) * spiralRadius,
                            Math.sin(spiralAngle) * spiralRadius
                        );
                        ctx.stroke();
                    }
                    
                    ctx.shadowBlur = 0;
                    ctx.restore();
                } else if (this.type === 'drone_rocket') {
                    // Orange mini-rocket
                    ctx.save();
                    const angle = Math.atan2(this.vy, this.vx);
                    ctx.translate(this.x, this.y);
                    ctx.rotate(angle);
                    
                    // Rocket body
                    ctx.fillStyle = '#ff8800';
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = '#ff8800';
                    ctx.fillRect(-6, -2, 10, 4);
                    
                    // Bright tip
                    ctx.fillStyle = '#ffff00';
                    ctx.fillRect(4, -1.5, 3, 3);
                    
                    // Engine glow
                    ctx.fillStyle = '#ffaa00';
                    ctx.shadowBlur = 20;
                    ctx.beginPath();
                    ctx.arc(-6, 0, 3, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.shadowBlur = 0;
                    ctx.restore();
                    
                    // Exhaust trail (2 frames = ~0.033s at 60fps)
                    if (!this.exhaustParticleTimer) this.exhaustParticleTimer = 0;
                    this.exhaustParticleTimer += dt/16;
                    if (this.exhaustParticleTimer >= 2) {
                        this.exhaustParticleTimer -= 2;
                        entities.particles.push({
                            x: this.x,
                            y: this.y,
                            life: 8,
                            size: 3,
                            color: '#ff8800',
                            update: function(dt) {
                                this.life -= dt/16;
                                this.size *= 0.95;
                                return this.life > 0;
                            },
                            draw: function(ctx) {
                                ctx.fillStyle = this.color;
                                ctx.globalAlpha = this.life / 8;
                                ctx.shadowBlur = 8;
                                ctx.shadowColor = this.color;
                                ctx.beginPath();
                                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                                ctx.fill();
                                ctx.globalAlpha = 1;
                                ctx.shadowBlur = 0;
                            }
                        });
                    }
                } else if (this.type === 'mine') {
                    // Collapsar mine: Circular design with bright magenta/red gravity theme (smaller size)
                    ctx.save();
                    ctx.translate(this.x, this.y);
                    
                    const isArming = this.life > 570;
                    const armingProgress = isArming ? (600 - this.life) / 30 : 1; // 0 to 1 over 0.5 seconds
                    
                    // Determine visual state - BRIGHTER COLORS
                    let primaryColor, secondaryColor, pulseSpeed, glowIntensity;
                    
                    if (isArming) {
                        // Arming phase: pulsing magenta, building up energy
                        primaryColor = '#ff33bb'; // Brighter
                        secondaryColor = '#dd0099'; // Brighter
                        pulseSpeed = 0.3;
                        glowIntensity = armingProgress * 0.5; // Ramps up during arming
                    } else if (this.triggered) {
                        // Triggered: intense magenta/red pulsing with gravity waves
                        const countdown = this.detonationTimer / 60; // 0 to 1
                        primaryColor = '#ff44cc'; // Brighter
                        secondaryColor = '#ff0088'; // Brighter
                        pulseSpeed = 5 - (countdown * 4); // Speeds up as countdown approaches zero
                        glowIntensity = 1.5 - (countdown * 0.5); // Intensifies as it gets closer to detonation
                    } else {
                        // Armed and ready: steady magenta glow
                        primaryColor = '#ff44cc'; // Brighter
                        secondaryColor = '#ff0099'; // Brighter
                        pulseSpeed = 0.1;
                        glowIntensity = 0.3 + Math.sin(this.pulsePhase) * 0.2;
                    }
                    
                    const pulseIntensity = 0.5 + Math.sin(this.pulsePhase * pulseSpeed) * 0.5;
                    
                    // Gravity field rings when triggered (pulling effect) - WHITE/BRIGHT for visibility
                    if (this.triggered) {
                        const gravityRadius = this.blastRadius * 1.6;
                        for (let i = 0; i < 4; i++) {
                            const ringProgress = (this.pulsePhase * pulseSpeed * 0.5 + i * 0.25) % 1;
                            const ringAlpha = (1 - ringProgress) * 0.6;
                            const ringRadius = 15 + (ringProgress * (gravityRadius * 0.5));
                            ctx.strokeStyle = `rgba(255, 255, 255, ${ringAlpha})`; // WHITE gravity rings for visibility
                            ctx.lineWidth = 2;
                            ctx.beginPath();
                            ctx.arc(0, 0, ringRadius, 0, Math.PI*2);
                            ctx.stroke();
                        }
                    }
                    
                    // Detection radius ring (only when armed, not triggered)
                    if (!isArming && !this.triggered) {
                        ctx.strokeStyle = `rgba(255, 68, 204, ${0.15 + glowIntensity * 0.2})`; // Brighter magenta detection ring
                        ctx.lineWidth = 1;
                        ctx.setLineDash([5, 5]);
                        ctx.beginPath();
                        ctx.arc(0, 0, this.detectionRadius, 0, Math.PI*2);
                        ctx.stroke();
                        ctx.setLineDash([]);
                    }
                    
                    // Outer glow (smaller)
                    const glowSize = 10 + (pulseIntensity * glowIntensity * 3);
                    const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, glowSize);
                    gradient.addColorStop(0, primaryColor);
                    gradient.addColorStop(0.5, secondaryColor);
                    gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
                    
                    ctx.fillStyle = gradient;
                    ctx.shadowBlur = 15 + (glowIntensity * 10);
                    ctx.shadowColor = primaryColor;
                    ctx.beginPath();
                    ctx.arc(0, 0, glowSize, 0, Math.PI*2);
                    ctx.fill();
                    
                    // Main body - circular with rotating segments (smaller)
                    ctx.shadowBlur = 12;
                    ctx.fillStyle = primaryColor;
                    ctx.beginPath();
                    ctx.arc(0, 0, 6, 0, Math.PI*2);
                    ctx.fill();
                    
                    // Rotating energy segments (4 segments, smaller) - Keep original secondary color style
                    const rotationSpeed = isArming ? 0.1 : (this.triggered ? 0.5 : 0.05);
                    for (let i = 0; i < 4; i++) {
                        const angle = (this.pulsePhase * rotationSpeed) + (i * Math.PI / 2);
                        const segmentLength = 5;
                        const segmentDist = 7;
                        
                        ctx.strokeStyle = secondaryColor;
                        ctx.lineWidth = 2;
                        ctx.lineCap = 'round';
                        ctx.shadowBlur = 8;
                        ctx.shadowColor = secondaryColor;
                        
                        ctx.beginPath();
                        ctx.moveTo(
                            Math.cos(angle) * segmentDist,
                            Math.sin(angle) * segmentDist
                        );
                        ctx.lineTo(
                            Math.cos(angle) * (segmentDist + segmentLength),
                            Math.sin(angle) * (segmentDist + segmentLength)
                        );
                        ctx.stroke();
                    }
                    
                    // Inner core - pulses with state (smaller) - Keep original white
                    ctx.fillStyle = this.triggered ? '#ffffff' : '#ffffff';
                    ctx.shadowBlur = 6;
                    ctx.shadowColor = primaryColor;
                    ctx.beginPath();
                    ctx.arc(0, 0, 2.5 + (pulseIntensity * 1.5), 0, Math.PI*2);
                    ctx.fill();
                    
                    // Arming indicator - expanding ring during arming phase (smaller)
                    if (isArming) {
                        ctx.strokeStyle = `rgba(255, 51, 187, ${1 - armingProgress})`; // Brighter magenta arming ring
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.arc(0, 0, 6 + (armingProgress * 10), 0, Math.PI*2);
                        ctx.stroke();
                    }
                    
                    ctx.shadowBlur = 0;
                    ctx.restore();
                } else if (this.type === 'turret_shot') {
                    // Orange turret shot - simple glowing orb
                    ctx.save();
                    ctx.translate(this.x, this.y);
                    
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = '#ff8800';
                    ctx.fillStyle = '#ff8800';
                    ctx.beginPath();
                    ctx.arc(0, 0, 5, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.fillStyle = '#ffaa00';
                    ctx.beginPath();
                    ctx.arc(0, 0, 3, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.shadowBlur = 0;
                    ctx.restore();
                } else if (this.type === 'emp_pulse') {
                    // Purple EMP pulse - pulsing orb
                    ctx.save();
                    ctx.translate(this.x, this.y);
                    
                    const pulse = 0.8 + Math.sin(state.frameCount * 0.15) * 0.2;
                    
                    ctx.shadowBlur = 20 * pulse;
                    ctx.shadowColor = '#a855f7';
                    ctx.fillStyle = '#a855f7';
                    ctx.beginPath();
                    ctx.arc(0, 0, 6 * pulse, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.fillStyle = '#c084fc';
                    ctx.beginPath();
                    ctx.arc(0, 0, 4 * pulse, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.shadowBlur = 0;
                    ctx.restore();
                } else {
                    ctx.strokeStyle = 'rgba(0,255,245,0.5)'; ctx.lineWidth = 2; ctx.beginPath();
                    this.trail.forEach((p,i) => { if(i===0) ctx.moveTo(p.x,p.y); else ctx.lineTo(p.x,p.y); });
                    ctx.stroke(); ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(this.x, this.y, 3, 0, Math.PI*2); ctx.fill();
                }
            }
        }


        class Shockwave {
            constructor(x, y, maxR, color = '#00ffff') { this.x=x; this.y=y; this.r=1; this.maxR=maxR; this.life=1; this.color=color; }
            update(dt = 16) { 
                const scaledDt = dt || 16; // Default to 16ms if no dt provided
                this.r += (this.maxR-this.r)*0.1*(scaledDt/16); 
                this.life -= 0.05*(scaledDt/16); 
                return this.life>0; 
            }
            draw(ctx) {
                ctx.globalAlpha=this.life; ctx.strokeStyle=this.color; ctx.lineWidth=3;
                ctx.shadowBlur = 10; ctx.shadowColor = this.color;
                ctx.beginPath(); ctx.arc(this.x, this.y, this.r, 0, Math.PI*2); ctx.stroke();
                ctx.shadowBlur = 0;
                ctx.globalAlpha=1;
            }
        }


        class ShrapnelSpark {
            constructor(x, y, angle, speed) {
                this.x = x; this.y = y; 
                this.vx = Math.cos(angle) * speed;
                this.vy = Math.sin(angle) * speed;
                this.life = 1.0;
                this.angle = angle;
            }
            update(dt = 16) {
                const scaledDt = dt || 16;
                this.x += this.vx * (scaledDt/16);
                this.y += this.vy * (scaledDt/16);
                this.vx *= Math.pow(0.9, scaledDt/16); 
                this.vy *= Math.pow(0.9, scaledDt/16); 
                this.life -= 0.05 * (scaledDt/16); 
                return this.life > 0;
            }
            draw(ctx) {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle);
                ctx.globalAlpha = this.life;
                ctx.fillStyle = '#ffffaa';
                ctx.fillRect(0, -1, 10 + (this.life * 5), 2);
                ctx.globalAlpha = 1.0;
                ctx.restore();
            }
        }


        class Pickup {
            constructor(x, y, val, type='xp') { this.x = x; this.y = y; this.val = val; this.type = type; this.magnetized = false; }
            update(dt) {
                const dx = player.x - this.x; const dy = player.y - this.y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                
                if (this.magnetized || dist < player.pickupRadius) {
                    if(!this.magnetized) this.magnetized = true;
                    const speed = 15;
                    this.x += (dx/dist)*speed*(dt/16); this.y += (dy/dist)*speed*(dt/16);
                }
                
                if(this.magnetized) {
                     // Only data cores and mod crates magnetize other pickups
                     const isDataCore = (this.type === 'core' || this.type === 'mod_crate');
                     if (isDataCore) {
                         const magnetRange = 9999; // Data cores = infinite range (reverted)
                         entities.pickups.forEach(p => {
                             if(p !== this && !p.magnetized) {
                                 const dist = Math.sqrt((p.x-this.x)**2 + (p.y-this.y)**2);
                                 if(dist < magnetRange) {
                                     p.magnetized = true;
                                 }
                             }
                         });
                     }
                     // Normal XP shards DON'T magnetize other pickups (this was the bug!)
                }


                if (dist < player.radius + 10) { 
                    if (this.type === 'xp') gainXp(this.val);
                    if (this.type === 'health') { player.heal(30, true); } // Reduced from 50 to 30 
                    // Shield cells removed from game
                    if (this.type === 'shield_cell') { 
                        return false; // Remove pickup
                    }
                    if (this.type === 'magnet') { activateMagnet(); }
                    if (this.type === 'nexus_core') {
                        // TEST MODE: Don't save cores in test mode (would be cheating)
                        if (testModeEnabled) {
                            console.log('üß™ TEST MODE: Nexus Core collected but NOT saved');
                            createExplosion(player.x, player.y, '#ff00ff', 30);
                        } else {
                            // NORMAL MODE: Collect Nexus Core - increment counter with Ascension multiplier
                            const currentCores = parseInt(localStorage.getItem('neonrogue_nexusCores') || '0');
                            
                            // Calculate cores to award based on Ascension level
                            let coresToAward = 1; // Base: 1 core
                            if (state.activeAscension > 0) {
                                const ascensionData = {
                                    1: 2.0, // Ascension 1: +100% cores (2x)
                                    2: 3.0, // Ascension 2: +200% cores (3x)
                                    3: 4.0, // Ascension 3: +300% cores (4x)
                                    4: 5.0, // Ascension 4: +400% cores (5x)
                                    5: 6.0  // Ascension 5: +500% cores (6x)
                                };
                                coresToAward = Math.floor(ascensionData[state.activeAscension] || 1);
                                console.log(`üî• Ascension ${state.activeAscension}: ${coresToAward}x cores awarded!`);
                            }
                            
                            localStorage.setItem('neonrogue_nexusCores', currentCores + coresToAward);
                            createExplosion(player.x, player.y, '#ff00ff', 30);
                            
                            console.log(`üíé Nexus Core(s) collected! +${coresToAward} cores`);
                            console.log('   pendingUltimateSelection:', state.pendingUltimateSelection);
                        }
                        
                        // ULTIMATE SELECTION: Queue it (in both test and normal mode)
                        if (state.pendingUltimateSelection) {
                            console.log('‚úÖ Queuing ultimate selection...');
                            state.pendingUltimateSelection = false;
                            
                            // Add to upgrade queue
                            if (!state.upgradeQueue) state.upgradeQueue = [];
                            state.upgradeQueue.push({ type: 'ultimate' });
                            
                            // If not currently showing any upgrade screen, show it now
                            if (state.screen === 'game' && !player.ultimateActive) {
                                processNextUpgrade();
                            }
                        } else {
                            console.log('‚ö†Ô∏è No pending ultimate selection');
                        }
                    }
                    if (this.type === 'singularity') {
                        // Collect Quantum Singularity - trigger victory!
                        if (!testModeEnabled) {
                            // Only save in normal mode
                            const currentSingularities = parseInt(localStorage.getItem('neonrogue_singularities') || '0');
                            localStorage.setItem('neonrogue_singularities', currentSingularities + 1);
                            console.log(`üåå Singularity collected! Total: ${currentSingularities + 1}`);
                        } else {
                            console.log('üß™ TEST MODE: Singularity collected but NOT saved');
                        }
                        createExplosion(player.x, player.y, '#ff00ff', 50);
                        // Camera shake removed
                        
                        // Trigger victory after brief delay
                        setTimeout(() => {
                            showVictory();
                        }, 500);
                    }
                    if (this.type === 'core') { gainXp(state.xpToNext * 3); } 
                    if (this.type === 'mod_crate') { 
                        if(state.screen !== 'game') return true; 
                        triggerModPickup();
                    }
                    return false; 
                }
                return true;
            }
            draw(ctx) {
                if (this.type === 'xp') {
                    ctx.fillStyle = '#00d1b2'; ctx.shadowColor = '#00d1b2'; ctx.shadowBlur = 8;
                    ctx.beginPath(); ctx.moveTo(this.x, this.y-5); ctx.lineTo(this.x+5, this.y); ctx.lineTo(this.x, this.y+5); ctx.lineTo(this.x-5, this.y); ctx.fill(); ctx.shadowBlur = 0;
                } else if (this.type === 'health') {
                    // Health pack - glowing red cross with pulsing animation
                    const pulse = 0.8 + Math.sin(Date.now() * 0.005) * 0.2;
                    
                    // Background glow
                    ctx.fillStyle = `rgba(255, 50, 50, ${0.3 * pulse})`;
                    ctx.shadowColor = '#ff3232';
                    ctx.shadowBlur = 20 * pulse;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, 12, 0, Math.PI*2);
                    ctx.fill();
                    
                    // White cross with red glow
                    ctx.fillStyle = '#ffffff';
                    ctx.shadowColor = '#ff0000';
                    ctx.shadowBlur = 8;
                    // Vertical bar
                    ctx.fillRect(this.x - 2, this.y - 8, 4, 16);
                    // Horizontal bar
                    ctx.fillRect(this.x - 8, this.y - 2, 16, 4);
                    
                    // Outer frame
                    ctx.strokeStyle = '#ff3232';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(this.x - 10, this.y - 10, 20, 20);
                    
                    ctx.shadowBlur = 0;
                } else if (this.type === 'shield_cell') {
                    // Shield cells removed from game - don't render
                    return;
                } else if (this.type === 'magnet') {
                    // Magnet - Simple iconic design with pulsing field
                    const pulse = 0.7 + Math.sin(Date.now() * 0.006) * 0.3;
                    
                    // Magnetic field rings - cyan/white theme
                    ctx.save();
                    ctx.translate(this.x, this.y);
                    
                    for (let i = 0; i < 3; i++) {
                        const fieldRadius = 10 + i * 5;
                        ctx.strokeStyle = `rgba(100, 200, 255, ${0.3 * pulse * (1 - i / 3)})`;
                        ctx.lineWidth = 1.5;
                        ctx.beginPath();
                        ctx.arc(0, 0, fieldRadius, 0, Math.PI*2);
                        ctx.stroke();
                    }
                    
                    // Stylized M letter with glow
                    ctx.font = 'bold 20px Arial';
                    ctx.fillStyle = '#ffffff';
                    ctx.shadowColor = '#00ccff';
                    ctx.shadowBlur = 12 * pulse;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('M', 0, 0);
                    
                    // Subtle circle background
                    ctx.globalAlpha = 0.3;
                    ctx.fillStyle = '#00ccff';
                    ctx.shadowBlur = 0;
                    ctx.beginPath();
                    ctx.arc(0, 0, 12, 0, Math.PI*2);
                    ctx.fill();
                    ctx.globalAlpha = 1;
                    
                    ctx.shadowBlur = 0;
                    ctx.restore();
                } else if (this.type === 'nexus_core') {
                    // Nexus Core - Premium purple/magenta glowing crystal
                    const pulse = 0.6 + Math.sin(Date.now() * 0.004) * 0.4;
                    const rotation = Date.now() * 0.001;
                    
                    ctx.save();
                    ctx.translate(this.x, this.y);
                    ctx.rotate(rotation);
                    
                    // Outer glow aura
                    const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, 25);
                    gradient.addColorStop(0, `rgba(255, 0, 255, ${0.4 * pulse})`);
                    gradient.addColorStop(0.5, `rgba(180, 0, 200, ${0.2 * pulse})`);
                    gradient.addColorStop(1, 'rgba(255, 0, 255, 0)');
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(0, 0, 25, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Main hexagon crystal
                    ctx.fillStyle = '#aa00ff';
                    ctx.strokeStyle = '#ff00ff';
                    ctx.lineWidth = 2;
                    ctx.shadowColor = '#ff00ff';
                    ctx.shadowBlur = 20 * pulse;
                    ctx.beginPath();
                    for (let i = 0; i < 6; i++) {
                        const angle = (Math.PI / 3) * i;
                        const x = Math.cos(angle) * 12;
                        const y = Math.sin(angle) * 12;
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                    
                    // Inner glow core
                    ctx.fillStyle = '#ffffff';
                    ctx.globalAlpha = pulse;
                    ctx.shadowBlur = 10;
                    ctx.beginPath();
                    ctx.arc(0, 0, 5, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.globalAlpha = 1;
                    
                    // Energy particles orbiting
                    for (let i = 0; i < 4; i++) {
                        const orbitAngle = rotation * 2 + (i * Math.PI / 2);
                        const orbitRadius = 16;
                        const px = Math.cos(orbitAngle) * orbitRadius;
                        const py = Math.sin(orbitAngle) * orbitRadius;
                        ctx.fillStyle = `rgba(255, 100, 255, ${pulse})`;
                        ctx.shadowBlur = 8;
                        ctx.beginPath();
                        ctx.arc(px, py, 2, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    
                    ctx.shadowBlur = 0;
                    ctx.restore();
                    
                } else if (this.type === 'singularity') {
                    // QUANTUM SINGULARITY - Ultra-rare boss drop with insane effects
                    const pulse = 0.5 + Math.sin(Date.now() * 0.006) * 0.5;
                    const rotation = Date.now() * 0.002;
                    const time = Date.now() * 0.001;
                    
                    ctx.save();
                    ctx.translate(this.x, this.y);
                    
                    // Massive outer distortion field
                    const distortionGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, 60);
                    distortionGradient.addColorStop(0, `rgba(255, 0, 255, ${0.6 * pulse})`);
                    distortionGradient.addColorStop(0.3, `rgba(138, 43, 226, ${0.4 * pulse})`);
                    distortionGradient.addColorStop(0.6, `rgba(75, 0, 130, ${0.2 * pulse})`);
                    distortionGradient.addColorStop(1, 'rgba(255, 0, 255, 0)');
                    ctx.fillStyle = distortionGradient;
                    ctx.beginPath();
                    ctx.arc(0, 0, 60, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Rotating energy rings
                    for (let ring = 0; ring < 3; ring++) {
                        ctx.rotate(rotation + ring * Math.PI / 3);
                        ctx.strokeStyle = `rgba(255, 0, 255, ${0.5 * pulse})`;
                        ctx.lineWidth = 2;
                        ctx.shadowColor = '#ff00ff';
                        ctx.shadowBlur = 15;
                        ctx.beginPath();
                        ctx.ellipse(0, 0, 35 - ring * 5, 25 - ring * 5, 0, 0, Math.PI * 2);
                        ctx.stroke();
                        ctx.rotate(-(rotation + ring * Math.PI / 3));
                    }
                    
                    // Core singularity - black hole effect
                    ctx.rotate(rotation);
                    const coreGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, 20);
                    coreGradient.addColorStop(0, '#000000');
                    coreGradient.addColorStop(0.5, '#4a0080');
                    coreGradient.addColorStop(0.8, '#8b00ff');
                    coreGradient.addColorStop(1, `rgba(255, 0, 255, ${pulse})`);
                    ctx.fillStyle = coreGradient;
                    ctx.shadowColor = '#ff00ff';
                    ctx.shadowBlur = 30 * pulse;
                    ctx.beginPath();
                    ctx.arc(0, 0, 18, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Event horizon ring
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 2;
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = '#ffffff';
                    ctx.globalAlpha = pulse * 0.8;
                    ctx.beginPath();
                    ctx.arc(0, 0, 18, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.globalAlpha = 1;
                    
                    // Particle accretion disk
                    for (let i = 0; i < 12; i++) {
                        const angle = (time * 2 + i * Math.PI / 6) % (Math.PI * 2);
                        const radius = 25 + Math.sin(time * 3 + i) * 8;
                        const px = Math.cos(angle) * radius;
                        const py = Math.sin(angle) * radius * 0.3; // Flattened disk
                        
                        const particleSize = 2 + Math.sin(time * 5 + i) * 1;
                        ctx.fillStyle = i % 2 === 0 ? '#ff00ff' : '#ffffff';
                        ctx.shadowBlur = 10;
                        ctx.shadowColor = ctx.fillStyle;
                        ctx.beginPath();
                        ctx.arc(px, py, particleSize, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    
                    // Bright center flash
                    ctx.fillStyle = '#ffffff';
                    ctx.globalAlpha = pulse * 0.6;
                    ctx.shadowBlur = 25;
                    ctx.shadowColor = '#ff00ff';
                    ctx.beginPath();
                    ctx.arc(0, 0, 8, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.globalAlpha = 1;
                    
                    ctx.shadowBlur = 0;
                    ctx.restore();
                    
                } else if (this.type === 'core') {
                    ctx.fillStyle = '#ff00ff'; ctx.font = 'bold 24px Orbitron'; ctx.fillText('DATA', this.x-20, this.y+10);
                } else if (this.type === 'mod_crate') {
                    ctx.fillStyle = '#ffdd57'; ctx.shadowColor = '#ffdd57'; ctx.shadowBlur = 15;
                    ctx.fillRect(this.x-10, this.y-10, 20, 20); ctx.shadowBlur = 0;
                    ctx.fillStyle = '#000'; ctx.font = 'bold 12px Arial'; ctx.fillText('?', this.x-4, this.y+4);
                }
            }
        }
        
        class Particle {
            constructor(x, y, color, speed) {
                this.x=x; this.y=y; this.color=color; this.life=1;
                const a = seededRandom()*Math.PI*2; const s = seededRandom()*speed*3;
                this.vx = Math.cos(a)*s; this.vy = Math.sin(a)*s;
            }
            reset(x, y, color, speed) {
                // Reuse existing particle with new parameters
                this.x=x; this.y=y; this.color=color; this.life=1;
                const a = seededRandom()*Math.PI*2; const s = seededRandom()*speed*3;
                this.vx = Math.cos(a)*s; this.vy = Math.sin(a)*s;
            }
            update(dt = 16) {
                const scaledDt = dt || 16;
                this.x += this.vx * (scaledDt/16);
                this.y += this.vy * (scaledDt/16);
                this.life -= 0.05 * (scaledDt/16);
                return this.life>0;
            }
            draw(ctx) { ctx.globalAlpha=this.life; ctx.fillStyle=this.color; ctx.fillRect(this.x,this.y,3,3); ctx.globalAlpha=1; }
        }


        class MuzzleFlash {
            constructor(x,y) { this.x=x; this.y=y; this.life=3; }
            update(dt = 16) { this.life -= (dt/16); return this.life>0; }
            draw(ctx) { ctx.fillStyle='rgba(200,255,255,0.8)'; ctx.beginPath(); ctx.arc(this.x,this.y,10,0,Math.PI*2); ctx.fill(); }
        }


        class LightningBolt {
            constructor(x1, y1, x2, y2, color = '#ffeb3b') { this.x1=x1; this.y1=y1; this.x2=x2; this.y2=y2; this.life=8; this.color=color; }
            update(dt = 16) { this.life -= (dt/16); return this.life>0; }
            draw(ctx) {
                ctx.shadowBlur = 15; ctx.shadowColor = this.color;
                // Convert hex to rgba properly
                const r = parseInt(this.color.substr(1,2), 16);
                const g = parseInt(this.color.substr(3,2), 16);
                const b = parseInt(this.color.substr(5,2), 16);
                ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, ${this.life/8})`;
                ctx.lineWidth = 4;
                ctx.beginPath(); ctx.moveTo(this.x1,this.y1);
                const dist = Math.sqrt((this.x2-this.x1)**2 + (this.y2-this.y1)**2);
                const steps = Math.max(3, Math.floor(dist / 30));
                for(let i=1; i<steps; i++) {
                    const t = i / steps; const r = (seededRandom()-0.5) * 40;
                    ctx.lineTo(this.x1 + (this.x2-this.x1)*t + r, this.y1 + (this.y2-this.y1)*t + r);
                }
                ctx.lineTo(this.x2,this.y2); ctx.stroke(); ctx.shadowBlur = 0;
            }
        }
        
        class GasCloud {
            constructor(x, y, radius, tickDamage, level) {
                this.x = x;
                this.y = y;
                this.radius = radius;
                this.tickDamage = tickDamage;
                this.level = level;
                this.life = 300; // 5 seconds
                this.maxLife = 300;
                this.tickTimer = 0;
                this.opacity = 0;
                this.cloudParticles = [];
                
                // OPTIMIZED: Reduced particle count for better performance
                const particleCount = Math.floor(30 + (radius / 80) * 10); // Reduced from 50 base
                for (let i = 0; i < particleCount; i++) {
                    const angle = seededRandom() * Math.PI * 2;
                    const dist = Math.sqrt(seededRandom()) * radius; // Square root for even distribution
                    this.cloudParticles.push({
                        offsetX: Math.cos(angle) * dist,
                        offsetY: Math.sin(angle) * dist,
                        size: 8 + seededRandom() * 12, // Slightly larger particles
                        orbitAngle: angle,
                        orbitSpeed: (seededRandom() - 0.5) * 0.015,
                        orbitRadius: 5 + seededRandom() * 15,
                        phase: seededRandom() * Math.PI * 2,
                        pulseSpeed: 0.02 + seededRandom() * 0.03
                    });
                }
            }
            
            update(dt) {
                this.life -= dt/16;
                this.tickTimer += dt/16;
                
                // Fade in/out
                if (this.life > 270) {
                    this.opacity = Math.min(0.8, (300 - this.life) / 30);
                } else if (this.life < 60) {
                    this.opacity = this.life / 60 * 0.8;
                } else {
                    this.opacity = 0.8;
                }
                
                // Damage tick every 20 frames (~0.33s)
                if (Math.floor(this.tickTimer) % 20 === 0 && this.tickTimer > 1) {
                    entities.enemies.forEach(e => {
                        const dist = Math.sqrt((e.x - this.x)**2 + (e.y - this.y)**2);
                        if (dist < this.radius) {
                            player.dealElementalDamage(e, this.tickDamage, 'gas', '#99ff33');
                        }
                    });
                }
                
                // Update swirling particles
                this.cloudParticles.forEach(p => {
                    p.orbitAngle += p.orbitSpeed * (dt/16);
                    p.phase += p.pulseSpeed * (dt/16);
                });
                
                return this.life > 0;
            }
            
            draw(ctx) {
                ctx.save();
                ctx.translate(this.x, this.y);
                
                // OPTIMIZED: Simplified rendering with fewer calculations per particle
                this.cloudParticles.forEach((p, i) => {
                    // Particle drifts in small orbit
                    const driftX = Math.cos(p.orbitAngle) * p.orbitRadius;
                    const driftY = Math.sin(p.orbitAngle) * p.orbitRadius;
                    const x = p.offsetX + driftX;
                    const y = p.offsetY + driftY;
                    
                    // Simplified pulsing - use pre-calculated phase
                    const pulse = 0.7 + Math.sin(p.phase) * 0.3;
                    const size = p.size * pulse;
                    
                    // Varied opacity for depth (simpler calculation)
                    const baseOpacity = this.opacity * (0.3 + (i % 3) * 0.15);
                    
                    // OPTIMIZED: Simpler gradient with fewer color stops
                    const gradient = ctx.createRadialGradient(x, y, 0, x, y, size);
                    gradient.addColorStop(0, `rgba(153, 255, 51, ${baseOpacity})`);
                    gradient.addColorStop(0.6, `rgba(102, 204, 0, ${baseOpacity * 0.4})`);
                    gradient.addColorStop(1, 'rgba(51, 153, 0, 0)');
                    
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(x, y, size, 0, Math.PI * 2);
                    ctx.fill();
                });
                
                // OPTIMIZED: Simpler outer glow
                const outerGlow = ctx.createRadialGradient(0, 0, this.radius * 0.7, 0, 0, this.radius);
                outerGlow.addColorStop(0, 'rgba(153, 255, 51, 0)');
                outerGlow.addColorStop(0.9, `rgba(153, 255, 51, ${this.opacity * 0.08})`);
                outerGlow.addColorStop(1, 'rgba(153, 255, 51, 0)');
                
                ctx.fillStyle = outerGlow;
                ctx.beginPath();
                ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.restore();
            }
        }
        
        // PERFORMANCE-AWARE PARTICLE CREATION
        function createParticles(x, y, color, count, speed = 3) {
            // Reduce particle count based on performance mode
            let actualCount = count;
            if (state.performanceMode === 'reduced') actualCount = Math.floor(count * 0.5);
            if (state.performanceMode === 'minimal') actualCount = Math.floor(count * 0.25);
            
            for (let i = 0; i < actualCount; i++) {
                entities.particles.push(new Particle(x, y, color, speed));
            }
        }
        
        class FloatingText {
            constructor(x, y, text, color='#fff', isCrit=false, type='normal', sourceId=null, elementType=null) { 
                this.x=x; this.y=y; this.text=text; this.life=50; this.color=color; 
                this.isCrit = isCrit;
                this.sourceId = sourceId; // Weapon source (ion, tesla, beam, etc)
                this.elementType = elementType; // Element type for DOTs (fire, ice, volt, bio, hack)
                this.fontSize = null; // Custom font size (null = default)
                
                // Random Drift
                this.vx = (seededRandom()-0.5) * 2;
                if(isCrit) { this.life = 30; this.y -= 20; } // Faster crit (40 -> 30)
                if(type === 'dot') { this.x += (seededRandom()-0.5)*20; this.y += (seededRandom()-0.5)*20; }
            }
            update(dt) { 
                this.x += this.vx * (dt/16);
                this.y -= (this.isCrit ? 2 : 0.5) * (dt/16); // Faster rise for crits
                this.life -= (dt/16); 
                return this.life > 0; 
            }
            draw(ctx) { 
                ctx.globalAlpha = Math.min(1, this.life/30);
                if (this.isCrit) {
                    ctx.fillStyle = '#ffdd57'; 
                    const size = this.fontSize || 24;
                    ctx.font = `900 ${size}px "Orbitron"`;
                    ctx.shadowColor = '#ff5500'; ctx.shadowBlur = 10;
                    // Single pulse: grows then shrinks once
                    const scale = 1 + Math.sin((30-this.life)*0.21)*0.3; // Faster cycle
                    ctx.save(); ctx.translate(this.x, this.y); ctx.scale(scale, scale);
                    ctx.fillText(this.text + "!", 0, 0);
                    ctx.restore();
                } else {
                    ctx.fillStyle = this.color; 
                    const size = this.fontSize || 16;
                    ctx.font = `bold ${size}px "Orbitron"`; 
                    ctx.shadowColor = 'black'; ctx.shadowBlur = 4; 
                    ctx.fillText(this.text, this.x, this.y);
                    
                    // Draw elemental icon next to damage if present
                    if (this.elementType) {
                        ctx.shadowBlur = 0;
                        ctx.font = 'bold 16px "Orbitron"'; // Increased from 12px to 16px to match text
                        const iconOffset = ctx.measureText(this.text).width + 4;
                        
                        // Elemental icon colors and symbols
                        const elementIcons = {
                            'fire': { color: '#ff5722', symbol: 'üî•' },
                            'ice': { color: '#88d8ff', symbol: '‚ùÑ' },
                            'volt': { color: '#ffeb3b', symbol: '‚ö°' },
                            'bio': { color: '#00cc44', symbol: '‚ò£' }, // Changed from ‚ò† to ‚ò£ for better readability
                            'hack': { color: '#00ffff', symbol: '‚öô' }
                        };
                        
                        if (elementIcons[this.elementType]) {
                            const icon = elementIcons[this.elementType];
                            ctx.fillStyle = icon.color;
                            ctx.fillText(icon.symbol, this.x + iconOffset, this.y);
                        }
                    }
                }
                ctx.globalAlpha=1; ctx.shadowBlur = 0; 
            }
        }


        // --- Core ---


        function initGame() {
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            
            // Generate random seed for internal RNG
            setSeed(generateSeed());
            
            player = new Player();
            
            entities = { enemies: [], projectiles: [], enemyProjectiles: [], particles: [], pickups: [], texts: [], lightnings: [], gasClouds: [] };
            state.score=0; state.level=1; state.xp=0; state.xpToNext=10; 
            state.startTime=Date.now(); state.screen='game'; state.rerolls=3;
            state.paused = false; state.timeScale = 1.0; state.pendingLevelUps = 0; state.zoom = 0.70; 
            state.upgradeQueue = []; // Reset upgrade queue 
            state.bossActive = false; state.bossWave = 0; state.pendingSwap = null;
            state.bossTimer = 0; state.gameTime = 0; state.spawnTimer = 0;
            state.finalBossActive = false; // Reset final boss flag
            state.finalBossTriggered = false; // Reset final boss trigger
            state.finalBossDefeated = false; // Reset boss defeated flag
            state.saveCharges = 3; state.savedUpgrade = null;
            state.levelUpQueue = []; // Track level-up types to prevent reroll bugs
            state.weaponStats = {}; // Reset weapon stats tracking
            state.cameraLocked = false; // Unlock camera
            state.ultimateCameraTarget = null; // Clear camera target
            state.playerDead = false; // Reset death flag for new game
            window.upgradesSaveMode = false;
            // Reset HUD
            document.getElementById('boss-hud').classList.remove('active');
            
            updateHud(); 
            state.lastTime = Date.now();
            document.getElementById('hud').style.display='flex';
            document.getElementById('start-hint').style.display='block';
            
            // Apply Test Mode settings if enabled
            if (testModeEnabled) {
                setTimeout(() => {
                    console.log('üß™ APPLYING TEST MODE SETTINGS');
                    
                    // Set level
                    state.level = testModeSettings.level;
                    console.log(`  üìä Level: ${state.level}`);
                    
                    // Get the ship's starting weapon
                    const startingWeapon = shipStartingWeapons[testModeSettings.ship];
                    
                    // Prepare weapons list - handle "starting weapon" placeholder
                    const weaponsToApply = [];
                    for (let i = 0; i < 4; i++) {
                        let weaponId = testModeSettings.weapons[i];
                        
                        // If slot 1 is null (meaning "starting weapon"), use the ship's starting weapon
                        if (i === 0 && weaponId === null && startingWeapon) {
                            weaponId = startingWeapon;
                        }
                        
                        if (weaponId !== null) {
                            weaponsToApply.push({ id: weaponId, element: testModeSettings.elements[i] });
                        }
                    }
                    
                    // Apply weapons
                    if (weaponsToApply.length > 0) {
                        // Clear current weapons
                        Object.keys(player.weapons).forEach(w => player.weapons[w] = 0);
                        
                        weaponsToApply.forEach((weapon, index) => {
                            player.weapons[weapon.id] = testModeSettings.weaponLevel;
                            
                            // Initialize weapon stats
                            if (!player.weaponStats[weapon.id]) {
                                player.weaponStats[weapon.id] = { dmg: 1.0, rate: 1.0, area: 1.0 };
                            }
                            
                            // Apply scaling based on weapon level
                            for (let lvl = 1; lvl < testModeSettings.weaponLevel; lvl++) {
                                player.weaponStats[weapon.id].dmg *= 1.055;
                                player.weaponStats[weapon.id].rate *= 1.04;
                                player.weaponStats[weapon.id].area *= 1.02;
                            }
                            
                            // Apply element (random or specific)
                            let element = weapon.element;
                            if (element === 'random') {
                                const elements = ['fire', 'ice', 'volt', 'bio', 'hack'];
                                element = elements[Math.floor(Math.random() * elements.length)];
                            }
                            player.weaponAugments[weapon.id] = element;
                            
                            console.log(`  ‚öîÔ∏è Weapon ${index + 1}: ${weapon.id} (Level ${testModeSettings.weaponLevel}, ${element})`);
                        });
                    }
                    
                    // Apply ultimate
                    if (testModeSettings.ultimate && testModeSettings.ultimate !== '') {
                        let ultimateId = testModeSettings.ultimate;
                        
                        if (ultimateId === 'random') {
                            const ultimateIds = Object.keys(ULTIMATES);
                            ultimateId = ultimateIds[Math.floor(Math.random() * ultimateIds.length)];
                        }
                        
                        player.ultimate = ultimateId;
                        player.ultimateCharge = testModeSettings.ultimateCharge;
                        player.ultimateActive = false;
                        player.ultimateData = {};
                        console.log(`  üí´ Ultimate: ${ULTIMATES[ultimateId].name} (${testModeSettings.ultimateCharge}% charge)`);
                    }
                    
                    // Apply god mode
                    if (testModeSettings.godMode) {
                        player.invulnerable = true;
                        console.log('  üõ°Ô∏è God Mode: ENABLED');
                    }
                    
                    // Boost stats for survivability
                    player.maxHp = 500;
                    player.hp = 500;
                    player.damage = 35;
                    player.projectileSpeed = 12;
                    player.range = 500;
                    player.pierce = 3;
                    
                    // If level 50, trigger boss
                    if (state.level === 50) {
                        console.log('  üéØ Level 50 detected - triggering boss in 1 second');
                        state.finalBossTriggered = true;
                        
                        setTimeout(() => {
                            if (typeof triggerNexusPrime === 'function') {
                                console.log('  üî• Spawning Nexus Prime boss');
                                triggerNexusPrime();
                            }
                        }, 1000);
                    }
                    
                    console.log('‚úÖ Test mode applied successfully');
                }, 500); // Short delay to ensure game is initialized
            }
            
            gameLoop();
        }


        function createExplosion(x, y, color, count) {
            // Scale down particle creation if we're already at high counts
            const currentCount = entities.particles.length;
            let scaledCount = count;
            
            if(currentCount > 200) {
                scaledCount = Math.max(1, Math.floor(count * 0.3)); // Reduce to 30%
            } else if(currentCount > 150) {
                scaledCount = Math.max(2, Math.floor(count * 0.5)); // Reduce to 50%
            } else if(currentCount > 100) {
                scaledCount = Math.max(3, Math.floor(count * 0.7)); // Reduce to 70%
            }
            
            for(let i=0; i<scaledCount; i++) {
                // ‚ö° OPTIMIZED: Use particle pool instead of creating new objects
                entities.particles.push(particlePool.spawn(x, y, color, 1.0));
            }
        }

        function triggerResonanceBurst(element, x, y, areaMultiplier = 1.0) {
            console.log(`üåü RESONANCE BURST: ${element.toUpperCase()} (area: ${areaMultiplier.toFixed(2)}x)`);
            
            const elementColors = {
                fire: '#ff5722',
                ice: '#00e5ff',
                volt: '#ffeb3b',
                bio: '#39ff14'
            };
            
            const color = elementColors[element];
            
            if (element === 'fire') {
                // FIRE: FIERY EXPLOSION (optimized for performance)
                // Base radius: 120, scales with area
                const baseRadius = 120 * areaMultiplier;
                
                // OPTIMIZED: Spread explosions over longer time to reduce frame spikes
                createExplosion(x, y, color, 25); // Reduced from 40
                setTimeout(() => createExplosion(x, y, color, 15), 80); // Spread out more
                setTimeout(() => createExplosion(x, y, color, 10), 160); // Spread out more
                
                // OPTIMIZED: Fewer shockwaves, more spread out
                setTimeout(() => entities.particles.push(new Shockwave(x, y, baseRadius, color)), 0);
                setTimeout(() => entities.particles.push(new Shockwave(x, y, baseRadius, color)), 120);
                
                // OPTIMIZED: Reduced flame bursts from 8 to 4
                for (let i = 0; i < 4; i++) {
                    const angle = (i / 4) * Math.PI * 2;
                    const distance = 80;
                    setTimeout(() => {
                        entities.particles.push(new Shockwave(
                            x + Math.cos(angle) * distance * 0.5,
                            y + Math.sin(angle) * distance * 0.5,
                            100,
                            color
                        ));
                    }, i * 50); // Spread over 200ms instead of immediate
                }
                
                // OPTIMIZED: Reduced flame particles from 25 to 12
                for (let i = 0; i < 12; i++) {
                    entities.particles.push(new Particle(x, y, color, 5));
                }
                
                // Damage enemies - scaled with area
                entities.enemies.forEach(e => {
                    if (e.hp <= 0) return;
                    const dist = Math.sqrt((e.x - x)**2 + (e.y - y)**2);
                    if (dist < baseRadius) {
                        player.dealElementalDamage(e, player.damage * 0.8, 'surge', color, true, 'normal', 'fire');
                        // OPTIMIZED: Reduced hit particles from 6 to 3
                        for (let i = 0; i < 3; i++) {
                            entities.particles.push(new Particle(e.x, e.y, color, 3));
                        }
                    }
                });
                
            } else if (element === 'ice') {
                // ICE: CRYSTALLINE FREEZE NOVA (optimized)
                // Base radius: 110, scales with area
                const baseRadius = 110 * areaMultiplier;
                
                // OPTIMIZED: Fewer, spread out explosions
                createExplosion(x, y, color, 20); // Reduced from 30
                setTimeout(() => createExplosion(x, y, color, 12), 80); // Reduced from 20
                
                // OPTIMIZED: Reduced frost waves from 3 to 2
                setTimeout(() => entities.particles.push(new Shockwave(x, y, baseRadius, color)), 0);
                setTimeout(() => entities.particles.push(new Shockwave(x, y, baseRadius, color)), 100);
                
                // OPTIMIZED: Reduced ice shards from 12 to 6
                for (let i = 0; i < 6; i++) {
                    const angle = (i / 6) * Math.PI * 2;
                    entities.particles.push(new ShrapnelSpark(x, y, angle, 10));
                }
                
                // OPTIMIZED: Reduced ice particles from 18 to 10
                for (let i = 0; i < 10; i++) {
                    entities.particles.push(new Particle(x, y, color, 4));
                }
                
                // Freeze enemies - scaled with area
                entities.enemies.forEach(e => {
                    if (e.hp <= 0) return;
                    const dist = Math.sqrt((e.x - x)**2 + (e.y - y)**2);
                    if (dist < baseRadius) {
                        e.cryoState.frozen = true;
                        e.cryoState.frozenTimer = 90; // 1.5 seconds
                        // OPTIMIZED: Reduced hit particles from 5 to 3
                        for (let i = 0; i < 3; i++) {
                            entities.particles.push(new Particle(e.x, e.y, color, 3));
                        }
                    }
                });
                
            } else if (element === 'volt') {
                // VOLT: LIGHTNING STORM (optimized)
                // Base radius: 100, scales with area (for targeting range)
                const baseRadius = 100 * areaMultiplier;
                
                // OPTIMIZED: Reduced central explosion
                createExplosion(x, y, color, 30); // Reduced from 50
                
                const nearbyEnemies = entities.enemies
                    .filter(e => {
                        if (e.hp <= 0) return false;
                        const dist = Math.sqrt((e.x - x)**2 + (e.y - y)**2);
                        return dist < baseRadius; // Only target enemies in range
                    })
                    .sort((a, b) => {
                        const distA = Math.sqrt((a.x - x)**2 + (a.y - y)**2);
                        const distB = Math.sqrt((b.x - x)**2 + (b.y - y)**2);
                        return distA - distB;
                    })
                    .slice(0, 4); // Reduced from 5 to 4 enemies
                
                // OPTIMIZED: 1 lightning bolt per target (was 2)
                nearbyEnemies.forEach((e, idx) => {
                    setTimeout(() => {
                        entities.lightnings.push(new LightningBolt(x, y, e.x, e.y, color));
                        
                        player.dealElementalDamage(e, player.damage * 1.2, 'surge', color, true, 'normal', 'volt');
                        createExplosion(e.x, e.y, color, 12); // Reduced from 20
                        
                        // OPTIMIZED: Reduced particles from 10 to 5
                        for (let i = 0; i < 5; i++) {
                            entities.particles.push(new Particle(e.x, e.y, color, 4));
                        }
                    }, idx * 80); // Spread out more (was 60ms)
                });
                
                // OPTIMIZED: Reduced shockwaves from 3 to 2
                setTimeout(() => entities.particles.push(new Shockwave(x, y, baseRadius, color)), 0);
                setTimeout(() => entities.particles.push(new Shockwave(x, y, baseRadius, color)), 120);
                
            } else if (element === 'bio') {
                // BIO: MASSIVE TOXIC PLAGUE (optimized)
                // Base radius: 120, scales with area
                const baseRadius = 120 * areaMultiplier;
                
                // OPTIMIZED: Fewer, spread explosions
                createExplosion(x, y, color, 35); // Reduced from 70
                setTimeout(() => createExplosion(x, y, color, 25), 80); // Reduced from 60
                setTimeout(() => createExplosion(x, y, color, 20), 160); // Reduced from 50
                
                // OPTIMIZED: Reduced toxic waves from 5 to 3
                setTimeout(() => entities.particles.push(new Shockwave(x, y, baseRadius, color)), 0);
                setTimeout(() => entities.particles.push(new Shockwave(x, y, baseRadius, color)), 120);
                setTimeout(() => entities.particles.push(new Shockwave(x, y, baseRadius, color)), 240);
                
                // OPTIMIZED: Reduced toxic spores from 30 to 15
                for (let i = 0; i < 15; i++) {
                    const angle = (i / 15) * Math.PI * 2;
                    const speed = 3 + seededRandom() * 3;
                    entities.particles.push(new Particle(
                        x + Math.cos(angle) * 30,
                        y + Math.sin(angle) * 30,
                        color,
                        speed
                    ));
                }
                
                // Apply poison - scaled with area
                entities.enemies.forEach(e => {
                    if (e.hp <= 0) return;
                    const dist = Math.sqrt((e.x - x)**2 + (e.y - y)**2);
                    if (dist < baseRadius) {
                        e.bioState.active = true;
                        e.bioState.timer = 240; // 4 seconds
                        e.bioState.level = 1;
                        e.bioState.maxDmg = player.damage * 1.5;
                        e.bioState.sourceWeapon = 'surge'; // Track source
                        
                        // OPTIMIZED: Reduced bubble particles from 10 to 4
                        for (let i = 0; i < 4; i++) {
                            entities.particles.push(new Particle(e.x, e.y, color, 2));
                        }
                    }
                });
            }
        }

        // MULTISTRIKE SYSTEM
        // Multistrike system:
        // - Initial trigger: baseChance (from augment)
        // - Cascade Multistrike augment adds a chance for 1 additional chain (15/30/50% depending on tier)
        // - Max 2 total strikes (initial + 1 chain) to avoid performance issues
        function checkMultistrike(fireFunc, damageMultiplier = 1.0, depth = 0) {
            // Safety: Never go beyond depth 1 (initial trigger + 1 chain max)
            if (depth >= 1) return;
            
            // Initial multistrike trigger
            if (depth === 0 && player.multistrikeUnlocked && seededRandom() < player.multicast) {
                setTimeout(() => {
                    fireFunc(damageMultiplier, 1);
                    
                    // Cascade chain: If we have cascade, try to chain one more time
                    if (player.cascadeChainChance && seededRandom() < player.cascadeChainChance) {
                        setTimeout(() => fireFunc(damageMultiplier, 2), 150); // Increased from 100ms
                    }
                }, 150); // Increased from 100ms
            }
        }


        function activateMagnet() {
            entities.pickups.forEach(p => {
                p.magnetized = true;
                // Magnet lasts 10 seconds
                setTimeout(() => { p.magnetized = false; }, 10000);
            });
        }


        function triggerModPickup() {
            const possible = ['repulsor', 'revive', 'berserker', 'cascade', 'momentum', 'glasscannon', 'reaper', 'thrust']; 
            
            // Pick 2 random mods (ensure they're different)
            const shuffled = possible.sort(() => seededRandom() - 0.5);
            const mod1 = shuffled[0];
            const mod2 = shuffled[1];
            
            state.paused = true;
            document.getElementById('mod-confirm-screen').classList.add('active');
            
            const def1 = modDefs[mod1];
            const def2 = modDefs[mod2];
            
            // Build side-by-side card UI
            const hasExistingMod = player.activeMod !== null;
            const warningText = hasExistingMod 
                ? `<div class="text-yellow-400 text-sm mb-4">You have: <span class="text-teal-300">${modDefs[player.activeMod].name}</span> - Choosing a new mod will replace it!</div>`
                : '';
            
            document.getElementById('mod-confirm-content').innerHTML = `
                <div class="text-3xl font-bold text-white mb-2">BOSS DEFEATED</div>
                <div class="text-xl text-teal-400 mb-4">Choose Your Mod</div>
                ${warningText}
                
                <div style="display: flex; flex-direction: column; gap: 16px; width: 100%; max-width: 550px; margin: 0 auto 20px; padding: 0 20px;">
                    <!-- Mod 1 Card -->
                    <div class="card legendary" onclick="selectMod('${mod1}')" style="margin: 4px 0 4px 45px;">
                        <div class="card-header">
                            <i class="fas ${def1.icon}"></i>
                        </div>
                        <div class="card-content">
                            <h3>${def1.name}</h3>
                            <p>${def1.desc}</p>
                        </div>
                    </div>
                    
                    <!-- Mod 2 Card -->
                    <div class="card legendary" onclick="selectMod('${mod2}')" style="margin: 4px 0 4px 45px;">
                        <div class="card-header">
                            <i class="fas ${def2.icon}"></i>
                        </div>
                        <div class="card-content">
                            <h3>${def2.name}</h3>
                            <p>${def2.desc}</p>
                        </div>
                    </div>
                </div>
                
                <button onclick="closeModConfirm()" style="padding: 10px 20px; background: rgba(100,100,100,0.3); border: 2px solid #666; color: #999; border-radius: 4px; cursor: pointer; font-size: 14px;">
                    Skip (Keep Current Mod)
                </button>
            `;
        }

        function selectMod(id) {
            // If player has existing mod, show in-game confirmation dialog
            if (player.activeMod !== null && player.activeMod !== id) {
                const currentDef = modDefs[player.activeMod];
                const newDef = modDefs[id];
                
                // Show replacement confirmation modal
                const confirmScreen = document.getElementById('mod-confirm-screen');
                const confirmContent = document.getElementById('mod-confirm-content');
                
                confirmContent.innerHTML = `
                    <div class="text-center">
                        <div class="text-xl font-bold text-red-400 mb-4">‚ö†Ô∏è REPLACE MOD?</div>
                        <div class="text-gray-300 mb-2">Current: <span class="text-teal-400">${currentDef.name}</span></div>
                        <div class="text-gray-300 mb-4">New: <span class="text-yellow-400">${newDef.name}</span></div>
                        <div class="text-red-300 text-sm mb-6">This will permanently destroy your current mod!</div>
                        
                        <div class="flex gap-4 justify-center">
                            <button onclick="confirmModReplacement('${id}')" class="bg-red-500 hover:bg-red-400 text-white font-bold py-3 px-6 rounded transition">
                                REPLACE
                            </button>
                            <button onclick="cancelModReplacement()" class="bg-gray-600 hover:bg-gray-500 text-white font-bold py-3 px-6 rounded transition">
                                CANCEL
                            </button>
                        </div>
                    </div>
                `;
                
                confirmScreen.classList.add('active');
            } else {
                equipMod(id);
            }
        }
        
        function confirmModReplacement(id) {
            equipMod(id);
            document.getElementById('mod-confirm-screen').classList.remove('active');
        }
        
        function cancelModReplacement() {
            document.getElementById('mod-confirm-screen').classList.remove('active');
            // Don't unpause - still in mod selection
        }

        function equipMod(id) {
            player.activeMod = id;
            // Initialize mod-specific effects
            if (id === 'revive') {
                player.reviveCooldown = 0; // Ready to use
            }
            if (id === 'berserker') {
                player.hasBerserker = true;
            }
            if (id === 'cascade') {
                // Cascade mod: 25% boost to all multistrike (reduced from 2x)
                player.multicast *= 1.25; // Boost current multicast by 25%
                player.cascadeMultiplier = 1.25; // Track that future gains should be boosted
            }
            if (id === 'momentum') {
                player.hasMomentum = true;
                player.momentumTimer = 0;
            }
            if (id === 'glasscannon') {
                player.hasGlassCannon = true;
                // No HP modification - damage multipliers applied in combat
            }
            if (id === 'reaper') {
                player.hasReaper = true;
                player.reaperCooldown = 0;
            }
            if (id === 'thrust') {
                player.hasThrust = true;
                player.thrustCooldown = 0;
                player.thrustActive = false;
            }

            updateHud();
            closeModConfirm();
        }


        // Old button handlers removed - using inline onclick in HTML
        
        function closeModConfirm() {
            document.getElementById('mod-confirm-screen').classList.remove('active');
            state.paused = false;
            state.pendingMod = null;
            state.pendingMods = null;
            state.lastTime = Date.now();
        }


        function togglePause() {
            if (state.screen !== 'game') return;
            state.paused = !state.paused;
            if (state.paused) { 
                document.getElementById('pause-screen').classList.add('active'); 
                
                // Show stats tab by default
                document.getElementById('stats-tab').classList.remove('hidden');
                document.getElementById('kit-tab').classList.add('hidden');
                document.getElementById('stats-tab-btn').classList.add('active', 'border-teal-500', 'text-teal-500');
                document.getElementById('stats-tab-btn').classList.remove('border-transparent', 'text-gray-400');
                document.getElementById('kit-tab-btn').classList.remove('active', 'border-teal-500', 'text-teal-500');
                document.getElementById('kit-tab-btn').classList.add('border-transparent', 'text-gray-400');
                
                // Populate stats
                const grid = document.getElementById('stats-grid');
                grid.innerHTML = '';
                const addStat = (label, val, gold=false) => {
                    grid.innerHTML += `<div class="stat-row"><span class="stat-label">${label}</span><span class="stat-val ${gold?'gold':''}">${val}</span></div>`;
                };

                addStat('LEVEL', state.level);
                addStat('HP', `${Math.floor(player.hp)} / ${Math.floor(player.maxHp)}`, player.maxHp > 150);
                // Show damage relative to THIS ship's base (15 * shipDamageMult)
                const shipBaseDamage = 15 * player.shipDamageMult;
                const damageIncrease = Math.round((player.damage / shipBaseDamage - 1) * 100);
                addStat('DAMAGE', `+${damageIncrease}%`, player.damage > shipBaseDamage);
                const cdr = Math.round((1 - (player.fireRate / 500)) * 100); // Base is 500
                addStat('COOLDOWN REDUCTION', `${cdr > 0 ? '-' : ''}${cdr}%`, cdr !== 0); // Don't highlight at 0%
                addStat('ARMOR', player.armor, player.armor > 20);
                // Show actual speed with ship multiplier applied
                const actualSpeed = player.speed * player.shipSpeedMult;
                addStat('SPEED', actualSpeed.toFixed(1), actualSpeed > 2.5);
                addStat('CRIT CHANCE', `${Math.round(player.critChance*100)}%`, player.critChance > 0.07);
                addStat('MULTISTRIKE', `${Math.round(player.multicast*100)}%`, player.multicast > 0.07);
                addStat('LUCK', player.luck, player.luck > 0);
                
                // Calculate elemental chance with Catalyst bonus
                let baseElemChance = 0.5; // 50% base
                if (player.selectedShip === 'CATALYST') {
                    baseElemChance += 0.25; // +25% for Catalyst
                }
                const totalElemChance = baseElemChance * player.elementalMult;
                const isElemBoosted = player.elementalMult > 1.0 || player.selectedShip === 'CATALYST';
                addStat('ELEM CHANCE', `${Math.round(totalElemChance * 100)}%`, isElemBoosted);
                
                addStat('REGEN', `${player.regen.toFixed(2)}/s`, player.regen > 0);

                // Populate kit view
                const kitGrid = document.getElementById('kit-grid');
                kitGrid.innerHTML = '';
                
                // Show weapons
                Object.keys(player.weapons).forEach(wKey => {
                    if (player.weapons[wKey] > 0) {
                        const wDef = weaponDefs[wKey];
                        const wStats = player.weaponStats[wKey];
                        const level = player.weapons[wKey];
                        const augElement = player.weaponAugments[wKey]; // Single element or null
                        
                        const dmgModified = Math.abs(wStats.dmg - 1.0) > 0.01;
                        const rateModified = Math.abs(wStats.rate - 1.0) > 0.01;
                        const areaModified = Math.abs(wStats.area - 1.0) > 0.01;
                        
                        // Elemental augment display (single augment)
                        let augDisplay = '';
                        if (augElement) {
                            let augHTML = '';
                            if (augElement === 'fire') augHTML = `<span class="text-orange-400"><i class="fas fa-fire"></i> Fire</span>`;
                            if (augElement === 'ice') augHTML = `<span class="text-cyan-400"><i class="fas fa-snowflake"></i> Cryo</span>`;
                            if (augElement === 'volt') augHTML = `<span class="text-yellow-400"><i class="fas fa-bolt"></i> Volt</span>`;
                            if (augElement === 'bio') augHTML = `<span class="text-purple-400"><i class="fas fa-biohazard"></i> Bio</span>`;
                            if (augElement === 'hack') augHTML = `<span class="text-green-400"><i class="fas fa-terminal"></i> Hack</span>`;
                            if (augHTML) {
                                augDisplay = `<div class="text-xs mt-2">${augHTML}</div>`;
                            }
                        }
                        
                        kitGrid.innerHTML += `
                            <div class="bg-gray-800 bg-opacity-50 border border-gray-700 p-4 rounded">
                                <div class="flex items-center gap-3 mb-2">
                                    <i class="fas ${wDef.icon} text-2xl text-teal-400"></i>
                                    <div>
                                        <h3 class="text-white font-bold text-lg">${wDef.name}</h3>
                                        <p class="text-gray-400 text-sm">Level ${level}</p>
                                    </div>
                                </div>
                                <p class="text-gray-300 text-sm mb-3">${wDef.desc}</p>
                                <div class="grid grid-cols-3 gap-2 text-sm">
                                    <div class="text-center">
                                        <div class="text-gray-400">Damage</div>
                                        <div class="${dmgModified ? 'text-yellow-400 font-bold' : 'text-white'}">
                                            +${((wStats.dmg - 1.0) * 100).toFixed(0)}%
                                        </div>
                                    </div>
                                    <div class="text-center">
                                        <div class="text-gray-400">Cooldown</div>
                                        <div class="${rateModified ? 'text-yellow-400 font-bold' : 'text-white'}">
                                            ${wStats.rate >= 1.0 ? '-' : '+'}${Math.abs((wStats.rate - 1.0) * 100).toFixed(0)}%
                                        </div>
                                    </div>
                                    <div class="text-center">
                                        <div class="text-gray-400">Area</div>
                                        <div class="${areaModified ? 'text-yellow-400 font-bold' : 'text-white'}">
                                            +${((wStats.area - 1.0) * 100).toFixed(0)}%
                                        </div>
                                    </div>
                                </div>
                                ${augDisplay}
                            </div>
                        `;
                    }
                });
                
                // Show equipped mod
                if (player.activeMod) {
                    const modDef = modDefs[player.activeMod];
                    if (modDef) {
                        kitGrid.innerHTML += `
                            <div class="bg-yellow-900 bg-opacity-30 border-2 border-yellow-500 p-4 rounded">
                                <div class="flex items-center gap-3 mb-2">
                                    <i class="fas ${modDef.icon} text-2xl text-yellow-400"></i>
                                    <div>
                                        <h3 class="text-yellow-400 font-bold text-lg">${modDef.name}</h3>
                                        <p class="text-gray-400 text-sm">Equipped Mod</p>
                                    </div>
                                </div>
                                <p class="text-gray-300 text-sm">${modDef.desc}</p>
                            </div>
                        `;
                    }
                }


            } else { 
                document.getElementById('pause-screen').classList.remove('active'); 
                state.lastTime = Date.now(); 
            }
        }
        
        // Tab switching handlers
        document.getElementById('stats-tab-btn').onclick = () => {
            document.getElementById('stats-tab').classList.remove('hidden');
            document.getElementById('kit-tab').classList.add('hidden');
            document.getElementById('stats-tab-btn').classList.add('active', 'border-teal-500', 'text-teal-500');
            document.getElementById('stats-tab-btn').classList.remove('border-transparent', 'text-gray-400');
            document.getElementById('kit-tab-btn').classList.remove('active', 'border-teal-500', 'text-teal-500');
            document.getElementById('kit-tab-btn').classList.add('border-transparent', 'text-gray-400');
        };
        
        document.getElementById('kit-tab-btn').onclick = () => {
            document.getElementById('kit-tab').classList.remove('hidden');
            document.getElementById('stats-tab').classList.add('hidden');
            document.getElementById('kit-tab-btn').classList.add('active', 'border-teal-500', 'text-teal-500');
            document.getElementById('kit-tab-btn').classList.remove('border-transparent', 'text-gray-400');
            document.getElementById('stats-tab-btn').classList.remove('active', 'border-teal-500', 'text-teal-500');
            document.getElementById('stats-tab-btn').classList.add('border-transparent', 'text-gray-400');
        }


        window.closeGlossary = () => {
            document.getElementById('glossary-screen').classList.remove('active');
            document.getElementById('pause-screen').classList.add('active');
        };


        document.getElementById('glossary-btn').onclick = () => {
            document.getElementById('pause-screen').classList.remove('active');
            document.getElementById('glossary-screen').classList.add('active');
        };
        
        // Bug Report Capture
        document.getElementById('bug-report-btn').onclick = () => {
            const bugReport = {
                timestamp: new Date().toISOString(),
                gameVersion: 'v1.0-final-boss-fixed',
                
                // Game State
                gameState: {
                    level: state.level,
                    ascension: state.ascension,
                    activeAscension: state.activeAscension,
                    time: Math.floor(state.time / 1000),
                    running: state.running,
                    paused: state.paused,
                    screen: state.screen,
                    finalBossTriggered: state.finalBossTriggered,
                    finalBossActive: state.finalBossActive,
                    cameraLocked: state.cameraLocked
                },
                
                // Player State
                playerStats: {
                    hp: player.hp,
                    maxHp: player.maxHp,
                    shield: player.shield,
                    position: { x: Math.round(player.x), y: Math.round(player.y) },
                    damage: player.damage,
                    projectileSpeed: player.projectileSpeed,
                    range: player.range,
                    pierce: player.pierce,
                    invulnerable: player.invulnerable,
                    invulnTimer: player.invulnTimer,
                    phoenixLocked: player.phoenixLocked
                },
                
                // Weapons
                weapons: Object.keys(player.weapons)
                    .filter(w => player.weapons[w] > 0)
                    .map(w => ({
                        name: w,
                        level: player.weapons[w],
                        element: player.weaponAugments[w] || 'none',
                        stats: player.weaponStats[w] || null
                    })),
                
                // Ultimate
                ultimate: player.ultimate ? {
                    type: player.ultimate,
                    name: ULTIMATES[player.ultimate]?.name || 'unknown',
                    charge: Math.round(player.ultimateCharge),
                    active: player.ultimateActive,
                    data: player.ultimateData ? {
                        hasData: true,
                        keys: Object.keys(player.ultimateData)
                    } : null
                } : null,
                
                // Mods & Augments
                mods: player.mods || [],
                augments: player.augments ? player.augments.map(a => ({
                    id: a.id,
                    tier: a.tier,
                    active: a.active || true
                })) : [],
                
                // Enemies
                enemies: {
                    total: entities.enemies.length,
                    alive: entities.enemies.filter(e => e.hp > 0).length,
                    types: {},
                    bosses: entities.enemies
                        .filter(e => e.isNexusPrime || e.isChampion || e.isBossShield || e.isBossTurret)
                        .map(e => ({
                            type: e.type,
                            hp: Math.round(e.hp),
                            maxHp: Math.round(e.maxHp),
                            isNexusPrime: e.isNexusPrime || false,
                            isChampion: e.isChampion || false,
                            isBossShield: e.isBossShield || false,
                            isBossTurret: e.isBossTurret || false,
                            coreVulnerable: e.coreVulnerable || false,
                            position: { x: Math.round(e.x), y: Math.round(e.y) }
                        }))
                },
                
                // Recent Damage Log (last 10 hits to player)
                recentDamage: player.damageLog ? player.damageLog.slice(-10).map(d => ({
                    source: d.source,
                    damage: d.damage,
                    secondsAgo: Math.round((Date.now() - d.timestamp) / 1000),
                    wasFatal: d.wasFatal || false
                })) : [],
                
                // Performance
                performance: state.performanceMetrics ? {
                    avgFPS: Math.round(state.performanceMetrics.avgFPS || 0),
                    frameTime: Math.round(state.performanceMetrics.avgFrameTime || 0),
                    recentDrops: state.performanceMetrics.recentFPSDrops || 0
                } : null,
                
                // Upgrade Queue State
                upgradeQueue: {
                    length: state.upgradeQueue ? state.upgradeQueue.length : 0,
                    pending: state.pendingLevelUps || 0,
                    ultimateSelection: state.pendingUltimateSelection || false
                },
                
                // Entity Counts
                entityCounts: {
                    enemies: entities.enemies.length,
                    projectiles: entities.projectiles.length,
                    pickups: entities.pickups.length,
                    particles: entities.particles.length,
                    texts: entities.texts.length
                },
                
                // Console Errors (last 10 unique errors)
                consoleErrors: (() => {
                    // Get unique errors by message (deduplicate)
                    const uniqueErrors = [];
                    const seenMessages = new Set();
                    
                    // Process errors in reverse (most recent first)
                    for (let i = consoleErrors.length - 1; i >= 0 && uniqueErrors.length < 10; i--) {
                        const error = consoleErrors[i];
                        // Truncate very long error messages
                        const truncatedMsg = error.message.length > 500 
                            ? error.message.substring(0, 500) + '...[truncated]'
                            : error.message;
                        
                        if (!seenMessages.has(truncatedMsg)) {
                            seenMessages.add(truncatedMsg);
                            uniqueErrors.push({
                                message: truncatedMsg,
                                line: error.line,
                                stackTrace: error.stackTrace,
                                secondsAgo: Math.round((Date.now() - error.time) / 1000),
                                timestamp: error.timestamp
                            });
                        }
                    }
                    
                    return uniqueErrors.reverse(); // Return in chronological order
                })()
            };
            
            // Count enemy types
            entities.enemies.forEach(e => {
                const type = e.type || 'unknown';
                bugReport.enemies.types[type] = (bugReport.enemies.types[type] || 0) + 1;
            });
            
            // Copy to clipboard
            const reportText = JSON.stringify(bugReport, null, 2);
            
            // Try to copy to clipboard
            if (navigator.clipboard) {
                navigator.clipboard.writeText(reportText).then(() => {
                    const errorCount = bugReport.consoleErrors.length;
                    const errorMsg = errorCount > 0 ? `\n‚Ä¢ ${errorCount} console error${errorCount > 1 ? 's' : ''} (last 10 unique)` : '';
                    alert(`‚úÖ Bug report copied to clipboard!\n\nPaste it when reporting the issue.\n\nThe report includes:\n‚Ä¢ Game state & player stats\n‚Ä¢ All weapons, mods, and augments\n‚Ä¢ Enemy positions & boss state\n‚Ä¢ Recent damage log\n‚Ä¢ Performance metrics${errorMsg}`);
                }).catch(() => {
                    // Fallback: show in alert
                    prompt('Copy this bug report:', reportText);
                });
            } else {
                // Fallback for browsers without clipboard API
                prompt('Copy this bug report:', reportText);
            }
            
            console.log('üêõ BUG REPORT CAPTURED:');
            console.log(reportText);
        };


        function drawIndicators() {
            // Save context for screen-space drawing
            ctx.save();
            
            const screenW = width / state.zoom; const screenH = height / state.zoom;
            const centerX = width/2; const centerY = height/2; const padding = 50; // Screen center, not player
            
            const drawArrow = (worldX, worldY, color) => {
                // Convert world position to screen position
                const screenX = (worldX - player.x) * state.zoom + width/2;
                const screenY = (worldY - player.y) * state.zoom + height/2;
                
                const dx = screenX - centerX; const dy = screenY - centerY; 
                const angle = Math.atan2(dy, dx);
                const marginX = width/2 - padding; const marginY = height/2 - padding;
                if (Math.abs(dx) < 1 && Math.abs(dy) < 1) return;
                if (Math.abs(dx) > marginX || Math.abs(dy) > marginY) {
                    let cx = dx; let cy = dy; 
                    const slope = (Math.abs(dx) > 0.1) ? dy/dx : 10000 * Math.sign(dy);
                    if (Math.abs(dx) > marginX) { cx = Math.sign(dx) * marginX; cy = cx * slope; }
                    if (Math.abs(cy) > marginY) { cy = Math.sign(dy) * marginY; cx = cy / slope; if (Math.abs(cx) > marginX) cx = Math.sign(dx) * marginX; }
                    const px = centerX + cx; const py = centerY + cy;
                    ctx.save(); ctx.translate(px, py); ctx.rotate(angle); ctx.fillStyle = color;
                    ctx.beginPath(); ctx.moveTo(10, 0); ctx.lineTo(-10, 8); ctx.lineTo(-10, -8); ctx.fill(); ctx.restore();
                }
            };
            
            const drawChampionSkull = (worldX, worldY, color = '#ff0000') => {
                // Convert world position to screen position
                const screenX = (worldX - player.x) * state.zoom + width/2;
                const screenY = (worldY - player.y) * state.zoom + height/2;
                
                const dx = screenX - centerX; const dy = screenY - centerY; 
                const angle = Math.atan2(dy, dx);
                const marginX = width/2 - padding; const marginY = height/2 - padding;
                if (Math.abs(dx) < 1 && Math.abs(dy) < 1) return;
                if (Math.abs(dx) > marginX || Math.abs(dy) > marginY) {
                    let cx = dx; let cy = dy; 
                    const slope = (Math.abs(dx) > 0.1) ? dy/dx : 10000 * Math.sign(dy);
                    if (Math.abs(dx) > marginX) { cx = Math.sign(dx) * marginX; cy = cx * slope; }
                    if (Math.abs(cy) > marginY) { cy = Math.sign(dy) * marginY; cx = cy / slope; if (Math.abs(cx) > marginX) cx = Math.sign(dx) * marginX; }
                    const px = centerX + cx; const py = centerY + cy;
                    
                    ctx.save();
                    ctx.translate(px, py);
                    
                    // Draw arrow pointing to champion/boss (rotates, uses custom color)
                    ctx.save();
                    ctx.rotate(angle);
                    ctx.fillStyle = color;
                    ctx.beginPath();
                    ctx.moveTo(25, 0);
                    ctx.lineTo(10, 8);
                    ctx.lineTo(10, -8);
                    ctx.fill();
                    ctx.restore();
                    
                    // Draw skull emoji with matching glow color (stays upright, no rotation)
                    ctx.shadowBlur = 8;
                    ctx.shadowColor = color;
                    ctx.fillStyle = color;
                    ctx.font = 'bold 20px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('üíÄ', -5, 0);
                    ctx.shadowBlur = 0;
                    
                    ctx.restore();
                }
            };
            
            entities.enemies.forEach(e => { 
                if (e.isChampion) {
                    drawChampionSkull(e.x, e.y);
                } else if (e.isNexusPrime && state.finalBossActive) {
                    // Draw purple skull for NEXUS PRIME
                    drawChampionSkull(e.x, e.y, '#a855f7');
                } else if (e.type === 'tank') {
                    drawArrow(e.x, e.y, '#ff0000');
                }
            });
            entities.pickups.forEach(p => { if (p.type === 'health') drawArrow(p.x, p.y, '#00cc44'); if (p.type === 'magnet') drawArrow(p.x, p.y, '#ffffff'); });
            
            ctx.restore(); // Restore screen-space context
        }


        function toggleLockKit() {
            state.kitLocked = !state.kitLocked;
            state.lockUsed = true; // User has manually interacted - don't auto-enable again
            const el = document.getElementById('lock-kit-toggle');
            if(state.kitLocked) el.classList.add('toggle-active');
            else el.classList.remove('toggle-active');
        }

        // ===== NEXUS PRIME FINAL BOSS SYSTEM =====
        
        function triggerNexusPrime() {
            // Spawn boss at CENTER OF SCREEN in world coordinates
            // Camera centers on player, so we need to calculate where screen center is in world space
            const screenCenterWorldX = player.x;
            const screenCenterWorldY = player.y;
            
            // Actually, the player IS at screen center because camera follows player
            // So player position IS correct. The issue must be elsewhere.
            const spawnX = screenCenterWorldX;
            const spawnY = screenCenterWorldY;
            
            console.log(`üéØ Player velocity: vx=${player.vx.toFixed(2)}, vy=${player.vy.toFixed(2)}`);
            console.log(`üéØ Current zoom: ${state.zoom.toFixed(2)}`);
            
            // CRITICAL: Sync camera to player position IMMEDIATELY
            // Camera values are screen-space offsets, not world coordinates
            state.camera.x = width/2 - player.x * state.zoom;
            state.camera.y = height/2 - player.y * state.zoom;
            state.cameraLocked = false; // Ensure camera isn't locked from ultimates
            state.manualCameraControl = false; // Clear any manual control
            
            
            // CRITICAL: Stop enemy spawns immediately
            state.finalBossActive = true;
            
            // CLEAR ALL PICKUPS (XP, health, magnets)
            const pickupsBeforeClear = entities.pickups.length;
            entities.pickups = [];
            
            // Make enemies FLEE before despawning (cinematic effect)
            const fleeeingEnemies = entities.enemies.filter(e => 
                !e.isNexusPrime && !e.isBossTurret && !e.isBossShield
            );
            
            // Mark enemies as fleeing and set them to run away
            let markedCount = 0;
            fleeeingEnemies.forEach(e => {
                e.fleeing = true;
                e.fleeingTimer = 600; // 10 seconds to flee offscreen (increased from 180)
                
                // Calculate direction AWAY from player
                const dx = e.x - player.x;
                const dy = e.y - player.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                if (dist > 0) {
                    // Set velocity to flee away at 6x normal speed (increased for more dramatic effect)
                    const fleeSpeed = (e.speed || 1) * 6;
                    e.vx = (dx / dist) * fleeSpeed;
                    e.vy = (dy / dist) * fleeSpeed;
                }
                
                // Keep enemy fully opaque - no fade
                e.fleeingOpacity = 1.0;
                markedCount++;
                
                // Log first few for debugging
                if (markedCount <= 3) {
                    console.log(`   Enemy ${markedCount}: type=${e.type}, pos=(${e.x.toFixed(0)}, ${e.y.toFixed(0)}), fleeing=${e.fleeing}, timer=${e.fleeingTimer}, velocity=(${e.vx.toFixed(2)}, ${e.vy.toFixed(2)})`);
                }
            });
            
            
            
            // DRAMATIC SEQUENCE:
            // 1. Enemies flee (happening now)
            // 2. Warning appears (1 second delay)
            // 3. Boss spawns (2.5 seconds after warning starts = 3.5s total)
            
            
            // Step 1: Show warning after 1 second (let enemies flee first)
            setTimeout(() => {
                showBossWarning();
            }, 1000);
            
            // Step 2: Spawn boss 2.5 seconds after warning (3.5s total from trigger)
            setTimeout(() => {
                spawnNexusPrime(spawnX, spawnY);
            }, 3500);
        }
        
        function showBossWarning() {
            // If upgrade screen is open, queue the warning for after it closes
            if (state.screen === 'levelup') {
                state.queuedWarning = 'boss';
                return;
            }
            
            const warning = document.getElementById('boss-warning');
            warning.innerHTML = '<span style="font-size: 3rem;">‚ö†Ô∏è</span><br><br><span style="font-size: 2rem;">APEX THREAT DETECTED</span><br><br>NEXUS PRIME';
            warning.style.fontSize = '2.5rem'; // Applies to last line
            warning.style.display = 'block';
            setTimeout(() => {
                warning.style.display = 'none';
                warning.style.fontSize = '3rem'; // Reset for other warnings
            }, 3000);
        }
        
        function spawnNexusPrime(spawnX, spawnY) {
            // Use provided spawn position, or default to current player position
            const bossX = spawnX !== undefined ? spawnX : player.x;
            const bossY = spawnY !== undefined ? spawnY : player.y;
            
            const finalBossX = bossX;
            const finalBossY = bossY + 200; // Spawn 200 units SOUTH (positive Y = down in world space)
            
            // Gradually zoom out camera for boss fight
            state.targetZoom = 0.60; // Zoom out from 0.70 to 0.60
            
            const boss = {
                x: finalBossX,
                y: finalBossY,
                vx: 0,
                vy: 0,
                type: 'nexus_prime',
                isNexusPrime: true,
                tier: 'boss', // Mark as boss tier
                maxHp: 75000, // Reduced from 100000 for better pacing
                hp: 75000,
                radius: 60, // Reduced from 80 to fit screen better
                phase: 1,
                coreRotation: 0,
                shields: [],
                shieldsActive: true,
                coreVulnerable: false,
                vulnerabilityTimer: 0,
                attackTimer: 120,
                turretSpawnTimer: 360, // Spawn turrets every 6 seconds in Phase 1 (was 420/7s)
                nextAttack: null,
                // Elemental state tracking
                pyroState: { active: false, timer: 0, level: 0, baseDmg: 0 },
                cryoState: { slowed: false, slowDuration: 0, frozen: false, frozenTimer: 0 },
                bioState: { active: false, timer: 0, level: 0, maxDmg: 0, jumpCount: 0 },
                hackState: { active: false, timer: 0 },
                empState: { active: false, timer: 0 },
                ionState: { active: false, timer: 0 },
                // Dummy methods so boss doesn't crash in enemy filter
                update() { /* Boss updates happen in special isNexusPrime block */ },
                draw() { /* Boss draws happen in special isNexusPrime block */ },
                takeDamage(amt, color = '#ffffff', isCrit = false, type = 'normal', sourceId = null, elementType = null) {
                    if (this.coreVulnerable && this.hp > 0) {
                        this.hp -= amt;
                        
                        // Safety: Prevent HP from going too far negative (can cause issues with death sequence)
                        if (this.hp < -1000) {
                            console.warn(`‚ö†Ô∏è Boss HP went very negative (${this.hp}), clamping to -100`);
                            this.hp = -100;
                        }
                        
                        this.flash = 5;
                        
                        // Log when boss HP gets low
                        if (this.hp <= this.maxHp * 0.1 && this.hp > 0) {
                            console.log(`üö® NEXUS PRIME CRITICAL HP: ${Math.floor(this.hp)} / ${this.maxHp}`);
                        }
                        
                        // Log when boss dies
                        if (this.hp <= 0 && !this.deathSequenceStarted) {
                            console.log(`üíÄ NEXUS PRIME HP REACHED ZERO (HP: ${Math.floor(this.hp)}) - Death sequence should trigger next frame`);
                        }
                        
                        // Damage text
                        const damageText = new FloatingText(
                            this.x + (Math.random() - 0.5) * 40,
                            this.y + (Math.random() - 0.5) * 40,
                            Math.floor(amt),
                            color || '#ffffff',
                            isCrit,
                            type,
                            sourceId,
                            elementType
                        );
                        damageText.life = 60;
                        entities.texts.push(damageText);
                    }
                }
            };
            
            // Create 4 shield generators as targetable entities
            for (let i = 0; i < 4; i++) {
                const shield = {
                    index: i,
                    angle: (Math.PI * 2 / 4) * i,
                    orbitRadius: 140, // Reduced from 200
                    maxHp: 5000,
                    hp: 5000,
                    radius: 22, // Reduced from 30
                    flash: 0,
                    spawnInvuln: 120, // 2 seconds spawn protection
                    hasExploded: false, // Flag for one-time explosion
                    targetPriority: 10, // Highest priority - weapons should target shields first
                    // Make shields targetable entities
                    x: boss.x + Math.cos((Math.PI * 2 / 4) * i) * 200,
                    y: boss.y + Math.sin((Math.PI * 2 / 4) * i) * 200,
                    type: 'boss_shield',
                    isBossShield: true,
                    parentBoss: boss,
                    // Add all enemy-like properties to prevent errors
                    active: true,
                    vx: 0,
                    vy: 0,
                    cryoState: { 
                        slowed: false,
                        slowDuration: 0,
                        frozen: false,
                        frozenTimer: 0
                    },
                    pyroState: { active: false, timer: 0, level: 0, baseDmg: 0 },
                    bioState: { active: false, timer: 0, level: 0, maxDmg: 0, jumpCount: 0 },
                    hackState: { active: false, timer: 0 },
                    empState: { active: false, timer: 0 },
                    ionState: { active: false, timer: 0 },
                    empSlowStacks: 0,
                    // Dummy methods so it doesn't crash in enemy loops
                    update() { /* Updated in boss logic */ },
                    draw() { /* Drawn with boss */ },
                    // Add takeDamage method so ultimates can damage shields
                    takeDamage(amt, color = '#ffffff', isCrit = false, type = 'normal', sourceId = null, elementType = null) {
                        // Shields are simple - just take damage and flash
                        this.hp -= amt;
                        this.flash = 5;
                        
                        // Create damage text
                        if (amt >= 1 || type === 'dot') {
                            entities.texts.push(new FloatingText(this.x, this.y - 20, Math.ceil(amt), color, isCrit, type, sourceId, elementType));
                        }
                        
                        // Shields don't have death logic - handled by boss system
                    }
                };
                boss.shields.push(shield);
                // Add to entities so weapons can target it
                entities.enemies.push(shield);
            }
            
            state.finalBoss = boss;
            state.finalBossActive = true;
            state.bossActive = true;
            entities.enemies.push(boss);
            // Camera shake removed
            
            console.log('‚úÖ Boss added to entities.enemies, count:', entities.enemies.length);
            console.log('‚úÖ Boss final position:', boss.x.toFixed(2), boss.y.toFixed(2));
            
            // Show boss HUD
            document.getElementById('boss-hud').classList.add('active');
            
            createBossHealthBar();
        }
        
        function createBossHealthBar() {
            const container = document.getElementById('boss-bars-container');
            
            // Reset to row layout for NEXUS PRIME
            container.style.flexDirection = 'row';
            container.style.alignItems = 'stretch';
            
            container.innerHTML = `
                <div style="width: 90%; max-width: 900px; margin: 0 auto;">
                    <div style="text-align: center; color: #a855f7; font-weight: bold; margin-bottom: 4px; font-size: 16px; text-shadow: 0 0 10px #a855f7;">
                        NEXUS PRIME
                    </div>
                    <div style="position: relative; width: 100%; height: 20px;" id="boss-segments"></div>
                    <div style="display: flex; gap: 3px; margin-top: 4px;" id="shield-bars">
                        <div class="shield-bar" data-index="0" style="flex: 1; height: 8px; background: #1a1a1a; border: 1px solid #a855f7; position: relative;">
                            <div class="shield-fill" style="position: absolute; left: 0; top: 0; height: 100%; width: 100%; background: #a855f7;"></div>
                        </div>
                        <div class="shield-bar" data-index="1" style="flex: 1; height: 8px; background: #1a1a1a; border: 1px solid #a855f7; position: relative;">
                            <div class="shield-fill" style="position: absolute; left: 0; top: 0; height: 100%; width: 100%; background: #a855f7;"></div>
                        </div>
                        <div class="shield-bar" data-index="2" style="flex: 1; height: 8px; background: #1a1a1a; border: 1px solid #a855f7; position: relative;">
                            <div class="shield-fill" style="position: absolute; left: 0; top: 0; height: 100%; width: 100%; background: #a855f7;"></div>
                        </div>
                        <div class="shield-bar" data-index="3" style="flex: 1; height: 8px; background: #1a1a1a; border: 1px solid #a855f7; position: relative;">
                            <div class="shield-fill" style="position: absolute; left: 0; top: 0; height: 100%; width: 100%; background: #a855f7;"></div>
                        </div>
                    </div>
                </div>
            `;
            updateBossHealthBar();
        }
        
        function updateBossHealthBar() {
            if (!state.finalBoss) return;
            const hpPercent = state.finalBoss.hp / state.finalBoss.maxHp;
            const segments = document.getElementById('boss-segments');
            if (!segments) return;
            
            // Purple/fuchsia bar with white diamond markers
            segments.innerHTML = `
                <div style="position: relative; width: 100%; height: 100%; background: #1a1a1a; border: 2px solid #a855f7;">
                    <div style="position: absolute; left: 0; top: 0; height: 100%; width: ${hpPercent * 100}%; background: linear-gradient(to right, #a855f7, #ec4899); transition: width 0.3s;"></div>
                    
                    <!-- Clean white diamond markers at 25%, 50%, 75% -->
                    <div style="position: absolute; left: 25%; top: 50%; transform: translate(-50%, -50%) rotate(45deg); width: 6px; height: 6px; background: #ffffff; border: 1px solid #cccccc; box-shadow: 0 0 2px rgba(255,255,255,0.5);"></div>
                    <div style="position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%) rotate(45deg); width: 6px; height: 6px; background: #ffffff; border: 1px solid #cccccc; box-shadow: 0 0 2px rgba(255,255,255,0.5);"></div>
                    <div style="position: absolute; left: 75%; top: 50%; transform: translate(-50%, -50%) rotate(45deg); width: 6px; height: 6px; background: #ffffff; border: 1px solid #cccccc; box-shadow: 0 0 2px rgba(255,255,255,0.5);"></div>
                </div>
            `;
            
            // Update shield bars
            state.finalBoss.shields.forEach((shield, index) => {
                const shieldBar = document.querySelector(`.shield-bar[data-index="${index}"] .shield-fill`);
                if (shieldBar) {
                    const shieldPercent = Math.max(0, shield.hp / shield.maxHp);
                    shieldBar.style.width = `${shieldPercent * 100}%`;
                    shieldBar.style.transition = 'width 0.2s';
                    
                    // Flash effect when hit - MORE VISIBLE
                    if (shield.flash > 0) {
                        shieldBar.style.boxShadow = '0 0 20px #ec4899, 0 0 40px #ec4899, inset 0 0 10px rgba(236,72,153,0.5)';
                        shieldBar.style.filter = 'brightness(1.5)';
                    } else {
                        shieldBar.style.boxShadow = 'none';
                        shieldBar.style.filter = 'none';
                    }
                }
            });
        }
        
        function spawnBossTurret(boss) {
            // Check current turret count - hard cap at 10 turrets
            const currentTurrets = entities.enemies.filter(e => e.isBossTurret).length;
            const maxTurrets = 10;
            
            if (currentTurrets >= maxTurrets) {
                return;
            }
            
            const turretCount = [1, 2, 3, 4][boss.phase - 1]; // Reduced from [2, 4, 6, 8]
            const turretsToSpawn = Math.min(turretCount, maxTurrets - currentTurrets); // Don't exceed cap
            
            for (let i = 0; i < turretsToSpawn; i++) {
                const angle = (Math.PI * 2 / turretCount) * i + Math.random() * 0.3;
                const dist = 250 + Math.random() * 100;
                
                // Calculate position relative to boss (in world coordinates)
                const turretX = boss.x + Math.cos(angle) * dist;
                const turretY = boss.y + Math.sin(angle) * dist;
                
                // SAFETY: Validate coordinates
                if (isNaN(turretX) || isNaN(turretY) || isNaN(boss.x) || isNaN(boss.y)) {
                    console.error(`üö® CANNOT SPAWN TURRET: Invalid coordinates! boss=(${boss.x}, ${boss.y}), turret=(${turretX}, ${turretY})`);
                    continue; // Skip this turret
                }
                
                const turret = {
                    x: turretX,
                    y: turretY,
                    vx: 0,
                    vy: 0,
                    type: 'boss_turret',
                    isBossTurret: true,
                    maxHp: 250, // Reduced from 300
                    hp: 250,
                    radius: 15,
                    flash: 0,
                    fireTimer: 60,
                    tier: 'basic',
                    dmg: 20, // Increased from 15 - Contact damage if player touches turret
                    spawnInvuln: 60, // 1 second spawn protection
                    // Required enemy properties
                    active: true,
                    cryoState: { slowed: false, slowDuration: 0, frozen: false, frozenTimer: 0 },
                    pyroState: { active: false, timer: 0, level: 0, baseDmg: 0 },
                    bioState: { active: false, timer: 0, level: 0, maxDmg: 0, jumpCount: 0 },
                    hackState: { active: false, timer: 0 },
                    empState: { active: false, timer: 0 },
                    ionState: { active: false, timer: 0 },
                    empSlowStacks: 0,
                    // Dummy methods so it doesn't crash in enemy loops
                    update() { /* Updated in boss turret logic */ },
                    draw() { /* Drawn with boss logic */ },
                    // Add takeDamage method so ultimates can damage turrets
                    takeDamage(amt, color = '#ffffff', isCrit = false, type = 'normal', sourceId = null, elementType = null) {
                        // Turrets take damage and flash
                        this.hp -= amt;
                        this.flash = 5;
                        
                        // Create damage text
                        if (amt >= 1 || type === 'dot') {
                            entities.texts.push(new FloatingText(this.x, this.y - 20, Math.ceil(amt), color, isCrit, type, sourceId, elementType));
                        }
                        
                        // Turrets don't have special death logic
                    }
                };
                entities.enemies.push(turret);
                createExplosion(turret.x, turret.y, '#ff8800', 10);
            }
            
        }
        
        function executeBossAttack(boss) {
            const attacks = {
                1: ['tracking_laser', 'scatter_shot'], // Turrets are passive, not attacks
                2: ['spiral_barrage', 'homing_missiles', 'danger_zones', 'shield_laser'],
                3: ['bullet_hell_wave', 'meteor_shower'], // Keep just these two - they work well together
                4: [] // Will be filled with random selection from 1-3
            };
            
            // Phase 4: Random assortment from all previous phases
            if (boss.phase === 4) {
                const allAttacks = [...attacks[1], ...attacks[2], ...attacks[3]];
                const attack = allAttacks[Math.floor(seededRandom() * allAttacks.length)];
                
                // Execute the attack (uses same logic below)
                executeSingleAttack(boss, attack);
                return;
            }
            
            const phaseAttacks = attacks[boss.phase];
            const attack = phaseAttacks[Math.floor(seededRandom() * phaseAttacks.length)];
            
            executeSingleAttack(boss, attack);
        }
        
        function executeSingleAttack(boss, attack) {
            
            if (attack === 'tracking_laser') {
                // 1.5 second warning, then sweeps toward player for 3 seconds
                const playerAngle = Math.atan2(player.y - boss.y, player.x - boss.x);
                boss.laserWarning = {
                    active: true,
                    angle: playerAngle, // Start exactly on player
                    targetAngle: 0, // Will be updated each frame
                    sweepSpeed: 0.009, // Increased from 0.007
                    warningTime: 90, // 1.5 second warning (was 60)
                    activeTime: 180, // 3 seconds active (with damage)
                    timer: 270, // Total 4.5 seconds (was 240)
                    phase: 'warning' // 'warning' or 'active'
                };
            } else if (attack === 'scatter_shot') {
                // Dense cone with gap - narrower and slower for better dodging
                const angleToPlayer = Math.atan2(player.y - boss.y, player.x - boss.x);
                const totalBullets = 15; // Dense pattern
                const gapSize = 2; // Always 2 bullet gap for consistency
                // Gap positioned in middle area (positions 4-10), avoiding very ends
                const gapStart = 4 + Math.floor(seededRandom() * 7); // Gap between indices 4-10
                
                for (let i = 0; i < totalBullets; i++) {
                    // Skip bullets in the gap
                    if (i >= gapStart && i < gapStart + gapSize) continue;
                    
                    const spread = -0.87 + (i / (totalBullets - 1)) * 1.74; // 100¬∞ arc (was 110¬∞)
                    const angle = angleToPlayer + spread;
                    entities.enemyProjectiles.push({
                        x: boss.x,
                        y: boss.y,
                        vx: Math.cos(angle) * 3.5, // Slower (was 4)
                        vy: Math.sin(angle) * 3.5,
                        life: 180,
                        dmg: 38, // Increased from 35
                        radius: 5
                    });
                }
            } else if (attack === 'spiral_barrage') {
                // Rotating spiral
                let spiralAngle = 0;
                const spiralInterval = setInterval(() => {
                    if (!state.finalBossActive) {
                        clearInterval(spiralInterval);
                        return;
                    }
                    for (let i = 0; i < 8; i++) {
                        const angle = spiralAngle + (Math.PI * 2 / 8) * i;
                        entities.enemyProjectiles.push({
                            x: boss.x,
                            y: boss.y,
                            vx: Math.cos(angle) * 4,
                            vy: Math.sin(angle) * 4,
                            life: 180,
                            dmg: 30, // Increased from 28
                            radius: 5
                        });
                    }
                    spiralAngle += 0.3;
                }, 100);
                setTimeout(() => clearInterval(spiralInterval), 2000);
            } else if (attack === 'homing_missiles') {
                // 5 homing missiles with loose steering and detonation timer
                for (let i = 0; i < 5; i++) {
                    setTimeout(() => {
                        if (!state.finalBossActive) return;
                        const angle = Math.random() * Math.PI * 2;
                        entities.enemyProjectiles.push({
                            x: boss.x + Math.cos(angle) * 50,
                            y: boss.y + Math.sin(angle) * 50,
                            vx: Math.cos(angle) * 1.4, // Increased from 1.2
                            vy: Math.sin(angle) * 1.4,
                            life: 180, // Reduced from 240 - detonates after 3 seconds
                            maxLife: 180, // Track max life for detonation timer
                            dmg: 38, // Increased from 35
                            radius: 6,
                            homing: true,
                            homingStrength: 0.004, // Much weaker turning (was 0.01) - allows dodging
                            detonateOnTimeout: true, // Flag for explosion on timeout
                            chaseLifetime: 210 // 3.5 seconds before it stops chasing
                        });
                    }, i * 300);
                }
            } else if (attack === 'danger_zones') {
                // Red telegraphed circles - spawn around PLAYER to create threat
                for (let i = 0; i < 6; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    // Spawn closer to player (50-200 units instead of boss 150-350)
                    const dist = 50 + Math.random() * 150;
                    const zoneX = player.x + Math.cos(angle) * dist;
                    const zoneY = player.y + Math.sin(angle) * dist;
                    
                    // Create danger zone indicator
                    const zone = {
                        x: zoneX,
                        y: zoneY,
                        radius: 60,
                        timer: 60, // 1 second telegraph (reduced from 90)
                        isDangerZone: true
                    };
                    entities.particles.push(zone);
                    // Note: Explosion and damage handled by particle system, not setTimeout
                }
            } else if (attack === 'shield_laser') {
                // Each shield fires outward beam while rotating
                if (!boss.shieldsActive) return; // Skip if shields down
                
                boss.shields.forEach((shield, i) => {
                    setTimeout(() => {
                        if (!state.finalBossActive || shield.hp <= 0) return;
                        
                        // Fire laser outward from shield for 2 seconds
                        const startAngle = shield.angle;
                        const laserInterval = setInterval(() => {
                            if (!state.finalBossActive || shield.hp <= 0) {
                                clearInterval(laserInterval);
                                return;
                            }
                            
                            // Fire projectile along current shield angle
                            const shieldX = boss.x + Math.cos(shield.angle) * shield.orbitRadius;
                            const shieldY = boss.y + Math.sin(shield.angle) * shield.orbitRadius;
                            
                            entities.enemyProjectiles.push({
                                x: shieldX,
                                y: shieldY,
                                vx: Math.cos(shield.angle) * 5,
                                vy: Math.sin(shield.angle) * 5,
                                life: 120,
                                dmg: 30, // Increased from 28
                                radius: 4
                            });
                        }, 100); // Fire every 100ms
                        
                        setTimeout(() => clearInterval(laserInterval), 2000);
                    }, i * 150); // Stagger each shield
                });
            } else if (attack === 'bullet_hell_wave') {
                // Dense wall aimed at player with gaps - all bullets fired at once
                const angleToPlayer = Math.atan2(player.y - boss.y, player.x - boss.x);
                
                // Calculate gap positions
                // Gap 1: Second quarter (positions 5-9), bias towards center
                const gap1Start = 5 + Math.floor(seededRandom() * 3); // Positions 5, 6, or 7
                // Gap 2: Third quarter (positions 10-14), bias towards center  
                const gap2Start = 10 + Math.floor(seededRandom() * 3); // Positions 10, 11, or 12
                
                for (let i = 0; i < 20; i++) { // 20 bullets
                    // Skip gaps (each gap is 2 bullets wide)
                    if ((i >= gap1Start && i < gap1Start + 2) || (i >= gap2Start && i < gap2Start + 2)) continue;
                    
                    // Spread bullets in 180¬∞ arc centered on player
                    const spread = -Math.PI/2 + (i / 19) * Math.PI; // -90¬∞ to +90¬∞
                    const finalAngle = angleToPlayer + spread;
                    
                    // Fire all bullets at once (no setTimeout)
                    entities.enemyProjectiles.push({
                        x: boss.x,
                        y: boss.y,
                        vx: Math.cos(finalAngle) * 4.5,
                        vy: Math.sin(finalAngle) * 4.5,
                        life: 180,
                        dmg: 38, // Increased from 35
                        radius: 5
                    });
                }
            } else if (attack === 'cross_laser') {
                // X-shaped laser sweep (visual warning then damage)
                const warningTime = 90; // 1.5 seconds
                boss.laserWarning = { timer: warningTime, angle: 0 };
                setTimeout(() => {
                    if (!state.finalBossActive) return;
                    // Check if player in laser path
                    const dx = player.x - boss.x;
                    const dy = player.y - boss.y;
                    const playerAngle = Math.atan2(dy, dx);
                    const laserAngles = [0, Math.PI/2, Math.PI, -Math.PI/2];
                    for (let angle of laserAngles) {
                        const diff = Math.abs(((playerAngle - angle + Math.PI) % (Math.PI * 2)) - Math.PI);
                        if (diff < 0.3) {
                            player.takeHit(50, 'Cross Laser', 'NEXUS PRIME');
                            break;
                        }
                    }
                }, warningTime * 16);
            } else if (attack === 'meteor_shower') {
                // Random projectiles from above with ground warnings
                for (let i = 0; i < 20; i++) {
                    setTimeout(() => {
                        if (!state.finalBossActive) return;
                        // Much tighter spread around player (was 400, now 200)
                        // Mix of direct targeting and spread for variety
                        const spreadRange = i < 10 ? 150 : 200; // First half tighter
                        const targetX = player.x + (Math.random() - 0.5) * spreadRange;
                        const targetY = player.y + (Math.random() - 0.5) * spreadRange;
                        
                        // Add ground warning indicator
                        const warning = {
                            x: targetX,
                            y: targetY,
                            radius: 20,
                            timer: 60, // 1 second warning
                            isMeteorWarning: true,
                            update() { 
                                // Keep crosshair visible (stop at timer=1) until impact removes it
                                if (this.timer > 1) this.timer--;
                                return this.timer > 0; 
                            },
                            draw(ctx) {
                                // Fade in first half, stay bright second half
                                const alpha = this.timer >= 30 ? (60 - this.timer) / 30 : 1.0;
                                const pulse = 0.7 + Math.sin(state.frameCount * 0.2) * 0.3;
                                ctx.save();
                                ctx.translate(this.x, this.y);
                                // Green pulsing target
                                ctx.strokeStyle = `rgba(0, 255, 100, ${alpha * pulse})`;
                                ctx.lineWidth = 2;
                                ctx.shadowBlur = 15;
                                ctx.shadowColor = '#00ff64';
                                ctx.beginPath();
                                ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
                                ctx.stroke();
                                // Crosshair
                                ctx.beginPath();
                                ctx.moveTo(-this.radius, 0);
                                ctx.lineTo(this.radius, 0);
                                ctx.moveTo(0, -this.radius);
                                ctx.lineTo(0, this.radius);
                                ctx.stroke();
                                ctx.shadowBlur = 0;
                                ctx.restore();
                            }
                        };
                        entities.particles.push(warning);
                        
                        // Spawn falling meteor visual (0.5s before impact)
                        setTimeout(() => {
                            if (!state.finalBossActive) return;
                            
                            // Add falling meteor projectile
                            entities.particles.push({
                                x: targetX,
                                y: targetY - 300, // Start above target
                                targetX: targetX,
                                targetY: targetY,
                                life: 30, // 0.5 seconds to fall
                                size: 8,
                                isFallingMeteor: true,
                                update(dt) {
                                    this.life -= dt/16;
                                    // Fall toward target
                                    const progress = 1 - (this.life / 30);
                                    this.y = (this.targetY - 300) + (300 * progress);
                                    return this.life > 0;
                                },
                                draw(ctx) {
                                    ctx.save();
                                    // Green meteor with trail
                                    ctx.fillStyle = '#00ff64';
                                    ctx.shadowBlur = 15;
                                    ctx.shadowColor = '#00ff64';
                                    ctx.beginPath();
                                    ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                                    ctx.fill();
                                    
                                    // Trail
                                    ctx.fillStyle = 'rgba(0, 255, 100, 0.5)';
                                    ctx.fillRect(this.x - 2, this.y - 20, 4, 20);
                                    ctx.shadowBlur = 0;
                                    ctx.restore();
                                }
                            });
                        }, 500); // Spawn meteor 0.5s after warning starts
                        
                        // Spawn meteor impact after warning (lands exactly on crosshair)
                        setTimeout(() => {
                            if (!state.finalBossActive) return;
                            
                            // Remove the crosshair warning
                            warning.timer = 0;
                            
                            // Impact damage at exact crosshair location
                            const dx = player.x - targetX;
                            const dy = player.y - targetY;
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            const splashRadius = 40; // Splash damage radius
                            
                            if (dist < splashRadius) {
                                const damageFalloff = 1 - (dist / splashRadius);
                                player.takeHit(Math.ceil(35 * damageFalloff), 'Meteor Strike', 'NEXUS PRIME');
                            }
                            
                            // Create meteor impact explosion
                            createExplosion(targetX, targetY, '#00ff64', 25);
                            
                            // Ground impact shockwave
                            entities.particles.push({
                                x: targetX,
                                y: targetY,
                                radius: 10,
                                maxRadius: 50,
                                life: 20,
                                color: '#00ff64',
                                update(dt) {
                                    this.life -= dt/16;
                                    this.radius += (this.maxRadius - this.radius) * 0.2;
                                    return this.life > 0;
                                },
                                draw(ctx) {
                                    const alpha = this.life / 20;
                                    ctx.save();
                                    ctx.strokeStyle = `rgba(0, 255, 100, ${alpha})`;
                                    ctx.lineWidth = 3;
                                    ctx.shadowBlur = 10;
                                    ctx.shadowColor = '#00ff64';
                                    ctx.beginPath();
                                    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                                    ctx.stroke();
                                    ctx.shadowBlur = 0;
                                    ctx.restore();
                                }
                            });
                            
                            // Debris particles
                            for (let j = 0; j < 8; j++) {
                                const angle = (Math.PI * 2 / 8) * j;
                                const speed = 2 + Math.random() * 3;
                                entities.particles.push({
                                    x: targetX,
                                    y: targetY,
                                    vx: Math.cos(angle) * speed,
                                    vy: Math.sin(angle) * speed,
                                    life: 15,
                                    size: 3 + Math.random() * 3,
                                    color: '#00ff64',
                                    update(dt) {
                                        this.x += this.vx * (dt/16);
                                        this.y += this.vy * (dt/16);
                                        this.vx *= 0.95;
                                        this.vy *= 0.95;
                                        this.life -= dt/16;
                                        return this.life > 0;
                                    },
                                    draw(ctx) {
                                        const alpha = this.life / 15;
                                        ctx.fillStyle = `rgba(0, 255, 100, ${alpha})`;
                                        ctx.fillRect(this.x - this.size/2, this.y - this.size/2, this.size, this.size);
                                    }
                                });
                            }
                        }, 1000); // Impact after 1 second warning
                    }, i * 100);
                }
            } else if (attack === 'ring_of_death') {
                // Expanding ring of bullets
                for (let i = 0; i < 24; i++) {
                    const angle = (Math.PI * 2 / 24) * i;
                    entities.enemyProjectiles.push({
                        x: boss.x,
                        y: boss.y,
                        vx: Math.cos(angle) * 3,
                        vy: Math.sin(angle) * 3,
                        life: 240,
                        dmg: 20,
                        radius: 5
                    });
                }
            } else if (attack === 'omega_barrage') {
                // Combined attack - scatter + spiral
                const angleToPlayer = Math.atan2(player.y - boss.y, player.x - boss.x);
                for (let i = 0; i < 16; i++) {
                    const spread = -0.8 + (i / 15) * 1.6;
                    const angle = angleToPlayer + spread;
                    entities.enemyProjectiles.push({
                        x: boss.x,
                        y: boss.y,
                        vx: Math.cos(angle) * 6,
                        vy: Math.sin(angle) * 6,
                        life: 180,
                        dmg: 20,
                        radius: 5
                    });
                }
            }
        }
        
        // ===== END BOSS SYSTEM =====

        function gameLoop() {
            // CRITICAL: Stop immediately if player is dead
            if (state.playerDead) {
                console.log('üõë gameLoop stopped - player is dead');
                if (animationFrameId) {
                    cancelAnimationFrame(animationFrameId);
                    animationFrameId = null;
                }
                return;
            }
            
            animationFrameId = requestAnimationFrame(gameLoop);
            
            // Allow levelup screen to continue updating pickups in background
            const isLevelupScreen = state.screen === 'levelup';
            if (state.screen !== 'game' && !isLevelupScreen) return;


            const now = Date.now(); 
            let dt = now - state.lastTime;
            state.lastTime = now;
            
            // PERFORMANCE MONITORING - Track entity counts
            if (!state.performanceMode) state.performanceMode = 'normal'; // normal, reduced, minimal
            const entityCount = entities.enemies.length + entities.projectiles.length + entities.particles.length;
            
            // Auto-adjust performance based on entity count (REALISTIC THRESHOLDS)
            // Typical ranges: Early game 50-150, Mid game 150-250, Late game 250-350
            if (entityCount > 300) {  // Boss fights and extreme scenarios
                state.performanceMode = 'minimal';
            } else if (entityCount > 200) {  // Late game, heavy combat
                state.performanceMode = 'reduced';
            } else {  // Early-mid game, normal play
                state.performanceMode = 'normal';
            }
            
            // PERFORMANCE HELPERS (non-viewport related)
            const useShadows = state.performanceMode === 'normal';
            const particleFactor = {
                normal: 1.0,
                reduced: 0.6,   // 40% fewer particles
                minimal: 0.3    // 70% fewer particles
            }[state.performanceMode];
            
            // Helper: Apply shadow (respects performance mode with reduced blur in normal)
            const applyShadow = (blur, color) => {
                if (useShadows) {
                    ctx.shadowBlur = blur * 0.7; // Reduce blur by 30% for better performance
                    ctx.shadowColor = color;
                }
            };
            const clearShadow = () => {
                if (useShadows) ctx.shadowBlur = 0;
            };
            
            // CRITICAL: Clamp dt to prevent catch-up behavior after lag/freezes
            // If game freezes for 1 second, we don't want to fire 60 frames of projectiles at once
            if (dt > 32) dt = 16; // Anything over 2 frames gets clamped to 1 frame
            
            if (state.paused) return; 


            state.gameTime += (dt * state.timeScale);
            if(state.breathingRoomTimer > 0) state.breathingRoomTimer -= dt/16;
            
            // Enemy spawn timer (framerate-independent)
            if (!state.spawnTimer) state.spawnTimer = 0;
            state.spawnTimer += dt/16;

            let targetTimeScale = input.active ? 1.0 : 0.1;
            
            // CHRONO SHIELD MOD: Slow time to 20% when below 30% HP, but player stays at 100%
            if (player.activeMod === 'chrono' && player.chronoActive && input.active) {
                targetTimeScale = 0.2; // 20% slow (everything except player)
            }
            
            // ASCENSION 5: TIME DILATION - slow time to 40% when below 30% HP
            if (state.activeAscension === 5 && input.active) {
                const hpPercent = player.hp / player.maxHp;
                if (hpPercent < 0.3) {
                    targetTimeScale = 0.4; // 40% slow when low HP
                }
            }
            
            state.timeScale += (targetTimeScale - state.timeScale) * 0.1;
            const scaledDt = dt * state.timeScale;


            // Frame count should be time-based, not actual frames, to be framerate-independent
            // Increment by dt/16 so it matches 60fps timing regardless of actual framerate
            state.frameCount += (dt/16);
            
            // Health Regeneration handled in player.update() - removed duplicate system here
            
            // Smooth zoom interpolation for boss fight
            if (!state.targetZoom) state.targetZoom = 0.70; // Default zoom
            state.zoom += (state.targetZoom - state.zoom) * 0.02; // Slow interpolation
            
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.fillStyle = '#050608'; ctx.fillRect(0, 0, width, height);


            const tx = width/2 - player.x * state.zoom; const ty = height/2 - player.y * state.zoom;
            
            // VIEWPORT CULLING - Calculate visible area (with buffer for smooth entry/exit)
            const viewBuffer = 200; // Extra buffer beyond screen edges
            const camX = -tx / state.zoom;
            const camY = -ty / state.zoom;
            const viewWidth = width / state.zoom;
            const viewHeight = height / state.zoom;
            const viewLeft = camX - viewBuffer;
            const viewRight = camX + viewWidth + viewBuffer;
            const viewTop = camY - viewBuffer;
            const viewBottom = camY + viewHeight + viewBuffer;
            
            // Helper: Check if point is in viewport
            const inViewport = (x, y) => x >= viewLeft && x <= viewRight && y >= viewTop && y <= viewBottom;
            
            // Framerate-independent camera lerp (targets ~60fps behavior)
            const lerpFactor = 1 - Math.pow(0.85, dt/16); // Smooth follow that works at any framerate
            
            // Only update camera if not manually controlled by ultimate
            if (state.manualCameraControl) {
                // Do nothing - camera is being controlled by manual pan interval
            } else if (!state.cameraLocked) {
                state.camera.x += (tx - state.camera.x) * lerpFactor; 
                state.camera.y += (ty - state.camera.y) * lerpFactor;
            } else if (state.ultimateCameraTarget) {
                // Smooth tracking of target enemy (for Skyfall retargeting)
                const target = state.ultimateCameraTarget;
                if (target && target.hp > 0) {
                    const targetCamX = width/2 - target.x * state.zoom;
                    const targetCamY = height/2 - target.y * state.zoom;
                    
                    // Use lerp for smooth camera movement instead of instant snap
                    const smoothFactor = 0.15; // Faster than normal follow but still smooth
                    state.camera.x += (targetCamX - state.camera.x) * smoothFactor;
                    state.camera.y += (targetCamY - state.camera.y) * smoothFactor;
                }
                // Note: If target dies, we DON'T pan back here - the ultimate itself handles
                // retargeting (Skyfall) or ending (when ultimate finishes naturally)
            } else if (state.lockedWorldX !== undefined && state.lockedWorldY !== undefined) {
                // Fixed camera position for AOE ultimates (Event Horizon, Seismic Bomb)
                // Continuously enforce the locked world position
                state.camera.x = width/2 - state.lockedWorldX * state.zoom;
                state.camera.y = height/2 - state.lockedWorldY * state.zoom;
            }
            // else: camera stays at whatever position it's at (shouldn't happen)
            
            if (!Number.isFinite(state.camera.x)) state.camera.x = 0;
            if (!Number.isFinite(state.camera.y)) state.camera.y = 0;


            let sx=0, sy=0;
            if(state.shake>0) { sx=(seededRandom()-0.5)*state.shake; sy=(seededRandom()-0.5)*state.shake; state.shake*=0.9; }


            // SAFE GRID
            const gs = 80 * state.zoom;
            ctx.strokeStyle = '#1e2130'; ctx.lineWidth = 2; ctx.beginPath();
            let offsetX = state.camera.x % gs; let offsetY = state.camera.y % gs;
            if (isNaN(offsetX)) offsetX = 0; if (isNaN(offsetY)) offsetY = 0;
            
            let loopGuard = 0;
            for (let x = offsetX; x < width; x += gs) { ctx.moveTo(x, 0); ctx.lineTo(x, height); loopGuard++; if(loopGuard>1000) break; }
            loopGuard = 0;
            for (let y = offsetY; y < height; y += gs) { ctx.moveTo(0, y); ctx.lineTo(width, y); loopGuard++; if(loopGuard>1000) break; }
            ctx.stroke();


            ctx.save(); ctx.translate(state.camera.x+sx, state.camera.y+sy); ctx.scale(state.zoom, state.zoom);


            // NEXUS PRIME BOSS: Level 50 - Final Boss Fight
            // Boss is triggered in the XP collection code (gainXp function) to ensure immediate spawn
            // This section is left as a debug check only
            if (state.level === 50 && !state.finalBossTriggered && !state.finalBossActive) {
                console.log('‚ö†Ô∏è WARNING: Level 50 detected but boss not triggered yet!');
                console.log('This should not happen - boss should trigger in gainXp()');
            }
            
            // CHAMPION SPAWN: Levels 15, 25, 35 only (skip 45, go straight to boss at 50)
            if (!state.finalBossTriggered && !state.bossActive && state.bossWave !== state.level && (state.level === 15 || state.level === 25 || state.level === 35)) {
                state.bossActive = true; // Flag to track champion is active
                state.bossWave = state.level;
                // DON'T clear enemies - champion joins the fight!
                
                // Determine number of TITANs based on level
                let titanCount = 1;
                if (state.level >= 35) titanCount = 3;
                else if (state.level >= 25) titanCount = 2;
                
                // Clear previous health bars
                const barsContainer = document.getElementById('boss-bars-container');
                barsContainer.innerHTML = '';
                
                // Change to column layout for title above bars
                barsContainer.style.flexDirection = 'column';
                barsContainer.style.alignItems = 'center';
                
                // Add title for TITAN encounter
                const titleDiv = document.createElement('div');
                titleDiv.style.textAlign = 'center';
                titleDiv.style.color = '#ff6600';
                titleDiv.style.fontWeight = 'bold';
                titleDiv.style.marginBottom = '-4px'; // Negative margin to bring health bars closer
                titleDiv.style.fontSize = '18px';
                titleDiv.style.textShadow = '0 0 10px #ff6600';
                titleDiv.innerText = titanCount === 1 ? 'TITAN' : 'TITAN SQUAD';
                barsContainer.appendChild(titleDiv);
                
                // Create container for health bars
                const barsRow = document.createElement('div');
                barsRow.style.display = 'flex';
                barsRow.style.gap = '8px';
                barsRow.style.width = '100%';
                barsRow.style.justifyContent = 'center';
                barsRow.style.margin = '0'; // Remove any default margin
                barsRow.style.padding = '0'; // Remove any default padding
                
                // Spawn TITANs in a formation
                for (let i = 0; i < titanCount; i++) {
                    const champion = new Enemy('champion');
                    champion.championId = `titan_${i}`;
                    
                    // DEFENSIVE: Prevent methods from being deleted
                    // Seal the prototype to prevent modification
                    if (i === 0) {
                        // Only need to do this once for the prototype
                        Object.seal(Object.getPrototypeOf(champion));
                        console.log('üõ°Ô∏è Sealed Enemy prototype to prevent method deletion');
                    }
                    
                    // Position TITANs in a spread formation
                    if (titanCount === 1) {
                        // Single TITAN - spawn at player position
                        champion.x = player.x + (Math.random() - 0.5) * 200;
                        champion.y = player.y + (Math.random() - 0.5) * 200;
                    } else if (titanCount === 2) {
                        // Two TITANs - spawn on opposite sides
                        const angle = (Math.PI * 2 / 2) * i + Math.random() * 0.5;
                        const dist = 250 + Math.random() * 100;
                        champion.x = player.x + Math.cos(angle) * dist;
                        champion.y = player.y + Math.sin(angle) * dist;
                    } else if (titanCount === 3) {
                        // Three TITANs - spawn in triangle formation
                        const angle = (Math.PI * 2 / 3) * i + Math.random() * 0.3;
                        const dist = 300 + Math.random() * 100;
                        champion.x = player.x + Math.cos(angle) * dist;
                        champion.y = player.y + Math.sin(angle) * dist;
                    }
                    
                    entities.enemies.push(champion);
                    
                    // Create health bar for this TITAN
                    const barWrapper = document.createElement('div');
                    barWrapper.id = `boss-bar-wrapper-${i}`;
                    barWrapper.style.flex = '1'; // Equal width, expands to fill space
                    barWrapper.style.minWidth = '80px'; // Minimum width for readability
                    
                    const barContainer = document.createElement('div');
                    barContainer.className = 'boss-bar-container';
                    barContainer.style.height = '15px'; // Consistent height
                    
                    const barFill = document.createElement('div');
                    barFill.id = `boss-bar-${i}`;
                    barFill.className = 'boss-bar-fill';
                    barFill.style.width = '100%';
                    barFill.style.background = '#ff6600';
                    barFill.style.boxShadow = '0 0 20px #ff6600';
                    
                    barContainer.appendChild(barFill);
                    barWrapper.appendChild(barContainer);
                    barsRow.appendChild(barWrapper);
                }
                
                barsContainer.appendChild(barsRow);
                
                // Champion name display
                const name = titanCount === 1 ? `TITAN` : `TITAN SQUAD`;
                document.getElementById('boss-name-display').innerText = name;

                document.getElementById('boss-hud').classList.add('active');
                
                // If upgrade screen is open, queue the warning for after it closes
                if (state.screen === 'levelup') {
                    state.queuedWarning = 'champion';
                } else {
                    const warn = document.getElementById('boss-warning');
                    warn.style.display = 'block';
                    setTimeout(() => warn.style.display = 'none', 3000);
                }
            }


            const mins = state.gameTime / 60000;
            // Boost early game spawn cap for levels 1-5
            const baseSpawnCap = state.level < 5 ? 8 : 5;
            const spawnCap = baseSpawnCap + Math.floor(mins * 15) + state.level; 
            
            // MINIMUM ENEMY COUNT SYSTEM (post-level 10)
            // Prevents enemy drought for strong builds
            let minimumEnemyTrigger = 0;
            let minimumEnemyTarget = 0;
            
            if (state.level >= 10 && !state.bossActive && !state.finalBossActive) {
                // Scale minimum with level
                minimumEnemyTrigger = 8 + Math.floor((state.level - 10) * 0.5); // 8 at lvl 10, 13 at lvl 20, 18 at lvl 30
                minimumEnemyTarget = minimumEnemyTrigger + 7; // Always 7 above trigger
            }
            
            // Count non-boss enemies
            const currentEnemyCount = entities.enemies.filter(e => 
                !e.isNexusPrime && !e.isBossShield && !e.isBossTurret && !e.isChampion
            ).length;
            
            // Check if we need rapid spawning
            const needsRapidSpawn = minimumEnemyTrigger > 0 && currentEnemyCount < minimumEnemyTrigger;
            const shouldStopRapidSpawn = minimumEnemyTarget > 0 && currentEnemyCount >= minimumEnemyTarget;
            
            // Track rapid spawn state
            if (!state.rapidSpawning) state.rapidSpawning = false;
            
            if (needsRapidSpawn && !state.rapidSpawning) {
                state.rapidSpawning = true;
                console.log(`üö® Rapid spawn activated! ${currentEnemyCount} < ${minimumEnemyTrigger}`);
            } else if (shouldStopRapidSpawn && state.rapidSpawning) {
                state.rapidSpawning = false;
                console.log(`‚úÖ Rapid spawn deactivated! ${currentEnemyCount} >= ${minimumEnemyTarget}`);
            }
            
            // Spawn interval in SECONDS (framerate-independent)
            // Reduced from 0.47-0.25s to 0.40-0.22s for ~15% more spawns
            let spawnIntervalSeconds = state.bossActive ? 
                (0.40 - Math.min(0.18, state.level * 0.016)) * 1.67 : // 67% slower during champion
                (0.40 - Math.min(0.18, state.level * 0.016));
            
            // Convert to timer units (dt/16, where dt is in ms)
            // At 60fps: dt=16.67, so dt/16‚âà1.04 per frame
            // To get seconds: multiply by 60 (frames per second)
            let spawnInterval = spawnIntervalSeconds * 60;
            
            // ASCENSION 3: AGGRESSIVE SWARMS - 15% faster spawns
            if (state.activeAscension === 3) {
                spawnInterval = Math.floor(spawnInterval * 0.87); // 13% reduction = ~15% more spawns
            }
            
            // Override spawn interval during rapid spawning
            if (state.rapidSpawning) {
                spawnInterval = 5; // Spawn every 5 frames (~12 per second at 60fps)
            }
            
            // Normal enemy spawning (skip during final boss) - framerate independent timer
            if(!state.finalBossActive && !state.finalBossDefeated && state.breathingRoomTimer <= 0 && entities.enemies.length < spawnCap && state.spawnTimer >= spawnInterval) { 
                state.spawnTimer -= spawnInterval; // Reset timer by subtracting interval (preserves overflow)
                let type = 'drone'; const r = seededRandom();
                if(state.score>300 && r>0.7) type='swarm';
                if(state.score>500 && r>0.99 && state.level >= 5) type='tank';
                // Splitters appear after level 8, 8% chance (reduced from 15%)
                if(state.level >= 8 && r>0.7 && r<=0.78) type='splitter';
                // Voidwalkers removed from game
                entities.enemies.push(new Enemy(type));
            }


            // Particle cap removed - handled later in filter (line ~11573) to not interfere with boss attacks

            entities.pickups = entities.pickups.filter(p => { 
                // FINAL BOSS: No pickups allowed during boss fight
                if (state.finalBossActive && !state.finalBossDefeated) {
                    return false; // Remove all pickups
                }
                const a=p.update(scaledDt); 
                if(a) p.draw(ctx); 
                return a; 
            });
            
            // Check if we have pending upgrades (level ups or ultimate selection)
            if (state.upgradeQueue && state.upgradeQueue.length > 0 && state.screen === 'game' && !player.ultimateActive) {
                processNextUpgrade();
            }
            
            // During levelup screen: Skip game updates but continue rendering (world visible behind UI)
            // Only pickups update (above) so XP collection continues
            if (isLevelupScreen) {
                // Still draw player/enemies so world is visible, but don't update them
                player.draw(ctx);
                entities.enemies.forEach(e => {
                    try {
                        if (e.draw && typeof e.draw === 'function') {
                            e.draw(ctx);
                        }
                    } catch (err) {
                        console.error('Error drawing enemy during levelup:', err);
                    }
                });
                entities.projectiles.forEach(p => { if(p.draw) p.draw(ctx); });
                entities.enemyProjectiles.forEach(ep => {
                    ctx.fillStyle = ep.color || '#ff6666';
                    ctx.beginPath();
                    ctx.arc(ep.x, ep.y, ep.radius || 4, 0, Math.PI*2);
                    ctx.fill();
                });
                return; // Skip rest of update logic
            }
            
            // Chrono Shield: Player moves at 100% speed even when time is slowed
            const playerDt = (player.activeMod === 'chrono' && player.chronoActive) ? dt : scaledDt;
            player.update(playerDt); player.draw(ctx);
            
            // ULTIMATE CHARGING SYSTEM
            if (player.ultimate && player.ultimateCharge < 100 && !player.ultimateActive) {
                // Passive time-based charging
                const ultimateData = ULTIMATES[player.ultimate];
                const passiveChargePerFrame = (player.ultimateChargeRate * (dt / 1000)) / ultimateData.chargeTime * 100;
                player.ultimateCharge += passiveChargePerFrame;
                
                // Cap at 100%
                if (player.ultimateCharge > 100) player.ultimateCharge = 100;
            }
            
            // PHOENIX PROTOCOL UPDATE - Game-time-based pulses and burning ground
            if (player.ultimateActive && player.ultimate === 'phoenix_protocol' && player.ultimateData) {
                const data = player.ultimateData;
                const ultimateData = ULTIMATES.phoenix_protocol;
                
                // Handle pending final explosion
                if (data.pendingFinalExplosion !== undefined) {
                    data.pendingFinalExplosion -= (scaledDt / 16);
                    if (data.pendingFinalExplosion <= 0) {
                        createExplosion(data.phoenixX, data.phoenixY, ultimateData.color, 80);
                        data.pendingFinalExplosion = undefined;
                    }
                }
                
                // Handle pulse timing
                if (data.pulseCount < data.totalPulses) {
                    data.nextPulseTimer -= scaledDt;
                    if (data.nextPulseTimer <= 0) {
                        executePhoenixPulse();
                    }
                }
                
                // Handle burning ground
                if (data.burningGround && data.burningGround.active) {
                    const bg = data.burningGround;
                    
                    // Update timers
                    bg.timer -= scaledDt;
                    bg.tickTimer -= scaledDt;
                    
                    // Damage tick
                    if (bg.tickTimer <= 0) {
                        bg.tickTimer = 1000; // Reset to 1 second
                        
                        entities.enemies.forEach(e => {
                            if (e.hp <= 0) return;
                            
                            const dist = Math.sqrt((e.x - bg.x)**2 + (e.y - bg.y)**2);
                            
                            if (dist < bg.radius) {
                                let damage = e.maxHp * (ultimateData.burningGround.damagePerSecond / 100);
                                
                                // Apply damage reduction
                                if (e.isNexusPrime) {
                                    damage *= ULTIMATE_DAMAGE_REDUCTION.nexusPrime;
                                } else if (e.isChampion) {
                                    damage *= ULTIMATE_DAMAGE_REDUCTION.titan;
                                } else {
                                    damage *= ULTIMATE_DAMAGE_REDUCTION.normal;
                                }
                                
                                // Ensure minimum damage
                                damage = Math.max(1, damage);
                                
                                // Use takeDamage instead of direct HP subtraction to ensure proper death handling
                                e.takeDamage(damage, '#ff8800', false, 'normal');
                                
                                const damageText = new FloatingText(
                                    e.x + (Math.random() - 0.5) * 20,
                                    e.y - 10,
                                    Math.floor(damage),
                                    '#ff8800'
                                );
                                damageText.fontSize = 18;
                                damageText.life = 50;
                                entities.texts.push(damageText);
                            }
                        });
                    }
                    
                    // Check if burning ground is done
                    if (bg.timer <= 0) {
                        bg.active = false;
                        player.ultimateActive = false;
                        player.ultimateData = {};
                        
                        // Check for queued upgrades
                        checkQueuedUpgrades();
                    }
                }
            }
            
            // ADRENALINE SURGE UPDATE - Game-time-based speed boost and trail damage
            if (player.ultimateActive && player.ultimate === 'adrenaline_surge' && player.ultimateData) {
                const data = player.ultimateData;
                const ultimateData = ULTIMATES.adrenaline_surge;
                
                // Update timer (game time)
                data.timer -= scaledDt;
                
                // Store player position for trail (use game time counter instead of Date.now())
                if (!data.gameTime) data.gameTime = 0;
                data.gameTime += scaledDt;
                
                data.trail.push({ x: player.x, y: player.y, time: data.gameTime });
                
                // Keep only recent positions (within trail duration, using game time)
                data.trail = data.trail.filter(pos => data.gameTime - pos.time < data.trailDuration);
                
                // ‚ö° Contact damage and trail damage now processed in consolidated enemy loop
                
                // Trail damage tick
                data.trailTickTimer -= scaledDt;
                if (data.trailTickTimer <= 0) {
                    data.trailTickTimer = data.trailTickRate; // Reset timer
                    // ‚ö° Trail damage now processed in consolidated enemy loop
                }
                
                // Check if ultimate is done
                if (data.timer <= 0) {
                    console.log('‚ö° Adrenaline Surge complete');
                    player.ultimateActive = false;
                    player.ultimateData = {};
                    
                    // Check for queued upgrades
                    checkQueuedUpgrades();
                }
            }
            
            // ‚ö° OPTIMIZED: Consolidated enemy processing (was 3 separate loops, now 1)
            // Pre-calculate values outside loop for Adrenaline Surge
            const hasAdrenalineSurge = player.ultimateActive && player.ultimate === 'adrenaline_surge' && player.ultimateData;
            const adrenalineData = hasAdrenalineSurge ? player.ultimateData : null;
            const hasEmpFields = player.empFields && player.empFields.length > 0;
            const adrenalineDoTrailTick = hasAdrenalineSurge && adrenalineData.trailTickTimer <= 0;
            
            // Enemy updates with spatial culling
            entities.enemies = entities.enemies.filter(e => {
                // FLEEING ENEMIES: Update and despawn when offscreen
                if (e.fleeing) {
                    // Track frames for debugging
                    if (!e.fleeingFrameCount) e.fleeingFrameCount = 0;
                    e.fleeingFrameCount++;
                    
                    e.fleeingTimer -= dt / 16;
                    
                    // Continue fleeing movement
                    e.x += e.vx * (dt / 16);
                    e.y += e.vy * (dt / 16);
                    
                    // Keep full opacity - no fade
                    e.fleeingOpacity = 1.0;
                    
                    // Log every 30 frames for first enemy to see if it's alive
                    if (e.fleeingFrameCount === 1 || e.fleeingFrameCount % 30 === 0) {
                        if (state.fleeingLogCount < 3) {
                            state.fleeingLogCount++;
                        }
                    }
                    
                    // GRACE PERIOD: Don't check offscreen for first 2.5 seconds (150 frames)
                    // This gives enemies time to visibly flee before despawning
                    if (e.fleeingTimer < 450) { // After 2.5 seconds of fleeing (started at 600)
                        // Check if offscreen (using world coordinates relative to camera)
                        const cameraLeft = state.camera.x;
                        const cameraRight = state.camera.x + (width / state.zoom);
                        const cameraTop = state.camera.y;
                        const cameraBottom = state.camera.y + (height / state.zoom);
                        const margin = 500; // Very large margin so they flee far offscreen
                        
                        const isOffscreen = (
                            e.x < cameraLeft - margin || e.x > cameraRight + margin ||
                            e.y < cameraTop - margin || e.y > cameraBottom + margin
                        );
                        
                        // Log camera bounds for debugging
                        if (e.fleeingFrameCount === 150) {
                            console.log(`üì∑ Camera bounds: (${cameraLeft.toFixed(0)}, ${cameraTop.toFixed(0)}) to (${cameraRight.toFixed(0)}, ${cameraBottom.toFixed(0)})`);
                            console.log(`   Enemy at (${e.x.toFixed(0)}, ${e.y.toFixed(0)}), offscreen=${isOffscreen}`);
                        }
                        
                        if (isOffscreen) {
                            // Log first few despawns
                            if (state.fleeDespawnCount < 5) {
                                state.fleeDespawnCount++;
                            }
                            return false; // Despawn
                        }
                    }
                    
                    // Timer expired - despawn regardless
                    if (e.fleeingTimer <= 0) {
                        return false;
                    }
                    
                    // Don't run normal update logic for fleeing enemies, but DO continue to draw
                    // (don't return here - let them fall through to draw code)
                }
                
                // DEFENSIVE: Verify enemy has update method before processing
                // If an enemy somehow lost its update method, try to restore it
                if (!e.update && e.type) {
                    console.error(`üêõ CRITICAL: Enemy lost update method! Type: ${e.type}, isChampion: ${e.isChampion}, championId: ${e.championId}`);
                    console.error(`Enemy object keys:`, Object.keys(e));
                    console.error(`Enemy prototype:`, Object.getPrototypeOf(e));
                    
                    // This should never happen - enemies are created with new Enemy() which has update as a method
                    // If we reach here, something is corrupting the enemy object or its prototype
                    
                    if (e.isChampion) {
                        console.error(`üö® Champion lost update method - this is a CRITICAL BUG`);
                        console.error(`Champion state:`, {
                            type: e.type,
                            hp: e.hp,
                            maxHp: e.maxHp,
                            x: e.x,
                            y: e.y,
                            championId: e.championId,
                            attackState: e.attackState
                        });
                    }
                }
                
                // SAFETY: Remove orphaned boss turrets/shields that are far off-screen or belong to dead boss
                if ((e.isBossShield || e.isBossTurret) && state.finalBossActive) {
                    const bosses = entities.enemies.filter(en => en.isNexusPrime && en.hp > 0);
                    if (bosses.length === 0) {
                        // No living boss - remove all shields/turrets
                        console.log(`‚ö†Ô∏è Removing orphaned ${e.isBossShield ? 'shield' : 'turret'} at (${e.x.toFixed(0)}, ${e.y.toFixed(0)})`);
                        return false;
                    }
                    // Check if entity is way too far from boss (world coordinates)
                    const boss = bosses[0];
                    const distFromBoss = Math.sqrt((e.x - boss.x)**2 + (e.y - boss.y)**2);
                    const maxDist = 2000; // 2000 world units from boss
                    if (distFromBoss > maxDist) {
                        console.log(`‚ö†Ô∏è Removing far off-screen ${e.isBossShield ? 'shield' : 'turret'} at (${e.x.toFixed(0)}, ${e.y.toFixed(0)}), dist from boss: ${distFromBoss.toFixed(0)}`);
                        return false;
                    }
                }
                
                // ‚ö° CONSOLIDATED: EMP field processing (moved from separate loop)
                if (hasEmpFields) {
                    e.empSlowStacks = 0; // Reset stacks each frame
                    player.empFields.forEach(field => {
                        const distSq = (e.x - field.x)**2 + (e.y - field.y)**2;
                        if (distSq < field.radius * field.radius) {
                            e.empSlowStacks++;
                        }
                    });
                }
                
                // ‚ö° CONSOLIDATED: Adrenaline Surge processing (moved from separate loops)
                if (hasAdrenalineSurge && e.hp > 0) {
                    const data = adrenalineData;
                    
                    // Contact damage check
                    const collisionDist = player.radius + (e.radius || 20);
                    const dx = e.x - player.x;
                    const dy = e.y - player.y;
                    const distSq = dx * dx + dy * dy;
                    
                    if (distSq < collisionDist * collisionDist) {
                        const lastHit = data.contactCooldowns.get(e.id) || 0;
                        const cooldownElapsed = data.gameTime - lastHit;
                        
                        if (cooldownElapsed >= data.contactCooldown) {
                            let contactDmg = e.maxHp * (data.contactDamage / 100);
                            
                            if (e.isNexusPrime) {
                                contactDmg *= ULTIMATE_DAMAGE_REDUCTION.nexusPrime;
                            } else if (e.isChampion) {
                                contactDmg *= ULTIMATE_DAMAGE_REDUCTION.titan;
                            } else {
                                contactDmg *= ULTIMATE_DAMAGE_REDUCTION.normal;
                            }
                            
                            contactDmg = Math.max(1, contactDmg);
                            e.takeDamage(contactDmg, data.color, false, 'normal');
                            data.contactCooldowns.set(e.id, data.gameTime);
                            createExplosion(e.x, e.y, data.color, 15);
                            entities.particles.push(new Shockwave(e.x, e.y, 50, data.color));
                        }
                    }
                    
                    // Trail damage tick (only when tick timer triggers)
                    if (adrenalineDoTrailTick) {
                        const inTrail = data.trail.some(pos => {
                            const dist = Math.sqrt((e.x - pos.x)**2 + (e.y - pos.y)**2);
                            return dist < (data.trailWidth / 2);
                        });
                        
                        if (inTrail) {
                            let trailDmg = e.maxHp * (data.trailDamage / 100) * (data.trailTickRate / 1000);
                            
                            if (e.isNexusPrime) {
                                trailDmg *= ULTIMATE_DAMAGE_REDUCTION.nexusPrime;
                            } else if (e.isChampion) {
                                trailDmg *= ULTIMATE_DAMAGE_REDUCTION.titan;
                            } else {
                                trailDmg *= ULTIMATE_DAMAGE_REDUCTION.normal;
                            }
                            
                            trailDmg = Math.max(1, trailDmg);
                            e.takeDamage(trailDmg, data.color, false, 'dot');
                        }
                    }
                }
                
                // Boss shields - KEEP THEM even if dead (for regeneration)
                // They're only drawn when hp > 0 anyway
                if (e.isBossShield) {
                    return true; // Always keep shields in array
                }
                
                // Special handling for NEXUS PRIME
                if (e.isNexusPrime) {
                    // CRITICAL SAFETY: Validate boss coordinates
                    if (e.x === null || e.x === undefined || e.y === null || e.y === undefined || isNaN(e.x) || isNaN(e.y)) {
                        console.error(`üö® CRITICAL BUG: Nexus Prime has invalid coordinates! x=${e.x}, y=${e.y}, hp=${e.hp}, coreVulnerable=${e.coreVulnerable}`);
                        console.error(`Boss state:`, {
                            x: e.x,
                            y: e.y,
                            hp: e.hp,
                            maxHp: e.maxHp,
                            phase: e.phase,
                            coreVulnerable: e.coreVulnerable,
                            deathSequenceStarted: e.deathSequenceStarted
                        });
                        // Try to recover by keeping boss at center if coordinates are lost
                        if (e.x === null || e.x === undefined || isNaN(e.x)) e.x = width / 2;
                        if (e.y === null || e.y === undefined || isNaN(e.y)) e.y = height / 2;
                        console.log(`üîß Recovered boss position to center: (${e.x}, ${e.y})`);
                    }
                    
                    // Skip all updates during death sequence
                    if (e.deathSequenceStarted) {
                        // Keep boss visible but frozen during death animation
                        if (e.flash > 0) e.flash -= scaledDt/16;
                        // Boss will be drawn normally but won't move or attack
                        return true; // CRITICAL: Must return true to keep boss in array during death sequence
                    }
                    
                    // Update phase based on HP with transition tracking
                    const hpPercent = e.hp / e.maxHp;
                    const oldPhase = e.phase;
                    if (hpPercent > 0.75) e.phase = 1;
                    else if (hpPercent > 0.50) e.phase = 2;
                    else if (hpPercent > 0.25) e.phase = 3;
                    else e.phase = 4;
                    
                    // Log phase transitions and clear any active attack intervals
                    if (oldPhase !== e.phase) {
                        console.log(`üîÑ PHASE TRANSITION: ${oldPhase} ‚Üí ${e.phase} (HP: ${(hpPercent * 100).toFixed(1)}%)`);
                        console.log(`Active intervals/timeouts may cause lag - clearing laser warnings`);
                        
                        // Clear laser warnings on phase transition to prevent stacking
                        if (e.laserWarning) {
                            e.laserWarning.active = false;
                            e.laserWarning = null;
                        }
                    }
                    
                    // Slow drift with directional variation based on player position
                    const dx = player.x - e.x;
                    const dy = player.y - e.y;
                    const distToPlayer = Math.sqrt(dx * dx + dy * dy);
                    
                    // SAFETY: Only update movement if we have valid values
                    if (!isNaN(distToPlayer) && distToPlayer > 0.1) {
                        const targetDist = 300; // Preferred distance
                        
                        // Determine which side player is on (for orbit direction)
                        const angleToPlayer = Math.atan2(dy, dx);
                        
                        // Slow drift toward/away from target distance
                        if (distToPlayer > targetDist + 50) {
                            // Too far - drift closer
                            e.vx += (dx / distToPlayer) * 0.02;
                            e.vy += (dy / distToPlayer) * 0.02;
                        } else if (distToPlayer < targetDist - 50) {
                            // Too close - drift away
                            e.vx -= (dx / distToPlayer) * 0.02;
                            e.vy -= (dy / distToPlayer) * 0.02;
                        }
                        
                        // Gentle perpendicular drift (changes based on player angle)
                        const perpX = -dy / distToPlayer;
                        const perpY = dx / distToPlayer;
                        // Vary direction based on player's relative position
                        const driftDir = Math.sin(angleToPlayer * 2); // Changes orbit direction
                        e.vx += perpX * driftDir * 0.05;
                        e.vy += perpY * driftDir * 0.05;
                    }
                    
                    // Slow random drift
                    if (Math.random() < 0.03) {
                        e.vx += (Math.random() - 0.5) * 0.1;
                        e.vy += (Math.random() - 0.5) * 0.1;
                    }
                    
                    // Strong drag for slow, smooth movement
                    e.vx *= 0.92;
                    e.vy *= 0.92;
                    
                    // Lower max speed for slow drift
                    const speed = Math.sqrt(e.vx * e.vx + e.vy * e.vy);
                    const maxSpeed = 0.8; // Much slower (was 2.0)
                    if (speed > maxSpeed) {
                        e.vx = (e.vx / speed) * maxSpeed;
                        e.vy = (e.vy / speed) * maxSpeed;
                    }
                    
                    // SAFETY: Validate velocity before applying
                    if (isNaN(e.vx)) e.vx = 0;
                    if (isNaN(e.vy)) e.vy = 0;
                    
                    e.x += e.vx * (scaledDt/16);
                    e.y += e.vy * (scaledDt/16);
                    
                    // SAFETY: Validate position after update
                    if (isNaN(e.x)) {
                        console.error(`üö® Boss X became NaN! Resetting to center. vx=${e.vx}, scaledDt=${scaledDt}`);
                        e.x = width / 2;
                        e.vx = 0;
                    }
                    if (isNaN(e.y)) {
                        console.error(`üö® Boss Y became NaN! Resetting to center. vy=${e.vy}, scaledDt=${scaledDt}`);
                        e.y = height / 2;
                        e.vy = 0;
                    }
                    
                    // Boss movement updates are done above - no clamping needed
                    // (Boss stays near player naturally via drift mechanics)
                    
                    e.coreRotation += 0.02 * (scaledDt/16);
                    
                    // Update shields
                    if (e.shields && e.shields.length > 0) {
                        e.shields.forEach(shield => {
                            shield.angle += 0.01 * (scaledDt/16);
                            if (shield.flash > 0) shield.flash -= scaledDt/16;
                            
                            // Countdown spawn invulnerability
                            if (shield.spawnInvuln > 0) {
                                shield.spawnInvuln -= scaledDt/16;
                            }
                            
                            // Update shield entity position for targeting
                            shield.x = e.x + Math.cos(shield.angle) * shield.orbitRadius;
                            shield.y = e.y + Math.sin(shield.angle) * shield.orbitRadius;
                            
                            // Shield collision damage (only if shield is alive)
                            if (shield.hp > 0 && player.invulnTimer <= 0) {
                                const dx = shield.x - player.x;
                                const dy = shield.y - player.y;
                                const dist = Math.sqrt(dx * dx + dy * dy);
                                if (dist < shield.radius + player.radius) {
                                    player.takeHit(35, 'Shield Collision', 'NEXUS PRIME');
                                }
                            }
                        });
                    }
                    
                    // Check shield status (only when not already vulnerable and not regenerating)
                    if (!e.coreVulnerable && e.shieldsActive && !e.isRegeneratingShields) {
                        const activeShields = e.shields.filter(s => s.hp > 0).length;
                        if (activeShields === 0) {
                            e.coreVulnerable = true;
                            e.shieldsActive = false;
                            e.vulnerabilityTimer = 900; // 15 seconds
                        }
                    }
                    
                    // Vulnerability timer
                    if (e.coreVulnerable) {
                        e.vulnerabilityTimer -= scaledDt/16;
                        
                        // Log every second
                        if (Math.floor(e.vulnerabilityTimer / 60) !== Math.floor((e.vulnerabilityTimer + scaledDt/16) / 60)) {
                        }
                        
                        if (e.vulnerabilityTimer <= 0) {
                            console.log(`Boss position: x=${e.x}, y=${e.y}`);
                            console.log(`Boss shields array:`, e.shields.map(s => ({hp: s.hp, alive: s.hp > 0})));
                            console.log(`Shields in entities.enemies:`, entities.enemies.filter(en => en.isBossShield).map(s => ({hp: s.hp})));
                            
                            e.coreVulnerable = false;
                            e.shieldsActive = false; // Keep false during regeneration
                            e.isRegeneratingShields = true; // Flag to block shield check
                            
                            // Remove ALL old shields from both arrays
                            const beforeCount = entities.enemies.length;
                            entities.enemies = entities.enemies.filter(en => !en.isBossShield);
                            
                            // Clear boss shields array
                            e.shields = [];
                            
                            // FORCE RETARGET: Clear ALL targeting systems
                            
                            let turretsCleared = 0;
                            let dronesCleared = 0;
                            
                            try {
                                // Clear player turret targets
                                if (player.turrets) {
                                    player.turrets.forEach(t => {
                                        if (t) {
                                            t.target = null;
                                            t.lockedTarget = null;
                                            turretsCleared++;
                                        }
                                    });
                                }
                            } catch (e) {
                                console.error('‚ùå Error clearing turret targets:', e);
                            }
                            
                            try {
                                // Clear combat drone targets
                                if (player.combatDrones) {
                                    player.combatDrones.forEach(d => {
                                        if (d) {
                                            d.target = null;
                                            dronesCleared++;
                                        }
                                    });
                                }
                            } catch (e) {
                                console.error('‚ùå Error clearing drone targets:', e);
                            }
                            
                            // Note: Projectiles don't need clearing - they're fire-and-forget
                            // and will naturally hit shields due to priority targeting
                            
                            for (let i = 0; i < 4; i++) {
                                const shield = {
                                    index: i,
                                    angle: (Math.PI * 2 / 4) * i,
                                    orbitRadius: 140, // Reduced from 200
                                    maxHp: 5000,
                                    hp: 5000,
                                    radius: 22, // Reduced from 30
                                    flash: 0,
                                    spawnInvuln: 120, // 2 seconds spawn protection for shields
                                    hasExploded: false, // Flag for one-time explosion
                                    targetPriority: 10, // Highest priority - weapons should target shields first
                                    // Make shields targetable entities again
                                    x: e.x + Math.cos((Math.PI * 2 / 4) * i) * 200,
                                    y: e.y + Math.sin((Math.PI * 2 / 4) * i) * 200,
                                    type: 'boss_shield',
                                    isBossShield: true,
                                    parentBoss: e,
                                    active: true,
                                    vx: 0,
                                    vy: 0,
                                    cryoState: { 
                                        slowed: false,
                                        slowDuration: 0,
                                        frozen: false,
                                        frozenTimer: 0
                                    },
                                    pyroState: { active: false, timer: 0, level: 0, baseDmg: 0 },
                                    bioState: { active: false, timer: 0, level: 0, maxDmg: 0, jumpCount: 0 },
                                    hackState: { active: false, timer: 0 },
                                    empState: { active: false, timer: 0 },
                                    ionState: { active: false, timer: 0 },
                                    empSlowStacks: 0,
                                    update() { /* Updated in boss logic */ },
                                    draw() { /* Drawn with boss */ },
                                    // Add takeDamage method so ultimates can damage shields
                                    takeDamage(amt, color = '#ffffff', isCrit = false, type = 'normal', sourceId = null, elementType = null) {
                                        // Shields are simple - just take damage and flash
                                        this.hp -= amt;
                                        this.flash = 5;
                                        
                                        // Create damage text
                                        if (amt >= 1 || type === 'dot') {
                                            entities.texts.push(new FloatingText(this.x, this.y - 20, Math.ceil(amt), color, isCrit, type, sourceId, elementType));
                                        }
                                        
                                        // Shields don't have death logic - handled by boss system
                                    }
                                };
                                e.shields.push(shield);
                                // Don't add to entities during filter - will add after
                            }
                            
                            // Flag that we need to add shields after filter completes
                            e.needsToAddShields = true;
                            const afterCount = entities.enemies.length;
                            console.log(`‚úÖ Shield check: ${entities.enemies.filter(en => en.isBossShield && en.hp > 0).length} alive shields in entities array`);
                            
                            // DEBUG: Log detailed shield info
                            entities.enemies.filter(en => en.isBossShield).forEach((s, i) => {
                                console.log(`Shield ${i}: hp=${s.hp}, spawnInvuln=${s.spawnInvuln}, type=${s.type}, isBossShield=${s.isBossShield}, x=${s.x.toFixed(0)}, y=${s.y.toFixed(0)}`);
                            });
                            
                            // Re-enable shields after regeneration complete
                            e.shieldsActive = true;
                            e.isRegeneratingShields = false;
                        }
                    }
                    
                    // Track turret spawn timing but don't spawn yet (will spawn after filter)
                    e.turretSpawnTimer -= scaledDt/16;
                    if (e.turretSpawnTimer <= 0) {
                        e.needsToSpawnTurrets = true; // Flag for after filter
                        // Keep Phase 2 spawn rate (5s) for Phase 3 and 4 to avoid overwhelming player
                        const spawnRate = [360, 300, 300, 300][e.phase - 1]; // Phase 1: 6s, Phase 2/3/4: 5s
                        e.turretSpawnTimer = spawnRate;
                    }
                    
                    // Attack patterns
                    e.attackTimer -= scaledDt/16;
                    if (e.attackTimer <= 0) {
                        executeBossAttack(e);
                        // Phase-based cooldowns: Phase 3 = 4s, Phase 4 = 3s, others = 5s
                        if (e.phase === 4) {
                            e.attackTimer = 180; // 3s - fastest
                        } else if (e.phase === 3) {
                            e.attackTimer = 240; // 4s - constant pressure
                        } else {
                            e.attackTimer = 300; // 5s - phases 1 and 2
                        }
                    }
                    
                    // Laser warning countdown and sweep
                    if (e.laserWarning && e.laserWarning.active) {
                        e.laserWarning.timer -= scaledDt/16;
                        
                        // Transition from warning to active phase
                        if (e.laserWarning.timer > e.laserWarning.activeTime) {
                            e.laserWarning.phase = 'warning';
                        } else {
                            e.laserWarning.phase = 'active';
                        }
                        
                        // During active phase, sweep toward player
                        if (e.laserWarning.phase === 'active') {
                            // Calculate angle to player
                            const dx = player.x - e.x;
                            const dy = player.y - e.y;
                            e.laserWarning.targetAngle = Math.atan2(dy, dx);
                            
                            // Calculate angle difference (shortest path)
                            let angleDiff = e.laserWarning.targetAngle - e.laserWarning.angle;
                            if (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
                            if (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;
                            
                            // Rotate toward player with slight lag (95% pursuit)
                            // This means player can BARELY outrun it with good movement
                            const rotationAmount = Math.sign(angleDiff) * Math.min(Math.abs(angleDiff), e.laserWarning.sweepSpeed * (scaledDt/16));
                            e.laserWarning.angle += rotationAmount * 0.95; // 95% tracking, not 100%
                            
                            // Damage player if they're in the beam
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            const playerAngle = Math.atan2(dy, dx);
                            
                            let playerAngleDiff = Math.abs(playerAngle - e.laserWarning.angle);
                            if (playerAngleDiff > Math.PI) playerAngleDiff = 2 * Math.PI - playerAngleDiff;
                            
                            // Hit player if in beam (narrower cone than warning)
                            if (dist < 600 && playerAngleDiff < 0.15 && player.invulnTimer <= 0) {
                                player.takeHit(35, 'Turret Laser', 'NEXUS TURRET');
                                createExplosion(player.x, player.y, '#ff0000', 15);
                            }
                        }
                        
                        // End laser after duration
                        if (e.laserWarning.timer <= 0) e.laserWarning = null;
                    }
                    
                    // Draw boss
                    ctx.save();
                    ctx.translate(e.x, e.y);
                    
                    const colors = ['#00d1b2', '#ff8800', '#ff0000', '#a855f7'];
                    const phaseColor = colors[e.phase - 1];
                    
                    // Shield immune indicator
                    if (e.shieldsActive && !e.coreVulnerable) {
                        const pulseAlpha = 0.3 + Math.sin(state.frameCount * 0.1) * 0.2;
                        ctx.fillStyle = `rgba(0, 200, 255, ${pulseAlpha})`;
                        ctx.shadowBlur = 30;
                        ctx.shadowColor = '#00c8ff';
                        ctx.beginPath();
                        ctx.arc(0, 0, e.radius + 20, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    
                    // Cross laser warning (only for cross_laser attack, not tracking_laser)
                    if (e.laserWarning && !e.laserWarning.active && e.laserWarning.timer) {
                        const alpha = e.laserWarning.timer / 90;
                        const laserAngles = [0, Math.PI/2, Math.PI, -Math.PI/2];
                        ctx.strokeStyle = `rgba(255, 0, 0, ${alpha * 0.5})`;
                        ctx.lineWidth = 40;
                        ctx.shadowBlur = 20;
                        ctx.shadowColor = '#ff0000';
                        laserAngles.forEach(angle => {
                            ctx.beginPath();
                            ctx.moveTo(0, 0);
                            ctx.lineTo(Math.cos(angle) * 1000, Math.sin(angle) * 1000);
                            ctx.stroke();
                        });
                    }
                    
                    ctx.shadowBlur = 0;
                    
                    // Core hexagon
                    ctx.save();
                    ctx.rotate(e.coreRotation);
                    ctx.fillStyle = '#1a1a2e';
                    ctx.strokeStyle = phaseColor;
                    ctx.lineWidth = 4;
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = phaseColor;
                    ctx.beginPath();
                    for (let i = 0; i < 6; i++) {
                        const angle = (Math.PI / 3) * i;
                        const x = Math.cos(angle) * e.radius;
                        const y = Math.sin(angle) * e.radius;
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                    
                    // Pulsing core
                    const pulse = 0.6 + Math.sin(state.frameCount * 0.05) * 0.4;
                    const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, e.radius * 0.6);
                    gradient.addColorStop(0, `rgba(255, 255, 255, ${pulse})`);
                    gradient.addColorStop(0.5, phaseColor);
                    gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(0, 0, e.radius * 0.6, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                    
                    // Draw shields
                    if (e.shields && e.shields.length > 0) {
                        e.shields.forEach(shield => {
                            if (shield.hp <= 0) return;
                            const sx = Math.cos(shield.angle) * shield.orbitRadius;
                            const sy = Math.sin(shield.angle) * shield.orbitRadius;
                            
                            // Spawn invuln visual
                            if (shield.spawnInvuln > 0) {
                                const invulnAlpha = 0.4 + Math.sin(state.frameCount * 0.3) * 0.3;
                                ctx.fillStyle = `rgba(0, 200, 255, ${invulnAlpha})`;
                                ctx.shadowBlur = 25;
                                ctx.shadowColor = '#00c8ff';
                                ctx.beginPath();
                                ctx.arc(sx, sy, shield.radius + 15, 0, Math.PI * 2);
                                ctx.fill();
                            }
                            
                            const alpha = shield.flash > 0 ? 0.8 : 0.5;
                            ctx.fillStyle = `rgba(0, 209, 178, ${alpha})`;
                            ctx.shadowBlur = 15;
                            ctx.shadowColor = '#00d1b2';
                            ctx.beginPath();
                            ctx.arc(sx, sy, shield.radius, 0, Math.PI * 2);
                            ctx.fill();
                            
                            ctx.fillStyle = '#ffffff';
                            ctx.beginPath();
                            ctx.arc(sx, sy, shield.radius * 0.5, 0, Math.PI * 2);
                            ctx.fill();
                        });
                    }
                    
                    // Draw laser warning/active beam
                    if (e.laserWarning && e.laserWarning.active) {
                        if (e.laserWarning.phase === 'warning') {
                            // Warning phase - fat red zone with pulsing
                            const pulseAlpha = 0.3 + Math.sin(state.frameCount * 0.2) * 0.15;
                            
                            // Fat translucent line showing danger zone
                            ctx.strokeStyle = `rgba(255, 0, 0, ${pulseAlpha})`;
                            ctx.lineWidth = 40; // Fat warning zone
                            ctx.shadowBlur = 20;
                            ctx.shadowColor = '#ff0000';
                            ctx.lineCap = 'round';
                            ctx.beginPath();
                            ctx.moveTo(0, 0);
                            ctx.lineTo(Math.cos(e.laserWarning.angle) * 700, Math.sin(e.laserWarning.angle) * 700);
                            ctx.stroke();
                            
                            // Pulsing outline
                            ctx.strokeStyle = `rgba(255, 100, 100, ${pulseAlpha * 1.5})`;
                            ctx.lineWidth = 45;
                            ctx.beginPath();
                            ctx.moveTo(0, 0);
                            ctx.lineTo(Math.cos(e.laserWarning.angle) * 700, Math.sin(e.laserWarning.angle) * 700);
                            ctx.stroke();
                        } else {
                            // Active phase - narrow bright beam
                            const pulseAlpha = 0.6 + Math.sin(state.frameCount * 0.15) * 0.2;
                            
                            // Outer glow
                            ctx.strokeStyle = `rgba(255, 0, 0, ${pulseAlpha * 0.5})`;
                            ctx.lineWidth = 20;
                            ctx.shadowBlur = 30;
                            ctx.shadowColor = '#ff0000';
                            ctx.lineCap = 'round';
                            ctx.beginPath();
                            ctx.moveTo(0, 0);
                            ctx.lineTo(Math.cos(e.laserWarning.angle) * 700, Math.sin(e.laserWarning.angle) * 700);
                            ctx.stroke();
                            
                            // Main beam
                            ctx.strokeStyle = `rgba(255, 50, 50, ${pulseAlpha})`;
                            ctx.lineWidth = 12;
                            ctx.shadowBlur = 20;
                            ctx.beginPath();
                            ctx.moveTo(0, 0);
                            ctx.lineTo(Math.cos(e.laserWarning.angle) * 700, Math.sin(e.laserWarning.angle) * 700);
                            ctx.stroke();
                            
                            // Inner bright core
                            ctx.strokeStyle = `rgba(255, 200, 200, ${pulseAlpha})`;
                            ctx.lineWidth = 4;
                            ctx.beginPath();
                            ctx.moveTo(0, 0);
                            ctx.lineTo(Math.cos(e.laserWarning.angle) * 700, Math.sin(e.laserWarning.angle) * 700);
                            ctx.stroke();
                        }
                    }
                    
                    
                    ctx.shadowBlur = 0;
                    ctx.restore();
                    
                    // Update health bar
                    updateBossHealthBar();
                    
                    // Death sequence is handled in the enemy update loop below
                    // Don't immediately trigger victory here - let the death animation play
                }
                
                // Boss Turret handling
                if (e.isBossTurret) {
                    // CRITICAL SAFETY: Validate turret coordinates
                    if (e.x === null || e.x === undefined || e.y === null || e.y === undefined || isNaN(e.x) || isNaN(e.y)) {
                        console.error(`üö® CRITICAL BUG: Boss turret has invalid coordinates! x=${e.x}, y=${e.y}, hp=${e.hp}`);
                        return false; // Remove invalid turret
                    }
                    
                    // Spawn invulnerability countdown
                    if (e.spawnInvuln > 0) {
                        e.spawnInvuln -= scaledDt/16;
                    }
                    
                    // Despawn timer
                    if (e.despawnTimer) {
                        e.despawnTimer -= scaledDt/16;
                        if (e.despawnTimer <= 0) {
                            e.hp = 0; // Despawn
                            createExplosion(e.x, e.y, '#ff8800', 15);
                        }
                    }
                    
                    e.fireTimer -= scaledDt/16;
                    if (e.fireTimer <= 0 && state.finalBossActive) {
                        const angle = Math.atan2(player.y - e.y, player.x - e.x);
                        entities.enemyProjectiles.push({
                            x: e.x,
                            y: e.y,
                            vx: Math.cos(angle) * 4,
                            vy: Math.sin(angle) * 4,
                            life: 180,
                            dmg: 10,
                            radius: 4,
                            color: '#00a8ff', // Blue bullets for boss turrets
                            type: 'boss_turret'
                        });
                        e.fireTimer = 60;
                    }
                    
                    if (e.flash > 0) e.flash -= scaledDt/16;
                    
                    // Draw turret (blue theme)
                    ctx.save();
                    ctx.translate(e.x, e.y);
                    
                    // Spawn invuln visual - blue shield
                    if (e.spawnInvuln > 0) {
                        const alpha = 0.3 + Math.sin(state.frameCount * 0.3) * 0.2;
                        ctx.fillStyle = `rgba(0, 200, 255, ${alpha})`;
                        ctx.shadowBlur = 15;
                        ctx.shadowColor = '#00c8ff';
                        ctx.beginPath();
                        ctx.arc(0, 0, e.radius + 8, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    
                    const flashColor = e.flash > 0 ? '#ffffff' : '#00a8ff'; // Blue when not flashing
                    ctx.fillStyle = '#1a2744'; // Dark blue base
                    ctx.strokeStyle = flashColor;
                    ctx.lineWidth = 2;
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = flashColor;
                    ctx.beginPath();
                    for (let i = 0; i < 6; i++) {
                        const angle = (Math.PI / 3) * i;
                        const x = Math.cos(angle) * e.radius;
                        const y = Math.sin(angle) * e.radius;
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                    
                    const barrelAngle = Math.atan2(player.y - e.y, player.x - e.x);
                    ctx.rotate(barrelAngle);
                    ctx.fillStyle = flashColor;
                    ctx.fillRect(-2, -2, e.radius, 4);
                    ctx.shadowBlur = 0;
                    ctx.restore();
                    
                    return e.hp > 0;
                }
                
                // Safety check before update - skip if no update method or missing properties
                if (!e.update || e.isBossShield || e.isNexusPrime || e.isBossTurret) {
                    // Log if champion is missing update method (this is the bug!)
                    if (e.isChampion && !e.update) {
                        console.error(`üêõ BUG: Champion ${e.championId} has no update method! Removing from game.`);
                        
                        // CRITICAL: Clean up health bar before removing
                        if (e.championId) {
                            const titanIndex = parseInt(e.championId.split('_')[1]);
                            const barWrapper = document.getElementById(`boss-bar-wrapper-${titanIndex}`);
                            if (barWrapper) {
                                barWrapper.remove();
                                console.log(`üóëÔ∏è Removed orphaned health bar for ${e.championId} (no update method)`);
                            }
                        }
                        
                        return false; // Remove this broken champion
                    }
                    
                    // NEXUS PRIME DEATH SEQUENCE
                    if (e.isNexusPrime && e.hp <= 0 && !e.deathSequenceStarted) {
                        e.deathSequenceStarted = true;
                        e.deathTimer = 0; // Track death animation progress
                        console.log('üí• NEXUS PRIME DEFEATED - Starting EPIC death sequence');
                        
                        // Store position for death animation
                        const deathX = e.x;
                        const deathY = e.y;
                        
                        // Add screen flash data to boss entity for rendering
                        e.deathFlash = 0;
                        
                        // STAGE 1: Initial implosion (0ms)
                        createExplosion(deathX, deathY, '#ff00ff', 150);
                        entities.particles.push(new Shockwave(deathX, deathY, 400, '#ff00ff'));
                        e.deathFlash = 1.0;
                        
                        // STAGE 2: First massive shockwave (400ms)
                        setTimeout(() => {
                            entities.particles.push(new Shockwave(deathX, deathY, 800, '#00d1b2'));
                            entities.particles.push(new Shockwave(deathX, deathY, 700, '#ffffff'));
                            createExplosion(deathX, deathY, '#00d1b2', 200);
                            e.deathFlash = 0.8;
                            state.shake = 8;
                        }, 400);
                        
                        // STAGE 3: Energy collapse rings (800ms)
                        setTimeout(() => {
                            for (let i = 0; i < 5; i++) {
                                setTimeout(() => {
                                    entities.particles.push(new Shockwave(deathX, deathY, 600 - i * 100, '#ff5722'));
                                }, i * 80);
                            }
                            createExplosion(deathX, deathY, '#ff5722', 180);
                            e.deathFlash = 0.6;
                            state.shake = 10;
                        }, 800);
                        
                        // STAGE 4: Cascading explosions (1200ms)
                        setTimeout(() => {
                            const angles = [0, Math.PI/3, 2*Math.PI/3, Math.PI, 4*Math.PI/3, 5*Math.PI/3];
                            angles.forEach((angle, i) => {
                                setTimeout(() => {
                                    const offsetX = deathX + Math.cos(angle) * 150;
                                    const offsetY = deathY + Math.sin(angle) * 150;
                                    entities.particles.push(new Shockwave(offsetX, offsetY, 500, '#ffeb3b'));
                                    createExplosion(offsetX, offsetY, '#ffeb3b', 120);
                                }, i * 100);
                            });
                            e.deathFlash = 0.5;
                            state.shake = 12;
                        }, 1200);
                        
                        // STAGE 5: Converging energy waves (1800ms)
                        setTimeout(() => {
                            entities.particles.push(new Shockwave(deathX, deathY, 900, '#00e5ff'));
                            entities.particles.push(new Shockwave(deathX, deathY, 850, '#ffffff'));
                            entities.particles.push(new Shockwave(deathX, deathY, 800, '#00e5ff'));
                            createExplosion(deathX, deathY, '#00e5ff', 220);
                            e.deathFlash = 0.7;
                            state.shake = 15;
                        }, 1800);
                        
                        // STAGE 6: Pre-supernova buildup (2200ms)
                        setTimeout(() => {
                            // Rapid pulse of expanding rings
                            for (let i = 0; i < 8; i++) {
                                setTimeout(() => {
                                    entities.particles.push(new Shockwave(deathX, deathY, 300 + i * 100, '#39ff14'));
                                }, i * 60);
                            }
                            e.deathFlash = 0.9;
                            state.shake = 18;
                        }, 2200);
                        
                        // STAGE 7: MASSIVE SUPERNOVA (2800ms)
                        setTimeout(() => {
                            // Screen-filling white flash
                            e.deathFlash = 1.5;
                            
                            // Multiple overlapping giant shockwaves
                            entities.particles.push(new Shockwave(deathX, deathY, 1200, '#ffffff'));
                            entities.particles.push(new Shockwave(deathX, deathY, 1100, '#ff00ff'));
                            entities.particles.push(new Shockwave(deathX, deathY, 1000, '#00d1b2'));
                            entities.particles.push(new Shockwave(deathX, deathY, 900, '#ffeb3b'));
                            
                            // Massive central explosion
                            createExplosion(deathX, deathY, '#ffffff', 300);
                            
                            // Ring of secondary shockwaves
                            const ringAngles = [0, Math.PI/4, Math.PI/2, 3*Math.PI/4, Math.PI, 5*Math.PI/4, 3*Math.PI/2, 7*Math.PI/4];
                            ringAngles.forEach((angle, i) => {
                                setTimeout(() => {
                                    const rx = deathX + Math.cos(angle) * 200;
                                    const ry = deathY + Math.sin(angle) * 200;
                                    entities.particles.push(new Shockwave(rx, ry, 600, '#ffffff'));
                                    createExplosion(rx, ry, '#ffffff', 150);
                                }, i * 50);
                            });
                            
                            state.shake = 25;
                        }, 2800);
                        
                        // STAGE 8: Aftermath fade (3200ms)
                        setTimeout(() => {
                            entities.particles.push(new Shockwave(deathX, deathY, 1000, '#ff00ff'));
                            entities.particles.push(new Shockwave(deathX, deathY, 900, '#ffffff'));
                            e.deathFlash = 0.4;
                            state.shake = 10;
                        }, 3200);
                        
                        // FINAL: Cleanup and victory (3800ms)
                        setTimeout(() => {
                            e.deathFlash = 0;
                            
                            // Clear all boss entities
                            entities.enemies = entities.enemies.filter(en => 
                                !en.isNexusPrime && !en.isBossShield && !en.isBossTurret
                            );
                            
                            // Drop Quantum Singularity at boss location
                            entities.pickups.push(new Pickup(deathX, deathY, 1, 'singularity'));
                            
                            // Victory - boss defeated, no more enemy spawns
                            state.finalBossActive = false;
                            state.finalBossDefeated = true;
                        }, 3800);
                    }
                    
                    // Keep boss "alive" during death sequence so it stays in array for animations
                    if (e.isNexusPrime && e.deathSequenceStarted) {
                        return true; // Keep in array even with hp <= 0
                    }
                    
                    // EXPLICIT CLEANUP: Remove dead boss shields and turrets immediately
                    if ((e.isBossShield || e.isBossTurret) && e.hp <= 0) {
                        return false; // Remove from array
                    }
                    
                    return e.hp > 0;
                }
                
                // Extra safety check for champions
                if (e.isChampion && (!e.update || typeof e.update !== 'function')) {
                    console.error(`üêõ BUG: Champion ${e.championId} lost its update method! hp=${e.hp}, x=${e.x}, y=${e.y}`);
                    console.error('Champion state:', { isChampion: e.isChampion, hasUpdate: !!e.update, hp: e.hp });
                    
                    // CRITICAL: Clean up health bar before removing
                    if (e.championId) {
                        const titanIndex = parseInt(e.championId.split('_')[1]);
                        const barWrapper = document.getElementById(`boss-bar-wrapper-${titanIndex}`);
                        if (barWrapper) {
                            barWrapper.remove();
                            console.log(`üóëÔ∏è Removed orphaned health bar for ${e.championId}`);
                        }
                    }
                    
                    return false; // Remove broken champion
                }
                
                // Separate try-catch for update and draw to identify which fails
                try {
                    // Fleeing enemies: Don't call update() - manually handle animation
                    if (e.fleeing) {
                        // Increment animation tick slower for normal spinning speed
                        if (e.animTick !== undefined) {
                            e.animTick += (scaledDt / 16) * 0.3; // 30% of normal speed
                        }
                        // Don't call e.update() - it might override position/velocity
                    } else {
                        e.update(scaledDt);
                    }
                } catch (updateErr) {
                    const errorDetails = {
                        phase: 'UPDATE',
                        name: updateErr.name || 'Unknown',
                        message: updateErr.message || 'No message',
                        stack: updateErr.stack || 'No stack trace',
                        enemyType: e.type,
                        enemyHP: e.hp,
                        isChampion: e.isChampion,
                        championId: e.championId,
                        hasUpdate: !!e.update,
                        updateType: typeof e.update,
                        attackState: e.attackState,
                        actionState: e.actionState
                    };
                    console.error('Error during enemy UPDATE:', JSON.stringify(errorDetails, null, 2));
                    
                    if (e.isChampion) {
                        console.error(`üêõ Champion ${e.championId} crashed during UPDATE!`);
                        console.error(`Error: ${updateErr.name}: ${updateErr.message}`);
                        
                        // Clean up health bar
                        if (e.championId) {
                            const titanIndex = parseInt(e.championId.split('_')[1]);
                            const barWrapper = document.getElementById(`boss-bar-wrapper-${titanIndex}`);
                            if (barWrapper) {
                                barWrapper.remove();
                                console.log(`üóëÔ∏è Removed orphaned health bar for ${e.championId} (update crash)`);
                            }
                        }
                        
                        return false; // Remove crashed champion
                    }
                }
                
                try {
                    // Apply opacity for fleeing enemies
                    if (e.fleeing && e.fleeingOpacity !== undefined) {
                        // Log first few draws
                        if (!e.drawLogCount) e.drawLogCount = 0;
                        if (e.drawLogCount < 3) {
                            e.drawLogCount++;
                        }
                        ctx.save();
                        ctx.globalAlpha = e.fleeingOpacity;
                        e.draw(ctx);
                        ctx.restore();
                    } else {
                        e.draw(ctx);
                    }
                } catch (drawErr) {
                    const errorDetails = {
                        phase: 'DRAW',
                        name: drawErr.name || 'Unknown',
                        message: drawErr.message || 'No message',
                        stack: drawErr.stack || 'No stack trace',
                        enemyType: e.type,
                        enemyHP: e.hp,
                        isChampion: e.isChampion,
                        championId: e.championId,
                        hasDraw: !!e.draw,
                        drawType: typeof e.draw
                    };
                    console.error('Error during enemy DRAW:', JSON.stringify(errorDetails, null, 2));
                    
                    if (e.isChampion) {
                        console.error(`üêõ Champion ${e.championId} crashed during DRAW!`);
                        console.error(`Error: ${drawErr.name}: ${drawErr.message}`);
                        
                        // Clean up health bar
                        if (e.championId) {
                            const titanIndex = parseInt(e.championId.split('_')[1]);
                            const barWrapper = document.getElementById(`boss-bar-wrapper-${titanIndex}`);
                            if (barWrapper) {
                                barWrapper.remove();
                                console.log(`üóëÔ∏è Removed orphaned health bar for ${e.championId} (draw crash)`);
                            }
                        }
                        
                        return false; // Remove crashed champion
                    }
                }
                return e.hp>0; 
            });
            
            // Spawn boss turrets AFTER filter (can't modify array during iteration)
            if (state.finalBoss && state.finalBoss.needsToSpawnTurrets) {
                spawnBossTurret(state.finalBoss);
                state.finalBoss.needsToSpawnTurrets = false;
            }
            
            // Add regenerated shields AFTER filter (can't modify array during iteration)
            if (state.finalBoss && state.finalBoss.needsToAddShields) {
                state.finalBoss.shields.forEach(shield => {
                    entities.enemies.push(shield);
                });
                state.finalBoss.needsToAddShields = false;
            }
            
            // SAFETY: Ensure shields are always in entities.enemies if they should be
            if (state.finalBoss && state.finalBoss.shields && state.finalBoss.shieldsActive) {
                const shieldsInEntities = entities.enemies.filter(e => e.isBossShield);
                const shieldsInBoss = state.finalBoss.shields.filter(s => s.hp > 0);
                
                // If we're missing shields, add them back
                if (shieldsInBoss.length > shieldsInEntities.length) {
                    console.error(`üö® SHIELD DESYNC: Boss has ${shieldsInBoss.length} shields but entities has ${shieldsInEntities.length}! Re-adding missing shields...`);
                    shieldsInBoss.forEach(shield => {
                        // Check if shield is already in entities
                        if (!entities.enemies.some(e => e === shield)) {
                            entities.enemies.push(shield);
                            console.log(`  ‚úÖ Re-added missing shield ${shield.index}`);
                        }
                    });
                }
            }
            
            // ‚ö° OPTIMIZED PARTICLE SYSTEM - Uses object pooling to reduce GC pressure
            // Instead of filter (which creates new array), we swap-and-pop for better performance
            for (let i = entities.particles.length - 1; i >= 0; i--) {
                const p = entities.particles[i];
                let keepParticle = false;
                
                // Danger zones from boss attacks
                if (p.isDangerZone) {
                    p.timer -= scaledDt/16;
                    
                    // Check if detonating (timer at 0, explosion phase)
                    if (p.timer <= 0 && !p.exploding) {
                        p.exploding = true;
                        p.explosionTimer = 60; // 1 second explosion visual (was 180)
                        p.hasDealtDamage = false; // Track if we've dealt damage this explosion
                        
                        // Pre-create gradients ONCE for performance (not every frame)
                        const pillarHeight = 250;
                        
                        // Outer glow gradient
                        const outerGrad = ctx.createLinearGradient(0, 0, 0, -pillarHeight);
                        outerGrad.addColorStop(0, `rgba(255, 100, 0, 1)`);
                        outerGrad.addColorStop(0.4, `rgba(255, 120, 0, 0.5)`);
                        outerGrad.addColorStop(0.8, `rgba(255, 80, 0, 0.2)`);
                        outerGrad.addColorStop(1, `rgba(255, 50, 0, 0)`);
                        p.outerGradient = outerGrad;
                        
                        // Inner core gradient
                        const coreGrad = ctx.createLinearGradient(0, 0, 0, -pillarHeight);
                        coreGrad.addColorStop(0, `rgba(255, 255, 255, 1)`);
                        coreGrad.addColorStop(0.5, `rgba(255, 200, 100, 0.7)`);
                        coreGrad.addColorStop(1, `rgba(255, 100, 0, 0)`);
                        p.coreGradient = coreGrad;
                    }
                    
                    if (p.exploding) {
                        // Deal damage once when explosion starts
                        if (!p.hasDealtDamage) {
                            const dx = player.x - p.x;
                            const dy = player.y - p.y;
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            
                            if (dist < p.radius) {
                                player.takeHit(50, 'Danger Zone', 'BOSS');
                                console.log('üí• Danger zone hit!');
                            }
                            p.hasDealtDamage = true;
                            console.log('üî• Danger zone pillar START - will last 3 seconds');
                        }
                        
                        // Draw energy pillar/beam explosion
                        p.explosionTimer -= scaledDt/16;
                        
                        ctx.save();
                        ctx.translate(p.x, p.y);
                        
                        // Longer duration with proper fade
                        const totalTime = 60; // 1 second total (was 180)
                        const progress = 1 - (p.explosionTimer / totalTime);
                        
                        // Strong fade from 1.0 to 0.2 (don't fade to 0, keep visible)
                        const baseAlpha = 1.0 - (progress * 0.8);
                        const pulse = 0.95 + Math.sin(state.frameCount * 0.2) * 0.05;
                        const finalAlpha = Math.max(0.2, baseAlpha * pulse); // Never drop below 0.2
                        
                        const expansionProgress = progress;
                        const baseRadius = p.radius * (1 + expansionProgress * 0.5);
                        
                        // Ground shockwave - smaller and cleaner
                        ctx.strokeStyle = `rgba(255, 80, 0, ${finalAlpha * 0.8})`;
                        ctx.lineWidth = 4;
                        ctx.shadowBlur = 25;
                        ctx.shadowColor = '#ff3300';
                        ctx.beginPath();
                        ctx.arc(0, 0, baseRadius, 0, Math.PI * 2);
                        ctx.stroke();
                        
                        // Inner ring
                        ctx.strokeStyle = `rgba(255, 150, 0, ${finalAlpha * 0.5})`;
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.arc(0, 0, baseRadius * 0.6, 0, Math.PI * 2);
                        ctx.stroke();
                        
                        // SMALLER vertical pillar
                        const pillarHeight = 250; // Reduced from 400
                        const pillarWidth = p.radius * 0.6; // Reduced from 1.5
                        
                        // Use pre-created gradients with alpha multiplier (much faster than recreating)
                        ctx.globalAlpha = finalAlpha * 0.7;
                        ctx.fillStyle = p.outerGradient;
                        ctx.shadowBlur = 30;
                        ctx.shadowColor = '#ff3300';
                        ctx.fillRect(-pillarWidth * 1.2, -pillarHeight, pillarWidth * 2.4, pillarHeight);
                        
                        // Inner core beam - use pre-created gradient
                        ctx.globalAlpha = finalAlpha * 0.9;
                        ctx.fillStyle = p.coreGradient;
                        ctx.shadowBlur = 40;
                        ctx.shadowColor = '#ffaa00';
                        ctx.fillRect(-pillarWidth * 0.5, -pillarHeight, pillarWidth, pillarHeight);
                        ctx.globalAlpha = 1.0; // Reset
                        
                        // Fewer particles for performance
                        ctx.shadowBlur = 15;
                        for (let i = 0; i < 4; i++) { // Reduced from 8
                            const angle = (i / 4) * Math.PI * 2 + (expansionProgress * Math.PI * 4);
                            const spiralRadius = pillarWidth * (1 + expansionProgress * 0.5);
                            const height = -pillarHeight * (i / 4);
                            const px = Math.cos(angle) * spiralRadius;
                            const py = height;
                            
                            ctx.fillStyle = `rgba(255, 200, 100, ${finalAlpha * 0.6})`;
                            ctx.shadowColor = '#ff6600';
                            ctx.beginPath();
                            ctx.arc(px, py, 3, 0, Math.PI * 2);
                            ctx.fill();
                        }
                        
                        ctx.shadowBlur = 0;
                        ctx.restore();
                        
                        keepParticle = p.explosionTimer > 0;
                    } else {
                        // Draw pulsing red circle (telegraph phase)
                        const alpha = (p.timer / 90) * 0.5; // Updated from 120 to 90
                        const pulse = 0.7 + Math.sin(state.frameCount * 0.15) * 0.3;
                        ctx.save();
                        ctx.translate(p.x, p.y);
                        ctx.strokeStyle = `rgba(255, 0, 0, ${alpha * pulse})`;
                        ctx.lineWidth = 3;
                        ctx.shadowBlur = 20;
                        ctx.shadowColor = '#ff0000';
                        ctx.beginPath();
                        ctx.arc(0, 0, p.radius, 0, Math.PI * 2);
                        ctx.stroke();
                        ctx.fillStyle = `rgba(255, 50, 0, ${alpha * 0.3})`;
                        ctx.fill();
                        ctx.shadowBlur = 0;
                        ctx.restore();
                        
                        keepParticle = p.timer > 0;
                    }
                }
                // Falling meteors
                else if (p.isFallingMeteor) {
                    const alive = p.update(scaledDt);
                    if (alive) {
                        p.draw(ctx);
                    }
                    keepParticle = alive;
                }
                // Meteor warning crosshairs
                else if (p.isMeteorWarning) {
                    const alive = p.update();
                    if (alive) {
                        p.draw(ctx);
                    }
                    keepParticle = alive;
                }
                // Standard particles (most common case)
                else {
                    const alive = p.update(scaledDt); 
                    if(alive) {
                        // Cull particles far from player view
                        const dx = Math.abs(p.x - player.x);
                        const dy = Math.abs(p.y - player.y);
                        if(dx < 1500 && dy < 1500) { // Only draw nearby particles
                            p.draw(ctx);
                        }
                    }
                    keepParticle = alive;
                    
                    // ‚ö° POOLING: Recycle standard Particle objects
                    if (!alive && p.constructor.name === 'Particle') {
                        particlePool.recycle(p);
                    }
                }
                
                // Remove dead particles using swap-and-pop (faster than filter/splice)
                if (!keepParticle) {
                    entities.particles[i] = entities.particles[entities.particles.length - 1];
                    entities.particles.pop();
                }
            }
            
            // Hard cap on particle count to prevent performance degradation
            const MAX_PARTICLES = 200; // Reduced from 250 for better performance
            if(entities.particles.length > MAX_PARTICLES) {
                entities.particles = entities.particles.slice(-MAX_PARTICLES);
            }
            
            entities.gasClouds = entities.gasClouds.filter(c => { const a=c.update(scaledDt); if(a) c.draw(ctx); return a; });
            entities.lightnings = entities.lightnings.filter(l => { const a=l.update(scaledDt); if(a) l.draw(ctx); return a; });
            entities.texts = entities.texts.filter(t => { const a=t.update(scaledDt); if(a) t.draw(ctx); return a; });

            // SKYFALL BEAM RENDERING - Ultra-powerful divine annihilation beam
            if (player.ultimateData.skyfallBeam && player.ultimateData.skyfallBeam.active) {
                const beam = player.ultimateData.skyfallBeam;
                
                // Update beam position to target EVERY FRAME (1:1 tracking)
                if (beam.target && beam.target.hp > 0) {
                    beam.x = beam.target.x;
                    beam.y = beam.target.y;
                }
                
                const tickProgress = beam.tickCount / 5; // 0 to 1 over 5 ticks
                const time = state.frameCount * 0.1;
                
                // Multiple pulsing layers for intensity
                const pulse1 = 0.5 + Math.sin(time * 3) * 0.5;
                const pulse2 = 0.5 + Math.sin(time * 2.3) * 0.5;
                const pulse3 = 0.5 + Math.sin(time * 1.7) * 0.5;
                
                // Energy spirals around the beam
                for (let i = 0; i < 6; i++) {
                    const spiralAngle = (time + i * Math.PI / 3) % (Math.PI * 2);
                    const spiralRadius = 30 + tickProgress * 20;
                    const spiralX = beam.x + Math.cos(spiralAngle) * spiralRadius;
                    const spiralY = beam.y + Math.sin(spiralAngle) * spiralRadius;
                    
                    const spiralGradient = ctx.createRadialGradient(spiralX, spiralY, 0, spiralX, spiralY, 15);
                    spiralGradient.addColorStop(0, `rgba(0, 255, 255, ${0.8 * pulse1})`);
                    spiralGradient.addColorStop(0.5, `rgba(0, 200, 255, ${0.4 * pulse1})`);
                    spiralGradient.addColorStop(1, 'rgba(0, 150, 255, 0)');
                    
                    ctx.fillStyle = spiralGradient;
                    ctx.beginPath();
                    ctx.arc(spiralX, spiralY, 15 + tickProgress * 5, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Massive outer glow - divine light from heaven
                const outerWidth = 80 + tickProgress * 60;
                ctx.shadowBlur = 60 + tickProgress * 40;
                ctx.shadowColor = '#00ffff';
                const outerGradient = ctx.createLinearGradient(beam.x - outerWidth, beam.y - 2000, beam.x + outerWidth, beam.y);
                outerGradient.addColorStop(0, 'rgba(0, 150, 255, 0)');
                outerGradient.addColorStop(0.4, `rgba(0, 212, 255, ${0.1 * pulse2})`);
                outerGradient.addColorStop(0.5, `rgba(0, 255, 255, ${0.15 * pulse2})`);
                outerGradient.addColorStop(0.6, `rgba(0, 212, 255, ${0.1 * pulse2})`);
                outerGradient.addColorStop(1, 'rgba(0, 150, 255, 0)');
                ctx.strokeStyle = outerGradient;
                ctx.lineWidth = outerWidth;
                ctx.beginPath();
                ctx.moveTo(beam.x, beam.y - 2000);
                ctx.lineTo(beam.x, beam.y);
                ctx.stroke();
                
                // Mid-layer - intense energy
                const midWidth = 50 + tickProgress * 35;
                ctx.shadowBlur = 40 + tickProgress * 30;
                ctx.shadowColor = '#00ddff';
                ctx.strokeStyle = `rgba(100, 240, 255, ${(0.3 + tickProgress * 0.3) * pulse1})`;
                ctx.lineWidth = midWidth;
                ctx.beginPath();
                ctx.moveTo(beam.x, beam.y - 2000);
                ctx.lineTo(beam.x, beam.y);
                ctx.stroke();
                
                // Lightning-like energy bolts around the beam
                for (let i = 0; i < 8; i++) {
                    const boltAngle = (i / 8) * Math.PI * 2 + time * 2;
                    const boltRadius = 40 + Math.sin(time * 3 + i) * 15;
                    const boltX = beam.x + Math.cos(boltAngle) * boltRadius;
                    
                    ctx.strokeStyle = `rgba(200, 255, 255, ${0.6 * pulse3})`;
                    ctx.lineWidth = 2;
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = '#ffffff';
                    ctx.beginPath();
                    ctx.moveTo(boltX, beam.y - 2000);
                    ctx.lineTo(boltX, beam.y);
                    ctx.stroke();
                }
                
                // Core beam - the soul-melting center
                const coreWidth = 25 + tickProgress * 20;
                ctx.shadowBlur = 30 + tickProgress * 25;
                ctx.shadowColor = '#ffffff';
                const coreGradient = ctx.createLinearGradient(beam.x - coreWidth/2, beam.y - 2000, beam.x + coreWidth/2, beam.y);
                coreGradient.addColorStop(0, 'rgba(255, 255, 255, 0)');
                coreGradient.addColorStop(0.3, `rgba(255, 255, 255, ${0.7 + tickProgress * 0.3})`);
                coreGradient.addColorStop(0.5, `rgba(255, 255, 255, ${0.9 + tickProgress * 0.1})`);
                coreGradient.addColorStop(0.7, `rgba(255, 255, 255, ${0.7 + tickProgress * 0.3})`);
                coreGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                ctx.strokeStyle = coreGradient;
                ctx.lineWidth = coreWidth;
                ctx.beginPath();
                ctx.moveTo(beam.x, beam.y - 2000);
                ctx.lineTo(beam.x, beam.y);
                ctx.stroke();
                
                // Innermost laser - pure white destruction
                ctx.shadowBlur = 20;
                ctx.strokeStyle = `rgba(255, 255, 255, ${0.95 + pulse1 * 0.05})`;
                ctx.lineWidth = 8 + tickProgress * 6;
                ctx.beginPath();
                ctx.moveTo(beam.x, beam.y - 2000);
                ctx.lineTo(beam.x, beam.y);
                ctx.stroke();
                
                // Impact crater - disintegration zone
                const impactSize = 25 + tickProgress * 25 + Math.sin(time * 4) * 8;
                
                // Outer shockwave rings
                for (let ring = 0; ring < 3; ring++) {
                    const ringSize = impactSize + (ring * 15) + Math.sin(time * 2 + ring) * 5;
                    const ringAlpha = (0.5 - ring * 0.15) * pulse2;
                    ctx.strokeStyle = `rgba(0, 255, 255, ${ringAlpha})`;
                    ctx.lineWidth = 4 - ring;
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = '#00ffff';
                    ctx.beginPath();
                    ctx.arc(beam.x, beam.y, ringSize, 0, Math.PI * 2);
                    ctx.stroke();
                }
                
                // Main impact point
                const impactGradient = ctx.createRadialGradient(beam.x, beam.y, 0, beam.x, beam.y, impactSize);
                impactGradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
                impactGradient.addColorStop(0.3, `rgba(200, 255, 255, ${0.9})`);
                impactGradient.addColorStop(0.6, `rgba(0, 255, 255, ${0.6 * pulse1})`);
                impactGradient.addColorStop(1, 'rgba(0, 200, 255, 0)');
                
                ctx.shadowBlur = 40 + tickProgress * 30;
                ctx.shadowColor = '#ffffff';
                ctx.fillStyle = impactGradient;
                ctx.beginPath();
                ctx.arc(beam.x, beam.y, impactSize, 0, Math.PI * 2);
                ctx.fill();
                
                // Disintegration particles flying outward
                for (let p = 0; p < 12; p++) {
                    const particleAngle = (p / 12) * Math.PI * 2 + time;
                    const particleDist = impactSize + 10 + Math.sin(time * 3 + p) * 10;
                    const px = beam.x + Math.cos(particleAngle) * particleDist;
                    const py = beam.y + Math.sin(particleAngle) * particleDist;
                    
                    ctx.fillStyle = `rgba(255, 255, 255, ${0.8 * pulse3})`;
                    ctx.shadowBlur = 8;
                    ctx.beginPath();
                    ctx.arc(px, py, 3 + tickProgress * 2, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Final tick - massive burst
                if (beam.tickCount >= 4) {
                    const burstSize = impactSize + 30 + Math.sin(time * 5) * 10;
                    ctx.strokeStyle = `rgba(255, 255, 100, ${0.7 * pulse1})`;
                    ctx.lineWidth = 5;
                    ctx.shadowBlur = 30;
                    ctx.shadowColor = '#ffff00';
                    ctx.beginPath();
                    ctx.arc(beam.x, beam.y, burstSize, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    ctx.strokeStyle = `rgba(255, 255, 200, ${0.5 * pulse2})`;
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(beam.x, beam.y, burstSize + 15, 0, Math.PI * 2);
                    ctx.stroke();
                }
                
                ctx.shadowBlur = 0;
            }
            
            // EVENT HORIZON RENDERING - Elegant spacetime singularity
            if (player.ultimateData.eventHorizon && player.ultimateData.eventHorizon.active) {
                const horizon = player.ultimateData.eventHorizon;
                const time = state.frameCount * 0.1;
                
                if (horizon.phase === 'pull') {
                    // Slow, elegant build-up
                    const pullProgress = 1 - (horizon.pullTimer / ULTIMATES.event_horizon.pullDuration);
                    const buildUp = Math.min(1, pullProgress * 1.5); // Reaches full intensity at 66% progress
                    const radius = 350 + buildUp * 50; // Grows slowly
                    
                    // Cohesive purple/violet distortion rings (no rainbow)
                    for (let i = 0; i < 5; i++) {
                        const ringRadius = radius - (i * 70);
                        if (ringRadius <= 0) continue;
                        
                        const pulse = Math.sin(time * 1.2 + i * 0.8) * 10;
                        const ringAlpha = (0.35 - i * 0.05) * buildUp;
                        
                        // Shades of purple/violet only
                        const purpleR = 120 + i * 25;
                        const purpleB = 255 - i * 20;
                        
                        ctx.strokeStyle = `rgba(${purpleR}, 20, ${purpleB}, ${ringAlpha})`;
                        ctx.lineWidth = 3 - i * 0.4;
                        ctx.shadowBlur = 15 * buildUp;
                        ctx.shadowColor = `rgba(${purpleR}, 20, ${purpleB}, 0.5)`;
                        ctx.beginPath();
                        ctx.arc(horizon.x, horizon.y, ringRadius + pulse, 0, Math.PI * 2);
                        ctx.stroke();
                    }
                    
                    // Elegant spiral streams flowing inward (fewer, slower)
                    for (let i = 0; i < 8; i++) {
                        const spiralAngle = (time * 1.2 + (i * Math.PI * 2 / 8)) % (Math.PI * 2);
                        const spiralRadius = radius * 0.6 + Math.sin(time + i) * 25;
                        
                        const x1 = horizon.x + Math.cos(spiralAngle) * spiralRadius;
                        const y1 = horizon.y + Math.sin(spiralAngle) * spiralRadius;
                        
                        const streamGradient = ctx.createLinearGradient(x1, y1, horizon.x, horizon.y);
                        streamGradient.addColorStop(0, `rgba(160, 20, 255, 0)`);
                        streamGradient.addColorStop(0.5, `rgba(140, 40, 255, ${0.3 * buildUp})`);
                        streamGradient.addColorStop(1, `rgba(120, 60, 255, ${0.15 * buildUp})`);
                        
                        ctx.strokeStyle = streamGradient;
                        ctx.lineWidth = 2;
                        ctx.shadowBlur = 8 * buildUp;
                        ctx.shadowColor = '#8800ff';
                        ctx.beginPath();
                        ctx.moveTo(x1, y1);
                        ctx.lineTo(horizon.x, horizon.y);
                        ctx.stroke();
                    }
                    
                    // Subtle energy particles being drawn in (purple/white only, MORE VISIBLE)
                    const particleCount = Math.floor(30 * buildUp); // Increased from 20
                    for (let i = 0; i < particleCount; i++) {
                        const particleAngle = (i / 30) * Math.PI * 2 + time * 1.8;
                        const particleDist = 100 + Math.sin(time * 1.3 + i) * 35 - (pullProgress * 45);
                        const px = horizon.x + Math.cos(particleAngle) * particleDist;
                        const py = horizon.y + Math.sin(particleAngle) * particleDist;
                        
                        const particleSize = (2.5 + Math.sin(time * 3 + i) * 1.2) * buildUp; // Slightly larger
                        const isWhite = i % 5 === 0;
                        const particleColor = isWhite ? '#ffffff' : '#bb88ff';
                        
                        ctx.fillStyle = particleColor;
                        ctx.shadowBlur = isWhite ? 10 : 7; // More glow
                        ctx.shadowColor = particleColor;
                        ctx.beginPath();
                        ctx.arc(px, py, particleSize, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    
                    // Small, dense black hole core with PURE BLACK center
                    const voidSize = 30 + Math.sin(time * 1.5) * 4;
                    
                    // Pure black center circle (no gradient, just solid black)
                    ctx.fillStyle = 'rgba(0, 0, 0, 1)';
                    ctx.shadowBlur = 0;
                    ctx.beginPath();
                    ctx.arc(horizon.x, horizon.y, voidSize * 0.5, 0, Math.PI * 2); // Half the radius is pure black
                    ctx.fill();
                    
                    // Gradient from black center to purple edge
                    const voidGradient = ctx.createRadialGradient(
                        horizon.x, horizon.y, voidSize * 0.5, // Start gradient at edge of pure black
                        horizon.x, horizon.y, voidSize
                    );
                    voidGradient.addColorStop(0, 'rgba(0, 0, 0, 1)');
                    voidGradient.addColorStop(0.3, 'rgba(10, 0, 25, 0.95)');
                    voidGradient.addColorStop(0.7, 'rgba(30, 0, 60, 0.7)');
                    voidGradient.addColorStop(1, 'rgba(70, 0, 120, 0)');
                    
                    ctx.fillStyle = voidGradient;
                    ctx.shadowBlur = 35 * buildUp;
                    ctx.shadowColor = '#5500aa';
                    ctx.beginPath();
                    ctx.arc(horizon.x, horizon.y, voidSize, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Brilliant white event horizon ring - the point of no return
                    const horizonRingPulse = Math.sin(time * 2.5) * 0.25;
                    for (let ring = 0; ring < 4; ring++) {
                        const ringOffset = ring * 1.2;
                        const ringAlpha = (0.85 - ring * 0.16 + horizonRingPulse) * buildUp;
                        
                        ctx.strokeStyle = `rgba(255, 255, 255, ${ringAlpha})`;
                        ctx.lineWidth = 4 - ring * 0.7;
                        ctx.shadowBlur = 25 + ring * 7;
                        ctx.shadowColor = '#ffffff';
                        ctx.beginPath();
                        ctx.arc(horizon.x, horizon.y, voidSize - 2 + ringOffset, 0, Math.PI * 2);
                        ctx.stroke();
                    }
                    
                    // Soft outer glow - ONLY around the event horizon ring, not covering the black center
                    const horizonGlowGradient = ctx.createRadialGradient(
                        horizon.x, horizon.y, voidSize + 10, // Start glow OUTSIDE the event horizon
                        horizon.x, horizon.y, voidSize + 45
                    );
                    horizonGlowGradient.addColorStop(0, `rgba(255, 255, 255, ${0.6 * buildUp})`);
                    horizonGlowGradient.addColorStop(0.4, `rgba(200, 180, 255, ${0.35 * buildUp})`);
                    horizonGlowGradient.addColorStop(1, 'rgba(120, 0, 200, 0)');
                    
                    ctx.fillStyle = horizonGlowGradient;
                    ctx.shadowBlur = 40 * buildUp;
                    ctx.shadowColor = '#ffffff';
                    ctx.beginPath();
                    ctx.arc(horizon.x, horizon.y, voidSize + 45, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.shadowBlur = 0;
                    
                    // REDRAW pure black center on TOP of everything (including glow)
                    // This ensures the black hole core remains visually devoid of light
                    ctx.fillStyle = 'rgba(0, 0, 0, 1)';
                    ctx.shadowBlur = 0;
                    ctx.beginPath();
                    ctx.arc(horizon.x, horizon.y, voidSize * 0.5, 0, Math.PI * 2);
                    ctx.fill();
                    
                } else if (horizon.phase === 'collapse') {
                    // ULTRA EPIC COSMIC COLLAPSE - Reality-shattering implosion
                    const cycleTime = (state.gameTime % 500) / 500; // 0 to 1 over 0.5s
                    const collapseProgress = 1 - cycleTime;
                    const collapseSize = 500 * collapseProgress; // Even larger collapse
                    
                    if (collapseSize > 0) {
                        // Blinding white supernova flash at center
                        const supernovaGradient = ctx.createRadialGradient(horizon.x, horizon.y, 0, horizon.x, horizon.y, collapseSize * 0.3);
                        supernovaGradient.addColorStop(0, `rgba(255, 255, 255, ${collapseProgress})`);
                        supernovaGradient.addColorStop(0.5, `rgba(255, 255, 255, ${collapseProgress * 0.7})`);
                        supernovaGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                        
                        ctx.fillStyle = supernovaGradient;
                        ctx.shadowBlur = 80;
                        ctx.shadowColor = '#ffffff';
                        ctx.beginPath();
                        ctx.arc(horizon.x, horizon.y, collapseSize * 0.3, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Massive energy beams shooting outward
                        for (let i = 0; i < 12; i++) {
                            const beamAngle = (i / 12) * Math.PI * 2 + time * 3;
                            const beamLength = collapseSize * 1.8;
                            
                            const beamGradient = ctx.createLinearGradient(
                                horizon.x, horizon.y,
                                horizon.x + Math.cos(beamAngle) * beamLength,
                                horizon.y + Math.sin(beamAngle) * beamLength
                            );
                            beamGradient.addColorStop(0, `rgba(255, 255, 255, ${collapseProgress * 0.9})`);
                            beamGradient.addColorStop(0.3, `rgba(255, 200, 255, ${collapseProgress * 0.6})`);
                            beamGradient.addColorStop(0.7, `rgba(200, 100, 255, ${collapseProgress * 0.3})`);
                            beamGradient.addColorStop(1, 'rgba(148, 0, 255, 0)');
                            
                            ctx.strokeStyle = beamGradient;
                            ctx.lineWidth = 20 * collapseProgress;
                            ctx.shadowBlur = 50;
                            ctx.shadowColor = '#ff00ff';
                            ctx.beginPath();
                            ctx.moveTo(horizon.x, horizon.y);
                            ctx.lineTo(
                                horizon.x + Math.cos(beamAngle) * beamLength,
                                horizon.y + Math.sin(beamAngle) * beamLength
                            );
                            ctx.stroke();
                        }
                        
                        // Reality-tearing fragments
                        for (let i = 0; i < 40; i++) {
                            const fragAngle = (i / 40) * Math.PI * 2 + time * 5;
                            const fragDist = collapseSize * (0.6 + Math.sin(time * 8 + i) * 0.2);
                            const fx = horizon.x + Math.cos(fragAngle) * fragDist;
                            const fy = horizon.y + Math.sin(fragAngle) * fragDist;
                            
                            const fragSize = 8 * collapseProgress;
                            const fragGradient = ctx.createRadialGradient(fx, fy, 0, fx, fy, fragSize);
                            fragGradient.addColorStop(0, `rgba(255, 255, 255, ${collapseProgress})`);
                            fragGradient.addColorStop(0.5, `rgba(255, 150, 255, ${collapseProgress * 0.7})`);
                            fragGradient.addColorStop(1, 'rgba(148, 0, 255, 0)');
                            
                            ctx.fillStyle = fragGradient;
                            ctx.shadowBlur = 20;
                            ctx.beginPath();
                            ctx.arc(fx, fy, fragSize, 0, Math.PI * 2);
                            ctx.fill();
                        }
                        
                        // Multiple colored shockwaves with MAXIMUM intensity
                        for (let i = 0; i < 12; i++) {
                            const waveSize = collapseSize * (1 + i * 0.15);
                            const waveAlpha = collapseProgress * (1.0 - i * 0.07);
                            
                            const hue = (time * 100 + i * 30) % 360;
                            ctx.strokeStyle = `hsla(${hue}, 100%, 75%, ${waveAlpha})`;
                            ctx.lineWidth = 12 - i * 0.8;
                            ctx.shadowBlur = 50;
                            ctx.shadowColor = `hsla(${hue}, 100%, 70%, ${waveAlpha * 0.9})`;
                            ctx.beginPath();
                            ctx.arc(horizon.x, horizon.y, waveSize, 0, Math.PI * 2);
                            ctx.stroke();
                        }
                        
                        // Spiral implosion lines
                        for (let i = 0; i < 8; i++) {
                            const spiralAngle = (i / 8) * Math.PI * 2 + time * 10;
                            const spiralRadius = collapseSize * 0.8;
                            const sx = horizon.x + Math.cos(spiralAngle) * spiralRadius;
                            const sy = horizon.y + Math.sin(spiralAngle) * spiralRadius;
                            
                            const spiralGradient = ctx.createLinearGradient(sx, sy, horizon.x, horizon.y);
                            spiralGradient.addColorStop(0, 'rgba(255, 255, 255, 0)');
                            spiralGradient.addColorStop(0.5, `rgba(255, 200, 255, ${collapseProgress * 0.6})`);
                            spiralGradient.addColorStop(1, `rgba(255, 255, 255, ${collapseProgress * 0.8})`);
                            
                            ctx.strokeStyle = spiralGradient;
                            ctx.lineWidth = 8 * collapseProgress;
                            ctx.shadowBlur = 30;
                            ctx.beginPath();
                            ctx.moveTo(sx, sy);
                            ctx.lineTo(horizon.x, horizon.y);
                            ctx.stroke();
                        }
                        
                        // Massive implosion core gradient
                        const implodeGradient = ctx.createRadialGradient(horizon.x, horizon.y, 0, horizon.x, horizon.y, collapseSize * 0.6);
                        implodeGradient.addColorStop(0, `rgba(255, 255, 255, ${collapseProgress})`);
                        implodeGradient.addColorStop(0.2, `rgba(255, 255, 255, ${collapseProgress * 0.9})`);
                        implodeGradient.addColorStop(0.5, `rgba(255, 200, 255, ${collapseProgress * 0.6})`);
                        implodeGradient.addColorStop(0.8, `rgba(200, 100, 255, ${collapseProgress * 0.3})`);
                        implodeGradient.addColorStop(1, 'rgba(148, 0, 255, 0)');
                        
                        ctx.fillStyle = implodeGradient;
                        ctx.shadowBlur = 80;
                        ctx.shadowColor = '#ff00ff';
                        ctx.beginPath();
                        ctx.arc(horizon.x, horizon.y, collapseSize * 0.6, 0, Math.PI * 2);
                        ctx.fill();
                        
                        ctx.shadowBlur = 0;
                    }
                }
            }
            
            // SEISMIC BOMB RENDERING - Massive nuclear-style explosion
            if (player.ultimateData.seismicBomb && player.ultimateData.seismicBomb.active) {
                const bomb = player.ultimateData.seismicBomb;
                const time = Date.now() / 100; // Use real time for smooth animation
                
                if (bomb.phase === 'travel') {
                    // Glowing projectile traveling to target
                    const pulseSize = 20 + Math.sin(time * 3) * 5;
                    
                    // Outer glow - REDUCED OPACITY
                    const glowGradient = ctx.createRadialGradient(bomb.x, bomb.y, 0, bomb.x, bomb.y, pulseSize * 3);
                    glowGradient.addColorStop(0, 'rgba(255, 200, 0, 0.5)'); // Reduced from 0.9
                    glowGradient.addColorStop(0.4, 'rgba(255, 120, 0, 0.3)'); // Reduced from 0.6
                    glowGradient.addColorStop(0.7, 'rgba(255, 60, 0, 0.15)'); // Reduced from 0.3
                    glowGradient.addColorStop(1, 'rgba(255, 0, 0, 0)');
                    
                    ctx.fillStyle = glowGradient;
                    ctx.shadowBlur = 20; // Reduced from 40
                    ctx.shadowColor = '#ff6600';
                    ctx.beginPath();
                    ctx.arc(bomb.x, bomb.y, pulseSize * 3, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Core
                    ctx.fillStyle = '#ffaa00';
                    ctx.shadowBlur = 15; // Reduced from 30
                    ctx.shadowColor = '#ffffff';
                    ctx.beginPath();
                    ctx.arc(bomb.x, bomb.y, pulseSize, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Bright center - SMALLER
                    ctx.fillStyle = '#ffffff';
                    ctx.shadowBlur = 10; // Reduced from 20
                    ctx.beginPath();
                    ctx.arc(bomb.x, bomb.y, pulseSize * 0.3, 0, Math.PI * 2); // Reduced from 0.4
                    ctx.fill();
                    
                    // Trail from player - MUCH DIMMER
                    ctx.strokeStyle = 'rgba(255, 150, 0, 0.2)'; // Reduced from 0.4
                    ctx.lineWidth = 15;
                    ctx.shadowBlur = 15; // Reduced from 30
                    ctx.shadowColor = '#ff6600';
                    ctx.beginPath();
                    ctx.moveTo(player.x, player.y);
                    ctx.lineTo(bomb.x, bomb.y);
                    ctx.stroke();
                    
                    ctx.shadowBlur = 0;
                    
                } else if (bomb.phase === 'explode') {
                    // MASSIVE BLAST - REDUCED BRIGHTNESS
                    const blastSize = 220 + Math.sin(time * 8) * 40;
                    
                    // White core - MUCH LESS BLINDING
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.4)'; // Reduced from full white
                    ctx.shadowBlur = 30; // Reduced from 80
                    ctx.shadowColor = 'rgba(255, 255, 255, 0.3)';
                    ctx.beginPath();
                    ctx.arc(bomb.targetX, bomb.targetY, blastSize * 0.3, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Yellow-orange fireball - REDUCED OPACITY
                    const fireGradient = ctx.createRadialGradient(
                        bomb.targetX, bomb.targetY, 0,
                        bomb.targetX, bomb.targetY, blastSize
                    );
                    fireGradient.addColorStop(0, 'rgba(255, 255, 200, 0.5)'); // Reduced from 1
                    fireGradient.addColorStop(0.2, 'rgba(255, 220, 100, 0.4)'); // Reduced from 0.9
                    fireGradient.addColorStop(0.5, 'rgba(255, 150, 0, 0.35)'); // Reduced from 0.7
                    fireGradient.addColorStop(0.8, 'rgba(255, 80, 0, 0.2)'); // Reduced from 0.4
                    fireGradient.addColorStop(1, 'rgba(200, 0, 0, 0)');
                    
                    ctx.fillStyle = fireGradient;
                    ctx.shadowBlur = 25; // Reduced from 60
                    ctx.shadowColor = '#ff8800';
                    ctx.beginPath();
                    ctx.arc(bomb.targetX, bomb.targetY, blastSize, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Expanding rings - THINNER AND DIMMER
                    for (let i = 0; i < 6; i++) {
                        const ringSize = blastSize + (i * 60) + Math.sin(time * 5 + i) * 20;
                        const ringAlpha = Math.max(0, 0.35 - (i * 0.05)); // Reduced from 0.7
                        
                        ctx.strokeStyle = `rgba(255, ${220 - i * 30}, ${100 - i * 15}, ${ringAlpha})`;
                        ctx.lineWidth = 5 - (i * 0.5); // Reduced from 10 - i
                        ctx.shadowBlur = 15; // Reduced from 35
                        ctx.shadowColor = '#ff6600';
                        ctx.beginPath();
                        ctx.arc(bomb.targetX, bomb.targetY, ringSize, 0, Math.PI * 2);
                        ctx.stroke();
                    }
                    
                    ctx.shadowBlur = 0;
                    
                } else if (bomb.phase === 'shockwave1') {
                    // FIRST SHOCKWAVE - REDUCED OPACITY
                    const baseSize = 280;
                    
                    // Central glow - DIMMER
                    const glowGradient = ctx.createRadialGradient(
                        bomb.targetX, bomb.targetY, 0,
                        bomb.targetX, bomb.targetY, baseSize * 0.6
                    );
                    glowGradient.addColorStop(0, 'rgba(255, 200, 100, 0.3)'); // Reduced from 0.7
                    glowGradient.addColorStop(0.5, 'rgba(255, 150, 50, 0.2)'); // Reduced from 0.4
                    glowGradient.addColorStop(1, 'rgba(255, 100, 0, 0)');
                    
                    ctx.fillStyle = glowGradient;
                    ctx.beginPath();
                    ctx.arc(bomb.targetX, bomb.targetY, baseSize * 0.6, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Expanding pressure waves - THINNER AND DIMMER
                    for (let i = 0; i < 8; i++) {
                        const waveSize = baseSize * 0.4 + (i * 40) + Math.sin(time * 4 + i) * 15;
                        const waveAlpha = Math.max(0, 0.4 - (i * 0.045)); // Reduced from 0.8
                        
                        ctx.strokeStyle = `rgba(255, ${180 - i * 20}, 0, ${waveAlpha})`;
                        ctx.lineWidth = 6 - (i * 0.5); // Reduced from 12 - i
                        ctx.shadowBlur = 12; // Reduced from 25
                        ctx.shadowColor = '#ff6600';
                        ctx.beginPath();
                        ctx.arc(bomb.targetX, bomb.targetY, waveSize, 0, Math.PI * 2);
                        ctx.stroke();
                    }
                    
                    ctx.shadowBlur = 0;
                    
                } else if (bomb.phase === 'shockwave2') {
                    // SECOND SHOCKWAVE - EVEN DIMMER
                    const baseSize = 400;
                    
                    // Fading central glow - VERY DIM
                    const glowGradient = ctx.createRadialGradient(
                        bomb.targetX, bomb.targetY, 0,
                        bomb.targetX, bomb.targetY, baseSize * 0.5
                    );
                    glowGradient.addColorStop(0, 'rgba(255, 180, 80, 0.25)'); // Reduced from 0.5
                    glowGradient.addColorStop(0.6, 'rgba(255, 120, 40, 0.15)'); // Reduced from 0.3
                    glowGradient.addColorStop(1, 'rgba(255, 80, 0, 0)');
                    
                    ctx.fillStyle = glowGradient;
                    ctx.beginPath();
                    ctx.arc(bomb.targetX, bomb.targetY, baseSize * 0.5, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Wider pressure waves - VERY THIN AND DIM
                    for (let i = 0; i < 10; i++) {
                        const waveSize = baseSize * 0.3 + (i * 50) + Math.sin(time * 3 + i) * 20;
                        const waveAlpha = Math.max(0, 0.35 - (i * 0.035)); // Reduced from 0.7
                        
                        ctx.strokeStyle = `rgba(255, ${160 - i * 15}, 0, ${waveAlpha})`;
                        ctx.lineWidth = 5 - (i * 0.4); // Reduced from 10
                        ctx.shadowBlur = 10; // Reduced from 20
                        ctx.shadowColor = '#ff8800';
                        ctx.beginPath();
                        ctx.arc(bomb.targetX, bomb.targetY, waveSize, 0, Math.PI * 2);
                        ctx.stroke();
                    }
                    
                    ctx.shadowBlur = 0;
                    
                } else if (bomb.phase === 'burning') {
                    // BURNING GROUND - MUCH LESS BRIGHT
                    const radius = ULTIMATES.seismic_bomb.burningGround.radius;
                    const timeLeft = bomb.burningTimer || 0;
                    const totalDuration = ULTIMATES.seismic_bomb.burningGround.duration;
                    const alpha = Math.max(0, timeLeft / totalDuration) * 0.6; // Scale down opacity by 0.6
                    
                    // Molten ground base - DIMMER
                    const lavaGradient = ctx.createRadialGradient(
                        bomb.burningX, bomb.burningY, 0,
                        bomb.burningX, bomb.burningY, radius
                    );
                    const pulse = Math.sin(time * 2) * 0.1; // Reduced from 0.15
                    lavaGradient.addColorStop(0, `rgba(255, 255, 100, ${Math.min(0.5, alpha * 0.9 + pulse)})`); // Capped at 0.5
                    lavaGradient.addColorStop(0.3, `rgba(255, 180, 0, ${alpha * 0.5})`); // Reduced from 0.7
                    lavaGradient.addColorStop(0.6, `rgba(255, 100, 0, ${alpha * 0.35})`); // Reduced from 0.5
                    lavaGradient.addColorStop(0.85, `rgba(200, 60, 0, ${alpha * 0.2})`); // Reduced from 0.3
                    lavaGradient.addColorStop(1, 'rgba(150, 0, 0, 0)');
                    
                    ctx.fillStyle = lavaGradient;
                    ctx.shadowBlur = 25; // Reduced from 50
                    ctx.shadowColor = '#ff6600';
                    ctx.beginPath();
                    ctx.arc(bomb.burningX, bomb.burningY, radius, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Rising heat bubbles - FEWER AND DIMMER
                    for (let i = 0; i < 10; i++) { // Reduced from 16
                        const angle = (i / 10) * Math.PI * 2 + time * 0.3;
                        const dist = radius * (0.3 + Math.sin(time * 1.5 + i) * 0.25);
                        const bx = bomb.burningX + Math.cos(angle) * dist;
                        const by = bomb.burningY + Math.sin(angle) * dist;
                        const bubbleSize = 12 + Math.sin(time * 3 + i) * 5; // Smaller
                        
                        const bubbleGradient = ctx.createRadialGradient(bx, by, 0, bx, by, bubbleSize);
                        bubbleGradient.addColorStop(0, `rgba(255, 255, 150, ${alpha * 0.4})`); // Reduced from 0.8
                        bubbleGradient.addColorStop(0.5, `rgba(255, 150, 0, ${alpha * 0.25})`); // Reduced from 0.5
                        bubbleGradient.addColorStop(1, 'rgba(255, 0, 0, 0)');
                        
                        ctx.fillStyle = bubbleGradient;
                        ctx.shadowBlur = 8; // Reduced from 15
                        ctx.shadowColor = '#ff6600';
                        ctx.beginPath();
                        ctx.arc(bx, by, bubbleSize, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    
                    // Floating embers - FEWER AND SMALLER
                    for (let i = 0; i < 15; i++) { // Reduced from 25
                        const emberAngle = (i / 15) * Math.PI * 2 + time * 0.4;
                        const emberDist = radius * (0.5 + Math.sin(time + i) * 0.3);
                        const ex = bomb.burningX + Math.cos(emberAngle) * emberDist;
                        const ey = bomb.burningY + Math.sin(emberAngle) * emberDist - Math.abs(Math.sin(time * 2 + i)) * 20;
                        const emberSize = 1.5 + Math.sin(time * 4 + i) * 1; // Smaller
                        
                        ctx.fillStyle = `rgba(255, ${180 + Math.sin(time * 3 + i) * 75}, 0, ${alpha * 0.6})`; // Reduced from 0.9
                        ctx.shadowBlur = 5; // Reduced from 8
                        ctx.shadowColor = '#ffaa00';
                        ctx.beginPath();
                        ctx.arc(ex, ey, emberSize, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    
                    // Bright pulsing core - MUCH SMALLER AND DIMMER
                    const coreSize = 25 + Math.sin(time * 3) * 8; // Reduced from 40 + 12
                    const coreGradient = ctx.createRadialGradient(
                        bomb.burningX, bomb.burningY, 0,
                        bomb.burningX, bomb.burningY, coreSize
                    );
                    coreGradient.addColorStop(0, `rgba(255, 255, 255, ${alpha * 0.5})`); // Reduced from alpha
                    coreGradient.addColorStop(0.4, `rgba(255, 220, 100, ${alpha * 0.4})`); // Reduced from 0.8
                    coreGradient.addColorStop(0.7, `rgba(255, 150, 0, ${alpha * 0.25})`); // Reduced from 0.5
                    coreGradient.addColorStop(1, 'rgba(255, 100, 0, 0)');
                    
                    ctx.fillStyle = coreGradient;
                    ctx.shadowBlur = 20; // Reduced from 40
                    ctx.shadowColor = '#ffffff';
                    ctx.beginPath();
                    ctx.arc(bomb.burningX, bomb.burningY, coreSize, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.shadowBlur = 0;
                }
            }

            // Adrenaline Surge energy trail effect
            if (player.ultimateActive && player.ultimate === 'adrenaline_surge' && player.ultimateData && player.ultimateData.trail.length > 0) {
                const trail = player.ultimateData.trail;
                const trailWidth = player.ultimateData.trailWidth;
                const color = player.ultimateData.color;
                const gameTime = player.ultimateData.gameTime || 0;
                
                ctx.shadowBlur = 12; // Reduced from 25
                ctx.shadowColor = color;
                
                // Draw trail as connected segments
                for (let i = 1; i < trail.length; i++) {
                    const prev = trail[i - 1];
                    const curr = trail[i];
                    
                    // Calculate age-based alpha (newer = brighter) using game time - REDUCED
                    const age = gameTime - curr.time;
                    const ageRatio = 1 - (age / player.ultimateData.trailDuration);
                    const alpha = Math.max(0, ageRatio * 0.4); // Reduced from 0.7
                    
                    // Draw glowing trail segment
                    const gradient = ctx.createLinearGradient(prev.x, prev.y, curr.x, curr.y);
                    gradient.addColorStop(0, `rgba(255, 235, 59, ${alpha * 0.3})`); // Reduced from 0.5
                    gradient.addColorStop(1, `rgba(255, 235, 59, ${alpha * 0.6})`); // Reduced from 1.0
                    
                    ctx.strokeStyle = gradient;
                    ctx.lineWidth = trailWidth * ageRatio;
                    ctx.lineCap = 'round';
                    ctx.beginPath();
                    ctx.moveTo(prev.x, prev.y);
                    ctx.lineTo(curr.x, curr.y);
                    ctx.stroke();
                }
                
                // Electric particles along trail
                const particleInterval = 3; // Every 3rd trail position
                for (let i = 0; i < trail.length; i += particleInterval) {
                    const pos = trail[i];
                    const age = gameTime - pos.time;
                    const ageRatio = 1 - (age / player.ultimateData.trailDuration);
                    
                    if (ageRatio > 0) {
                        // Sparks
                        for (let j = 0; j < 2; j++) {
                            const angle = seededRandom() * Math.PI * 2;
                            const dist = seededRandom() * trailWidth * 0.5;
                            const px = pos.x + Math.cos(angle) * dist;
                            const py = pos.y + Math.sin(angle) * dist;
                            const sparkSize = 2 + seededRandom() * 3;
                            
                            ctx.fillStyle = `rgba(255, 255, 255, ${ageRatio * 0.8})`;
                            ctx.shadowBlur = 10;
                            ctx.shadowColor = color;
                            ctx.beginPath();
                            ctx.arc(px, py, sparkSize, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    }
                }
                
                ctx.shadowBlur = 0;
                
                // Player glow during Adrenaline Surge (use game time for pulse) - VERY SUBTLE
                const pulse = Math.sin(state.gameTime * 0.01) * 0.2 + 0.5;
                const glowRadius = 40 * pulse; // Reduced from 50
                const glowGradient = ctx.createRadialGradient(player.x, player.y, 0, player.x, player.y, glowRadius);
                glowGradient.addColorStop(0, `rgba(255, 235, 59, ${0.15 * pulse})`); // Reduced from 0.3
                glowGradient.addColorStop(0.5, `rgba(255, 235, 59, ${0.08 * pulse})`); // Reduced from 0.15
                glowGradient.addColorStop(1, 'rgba(255, 235, 59, 0)');
                
                ctx.fillStyle = glowGradient;
                ctx.beginPath();
                ctx.arc(player.x, player.y, glowRadius, 0, Math.PI * 2);
                ctx.fill();
                
                // Speed lines - REDUCED
                for (let i = 0; i < 6; i++) { // Reduced from 8
                    const angle = (i / 6) * Math.PI * 2;
                    const lineLength = 30 + seededRandom() * 20; // Reduced from 40 + 30
                    const startX = player.x + Math.cos(angle) * 20; // Reduced from 25
                    const startY = player.y + Math.sin(angle) * 20;
                    const endX = startX + Math.cos(angle) * lineLength;
                    const endY = startY + Math.sin(angle) * lineLength;
                    
                    ctx.strokeStyle = `rgba(255, 235, 59, ${0.2 * pulse})`; // Reduced from 0.4
                    ctx.lineWidth = 1.5; // Reduced from 2
                    ctx.beginPath();
                    ctx.moveTo(startX, startY);
                    ctx.lineTo(endX, endY);
                    ctx.stroke();
                }
                
                // Clear shadow effects after Adrenaline Surge visuals
                ctx.shadowBlur = 0;
            }

            // Phoenix Protocol burning ground effect
            if (player.ultimateData && player.ultimateData.burningGround && player.ultimateData.burningGround.active) {
                const burning = player.ultimateData.burningGround;
                const radius = burning.radius;
                
                // SAFETY: Ensure time is valid for all calculations
                const safeTime = (time !== undefined && !isNaN(time) && isFinite(time)) ? time : 0;
                
                // SAFETY: Calculate alpha with fallback for invalid values
                let alpha = 1.0;
                if (burning.timer !== undefined && burning.timer !== null && 
                    ULTIMATES.phoenix_protocol.burningGround.duration > 0) {
                    alpha = Math.max(0, Math.min(1, burning.timer / ULTIMATES.phoenix_protocol.burningGround.duration));
                }
                
                // SAFETY: Calculate pulse with fallback for invalid time
                const pulse = Math.sin(safeTime * 2.5) * 0.25;
                
                // Scorched earth gradient (orange/red fire theme)
                const fireGradient = ctx.createRadialGradient(
                    burning.x, burning.y, 0,
                    burning.x, burning.y, radius
                );
                fireGradient.addColorStop(0, `rgba(255, 200, 50, ${Math.max(0, Math.min(1, alpha * 0.7 + pulse))})`);
                fireGradient.addColorStop(0.3, `rgba(255, 100, 0, ${Math.max(0, Math.min(1, alpha * 0.6))})`);
                fireGradient.addColorStop(0.6, `rgba(200, 50, 0, ${Math.max(0, Math.min(1, alpha * 0.4))})`);
                fireGradient.addColorStop(1, 'rgba(100, 0, 0, 0)');
                
                ctx.fillStyle = fireGradient;
                ctx.shadowBlur = 35;
                ctx.shadowColor = '#ff6600';
                ctx.beginPath();
                ctx.arc(burning.x, burning.y, radius, 0, Math.PI * 2);
                ctx.fill();
                
                // Solar flare rings
                for (let ring = 0; ring < 3; ring++) {
                    const ringRadius = radius * (0.3 + ring * 0.25) + Math.sin(safeTime * 2 + ring) * 20;
                    ctx.strokeStyle = `rgba(255, ${150 - ring * 30}, 0, ${alpha * 0.4})`;
                    ctx.lineWidth = 3;
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = '#ff8800';
                    ctx.beginPath();
                    ctx.arc(burning.x, burning.y, ringRadius, 0, Math.PI * 2);
                    ctx.stroke();
                }
                
                // Flame particles dancing
                for (let i = 0; i < 16; i++) {
                    const angle = (i / 16) * Math.PI * 2 + safeTime * 0.4;
                    const flameDist = radius * (0.5 + Math.sin(safeTime * 1.8 + i) * 0.35);
                    const fx = burning.x + Math.cos(angle) * flameDist;
                    const fy = burning.y + Math.sin(angle) * flameDist;
                    const flameSize = 4 + Math.sin(safeTime * 5 + i) * 3;
                    
                    ctx.fillStyle = `rgba(255, ${100 + Math.sin(safeTime * 3 + i) * 100}, 0, ${alpha * 0.8})`;
                    ctx.shadowBlur = 12;
                    ctx.shadowColor = '#ff6600';
                    ctx.beginPath();
                    ctx.arc(fx, fy, flameSize, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Bright pulsing core
                const coreSize = 40 + Math.sin(safeTime * 3.5) * 15;
                const coreGradient = ctx.createRadialGradient(burning.x, burning.y, 0, burning.x, burning.y, coreSize);
                coreGradient.addColorStop(0, `rgba(255, 255, 200, ${alpha * 0.9})`);
                coreGradient.addColorStop(0.4, `rgba(255, 180, 50, ${alpha * 0.7})`);
                coreGradient.addColorStop(1, 'rgba(255, 100, 0, 0)');
                
                ctx.fillStyle = coreGradient;
                ctx.shadowBlur = 35;
                ctx.shadowColor = '#ffcc00';
                ctx.beginPath();
                ctx.arc(burning.x, burning.y, coreSize, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.shadowBlur = 0;
            }

            if (player.beamActive && player.beamActiveTime >= 5) {
                // Get targets for drawing (use existing targets or find closest for initial frames)
                let drawTargets = player.beamTargets && player.beamTargets.length > 0 
                    ? player.beamTargets 
                    : entities.enemies
                        .filter(e => e.hp > 0)
                        .sort((a,b) => {
                            const da = Math.sqrt((a.x-player.x)**2 + (a.y-player.y)**2);
                            const db = Math.sqrt((b.x-player.x)**2 + (b.y-player.y)**2);
                            return da - db;
                        })
                        .slice(0, Math.min(3, player.weapons.beam));
                
                drawTargets.forEach((t, idx) => {
                   // VIEWPORT CULLING: Skip if target off-screen
                   if (!inViewport(t.x, t.y)) return;
                   
                   // Calculate staggered ignition timing (5 frame delay between beams)
                   const ignitionOrder = player.beamIgnitionOrder || [0, 1, 2];
                   const beamOrderIndex = ignitionOrder.indexOf(idx);
                   const ignitionDelay = beamOrderIndex * 5; // 5 frames between each beam
                   const effectiveActiveTime = player.beamActiveTime - ignitionDelay;
                   
                   // Skip if this beam hasn't ignited yet
                   if (effectiveActiveTime < 5) return;
                   
                   // Get ramp progress for this target
                   const rampFrames = player.beamRampMap.get(t) || 0;
                   const rampProgress = Math.min(rampFrames / 180, 1.0);
                   
                   // Ignition fade-in (first 10 frames after delay)
                   const ignitionProgress = Math.min(effectiveActiveTime / 10, 1.0);
                   const intensity = (0.75 + (rampProgress * 0.25)) * ignitionProgress; // Fade in + ramp
                   
                   // Calculate beam angle for perpendicular effects
                   const dx = t.x - player.x;
                   const dy = t.y - player.y;
                   const beamAngle = Math.atan2(dy, dx);
                   const beamLength = Math.sqrt(dx*dx + dy*dy);
                   
                   // LAYERED BEAM EFFECT
                   ctx.save();
                   
                   // Layer 1: Outer glow (wide, diffuse)
                   const outerPulse = Math.sin(state.frameCount * 0.3 + idx) * 0.3;
                   ctx.strokeStyle = `rgba(255, 0, 255, ${(0.2 + outerPulse) * intensity})`;
                   ctx.lineWidth = 12 + rampProgress * 4;
                   applyShadow(25, '#ff00ff');
                   ctx.lineCap = 'round';
                   ctx.beginPath();
                   ctx.moveTo(player.x, player.y);
                   ctx.lineTo(t.x, t.y);
                   ctx.stroke();
                   
                   // Layer 2: Mid beam (bright magenta)
                   ctx.strokeStyle = `rgba(255, 50, 255, ${(0.6 + outerPulse * 0.5) * intensity})`;
                   ctx.lineWidth = 6 + rampProgress * 2;
                   applyShadow(15, '#ff66ff');
                   ctx.beginPath();
                   ctx.moveTo(player.x, player.y);
                   ctx.lineTo(t.x, t.y);
                   ctx.stroke();
                   
                   // Layer 3: Core beam (white-hot center)
                   const corePulse = Math.sin(state.frameCount * 0.5 + idx) * 0.2;
                   ctx.strokeStyle = `rgba(255, 255, 255, ${(0.8 + corePulse) * intensity})`;
                   ctx.lineWidth = 2 + rampProgress;
                   applyShadow(10, '#ffffff');
                   ctx.beginPath();
                   ctx.moveTo(player.x, player.y);
                   ctx.lineTo(t.x, t.y);
                   ctx.stroke();
                   
                   clearShadow();
                   ctx.restore();
                   
                   // WELDING SPARKS AT IMPACT POINT
                   ctx.save();
                   ctx.translate(t.x, t.y);
                   
                   // Bright impact flash (scales with ramp)
                   const flashSize = 10 + rampProgress * 8;
                   const flashPulse = 0.6 + Math.sin(state.frameCount * 0.8) * 0.4;
                   
                   // Outer impact glow
                   ctx.fillStyle = `rgba(255, 150, 0, ${flashPulse * 0.4 * intensity})`;
                   applyShadow(30, '#ffaa00');
                   ctx.beginPath();
                   ctx.arc(0, 0, flashSize * 1.5, 0, Math.PI * 2);
                   ctx.fill();
                   
                   // Inner white-hot core
                   ctx.fillStyle = `rgba(255, 255, 255, ${flashPulse * 0.9 * intensity})`;
                   applyShadow(20, '#ffffff');
                   ctx.beginPath();
                   ctx.arc(0, 0, flashSize * 0.6, 0, Math.PI * 2);
                   ctx.fill();
                   
                   // ARCING SPARK PARTICLES (wide spread with gentle arc)
                   // PARTICLE REDUCTION: Reduced base count for better performance
                   const baseSparkCount = Math.floor(7 + rampProgress * 5); // Reduced from 10-18 to 7-12
                   const numSparks = Math.floor(baseSparkCount * particleFactor * intensity); // Scale by intensity
                   
                   for (let i = 0; i < numSparks; i++) {
                       // Initial ejection angle (perpendicular to beam, wide spread)
                       const perpAngle = beamAngle + Math.PI; // Opposite beam direction
                       const spreadAngle = (Math.random() - 0.5) * Math.PI * 1.4; // 252¬∞ wide spread
                       const initialAngle = perpAngle + spreadAngle;
                       
                       // Strong ejection velocity for distance
                       const ejectSpeed = 20 + Math.random() * 25; // 20-45 pixels initial velocity
                       
                       // Simulate gentle arc trajectory (less gravity for wider spread)
                       const timeStep = Math.random() * 0.6 + 0.2; // 0.2-0.8 time progression
                       const gravity = 8; // Gentle downward acceleration (was 15)
                       
                       // Position after time (projectile motion)
                       const vx0 = Math.cos(initialAngle) * ejectSpeed;
                       const vy0 = Math.sin(initialAngle) * ejectSpeed;
                       const sparkX = vx0 * timeStep;
                       const sparkY = vy0 * timeStep + 0.5 * gravity * timeStep * timeStep;
                       
                       // Velocity at this time (for trail direction)
                       const vx = vx0;
                       const vy = vy0 + gravity * timeStep;
                       
                       // Spark trail (points in velocity direction)
                       const sparkLength = 6 + Math.random() * 6;
                       const trailAngle = Math.atan2(vy, vx);
                       const sparkEndX = sparkX - Math.cos(trailAngle) * sparkLength;
                       const sparkEndY = sparkY - Math.sin(trailAngle) * sparkLength;
                       
                       // WELDING COLOR: Blue-tinted at source ‚Üí yellow ‚Üí white hot
                       const heat = 1 - timeStep * 0.4; // Hotter near source
                       let sparkHue, shadowColor;
                       if (heat > 0.7) {
                           // Very hot: White with blue tint
                           sparkHue = `rgba(220, 230, 255`; // Blue-white
                           shadowColor = '#aaccff';
                       } else if (heat > 0.5) {
                           // Hot: Bright yellow-white
                           sparkHue = `rgba(255, 255, 200`; // Yellow-white
                           shadowColor = '#ffffaa';
                       } else if (heat > 0.3) {
                           // Cooling: Golden yellow
                           sparkHue = `rgba(255, 230, 120`; // Golden
                           shadowColor = '#ffdd66';
                       } else {
                           // Cool: Deep yellow-orange
                           sparkHue = `rgba(255, 200, 80`; // Yellow-orange
                           shadowColor = '#ffaa44';
                       }
                       
                       const sparkAlpha = (0.5 + Math.random() * 0.5) * (1 - timeStep * 0.2) * intensity;
                       
                       ctx.strokeStyle = `${sparkHue}, ${sparkAlpha})`;
                       ctx.lineWidth = 1.5 + heat * 0.5;
                       applyShadow(5 + heat * 3, shadowColor);
                       ctx.lineCap = 'round';
                       ctx.beginPath();
                       ctx.moveTo(sparkEndX, sparkEndY);
                       ctx.lineTo(sparkX, sparkY);
                       ctx.stroke();
                   }
                   
                   // Circular impact ring (expanding shockwave)
                   const ringPhase = (state.frameCount * 0.2 + idx * 2) % (Math.PI * 2);
                   const ringSize = flashSize * (1 + Math.sin(ringPhase) * 0.4);
                   const ringAlpha = (1 - Math.sin(ringPhase)) * 0.3 * intensity;
                   
                   ctx.strokeStyle = `rgba(255, 150, 50, ${ringAlpha})`;
                   ctx.lineWidth = 2;
                   applyShadow(10, '#ff6600');
                   ctx.beginPath();
                   ctx.arc(0, 0, ringSize, 0, Math.PI * 2);
                   ctx.stroke();
                   
                   clearShadow();
                   ctx.restore();
               });
            }
            
            // BEAM IGNITION FLASH (arc strike) - shows during first frames of beam
            if (player.beamIgnitionFlash > 0 && player.beamActive && player.beamActiveTime <= 15) {
                player.beamIgnitionFlash -= scaledDt/16;
                
                const flashProgress = player.beamIgnitionFlash / 15;
                const flashSize = 20 * (1 - flashProgress); // Expands outward
                const flashAlpha = flashProgress * 0.9; // Fades as it expands
                
                ctx.save();
                ctx.translate(player.x, player.y);
                
                // Bright blue-white flash (arc strike)
                ctx.fillStyle = `rgba(200, 220, 255, ${flashAlpha * 0.6})`;
                applyShadow(40, '#aaccff');
                ctx.beginPath();
                ctx.arc(0, 0, flashSize * 2, 0, Math.PI * 2);
                ctx.fill();
                
                // Intense white core
                ctx.fillStyle = `rgba(255, 255, 255, ${flashAlpha})`;
                applyShadow(30, '#ffffff');
                ctx.beginPath();
                ctx.arc(0, 0, flashSize, 0, Math.PI * 2);
                ctx.fill();
                
                // Electric ring burst
                ctx.strokeStyle = `rgba(150, 200, 255, ${flashAlpha * 0.8})`;
                ctx.lineWidth = 3;
                applyShadow(20, '#96c8ff');
                ctx.beginPath();
                ctx.arc(0, 0, flashSize * 1.5, 0, Math.PI * 2);
                ctx.stroke();
                
                clearShadow();
                ctx.restore();
            }
            
            // BEAM TERMINATION FLASH (arc break)
            // PLASMA BEAM TERMINATION - Staggered fade-out with beams dissolving
            if (player.beamTerminationTimer > 0) {
                player.beamTerminationTimer -= scaledDt/16;
                
                if (player.beamTerminationTargets && player.beamTerminationOrder) {
                    const terminationOrder = player.beamTerminationOrder;
                    
                    player.beamTerminationTargets.forEach((target, idx) => {
                        // Calculate staggered termination timing (5 frame delay between beams)
                        const beamOrderIndex = terminationOrder.indexOf(idx);
                        const terminationDelay = beamOrderIndex * 5; // 5 frames between each beam terminating
                        const beamTerminationProgress = (25 - player.beamTerminationTimer - terminationDelay) / 15; // 15 frames fade-out
                        
                        // Skip if this beam hasn't started terminating yet
                        if (beamTerminationProgress < 0) {
                            // Still active - draw full beam
                            const dx = target.x - player.x;
                            const dy = target.y - player.y;
                            
                            ctx.save();
                            
                            // Full opacity beam layers
                            ctx.strokeStyle = 'rgba(255, 0, 255, 0.4)';
                            ctx.lineWidth = 12;
                            ctx.shadowBlur = 25;
                            ctx.shadowColor = '#ff00ff';
                            ctx.lineCap = 'round';
                            ctx.beginPath();
                            ctx.moveTo(player.x, player.y);
                            ctx.lineTo(target.x, target.y);
                            ctx.stroke();
                            
                            ctx.strokeStyle = 'rgba(255, 50, 255, 0.8)';
                            ctx.lineWidth = 6;
                            ctx.shadowBlur = 15;
                            ctx.shadowColor = '#ff66ff';
                            ctx.beginPath();
                            ctx.moveTo(player.x, player.y);
                            ctx.lineTo(target.x, target.y);
                            ctx.stroke();
                            
                            ctx.strokeStyle = 'rgba(255, 255, 255, 0.9)';
                            ctx.lineWidth = 2;
                            ctx.shadowBlur = 10;
                            ctx.shadowColor = '#ffffff';
                            ctx.beginPath();
                            ctx.moveTo(player.x, player.y);
                            ctx.lineTo(target.x, target.y);
                            ctx.stroke();
                            
                            ctx.shadowBlur = 0;
                            ctx.restore();
                            return;
                        }
                        
                        // Terminating - fade out
                        if (beamTerminationProgress > 0 && beamTerminationProgress <= 1) {
                            const fadeAlpha = Math.pow(1 - beamTerminationProgress, 2); // Smooth fade-out curve
                            const dx = target.x - player.x;
                            const dy = target.y - player.y;
                            
                            ctx.save();
                            
                            // Fading beam layers
                            ctx.strokeStyle = `rgba(255, 0, 255, ${0.4 * fadeAlpha})`;
                            ctx.lineWidth = 12 * fadeAlpha;
                            ctx.shadowBlur = 25 * fadeAlpha;
                            ctx.shadowColor = '#ff00ff';
                            ctx.lineCap = 'round';
                            ctx.beginPath();
                            ctx.moveTo(player.x, player.y);
                            ctx.lineTo(target.x, target.y);
                            ctx.stroke();
                            
                            ctx.strokeStyle = `rgba(255, 50, 255, ${0.8 * fadeAlpha})`;
                            ctx.lineWidth = 6 * fadeAlpha;
                            ctx.shadowBlur = 15 * fadeAlpha;
                            ctx.shadowColor = '#ff66ff';
                            ctx.beginPath();
                            ctx.moveTo(player.x, player.y);
                            ctx.lineTo(target.x, target.y);
                            ctx.stroke();
                            
                            ctx.strokeStyle = `rgba(255, 255, 255, ${0.9 * fadeAlpha})`;
                            ctx.lineWidth = 2 * fadeAlpha;
                            ctx.shadowBlur = 10 * fadeAlpha;
                            ctx.shadowColor = '#ffffff';
                            ctx.beginPath();
                            ctx.moveTo(player.x, player.y);
                            ctx.lineTo(target.x, target.y);
                            ctx.stroke();
                            
                            // Termination spark flash at target (when beam just breaks)
                            if (beamTerminationProgress < 0.2) {
                                const sparkAlpha = fadeAlpha * 2;
                                ctx.translate(target.x, target.y);
                                
                                ctx.fillStyle = `rgba(255, 200, 100, ${sparkAlpha * 0.5})`;
                                ctx.shadowBlur = 30 * sparkAlpha;
                                ctx.shadowColor = '#ffcc66';
                                ctx.beginPath();
                                ctx.arc(0, 0, 12, 0, Math.PI * 2);
                                ctx.fill();
                                
                                ctx.fillStyle = `rgba(255, 255, 255, ${sparkAlpha * 0.8})`;
                                ctx.shadowBlur = 20 * sparkAlpha;
                                ctx.shadowColor = '#ffffff';
                                ctx.beginPath();
                                ctx.arc(0, 0, 8, 0, Math.PI * 2);
                                ctx.fill();
                            }
                            
                            ctx.shadowBlur = 0;
                            ctx.restore();
                        }
                    });
                }
            }


            entities.enemyProjectiles = entities.enemyProjectiles.filter(ep => {
                // Early culling for projectiles far from player
                const roughDx = Math.abs(ep.x - player.x);
                const roughDy = Math.abs(ep.y - player.y);
                if(roughDx > 1500 || roughDy > 1500) return false; // Remove distant projectiles
                
                // Homing missiles
                if (ep.homing) {
                    const angle = Math.atan2(player.y - ep.y, player.x - ep.x);
                    const targetVx = Math.cos(angle) * 3.5; // Increased from 3.0
                    const targetVy = Math.sin(angle) * 3.5;
                    ep.vx += (targetVx - ep.vx) * ep.homingStrength;
                    ep.vy += (targetVy - ep.vy) * ep.homingStrength;
                }
                
                // Special rendering for meteor warnings
                if (ep.isMeteorWarning) {
                    ep.life -= (scaledDt/16);
                    
                    const progress = 1 - (ep.life / ep.maxLife);
                    ctx.save();
                    ctx.translate(ep.x, ep.y);
                    
                    // Pulsing danger zone - gets more intense as impact approaches
                    for (let i = 0; i < 3; i++) {
                        const ringProgress = (progress + (i * 0.2)) % 1;
                        const ringAlpha = 0.5 * (1 - ringProgress);
                        const ringRadius = ep.radius * (0.5 + ringProgress * 0.5);
                        ctx.strokeStyle = `rgba(255, 100, 0, ${ringAlpha})`;
                        ctx.lineWidth = 4;
                        ctx.beginPath();
                        ctx.arc(0, 0, ringRadius, 0, Math.PI*2);
                        ctx.stroke();
                    }
                    
                    // Filled danger zone - intensifies
                    const fillAlpha = 0.15 + (progress * 0.25);
                    ctx.fillStyle = `rgba(255, 100, 0, ${fillAlpha})`;
                    ctx.beginPath();
                    ctx.arc(0, 0, ep.radius, 0, Math.PI*2);
                    ctx.fill();
                    
                    // Outer warning ring
                    ctx.strokeStyle = `rgba(255, 0, 0, ${0.8 + Math.sin(progress * 30) * 0.2})`;
                    ctx.lineWidth = 3;
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = 'rgba(255, 100, 0, 0.6)';
                    ctx.beginPath();
                    ctx.arc(0, 0, ep.radius, 0, Math.PI*2);
                    ctx.stroke();
                    ctx.shadowBlur = 0;
                    
                    ctx.restore();
                    
                    return ep.life > 0;
                }
                
                // Homing for DEFLECTED projectiles - track origin enemy
                if (ep.deflected && ep.originEnemy) {
                    // Check if origin enemy is still alive
                    if (ep.originEnemy.hp > 0) {
                        const dx = ep.originEnemy.x - ep.x;
                        const dy = ep.originEnemy.y - ep.y;
                        const dist = Math.sqrt(dx*dx + dy*dy);
                        if (dist > 0) {
                            const turnSpeed = 0.12; // Strong homing for deflected shots
                            const targetAngle = Math.atan2(dy, dx);
                            const currentAngle = Math.atan2(ep.vy, ep.vx);
                            let angleDiff = targetAngle - currentAngle;
                            while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                            while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
                            
                            const newAngle = currentAngle + angleDiff * turnSpeed;
                            const speed = Math.sqrt(ep.vx*ep.vx + ep.vy*ep.vy);
                            ep.vx = Math.cos(newAngle) * speed;
                            ep.vy = Math.sin(newAngle) * speed;
                        }
                    } else {
                        // Origin enemy died, target nearest enemy
                        let nearestEnemy = null;
                        let minDist = Infinity;
                        entities.enemies.forEach(e => {
                            if (e.hp > 0) {
                                const d = Math.sqrt((e.x - ep.x)**2 + (e.y - ep.y)**2);
                                if (d < minDist) {
                                    minDist = d;
                                    nearestEnemy = e;
                                }
                            }
                        });
                        if (nearestEnemy) {
                            ep.originEnemy = nearestEnemy; // Update target
                        }
                    }
                }
                
                // Homing behavior for flagged projectiles
                if (ep.homing && ep.life > 0) {
                    const dx = player.x - ep.x;
                    const dy = player.y - ep.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    if (dist > 0) {
                        const turnSpeed = 0.05; // Gentle homing
                        const targetAngle = Math.atan2(dy, dx);
                        const currentAngle = Math.atan2(ep.vy, ep.vx);
                        let angleDiff = targetAngle - currentAngle;
                        // Normalize angle difference
                        while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                        while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
                        const newAngle = currentAngle + angleDiff * turnSpeed;
                        const speed = Math.sqrt(ep.vx*ep.vx + ep.vy*ep.vy);
                        ep.vx = Math.cos(newAngle) * speed;
                        ep.vy = Math.sin(newAngle) * speed;
                    }
                }
                
                // EMP FIELD SLOW - Slow down enemy projectiles in EMP fields
                let empProjectileSlow = 1.0;
                if (player.empFields && player.empFields.length > 0) {
                    player.empFields.forEach(field => {
                        const dist = Math.sqrt((ep.x - field.x)**2 + (ep.y - field.y)**2);
                        if (dist < field.radius) {
                            empProjectileSlow = 0.4; // 60% slow (move at 40% speed)
                        }
                    });
                }
                
                ep.x += ep.vx * empProjectileSlow * (scaledDt/16); 
                ep.y += ep.vy * empProjectileSlow * (scaledDt/16); 
                ep.life -= (scaledDt/16);
                
                // Homing missile detonation - explodes when life runs out
                if (ep.detonateOnTimeout && ep.life <= 0) {
                    createExplosion(ep.x, ep.y, '#ff3860', 15);
                    return false; // Remove projectile
                }
                
                // Special rendering for DEFLECTED projectiles - purple glow and trail
                if (ep.deflected) {
                    ep.glowPhase = (ep.glowPhase || 0) + 0.2;
                    const glowIntensity = 0.8 + Math.sin(ep.glowPhase) * 0.2;
                    
                    // Create purple trail particles
                    if (Math.random() < 0.3) {
                        entities.particles.push({
                            x: ep.x,
                            y: ep.y,
                            vx: 0,
                            vy: 0,
                            color: '#ff00ff',
                            life: 15,
                            size: ep.radius * 0.8,
                            update: function(dt) {
                                this.life -= dt/16;
                                this.size *= 0.95;
                                return this.life > 0;
                            },
                            draw: function(ctx) {
                                ctx.globalAlpha = this.life / 15;
                                ctx.fillStyle = this.color;
                                ctx.shadowBlur = 10;
                                ctx.shadowColor = this.color;
                                ctx.beginPath();
                                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                                ctx.fill();
                                ctx.globalAlpha = 1;
                                ctx.shadowBlur = 0;
                            }
                        });
                    }
                    
                    // Outer purple glow
                    ctx.shadowBlur = 25 * glowIntensity;
                    ctx.shadowColor = '#ff00ff';
                    ctx.fillStyle = '#ff00ff';
                    ctx.globalAlpha = 0.5;
                    ctx.beginPath();
                    ctx.arc(ep.x, ep.y, ep.radius * 1.5, 0, Math.PI*2);
                    ctx.fill();
                    
                    // Core projectile
                    ctx.globalAlpha = 1;
                    ctx.shadowBlur = 15;
                    ctx.fillStyle = '#ffffff';
                    ctx.beginPath();
                    ctx.arc(ep.x, ep.y, ep.radius, 0, Math.PI*2);
                    ctx.fill();
                    
                    // Inner purple core
                    ctx.shadowBlur = 0;
                    ctx.fillStyle = '#ff00ff';
                    ctx.beginPath();
                    ctx.arc(ep.x, ep.y, ep.radius * 0.6, 0, Math.PI*2);
                    ctx.fill();
                    
                    ctx.globalAlpha = 1;
                    ctx.shadowBlur = 0;
                }
                // Special rendering for splitter shots - HIGHLY VISIBLE
                else if (ep.splitterShot) {
                    ep.glowPhase = (ep.glowPhase || 0) + 0.15;
                    const glowIntensity = 0.7 + Math.sin(ep.glowPhase) * 0.3;
                    
                    // Outer glow
                    ctx.shadowBlur = 25 * glowIntensity;
                    ctx.shadowColor = ep.color;
                    ctx.fillStyle = ep.color;
                    ctx.globalAlpha = 0.4;
                    ctx.beginPath();
                    ctx.arc(ep.x, ep.y, ep.radius * 1.5, 0, Math.PI*2);
                    ctx.fill();
                    
                    // Core projectile
                    ctx.globalAlpha = 1;
                    ctx.shadowBlur = 15;
                    ctx.fillStyle = '#ffffff';
                    ctx.beginPath();
                    ctx.arc(ep.x, ep.y, ep.radius, 0, Math.PI*2);
                    ctx.fill();
                    
                    // Inner bright core
                    ctx.shadowBlur = 0;
                    ctx.fillStyle = ep.color;
                    ctx.beginPath();
                    ctx.arc(ep.x, ep.y, ep.radius * 0.6, 0, Math.PI*2);
                    ctx.fill();
                    
                    ctx.globalAlpha = 1;
                    ctx.shadowBlur = 0;
                }
                // Special rendering for HOMING MISSILES - missile shape with fins
                else if (ep.homing && ep.detonateOnTimeout) {
                    const angle = Math.atan2(ep.vy, ep.vx);
                    
                    ctx.save();
                    ctx.translate(ep.x, ep.y);
                    ctx.rotate(angle);
                    
                    // Red glow/exhaust trail
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = '#ff3860';
                    ctx.fillStyle = '#ff3860';
                    ctx.globalAlpha = 0.6;
                    ctx.beginPath();
                    ctx.arc(-ep.radius, 0, ep.radius * 0.8, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.globalAlpha = 1;
                    
                    // Missile body (elongated)
                    ctx.fillStyle = '#ffffff';
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = '#ff3860';
                    ctx.fillRect(-ep.radius, -ep.radius * 0.5, ep.radius * 2.5, ep.radius);
                    
                    // Nose cone (pointed front)
                    ctx.fillStyle = '#ff3860';
                    ctx.beginPath();
                    ctx.moveTo(ep.radius * 2.5, -ep.radius * 0.5);
                    ctx.lineTo(ep.radius * 3.5, 0);
                    ctx.lineTo(ep.radius * 2.5, ep.radius * 0.5);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Fins (small triangular wings)
                    ctx.fillStyle = '#ff6b9d';
                    ctx.beginPath();
                    // Top fin
                    ctx.moveTo(ep.radius * 0.5, -ep.radius * 0.5);
                    ctx.lineTo(ep.radius * 0.5, -ep.radius * 1.2);
                    ctx.lineTo(ep.radius * 1.5, -ep.radius * 0.5);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Bottom fin
                    ctx.beginPath();
                    ctx.moveTo(ep.radius * 0.5, ep.radius * 0.5);
                    ctx.lineTo(ep.radius * 0.5, ep.radius * 1.2);
                    ctx.lineTo(ep.radius * 1.5, ep.radius * 0.5);
                    ctx.closePath();
                    ctx.fill();
                    
                    ctx.shadowBlur = 0;
                    ctx.restore();
                } else {
                    // Regular enemy projectiles - assign colors based on type
                    if (!ep.color) {
                        // Default colors based on source
                        if (ep.type === 'boss_turret') {
                            ep.color = '#00a8ff'; // Blue for boss turrets
                        } else if (ep.type === 'meteor') {
                            ep.color = '#00ff64'; // Green for meteors
                        } else {
                            ep.color = '#ff0000'; // Red default (boss core)
                        }
                    }
                    
                    ctx.fillStyle = ep.color; 
                    ctx.beginPath(); 
                    ctx.arc(ep.x, ep.y, ep.radius, 0, Math.PI*2); 
                    ctx.fill();
                }
                
                const dx = player.x - ep.x; const dy = player.y - ep.y;
                
                // Deflected projectiles damage enemies along their path
                if (ep.deflected) {
                    let hitAnyEnemy = false;
                    for(let e of entities.enemies) {
                        if (ep.hitEnemies && ep.hitEnemies.includes(e)) continue; // Skip already hit
                        
                        const edx = e.x - ep.x;
                        const edy = e.y - ep.y;
                        const dist = Math.sqrt(edx*edx + edy*edy);
                        
                        if(dist < e.radius + ep.radius) {
                            // Check if this is the origin enemy for auto-crit
                            const isOriginEnemy = (ep.originEnemy && ep.originEnemy === e);
                            
                            if (isOriginEnemy) {
                                // AUTO-CRIT on origin enemy at full strength
                                const originalCrit = player.critChance;
                                player.critChance = 1.0; // 100% crit chance
                                player.dealElementalDamage(e, ep.deflectedDamage, 'whip', '#ff00ff');
                                player.critChance = originalCrit;
                                hitAnyEnemy = true;
                                break; // Remove projectile after hitting origin
                            } else {
                                // 50% damage to other enemies in path
                                player.dealElementalDamage(e, ep.deflectedDamage * 0.5, 'whip', '#ff00ff', false);
                                if (!ep.hitEnemies) ep.hitEnemies = [];
                                ep.hitEnemies.push(e);
                                // Don't break - continue through enemies
                            }
                        }
                    }
                    if (hitAnyEnemy) return false; // Remove projectile if hit origin
                }
                
                // Splitter shots from hacked splitters damage enemies instead of player
                if (ep.splitterShot && !ep.targetWasPlayer) {
                    let hitAnyEnemy = false;
                    
                    // If piercing, check all enemies and hit each once
                    if (ep.piercing) {
                        for(let e of entities.enemies) {
                            if (e.hackState.active) continue; // Don't hit other hacked enemies
                            
                            // Check if we've already hit this enemy
                            if (ep.hitEnemies.has(e)) continue;
                            
                            const edx = e.x - ep.x;
                            const edy = e.y - ep.y;
                            const dist = Math.sqrt(edx*edx + edy*edy);
                            
                            if(dist < e.radius + ep.radius) {
                                e.takeDamage(25, '#00ffff', false, 'normal'); // Decent damage, hacked color
                                createExplosion(ep.x, ep.y, '#00ffff', 8);
                                for(let i=0; i<6; i++) {
                                    entities.particles.push(new Particle(ep.x, ep.y, '#00ffff', 1.5));
                                }
                                ep.hitEnemies.add(e); // Mark this enemy as hit
                                hitAnyEnemy = true;
                                // Don't break - keep going to hit other enemies
                            }
                        }
                        // Piercing projectiles only die when life runs out, not on hit
                    } else {
                        // Non-piercing: old behavior (stop on first hit)
                        for(let e of entities.enemies) {
                            if (e.hackState.active) continue;
                            const edx = e.x - ep.x;
                            const edy = e.y - ep.y;
                            const dist = Math.sqrt(edx*edx + edy*edy);
                            if(dist < e.radius + ep.radius) {
                                e.takeDamage(25, '#ff9500', false, 'normal');
                                createExplosion(ep.x, ep.y, '#ff9500', 8);
                                for(let i=0; i<6; i++) {
                                    entities.particles.push(new Particle(ep.x, ep.y, '#ff9500', 1.5));
                                }
                                return false; // Stop projectile
                            }
                        }
                    }
                }
                
                // Normal collision with player (for non-hacked shots or hacked shots that missed enemies)
                if(Math.sqrt(dx*dx + dy*dy) < player.radius + ep.radius) {
                    if (player.invulnTimer <= 0) { 
                        const sourceType = ep.splitterShot ? 'SPLITTER' : (ep.fromBoss ? 'BOSS' : 'ENEMY');
                        player.takeHit(ep.splitterShot ? 20 : 15, 'Projectile', sourceType);
                        if(ep.splitterShot) {
                            createExplosion(ep.x, ep.y, '#ff9500', 10);
                        }
                        return false;
                    }
                }
                return ep.life > 0;
            });


            // ‚ö° SPATIAL GRID OPTIMIZATION - Populate grid with enemies for fast collision lookups
            spatialGrid.clear();
            entities.enemies.forEach(e => {
                if (e.hp > 0 && e.active !== false) {
                    spatialGrid.insert(e, e.x, e.y);
                }
            });

            entities.projectiles = entities.projectiles.filter(p => {
                const active = p.update(scaledDt);
                if(!active) return false;
                if (p.type !== 'meteor_warning' && p.type !== 'mine' && p.type !== 'grenade' && p.type !== 'railgun' && p.type !== 'flak_shell' && p.type !== 'bio_spore' && p.type !== 'ricochet' && p.type !== 'emp_pulse' && p.type !== 'surge' && p.source !== 'orbital') {
                    let hit = false;
                    // ‚ö° OPTIMIZED: Use spatial grid instead of checking ALL enemies
                    // Before: 100 projectiles √ó 50 enemies = 5000 checks/frame
                    // After: 100 projectiles √ó ~8 enemies = 800 checks/frame (87% reduction!)
                    const nearbyEnemies = spatialGrid.getNearby(p.x, p.y, 100);
                    
                    for(let e of nearbyEnemies) {
                        // Skip inactive or dead enemies (including destroyed boss shields)
                        if (e.hp <= 0 || (e.active === false)) continue;
                        
                        const dx = p.x - e.x; const dy = p.y - e.y;
                        const roughDist = Math.abs(dx) + Math.abs(dy); // Manhattan distance (faster)
                        if (roughDist < 60) { // Quick early rejection
                            if(Math.sqrt(dx*dx + dy*dy) < e.radius+10) {
                                let hitColor = '#ffffff';
                                if(p.type === 'seeker') hitColor = '#ff5500';
                                
                                player.dealElementalDamage(e, p.damage, p.source, hitColor);
                                
                                // DRONE ROCKET SPLASH DAMAGE
                                if (p.type === 'drone_rocket' && p.hasSplash) {
                                    createExplosion(p.x, p.y, '#ff8800', 12);
                                    const splashRangeSq = p.splashRange * p.splashRange;
                                    
                                    // ‚ö° OPTIMIZED: Apply splash damage to nearby enemies using spatial grid
                                    const splashNearby = spatialGrid.getNearby(p.x, p.y, p.splashRange);
                                    splashNearby.forEach(splashTarget => {
                                        if (splashTarget === e || splashTarget.hp <= 0) return;
                                        
                                        const dx = splashTarget.x - p.x;
                                        const dy = splashTarget.y - p.y;
                                        const distSq = dx*dx + dy*dy;
                                        
                                        if (distSq < splashRangeSq) {
                                            player.dealElementalDamage(splashTarget, p.splashDamage, p.source, '#ff8800');
                                        }
                                    });
                                }
                                
                                hit=true; 
                                if (p.type === 'seeker') {
                                    // Main explosion particles
                                    createExplosion(p.x, p.y, '#ff5500', 8);
                                    
                                    // Bright flash particles in explosion core
                                    for (let i = 0; i < 4; i++) {
                                        entities.particles.push({
                                            x: p.x,
                                            y: p.y,
                                            vx: 0,
                                            vy: 0,
                                            color: '#ffffff',
                                            life: 6,
                                            size: 12 - i * 2,
                                            update: function(dt) {
                                                this.life -= dt/16;
                                                this.size *= 0.85;
                                                return this.life > 0;
                                            },
                                            draw: function(ctx) {
                                                ctx.globalAlpha = this.life / 6;
                                                ctx.fillStyle = this.color;
                                                ctx.shadowBlur = 20;
                                                ctx.shadowColor = '#ff5500';
                                                ctx.beginPath();
                                                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                                                ctx.fill();
                                                ctx.shadowBlur = 0;
                                                ctx.globalAlpha = 1;
                                            }
                                        });
                                    }
                                    
                                    // Directional shrapnel burst (8 directions)
                                    if (entities.particles.length < 160) {
                                        for (let i = 0; i < 8; i++) {
                                            const angle = (i / 8) * Math.PI * 2;
                                            const speed = 4 + Math.random() * 3;
                                            entities.particles.push({
                                                x: p.x,
                                                y: p.y,
                                                vx: Math.cos(angle) * speed,
                                                vy: Math.sin(angle) * speed,
                                                color: i % 2 === 0 ? '#ffaa00' : '#ff5500',
                                                life: 12,
                                                size: 3,
                                                update: function(dt) {
                                                    this.x += this.vx * (dt/16);
                                                    this.y += this.vy * (dt/16);
                                                    this.vx *= 0.93;
                                                    this.vy *= 0.93;
                                                    this.life -= dt/16;
                                                    this.size *= 0.92;
                                                    return this.life > 0;
                                                },
                                                draw: function(ctx) {
                                                    ctx.globalAlpha = this.life / 12;
                                                    ctx.fillStyle = this.color;
                                                    ctx.shadowBlur = 8;
                                                    ctx.shadowColor = this.color;
                                                    ctx.beginPath();
                                                    ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                                                    ctx.fill();
                                                    ctx.shadowBlur = 0;
                                                    ctx.globalAlpha = 1;
                                                }
                                            });
                                        }
                                    }
                                    
                                    // Expanding shockwave ring
                                    entities.particles.push(new Shockwave(p.x, p.y, 75, '#ff7733'));
                                    
                                    // Secondary inner ring for depth
                                    entities.particles.push({
                                        x: p.x,
                                        y: p.y,
                                        radius: 5,
                                        maxRadius: 50,
                                        life: 15,
                                        update: function(dt) {
                                            this.radius += (this.maxRadius - this.radius) * 0.15 * (dt/16);
                                            this.life -= dt/16;
                                            return this.life > 0;
                                        },
                                        draw: function(ctx) {
                                            ctx.globalAlpha = this.life / 15;
                                            ctx.strokeStyle = '#ffaa00';
                                            ctx.lineWidth = 2;
                                            ctx.shadowBlur = 8;
                                            ctx.shadowColor = '#ffaa00';
                                            ctx.beginPath();
                                            ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                                            ctx.stroke();
                                            ctx.shadowBlur = 0;
                                            ctx.globalAlpha = 1;
                                        }
                                    });
                                    
                                    // SPLASH DAMAGE: Damage OTHER enemies in radius (not the primary target)
                                    const splashDist = 75;
                                    const splashDistSq = splashDist * splashDist;
                                    // ‚ö° OPTIMIZED: Use spatial grid instead of checking all enemies
                                    const splashNearby = spatialGrid.getNearby(p.x, p.y, splashDist);
                                    splashNearby.forEach(subE => {
                                        // Skip the primary target (already took full damage)
                                        if (subE === e) return;
                                        
                                        const sdx = p.x - subE.x;
                                        const sdy = p.y - subE.y;
                                        const distSq = sdx*sdx + sdy*sdy;
                                        if(distSq < splashDistSq) {
                                            player.dealElementalDamage(subE, p.damage * 0.5, 'seeker', '#ffffff');
                                        }
                                    });
                                }
                                if(p.pierce>0) { p.pierce--; hit=false; } else break;
                            }
                        }
                    }
                    if(hit) return false;
                }
                
                // SURGE PROJECTILE - AOE elemental orbs (no pierce, explodes on impact)
                if (p.type === 'surge') {
                    // Prevent multiple explosions from same orb
                    if (p.hasExploded) {
                        return false; // Already exploded, remove it
                    }
                    
                    let hitEnemy = false;
                    
                    // ‚ö° OPTIMIZED: Use spatial grid for initial collision check
                    const nearbyEnemies = spatialGrid.getNearby(p.x, p.y, 100);
                    for(let e of nearbyEnemies) {
                        if (e.hp <= 0 || (e.active === false)) continue;
                        
                        const dx = p.x - e.x;
                        const dy = p.y - e.y;
                        const distSq = dx*dx + dy*dy; // ‚ö° Use squared distance
                        const collisionRadiusSq = (e.radius + p.radius) * (e.radius + p.radius);
                        
                        if(distSq < collisionRadiusSq) {
                            // Mark as exploded to prevent re-triggering
                            p.hasExploded = true;
                            hitEnemy = true;
                            
                            // Create small AOE explosion effect
                            createExplosion(p.x, p.y, p.color, 25);
                            
                            // Damage all enemies in AOE (only once per orb)
                            const aoeRadius = 50; // Small AOE radius - catches 1-2 nearby enemies
                            const aoeRadiusSq = aoeRadius * aoeRadius;
                            const damagedEnemies = new Set(); // Track to prevent double-hit
                            
                            // ‚ö° OPTIMIZED: Use spatial grid for AOE damage too
                            const aoeNearby = spatialGrid.getNearby(p.x, p.y, aoeRadius + 50);
                            aoeNearby.forEach(target => {
                                if (target.hp <= 0 || (target.active === false)) return;
                                if (damagedEnemies.has(target)) return; // Already hit this enemy
                                
                                const aoeDistX = target.x - p.x;
                                const aoeDistY = target.y - p.y;
                                const aoeDistSq = aoeDistX*aoeDistX + aoeDistY*aoeDistY;
                                const targetRadiusSq = (aoeRadius + target.radius) * (aoeRadius + target.radius);
                                
                                if (aoeDistSq < targetRadiusSq) {
                                    damagedEnemies.add(target);
                                    
                                    // Damage falls off with distance (100% at center, 50% at edge)
                                    const aoeDist = Math.sqrt(aoeDistSq);
                                    const damageMult = 1.0 - (aoeDist / aoeRadius) * 0.5;
                                    const aoeDamage = p.damage * damageMult;
                                    
                                    // Deal elemental damage with proc chance
                                    player.dealElementalDamage(target, aoeDamage, 'surge', p.color, true, 'normal', p.element);
                                    
                                    // Visual feedback
                                    for (let i = 0; i < 4; i++) {
                                        entities.particles.push(new Particle(target.x, target.y, p.color, 2));
                                    }
                                }
                            });
                            
                            // NO AURA - removed for clean gameplay
                            
                            // Track hits for CATALYST ship resonance burst
                            if (player.selectedShip === 'CATALYST') {
                                player.surgeHitCount++;
                                
                                // Trigger burst every 5th hit
                                if (player.surgeHitCount >= 5) {
                                    // Use the current orb's element for the burst
                                    triggerResonanceBurst(p.element, p.x, p.y, player.weaponStats.surge.area);
                                    player.surgeHitCount = 0;
                                }
                            }
                            
                            // Orb destroyed on impact
                            return false;
                        }
                    }
                }
                
                p.draw(ctx); return true;
            });


            ctx.restore();
            
            // Draw offscreen indicators AFTER restore so they're on top of all game elements
            drawIndicators();
            
            if (state.timeScale < 0.9) {
                ctx.fillStyle = `rgba(0, 20, 40, ${0.4 * (1 - state.timeScale)})`; 
                ctx.fillRect(0, 0, width, height);
            }
            
            // NEXUS PRIME DEATH SCREEN FLASH
            if (state.finalBoss && state.finalBoss.deathFlash > 0) {
                const flashIntensity = Math.min(1, state.finalBoss.deathFlash);
                ctx.fillStyle = `rgba(255, 255, 255, ${flashIntensity * 0.6})`;
                ctx.fillRect(0, 0, width, height);
                
                // Fade out the flash
                state.finalBoss.deathFlash *= 0.92;
                if (state.finalBoss.deathFlash < 0.01) state.finalBoss.deathFlash = 0;
            }
            
            // Update HUD every ~33ms (30 times per second) for smooth cooldown radars
            if (!state.lastHudUpdate) state.lastHudUpdate = 0;
            if (now - state.lastHudUpdate >= 33) {
                updateHud();
                updateUltimateButton();
                state.lastHudUpdate = now;
            }
        }


        // --- RPG Logic ---


        function gainXp(amt) {
            state.xp += Math.ceil(amt); 
            state.score += 10;
            
            // Apply Ascension score multiplier
            if (state.activeAscension > 0) {
                const ascensionData = {
                    1: 2.0, 2: 3.0, 3: 4.0, 4: 5.0, 5: 6.0
                };
                const multiplier = ascensionData[state.activeAscension] || 1.0;
                state.score += Math.floor(10 * (multiplier - 1)); // Bonus score from ascension
            }
            
            let nextCurve;
            
            // Faster early game: reduced XP for levels 1-5
            if (state.level < 5) nextCurve = 8 + (state.level * 6); // 14, 20, 26, 32 (was 20, 30, 40, 50)
            else if (state.level < 10) nextCurve = 10 + (state.level * 10); // 60, 70, 80, 90, 100
            else if (state.level < 30) nextCurve = 110 + ((state.level - 10) * 15); // Linear through level 30
            else if (state.level < 35) nextCurve = 410 + ((state.level - 30) * 20); // +20 per level: 30-34 (smoother transition)
            else if (state.level < 45) nextCurve = 510 + ((state.level - 35) * 12); // +12 per level: 35-44 (was +15, reduced to make less grindy)
            else nextCurve = 630 + ((state.level - 45) * 8); // Final stretch 45-50: +8 per level (was +12, gentle finish) 


            if(state.xp >= state.xpToNext && state.level < 50) { // Cap at level 50
                state.level++; state.xp=0; state.xpToNext = nextCurve;
                
                console.log(`‚¨ÜÔ∏è LEVEL UP to ${state.level} (screen: ${state.screen}, queue length: ${state.upgradeQueue ? state.upgradeQueue.length : 0})`);
                
                // CRITICAL: Trigger NEXUS PRIME immediately on level 50 (NO level-up screen!)
                if (state.level === 50 && !state.finalBossTriggered) {
                    console.log('‚ö° Level 50 hit - triggering NEXUS PRIME immediately (NO LEVEL-UP)');
                    state.finalBossTriggered = true;
                    state.finalBossActive = true; // Set IMMEDIATELY to stop spawns
                    
                    // Clear all XP gems from screen
                    entities.pickups = entities.pickups.filter(p => p.type !== 'xp');
                    
                    // Trigger boss spawn (this will clear remaining pickups)
                    triggerNexusPrime();
                    
                    // Don't queue any level-up for level 50 - boss fight starts immediately
                    return; // Exit early, skip level-up queue
                }
                
                // Determine if this level is elemental
                const isElementalLevel = state.level >= 10 && (state.level === 10 || (state.level - 10) % 10 === 0);
                
                // Rerolls at levels 10, 20, 30, etc (elemental levels)
                if (isElementalLevel) state.rerolls++;
                
                // Queue this level-up with its type
                if (!state.levelUpQueue) state.levelUpQueue = [];
                state.levelUpQueue.push({
                    level: state.level,
                    isElemental: isElementalLevel
                });
                
                // Add to unified upgrade queue
                if (!state.upgradeQueue) state.upgradeQueue = [];
                state.upgradeQueue.push({ type: 'levelup' });
                
                console.log(`   ‚úÖ Queued level up (total in queue: ${state.upgradeQueue.length})`);
                
                state.pendingLevelUps++;
                // Don't show levelup screen immediately - let game loop handle it after XP collection completes
            } else if (state.level >= 50) {
                // At level 50, cap XP at xpToNext to prevent overflow
                state.xp = Math.min(state.xp, state.xpToNext);
            }
        }


        function rerollUpgrades() { if(state.rerolls > 0) { state.rerolls--; generateCards(); } }
        
        function toggleSaveMode() {
            if (state.saveCharges <= 0) return;
            window.upgradesSaveMode = !window.upgradesSaveMode;
            const saveBtn = document.getElementById('save-btn');
            const cards = document.querySelectorAll('#cards-container .card');
            if (window.upgradesSaveMode) {
                saveBtn.innerHTML = '<i class="fas fa-times"></i> CANCEL';
                saveBtn.style.background = '#ff3860';
                cards.forEach(card => { if (!card.classList.contains('disabled')) card.classList.add('save-mode'); });
            } else {
                saveBtn.innerHTML = '<i class="fas fa-save"></i> SAVE (<span id="save-count">' + state.saveCharges + '</span>)';
                saveBtn.style.background = '#00d1b2';
                cards.forEach(card => card.classList.remove('save-mode'));
            }
        }


        function processNextUpgrade() {
            if (!state.upgradeQueue || state.upgradeQueue.length === 0) return;
            
            console.log(`üìã Processing next upgrade (queue length: ${state.upgradeQueue.length}, screen: ${state.screen})`);
            
            const nextUpgrade = state.upgradeQueue[0]; // Peek at first item, don't remove yet
            
            if (nextUpgrade.type === 'levelup') {
                console.log('   ‚Üí Showing level up screen');
                showLevelUp();
            } else if (nextUpgrade.type === 'ultimate') {
                console.log('   ‚Üí Showing ultimate selection');
                showUltimateSelection();
            }
        }

        function showLevelUp() {
            state.screen = 'levelup';
            entities.projectiles = entities.projectiles.filter(p => p.type === 'mine' || p.type === 'grenade' || p.type === 'meteor_warning' || p.type === 'railgun');
            document.getElementById('levelup-screen').classList.add('active');
            
            // Show Lock Kit Toggle if slots full
            const full = player.getActiveWeaponCount() >= 4;
            document.getElementById('lock-kit-toggle').style.display = full ? 'flex' : 'none';
            
            // Auto-enable kit lock when all slots are filled, but ONLY if user hasn't manually changed it
            if (full && !state.kitLocked && !state.lockUsed) {
                state.kitLocked = true;
                state.lockUsed = true; // Mark that we've auto-enabled it once
                document.getElementById('lock-kit-toggle').classList.add('toggle-active');
            }
            
            // Show pending upgrades counter if multiple level ups
            const pendingDiv = document.getElementById('pending-upgrades');
            const pendingCount = document.getElementById('pending-count');
            if (state.pendingLevelUps > 1) {
                pendingDiv.style.display = 'block';
                pendingCount.textContent = state.pendingLevelUps;
            } else {
                pendingDiv.style.display = 'none';
            }
            
            generateCards();
        }
        
        function showUltimateSelection() {
            console.log('üéÅ Showing ultimate selection screen');
            state.screen = 'levelup'; // Reuse levelup screen
            document.getElementById('levelup-screen').classList.add('active');
            
            // Update title and subtitle
            document.getElementById('lvl-title').innerText = "TITAN DEFEATED";
            document.getElementById('lvl-title').className = "text-3xl font-bold mb-1";
            document.getElementById('lvl-title').style.color = '#ff00ff'; // Magenta
            document.getElementById('lvl-subtitle').innerText = "Choose an Ultimate Ability";
            
            // Hide normal level-up elements
            document.getElementById('lock-kit-toggle').style.display = 'none';
            document.getElementById('pending-upgrades').style.display = 'none';
            document.getElementById('reroll-btn').style.display = 'none';
            document.getElementById('save-btn').style.display = 'none';
            
            // Generate 2 random ultimates to choose from
            const ultimateIds = Object.keys(ULTIMATES);
            const shuffled = ultimateIds.sort(() => seededRandom() - 0.5);
            const choices = [shuffled[0], shuffled[1]];
            
            // If player already has an ultimate, add "Keep Current" option
            if (player.ultimate) {
                choices.push('keep_current');
            }
            
            console.log('Ultimate choices:', choices);
            
            // Create ultimate choice cards using EXACT card structure
            const container = document.getElementById('cards-container');
            container.innerHTML = ''; // Clear existing cards
            
            choices.forEach(ultId => {
                let ultData;
                let isKeepCurrent = false;
                
                if (ultId === 'keep_current') {
                    // Special "Keep Current" card
                    isKeepCurrent = true;
                    ultData = {
                        name: `Keep ${ULTIMATES[player.ultimate].name}`,
                        desc: `Continue using your current ultimate ability`,
                        icon: ULTIMATES[player.ultimate].icon
                    };
                } else {
                    ultData = ULTIMATES[ultId];
                }
                
                // Create card with exact structure from createCard
                const card = document.createElement('div');
                // Style Keep Current differently (like skip button)
                card.className = isKeepCurrent ? 'card skip-style' : 'card ultimate';
                
                card.innerHTML = `
                    <div class="card-header">
                        <i class="fas ${ultData.icon}"></i>
                    </div>
                    <div class="card-content">
                        <h3>${ultData.name}</h3>
                        <p>${ultData.desc}</p>
                    </div>
                `;
                
                // Add particles (skip for Keep Current, magenta for new ultimates)
                const particleCount = isKeepCurrent ? 8 : 12;
                const particleColor = isKeepCurrent ? '#888888' : '#ff00ff';
                for (let i = 0; i < particleCount; i++) {
                    const particle = document.createElement('div');
                    particle.className = 'legendary-particle';
                    particle.style.setProperty('--start-x', `${seededRandom() * 100}%`);
                    particle.style.setProperty('--drift-x', `${(seededRandom() - 0.5) * 60}px`);
                    particle.style.setProperty('--delay', `${seededRandom() * 2}s`);
                    // Use color based on card type
                    particle.style.background = particleColor;
                    particle.style.boxShadow = `0 0 6px ${particleColor}`;
                    card.appendChild(particle);
                }
                
                card.onclick = () => {
                    if (card.classList.contains('disabled')) return;
                    card.classList.add('disabled');
                    
                    if (isKeepCurrent) {
                        // Keep current ultimate - don't reset charge or state
                        console.log(`‚úÖ Keeping current ultimate: ${ULTIMATES[player.ultimate].name}`);
                    } else {
                        // New ultimate - start at full charge, ready to use
                        player.ultimate = ultId;
                        player.ultimateCharge = 100; // Start at full charge
                        player.ultimateActive = false; // Clear active state
                        player.ultimateData = {}; // Clear any lingering ultimate data
                        console.log(`‚úÖ Ultimate equipped: ${ultData.name} (ready to fire!)`);
                    }
                    
                    document.getElementById('levelup-screen').classList.remove('active');
                    state.screen = 'game';
                    player.invulnTimer = 120; // Brief invulnerability
                    resumeGame(); // Remove the ultimate selection from queue
                };
                
                container.appendChild(card);
            });
        }

        function generateCards() {
            const container = document.getElementById('cards-container');
            container.innerHTML = '';
            const btn = document.getElementById('reroll-btn');
            const saveBtn = document.getElementById('save-btn');
            
            // Update counts if elements exist
            const rerollCount = document.getElementById('reroll-count');
            const saveCount = document.getElementById('save-count');
            
            if (rerollCount) rerollCount.innerText = state.rerolls;
            if (saveCount) saveCount.innerText = state.saveCharges;
            
            // Get current level-up from queue (default to checking state.level if queue doesn't exist)
            const currentLevelUp = state.levelUpQueue && state.levelUpQueue.length > 0 
                ? state.levelUpQueue[0] 
                : { level: state.level, isElemental: state.level >= 10 && (state.level === 10 || (state.level - 10) % 10 === 0) };
            
            if (currentLevelUp.isElemental) {
                document.getElementById('lvl-subtitle').innerText = "ELEMENTAL SYNERGY";
                document.getElementById('lvl-title').innerText = "ELEMENTAL SYNERGY";
                document.getElementById('lvl-title').className = "text-3xl text-red-500 font-bold mb-1";
                btn.style.display = 'none';
                saveBtn.style.display = 'none';
                const unlockedWeapons = Object.keys(player.weapons).filter(k => player.weapons[k] > 0 && k !== 'surge'); // Surge has built-in elements
                if (unlockedWeapons.length === 0) unlockedWeapons.push('ion'); 

                // Separate weapons into those with and without elements
                const weaponsWithoutElements = unlockedWeapons.filter(w => !player.weaponAugments[w]);
                const weaponsWithElements = unlockedWeapons.filter(w => player.weaponAugments[w]);

                const generatedAugments = new Set();
                let attempts = 0;
                let guaranteedSlotFilled = false;
                
                while(generatedAugments.size < 4 && attempts < 50) { 
                    attempts++;
                    
                    // First slot MUST be for weapon without element if any exist
                    let weap;
                    if (!guaranteedSlotFilled && weaponsWithoutElements.length > 0) {
                        weap = weaponsWithoutElements[Math.floor(seededRandom() * weaponsWithoutElements.length)];
                        guaranteedSlotFilled = true;
                    } else {
                        // After guaranteed slot or if all have elements, use all weapons
                        weap = unlockedWeapons[Math.floor(seededRandom() * unlockedWeapons.length)];
                    }
                    
                    const el = elementalDefs[Math.floor(seededRandom() * elementalDefs.length)];
                    const key = `${weap}-${el.id}`;
                    if(generatedAugments.has(key)) continue;


                    generatedAugments.add(key);
                    const wName = weaponDefs[weap].name;
                    const currentAug = player.weaponAugments[weap];
                    const hasAugment = currentAug !== null;
                    const elName = `${wName} ${el.name.split(' ')[0]}`; 
                    let desc = `${el.desc}`; // Use actual element description
                    if (hasAugment) {
                        const currentElName = elementalDefs.find(e => e.id === currentAug).name.split(' ')[0];
                        desc = `Replace ${currentElName} with ${el.name.split(' ')[0]}. ${el.desc}`;
                    }
                    createCard(container, elName, desc, el.icon, 'elemental', (e) => {
                        if(e.target.closest('.card').classList.contains('disabled')) return;
                        e.target.closest('.card').classList.add('disabled');
                        player.weaponAugments[weap] = el.id; // Set single augment (replaces old)
                        resumeGame();
                    }, null, null, true, el.id); // isElementalAugment=true, augmentElement=el.id
                }
                
                // Add "Skip" option
                createCard(container, 'Skip Elemental', 'Continue without adding an elemental augment.', 'fa-forward', 'skip', (e) => {
                    if(e.target.closest('.card').classList.contains('disabled')) return;
                    e.target.closest('.card').classList.add('disabled');
                    resumeGame();
                }, null, null, false, null);
                
                return;
            }


            document.getElementById('lvl-subtitle').innerText = "SELECT SYSTEM AUGMENT";
            document.getElementById('lvl-title').innerText = "SYSTEM UPGRADE";
            document.getElementById('lvl-title').className = "text-3xl text-yellow-400 font-bold mb-1";
            btn.style.display = 'flex'; btn.disabled = state.rerolls <= 0;
            saveBtn.style.display = 'flex'; 
            saveBtn.disabled = state.saveCharges <= 0;
            saveBtn.style.background = '#00d1b2'; // Reset to teal
            window.upgradesSaveMode = false; // Ensure save mode is off


            let options = []; let offensivePool = []; let otherPool = [];
            Object.keys(weaponDefs).forEach(k => { 
                const weaponDef = weaponDefs[k];
                // Filter weapons by ship: only show if no ship lock OR matches player's ship
                if (k !== 'multi' && (!weaponDef.shipLocked || weaponDef.shipLocked === player.selectedShip)) {
                    offensivePool.push({ ...weaponDef, id: k });
                }
            });
            statDefs.forEach(s => { 
                // Flux Emitter only available at level 10+ (when elementals unlock)
                if (s.id === 'elem' && state.level < 10) return;
                if (s.offensive) offensivePool.push(s); 
                else otherPool.push(s); 
            });

            // Add Elemental Masteries (Level 10+, only for elements player has)
            if (state.level >= 10) {
                Object.keys(masteryDefs).forEach(elemId => {
                    // Check if player has this element on any weapon
                    const hasElement = Object.values(player.weaponAugments).includes(elemId);
                    // Check if already taken
                    const alreadyTaken = player.elementalMasteries[elemId];
                    if (hasElement && !alreadyTaken) {
                        // Add masteries 3 times to increase appearance rate
                        offensivePool.push(masteryDefs[elemId]);
                        offensivePool.push(masteryDefs[elemId]);
                        offensivePool.push(masteryDefs[elemId]);
                    }
                });
            }

            // Add Synergies (Level 20+, only for element pairs player has)
            if (state.level >= 20) {
                Object.keys(synergyDefs).forEach(synId => {
                    const syn = synergyDefs[synId];
                    // Check if player has both elements
                    const hasElem1 = Object.values(player.weaponAugments).includes(syn.elements[0]);
                    const hasElem2 = Object.values(player.weaponAugments).includes(syn.elements[1]);
                    // Check if already taken
                    const alreadyTaken = player.synergies[synId];
                    if (hasElem1 && hasElem2 && !alreadyTaken) {
                        // Add synergies 4 times to increase appearance rate (rarer than masteries)
                        offensivePool.push(syn);
                        offensivePool.push(syn);
                        offensivePool.push(syn);
                        offensivePool.push(syn);
                    }
                });
            }


            // Multistrike is now always available (no mod required)
            
            const fullWeaponCount = player.getActiveWeaponCount();
            
            // 1. FORCE WEAPON IF SLOT OPEN
            const forcedWeapon = fullWeaponCount < 4;
            const locked = state.kitLocked && fullWeaponCount >= 4;


            // Build Weighted Pool Logic
            const getRarity = (luck) => {
                 const r = seededRandom() + (luck * 0.0002); // Reduced from 0.0003 (33% nerf)
                 // Adjusted rates: C:50, U:30, R:15, E:4.5, L:0.5
                 if (r > 0.995) return 'legendary'; // 0.5% (was 2%)
                 if (r > 0.955) return 'epic';      // 4% (was 8%)
                 if (r > 0.80) return 'rare';       // 15.5% (was 15%)
                 if (r > 0.50) return 'uncommon';   // 30% (was 25%)
                 return 'common';                    // 50% (was 50%)
            };


            const pickedIds = new Set();
            const createOption = (forceType = null) => {
                 let pool = [...offensivePool, ...otherPool];
                 
                 // Remove magnet (pickup) from pool if at cap (6 upgrades)
                 if (player.pickupUpgradeCount >= 6) {
                     pool = pool.filter(o => o.id !== 'pickup');
                 }
                 
                 // MULTISTRIKE SYSTEM: Filter based on unlock status
                 if (!player.multistrikeUnlocked) {
                     // Not unlocked - remove multistrike stat upgrades from pool
                     pool = pool.filter(o => o.id !== 'multi');
                     
                     // Add unlock card at same rate as masteries/synergies (10% weight)
                     const multiUnlock = {
                         id: 'multi_unlock',
                         type: 'unlock',
                         name: 'Double Tap',
                         desc: 'Unlock Multistrike: Active weapons gain a chance to fire twice.',
                         icon: 'fa-bolt',
                         offensive: true
                         // rarity set to 'epic' in assignRarityToChoice
                     };
                     pool.push(multiUnlock); // Added once = 10% weight (same as masteries/synergies)
                 }
                 
                 if (locked) {
                     pool = pool.filter(o => o.type !== 'weapon' || player.weapons[o.id] > 0);
                 } else if (forceType === 'new_weapon') {
                     // Count current weapons (excluding multi/nuke, but INCLUDING surge)
                     const weaponCount = Object.keys(player.weapons).filter(k => player.weapons[k] > 0 && k !== 'multi' && k !== 'nuke').length;
                     if (weaponCount >= 4) {
                         // At limit - offer upgrades instead
                         pool = offensivePool.filter(o => o.type === 'weapon' && player.weapons[o.id] > 0);
                     } else {
                         pool = offensivePool.filter(o => o.type === 'weapon' && player.weapons[o.id] === 0);
                     }
                 } else if (forceType === 'upgrade_weapon') {
                     pool = offensivePool.filter(o => o.type === 'weapon' && player.weapons[o.id] > 0);
                 } else if (forceType === 'upgrade_attribute') {
                     pool = offensivePool.filter(o => o.type === 'weapon' && player.weapons[o.id] > 0);
                 }


                 // Filter out already picked options for this hand
                 pool = pool.filter(p => !pickedIds.has(p.id));


                 if(pool.length === 0) pool = [...otherPool].filter(p => !pickedIds.has(p.id)); // Fallback


                 if(pool.length === 0) return null; // Should rarely happen

                 // Weighted selection: Masteries and Synergies are rarer
                 let weightedPool = [];
                 pool.forEach(option => {
                     if (option.type === 'mastery') {
                         // Masteries: 15% as likely (add once)
                         weightedPool.push(option);
                     } else if (option.type === 'synergy') {
                         // Synergies: 10% as likely (add once)
                         weightedPool.push(option);
                     } else if (option.type === 'unlock') {
                         // Unlocks: Already added correct number of times to base pool (don't multiply)
                         weightedPool.push(option);
                     } else {
                         // Normal options: 100% weight (add 10 times)
                         for (let i = 0; i < 10; i++) {
                             weightedPool.push(option);
                         }
                     }
                 });

                 const choice = weightedPool[Math.floor(seededRandom() * weightedPool.length)];
                 pickedIds.add(choice.id);
                 
                 // Masteries and Synergies use special 'elemental' rarity (red outline)
                 // Unlock cards preserve their preset rarity
                 let rarity;
                 if (choice.type === 'mastery' || choice.type === 'synergy') {
                     rarity = 'elemental';
                 } else if (choice.id === 'multi_unlock') {
                     rarity = 'epic'; // Double TAP unlock is always epic
                 } else if (choice.type === 'unlock' && choice.rarity) {
                     rarity = choice.rarity; // Preserve preset rarity for other unlocks
                 } else {
                     rarity = getRarity(player.luck);
                 }
                 
                 return { ...choice, rarity };
            };


            // Card 1: Saved upgrade if available, otherwise new weapon or random
            if (state.savedUpgrade) {
                options.push(state.savedUpgrade);
                state.savedUpgrade = null;
            } else if (forcedWeapon && !locked) {
                options.push(createOption('new_weapon'));
            } else {
                options.push(createOption());
            }


            // Card 2, 3, 4: All random (no forced weapon upgrade)
            options.push(createOption());
            options.push(createOption());
            options.push(createOption());


            // SAFETY: Filter out null options and ensure we always have exactly 4 options
            options = options.filter(o => o !== null);
            
            console.log('üìã Generated options:', options.length, options.map(o => o.name));
            
            // If somehow we don't have 4 options, fill with random stat upgrades
            let safetyAttempts = 0;
            while (options.length < 4 && safetyAttempts < 10) {
                safetyAttempts++;
                const newOpt = createOption();
                if (newOpt) {
                    options.push(newOpt);
                } else {
                    // Ultimate fallback if createOption returns null
                    console.warn('‚ö†Ô∏è createOption returned null, using fallback HP upgrade');
                    options.push({ 
                        id: 'hp', 
                        type: 'stat', 
                        name: 'Hull Repair', 
                        desc: 'Max HP & Heal', 
                        icon: 'fa-heart', 
                        rarity: 'common' 
                    });
                }
            }
            
            if (options.length === 0) {
                console.error('üö® CRITICAL: No options generated! Force-adding default options');
                options = [
                    { id: 'hp', type: 'stat', name: 'Hull Repair', desc: 'Max HP & Heal', icon: 'fa-heart', rarity: 'common' },
                    { id: 'armor', type: 'stat', name: 'Plating', desc: 'Armor', icon: 'fa-shield-alt', rarity: 'common' },
                    { id: 'spd', type: 'stat', name: 'Thrusters', desc: 'Speed', icon: 'fa-wind', rarity: 'common' },
                    { id: 'regen', type: 'stat', name: 'Nano-Repair', desc: 'HP Regen', icon: 'fa-medkit', rarity: 'common' }
                ];
            }
            
            // Render
            options.forEach(opt => {
                if(!opt) return; // Safety


                let mult = 1; 
                if(opt.rarity === 'uncommon') mult=1.5;
                if(opt.rarity === 'rare') mult=2.5; // Buffed
                if(opt.rarity === 'epic') mult=4; // Buffed
                if(opt.rarity === 'legendary') mult=6; // Buffed


                let title = opt.name; let desc = opt.desc;


                if (opt.type === 'weapon') {
                    const lvl = player.weapons[opt.id];
                    if (lvl === 0) { 
                        title = opt.name; 
                        desc = weaponDefs[opt.id].desc;
                        opt.rarity = 'common'; 
                    }
                    else if (lvl > 0) {
                        // Single attribute upgrade based on weapon's valid upgrades
                        let validAttrs = weaponDefs[opt.id].validUpgrades || ['dmg', 'rate', 'area'];
                        
                        const attr = validAttrs[Math.floor(seededRandom() * validAttrs.length)];
                        opt.upgradeAttr = attr; // Store which attribute to upgrade
                        opt.upgradeAmount = mult; // Store multiplier
                        
                        // Rarity-based bonuses: Buffed to compete with globals
                        const bonusMap = { 'common': 8, 'uncommon': 12, 'rare': 20, 'epic': 35, 'legendary': 50 };
                        const bonus = bonusMap[opt.rarity] || 8;
                        
                        title = opt.name; // Just weapon name
                        
                        if (attr === 'dmg') {
                            desc = `Damage: +${bonus}%`;
                        } else if (attr === 'rate') {
                            desc = `Cooldown: -${bonus}%`;
                        } else if (attr === 'area') {
                            desc = `Area: +${bonus}%`;
                        }
                        
                        // Add legendary bonus indicator for weapon upgrades
                        if (opt.rarity === 'legendary') {
                            desc += ` + Grants 2 levels!`;
                        }
                    }
                } else {
                    // Standardized format: [Stat]: +X%
                    if (opt.id === 'hp') {
                        let hpGain = Math.floor(25 * mult); // Base HP gain - round to match actual application
                        
                        // Apply Fortified Hull bonus to display
                        if (player.fortifiedHullUpgradeBonus) {
                            hpGain = Math.floor(hpGain * (1 + player.fortifiedHullUpgradeBonus));
                        }
                        
                        // ASCENSION 1+: FRAGILE HULL - show reduced HP value
                        if (player.fragileHullPenalty) {
                            hpGain = Math.floor(hpGain * player.fragileHullPenalty);
                        }
                        
                        desc = `Max HP: +${hpGain} & Heal`;
                    }
                    else if (opt.id === 'luck') {
                        desc = `Luck & Drop Rate: +${Math.floor(10*mult)}%`;
                    }
                    else if (opt.id === 'multi') {
                        desc = `Multistrike: +${Math.floor(7.5*mult)}%`;
                    }
                    else if (opt.id === 'crit') {
                        desc = `Crit Chance: +${Math.floor(15*mult)}%`;
                    }
                    else if (opt.id === 'regen') {
                        let rVal = 0.2; // Base: 0.2 HP/sec
                        if(opt.rarity === 'uncommon') rVal = 0.4;
                        if(opt.rarity === 'rare') rVal = 0.6;
                        if(opt.rarity === 'epic') rVal = 1.0;
                        if(opt.rarity === 'legendary') rVal = 1.2;
                        desc = `HP Regen: +${rVal.toFixed(1)}/s`;
                    }
                    else if (opt.id === 'elem') {
                        let eVal = 5;
                        if(opt.rarity === 'uncommon') eVal = 8;
                        if(opt.rarity === 'rare') eVal = 12;
                        if(opt.rarity === 'epic') eVal = 18;
                        if(opt.rarity === 'legendary') eVal = 25;
                        desc = `Elemental Proc: +${eVal}%`;
                    }
                    else if (opt.id === 'spd') {
                        let sVal = 5;
                        if(opt.rarity === 'uncommon') sVal = 8;
                        if(opt.rarity === 'rare') sVal = 12;
                        if(opt.rarity === 'epic') sVal = 20;
                        if(opt.rarity === 'legendary') sVal = 30;
                        desc = `Move Speed: +${sVal}%`;
                    }
                    else if (opt.id === 'pickup') {
                         desc = `Magnet Range: +${Math.floor(10*mult)}%`;
                    }
                    else if (opt.id === 'armor') {
                        let armorVal = 1;
                        if(opt.rarity === 'uncommon') armorVal = 2;
                        if(opt.rarity === 'rare') armorVal = 3;
                        if(opt.rarity === 'epic') armorVal = 4;
                        if(opt.rarity === 'legendary') armorVal = 5;
                        desc = `Armor: +${armorVal}`;
                    }
                    else {
                        desc = opt.desc; // Just use the description directly (unlocks, masteries, synergies)
                    }
                    
                    // Add legendary bonus indicator (except for HP and unlocks)
                    if (opt.rarity === 'legendary' && opt.type !== 'unlock') {
                        desc += ` + Level up all weapons!`;
                    }
                }


                // Pass synergy elements for dual icon display
                const synergyElements = opt.type === 'synergy' ? opt.elements : null;
                
                createCard(container, title, desc, opt.icon, opt.rarity, (e) => {
                    const card = e.target.closest('.card');
                    if (window.upgradesSaveMode) {
                        if (card.classList.contains('disabled')) return;
                        
                        // Save the upgrade
                        state.savedUpgrade = opt;
                        state.saveCharges--;
                        window.upgradesSaveMode = false;
                        
                        // Update visual feedback
                        const saveBtn = document.getElementById('save-btn');
                        const allCards = document.querySelectorAll('#cards-container .card');
                        
                        // Remove save-mode from all cards
                        allCards.forEach(c => c.classList.remove('save-mode'));
                        
                        // Mark this card as saved
                        card.classList.add('saved');
                        
                        // Reset button to normal state but show "SAVED" feedback
                        saveBtn.style.background = '#00d1b2';
                        saveBtn.innerText = 'SAVED!';
                        saveBtn.disabled = true; // Disable for this level
                        
                        // After delay, update button text with remaining charges
                        setTimeout(function() {
                            const btn = document.getElementById('save-btn');
                            btn.innerHTML = '<i class="fas fa-save"></i> SAVE (<span id="save-count">' + state.saveCharges + '</span>)';
                            // Don't re-enable here - stays disabled for current level
                        }, 1000);
                        
                        // Don't resume game - player can still pick another upgrade
                        return;
                    }
                    if(card.classList.contains('disabled')) return;
                    card.classList.add('disabled');


                    if (opt.type === 'weapon') {
                        if (player.weapons[opt.id] === 0 && player.getActiveWeaponCount() >= 4) { 
                            state.pendingSwap = opt.id;
                            document.getElementById('levelup-screen').classList.remove('active');
                            showSwapScreen();
                        } else {
                            // BASE POWER PROGRESSION: Every level increases all weapon stats slightly
                            // This makes late game (level 20-30+) feel more powerful even without rarity bonuses
                            const currentLevel = player.weapons[opt.id];
                            if (currentLevel > 0) {
                                // Apply base increases across all stats (multiplicative)
                                // More aggressive scaling since weapons rarely get past level 10 in typical runs
                                // At level 5: ~32% dmg, 23% rate, 12% area
                                // At level 10: ~74% dmg, 51% rate, 25% area
                                player.weaponStats[opt.id].dmg *= 1.055;   // +5.5% dmg per level (increased from 2%)
                                player.weaponStats[opt.id].rate *= 1.04;   // +4% rate per level (increased from 1.5%)
                                
                                // Area upgrades affected by Compressed Field (-15%)
                                let areaBonus = 1.02; // +2% area per level base
                                if (player.compressedFieldPenalty) {
                                    areaBonus = 1 + ((areaBonus - 1) * player.compressedFieldPenalty); // Reduce bonus by 15%
                                }
                                player.weaponStats[opt.id].area *= areaBonus;
                            }
                            
                            // Legendary weapon upgrades grant +2 levels to that weapon
                            if (opt.rarity === 'legendary') {
                                player.weapons[opt.id] += 2;
                            } else {
                                player.weapons[opt.id]++;
                            }
                            
                            // Apply specific attribute upgrade (this is the BONUS on top of base)
                            if (opt.upgradeAttr && opt.upgradeAmount) {
                                const attr = opt.upgradeAttr;
                                const amt = opt.upgradeAmount;
                                // Apply bonus based on rarity - reduced area bonuses
                                const bonusMap = { 
                                    'common': { dmg: 0.05, rate: 0.05, area: 0.03 },      // Area: 3% (was 5%)
                                    'uncommon': { dmg: 0.075, rate: 0.075, area: 0.05 },  // Area: 5% (was 7.5%)
                                    'rare': { dmg: 0.15, rate: 0.15, area: 0.08 },        // Area: 8% (was 15%)
                                    'epic': { dmg: 0.30, rate: 0.30, area: 0.15 },        // Area: 15% (was 30%)
                                    'legendary': { dmg: 0.40, rate: 0.40, area: 0.20 }    // Area: 20% (was 40%)
                                };
                                const bonuses = bonusMap[opt.rarity] || bonusMap['common'];
                                const bonus = bonuses[attr] || 0.05;
                                
                                if (attr === 'dmg') {
                                    player.weaponStats[opt.id].dmg *= (1 + bonus);
                                } else if (attr === 'rate') {
                                    player.weaponStats[opt.id].rate *= (1 + bonus);
                                } else if (attr === 'area') {
                                    player.weaponStats[opt.id].area *= (1 + bonus);
                                }
                            }
                            resumeGame();
                        }
                    } else {
                        if (opt.type === 'mastery') {
                            player.elementalMasteries[opt.id] = true;
                            resumeGame();
                        } else if (opt.type === 'synergy') {
                            player.synergies[opt.id] = true;
                            resumeGame();
                        } else if (opt.type === 'unlock') {
                            // Handle unlock cards (multistrike, etc)
                            if (opt.id === 'multi_unlock') {
                                player.multistrikeUnlocked = true;
                                player.multicast = 0.10; // Grant 10% base multistrike (increased from 7%)
                            }
                            resumeGame();
                        } else {
                            applyStat(opt.id, mult, opt.rarity); resumeGame();
                        }
                    }
                }, synergyElements); // Pass synergyElements, upgradeAttr=null by default
            });
        }


        function createCard(parent, title, desc, icon, rarity, onClick, synergyElements = null, upgradeAttr = null, isElementalAugment = false, augmentElement = null) {
            const el = document.createElement('div');
            el.className = `card ${rarity}`;
            
            // Add elemental styling ONLY for elemental augment cards (not weapon upgrades)
            if (isElementalAugment && augmentElement) {
                if (augmentElement === 'fire') el.classList.add('elem-fire');
                if (augmentElement === 'ice') el.classList.add('elem-ice');
                if (augmentElement === 'volt') el.classList.add('elem-volt');
                if (augmentElement === 'bio') el.classList.add('elem-bio');
                if (augmentElement === 'hack') el.classList.add('elem-hack');
            }
            
            // For synergies, show both element icons
            let iconHTML;
            if (synergyElements && synergyElements.length === 2) {
                const elem1 = elementalDefs.find(e => e.id === synergyElements[0]);
                const elem2 = elementalDefs.find(e => e.id === synergyElements[1]);
                iconHTML = `
                    <div style="display: flex; gap: 12px; justify-content: center;">
                        <i class="fas ${elem1.icon}" style="color: ${elem1.color}; font-size: 2rem;"></i>
                        <i class="fas ${elem2.icon}" style="color: ${elem2.color}; font-size: 2rem;"></i>
                    </div>
                `;
            } else {
                iconHTML = `<i class="fas ${icon}"></i>`;
            }
            
            el.innerHTML = `
                <div class="card-header">
                    ${iconHTML}
                </div>
                <div class="card-content">
                    <h3>${title}</h3>
                    <p>${desc}</p>
                </div>
            `;
            el.onclick = onClick;
            
            // Add legendary particles to ALL legendary cards
            if (rarity === 'legendary') {
                for (let i = 0; i < 12; i++) {
                    const particle = document.createElement('div');
                    particle.className = 'legendary-particle';
                    particle.style.setProperty('--start-x', `${seededRandom() * 100}%`);
                    particle.style.setProperty('--drift-x', `${(seededRandom() - 0.5) * 60}px`);
                    particle.style.setProperty('--delay', `${seededRandom() * 2}s`);
                    el.appendChild(particle);
                }
            }
            
            parent.appendChild(el);
        }


        function resumeGame() {
            console.log(`üéÆ Resuming game (queue length before: ${state.upgradeQueue ? state.upgradeQueue.length : 0})`);
            
            // Remove processed upgrade from unified queue
            if (state.upgradeQueue && state.upgradeQueue.length > 0) {
                const completedUpgrade = state.upgradeQueue.shift();
                console.log(`   ‚úÖ Completed upgrade type: ${completedUpgrade.type}`);
                
                // If it was a level up, also decrement the legacy counter
                if (completedUpgrade.type === 'levelup') {
                    state.pendingLevelUps--;
                    
                    // Remove from levelup-specific queue too
                    if (state.levelUpQueue && state.levelUpQueue.length > 0) {
                        state.levelUpQueue.shift();
                    }
                }
            }
            
            console.log(`   Remaining in queue: ${state.upgradeQueue ? state.upgradeQueue.length : 0}`);
            
            // Update pending counter display (show total pending upgrades)
            const pendingDiv = document.getElementById('pending-upgrades');
            const pendingCount = document.getElementById('pending-count');
            const remainingUpgrades = state.upgradeQueue ? state.upgradeQueue.length : 0;
            
            if (remainingUpgrades > 0) {
                pendingDiv.style.display = 'block';
                pendingCount.textContent = remainingUpgrades + 1; // +1 because we're still on current screen
            } else {
                pendingDiv.style.display = 'none';
            }
            
            if (remainingUpgrades > 0) { 
                console.log('   ‚Üí Processing next upgrade in queue');
                // Process next upgrade in queue
                processNextUpgrade();
            } 
            else {
                console.log('   ‚Üí All upgrades complete, returning to game');
                // All upgrades chosen - return to game
                document.getElementById('levelup-screen').classList.remove('active');
                state.screen = 'game'; state.lastTime = Date.now();
                player.invulnTimer = 120;
                
                // Show any queued warnings now that upgrade screen is closed
                if (state.queuedWarning) {
                    if (state.queuedWarning === 'boss') {
                        showBossWarning();
                    } else if (state.queuedWarning === 'champion') {
                        const warn = document.getElementById('boss-warning');
                        warn.style.display = 'block';
                        setTimeout(() => warn.style.display = 'none', 3000);
                    }
                    state.queuedWarning = null;
                }
            }
        }


        // --- Weapon Swap UI ---
        function showSwapScreen() {
            const container = document.getElementById('swap-container');
            container.innerHTML = '';
            document.getElementById('swap-screen').classList.add('active');
            
            Object.keys(player.weapons).forEach(k => {
                const lvl = player.weapons[k];
                if (lvl > 0) {
                    const el = document.createElement('div');
                    el.className = 'card common'; 
                    const def = weaponDefs[k];
                    el.innerHTML = `<i class="fas ${def.icon}"></i><div class="card-content"><h3>${def.name}</h3><p>Level ${lvl}</p></div>`;
                    el.onclick = () => confirmSwap(k);
                    container.appendChild(el);
                }
            });
        }


        function confirmSwap(oldId) {
            player.weapons[oldId] = 0;
            player.weaponAugments[oldId] = { fire: 0, ice: 0, volt: 0, bio: 0 };
            
            player.weapons[state.pendingSwap] = 1;
            
            document.getElementById('swap-screen').classList.remove('active');
            state.pendingSwap = null;
            resumeGame();
        }


        function cancelSwap() {
            document.getElementById('swap-screen').classList.remove('active');
            state.pendingSwap = null;
            document.getElementById('levelup-screen').classList.add('active');
        }


        function applyStat(id, mult, rarity) {
            // Legendary passives boost all weapon levels by +1 (for ALL legendaries, not just non-hp)
            if (rarity === 'legendary') {
                Object.keys(player.weapons).forEach(w => {
                    if (player.weapons[w] > 0) {
                        player.weapons[w]++; // +1 level for global legendary
                    }
                });
            }
            
            if(id==='hp') { 
                let hpGain = Math.floor(25*mult); // Base: 25 HP per upgrade - round immediately to avoid decimals
                
                // FORTIFIED HULL AUGMENT: Increase HP upgrade effectiveness
                if (player.fortifiedHullUpgradeBonus) {
                    hpGain = Math.floor(hpGain * (1 + player.fortifiedHullUpgradeBonus));
                }
                
                // ASCENSION 1+: FRAGILE HULL - reduce HP upgrades by 30%
                if (player.fragileHullPenalty) {
                    hpGain = Math.floor(hpGain * player.fragileHullPenalty); // Apply penalty (0.70 = -30%)
                }
                
                player.maxHp += hpGain;
                player.heal(hpGain, true); // Heal with overshield allowed
            }
            // Global damage and cooldown removed - only weapon-specific now
            if(id==='armor') player.armor += 4*mult; // Increased from 3 to 4 (33% buff)
            if(id==='pickup') {
                player.pickupRadius *= (1 + 0.06*mult); // Reduced from 0.10 to 0.06 (40% nerf)
                player.pickupUpgradeCount += mult; // Track upgrades for cap
            }
            if(id==='regen') {
                // Regen now ticks every 1 second instead of 5 seconds, so values are 5x smaller
                let regenAmt = 0.2; // Base: 0.2 HP/sec
                if (mult >= 6) regenAmt = 1.2; // Max: 1.2 HP/sec (was 6 per 5 sec)
                else if (mult >= 4) regenAmt = 1.0; // 1.0 HP/sec (was 5 per 5 sec)
                else if (mult >= 2.5) regenAmt = 0.6; // 0.6 HP/sec (was 3 per 5 sec)
                else if (mult >= 1.5) regenAmt = 0.4; // 0.4 HP/sec (was 2 per 5 sec)
                player.regen += regenAmt;
            }
            if(id==='luck') player.luck += 10*mult; 
            if(id==='multi') {
                const multiplier = player.cascadeMultiplier || 1; // 1.25x if cascade mod active
                player.multicast *= (1 + (0.075 * mult * multiplier));
            } 
            if(id==='crit') player.critChance *= (1 + 0.15*mult);
            if(id==='elem') {
                let val = 0.05;
                if(rarity === 'uncommon') val = 0.08;
                if(rarity === 'rare') val = 0.12;
                if(rarity === 'epic') val = 0.18;
                if(rarity === 'legendary') val = 0.25;
                player.elementalMult += val;
            }
            if(id==='spd') {
                let val = 0.05;
                if(rarity === 'uncommon') val = 0.08;
                if(rarity === 'rare') val = 0.12;
                if(rarity === 'epic') val = 0.20;
                if(rarity === 'legendary') val = 0.30;
                player.speed *= (1 + val);
            }
        }


        // Format score with K/M abbreviations - GLOBAL FUNCTION
        function formatScore(score) {
            if (score >= 1000000) {
                return (score / 1000000).toFixed(1) + 'M';
            } else if (score >= 100000) {
                return (score / 1000).toFixed(1) + 'K';
            } else {
                return score.toString();
            }
        }

        function updateHud() {
            const hpPct = Math.max(0, (player.hp / player.maxHp) * 100);
            const xpPct = Math.min(100, (state.xp / state.xpToNext) * 100);
            document.getElementById('hp-bar').style.width = `${hpPct}%`;
            
            // Update HP text inside bar
            const hpTextEl = document.getElementById('hp-text');
            const currentHp = Math.ceil(Math.max(0, player.hp));
            hpTextEl.innerText = `${currentHp} / ${Math.ceil(player.maxHp)}`;
            
            // Update shield orbs based on charge level
            // Note: Shields deplete right to left (shield4 ‚Üí shield3 ‚Üí shield2 ‚Üí shield1)
            const orb1 = document.getElementById('shield-orb-1'); // LEFT
            const orb2 = document.getElementById('shield-orb-2'); // MIDDLE-LEFT
            const orb3 = document.getElementById('shield-orb-3'); // MIDDLE-RIGHT (Vanguard only)
            const orb4 = document.getElementById('shield-orb-4'); // RIGHT (Vanguard with Shield Capacitor only)
            
            // Hide ALL shield icons for Reaper (no shields)
            if (player.selectedShip === 'REAPER') {
                orb1.style.display = 'none';
                orb2.style.display = 'none';
                orb3.style.display = 'none';
                orb4.style.display = 'none';
            } else if (player.selectedShip === 'DISRUPTOR') {
                orb1.style.display = 'inline-block';
                orb2.style.display = 'none';
                orb3.style.display = 'none';
                orb4.style.display = 'none';
            } else {
                orb1.style.display = 'inline-block';
                orb2.style.display = 'inline-block';
                
                // Show/hide 3rd and 4th orb based on ship and augments
                if (player.selectedShip === 'VANGUARD') {
                    orb3.style.display = 'inline-block';
                    // Show 4th orb ONLY if Shield Capacitor Tier 3 is equipped (shield4 = 100)
                    // shield4 will be 0 by default, only 100 if augment is equipped
                    if (player.shield4 === 100 || player.shield4RechargeTimer > 0) {
                        orb4.style.display = 'inline-block';
                    } else {
                        orb4.style.display = 'none';
                    }
                } else {
                    orb3.style.display = 'none';
                    orb4.style.display = 'none';
                }
            }
            
            // Update shield states (outside conditional so all ships update)
            if (player.selectedShip !== 'REAPER') {
                // Left orb (shield1) - All ships except Reaper
                if (player.shield1 >= 100) {
                    orb1.style.color = '#00d1b2';
                    orb1.style.filter = 'drop-shadow(0 0 8px #00d1b2)';
                    orb1.style.opacity = '1';
                } else if (player.shield1 > 0) {
                    // Charging - slightly dimmed with reduced glow
                    orb1.style.color = '#00d1b2';
                    orb1.style.filter = 'drop-shadow(0 0 3px #00d1b2)';
                    orb1.style.opacity = '0.6';
                } else {
                    // Empty
                    orb1.style.color = 'rgba(0,209,178,0.3)';
                    orb1.style.filter = 'none';
                    orb1.style.opacity = '0.3';
                }
            }
            
            if (player.selectedShip !== 'REAPER' && player.selectedShip !== 'DISRUPTOR') {
                // Middle-left orb (shield2) - Pathfinder, Engineer, Vanguard
                if (player.shield2 >= 100) {
                    orb2.style.color = '#00d1b2';
                    orb2.style.filter = 'drop-shadow(0 0 8px #00d1b2)';
                    orb2.style.opacity = '1';
                } else if (player.shield2 > 0) {
                    // Charging - slightly dimmed with reduced glow
                    orb2.style.color = '#00d1b2';
                    orb2.style.filter = 'drop-shadow(0 0 3px #00d1b2)';
                    orb2.style.opacity = '0.6';
                } else {
                    // Empty
                    orb2.style.color = 'rgba(0,209,178,0.3)';
                    orb2.style.filter = 'none';
                    orb2.style.opacity = '0.3';
                }
            }
            
            if (player.selectedShip === 'VANGUARD') {
                // Middle-right orb (shield3, Vanguard only)
                if (player.shield3 >= 100) {
                    orb3.style.color = '#00d1b2';
                    orb3.style.filter = 'drop-shadow(0 0 8px #00d1b2)';
                    orb3.style.opacity = '1';
                } else if (player.shield3 > 0) {
                    // Charging - slightly dimmed with reduced glow
                    orb3.style.color = '#00d1b2';
                    orb3.style.filter = 'drop-shadow(0 0 3px #00d1b2)';
                    orb3.style.opacity = '0.6';
                } else {
                    // Empty
                    orb3.style.color = 'rgba(0,209,178,0.3)';
                    orb3.style.filter = 'none';
                    orb3.style.opacity = '0.3';
                }
                
                // Right orb (shield4, Vanguard with Shield Capacitor Tier 3 only) - depletes first
                if (player.shield4 !== undefined) {
                    if (player.shield4 >= 100) {
                        orb4.style.color = '#00d1b2';
                        orb4.style.filter = 'drop-shadow(0 0 8px #00d1b2)';
                        orb4.style.opacity = '1';
                    } else if (player.shield4 > 0) {
                        // Charging - slightly dimmed with reduced glow
                        orb4.style.color = '#00d1b2';
                        orb4.style.filter = 'drop-shadow(0 0 3px #00d1b2)';
                        orb4.style.opacity = '0.6';
                    } else {
                        // Empty
                        orb4.style.color = 'rgba(0,209,178,0.3)';
                        orb4.style.filter = 'none';
                        orb4.style.opacity = '0.3';
                    }
                }
            }
            
            document.getElementById('xp-bar').style.width = `${xpPct}%`;
            document.getElementById('lvl-text').innerText = `LVL ${state.level}`;
            document.getElementById('score').innerText = formatScore(state.score);
            const t = Math.floor((state.gameTime)/1000);
            document.getElementById('time').innerText = `${Math.floor(t/60).toString().padStart(2,'0')}:${(t%60).toString().padStart(2,'0')}`;


            const slotContainer = document.getElementById('weapon-slots');
            slotContainer.innerHTML = '';
            
            // RENDER 4 WEAPON SLOTS
            const activeWeapons = Object.keys(player.weapons).filter(k => player.weapons[k] > 0 && k !== 'multi' && k !== 'nuke');
            for(let i=0; i<4; i++) {
                const wId = activeWeapons[i];
                const slot = document.createElement('div');
                slot.className = 'weapon-slot';
                if (wId && weaponDefs[wId]) {
                    const def = weaponDefs[wId];
                    const lvl = player.weapons[wId];
                    const augs = player.weaponAugments[wId];
                    slot.classList.add('active');
                    slot.innerHTML = `<i class="fas ${def.icon}"></i><div class="level-badge">${lvl}</div>`;
                    
                    // COOLDOWN OVERLAY
                    let pct = 0;
                    if(wId === 'tesla') pct = player.teslaTimer / player.maxTeslaTimer;
                    if(wId === 'seeker') pct = player.seekerTimer / player.maxSeekerTimer;
                    if(wId === 'whip') pct = player.whipTimer / Math.max(40, 120 / player.weaponStats.whip.rate);
                    if(wId === 'meteor') pct = player.meteorTimer / player.maxMeteorTimer;
                    if(wId === 'railgun') pct = player.railgunTimer / player.maxRailgunTimer;
                    if(wId === 'flak') pct = player.flakTimer / player.maxFlakTimer;
                    if(wId === 'pylons') pct = player.pylonTimer / player.maxPylonTimer;
                    if(wId === 'mines') pct = player.minesTimer / player.maxMinesTimer;
                    if(wId === 'gas') pct = player.gasTimer / player.maxGasTimer;
                    if(wId === 'ricochet') pct = player.ricochetTimer / Math.max(60, 150 / player.weaponStats.ricochet.rate);
                    
                    if (wId === 'ion') {
                        const currentIonRate = player.fireRate / Math.min(4, Math.max(1, player.weapons.ion));
                         if (currentIonRate > 250 && player.lastShot > 0) {
                             pct = player.lastShot / currentIonRate;
                         }
                    }
                    if(wId === 'beam' && !player.beamActive) {
                         pct = player.beamCooldown / 3000 * 16; 
                    }


                    if (pct > 0) {
                        const ol = document.createElement('div');
                        ol.className = 'cooldown-overlay';
                        ol.style.background = `conic-gradient(rgba(0,0,0,0.8) ${pct*100}%, rgba(0,0,0,0) ${pct*100}%)`;
                        slot.appendChild(ol);
                    }


                    // Single Augment Border Logic
                    const augElement = augs; // Single element or null
                    let borderColor = null;
                    if (augElement === 'fire') borderColor = '#ff5722';
                    if (augElement === 'ice') borderColor = '#88d8ff';
                    if (augElement === 'volt') borderColor = '#ffeb3b';
                    if (augElement === 'bio') borderColor = '#00cc44';
                    if (augElement === 'hack') borderColor = '#00ffff';


                    if (borderColor) {
                        slot.style.borderColor = borderColor;
                        slot.style.boxShadow = `0 0 5px ${borderColor}`;
                        slot.querySelector('i').style.color = borderColor;
                    }


                } else {
                    slot.innerHTML = `<i class="fas fa-lock text-gray-700"></i>`;
                }
                slotContainer.appendChild(slot);
            }
            
            // Update mod slot separately
            updateModSlot();
        }
        
        // Update mod slot in separate container (bottom left)
        function updateModSlot() {
            // MOD SYSTEM HIDDEN - Will be repurposed as post-game "Nexus Augments"
            // Keeping code intact for future use
            const container = document.getElementById('mod-slot-container');
            if (container) container.style.display = 'none';
        }
        
        function updateUltimateButton() {
            const container = document.getElementById('ultimate-container');
            const btn = document.getElementById('ultimate-btn');
            const chargeEl = document.getElementById('ultimate-charge-text');
            const icon = btn.querySelector('i');
            
            if (!player.ultimate) {
                // No ultimate equipped yet
                container.style.display = 'none';
                return;
            }
            
            // Show ultimate button
            container.style.display = 'block';
            
            const ultimateData = ULTIMATES[player.ultimate];
            const charge = Math.floor(player.ultimateCharge);
            
            // Update icon and charge text
            icon.className = `fas ${ultimateData.icon}`;
            chargeEl.innerText = `${charge}%`;
            
            if (charge >= 100 && !player.ultimateActive) {
                // READY - Magenta styling with animation
                btn.style.background = 'linear-gradient(135deg, #ff00ff 0%, #c000c0 100%)';
                btn.style.border = '3px solid #ff66ff';
                btn.style.boxShadow = '0 0 10px rgba(255, 0, 255, 0.5), inset 0 0 10px rgba(255, 255, 255, 0.2)';
                btn.style.color = '#fff';
                btn.style.cursor = 'pointer';
                btn.style.opacity = '1';
                btn.style.transform = 'scale(1.05)';
                icon.style.color = '#fff';
                icon.style.textShadow = '0 0 8px #fff';
                chargeEl.innerText = 'READY';
                chargeEl.style.fontSize = '10px';
                chargeEl.style.color = '#fff';
                chargeEl.style.textShadow = '0 0 6px #ff00ff';
                
                // Pulsing animation
                if (!btn.dataset.animating) {
                    btn.dataset.animating = 'true';
                    btn.style.animation = 'ultimate-pulse 1.5s ease-in-out infinite';
                }
            } else {
                // CHARGING - Gray/disabled styling
                btn.style.background = 'linear-gradient(135deg, #2a2a3a 0%, #1a1a2a 100%)';
                btn.style.border = '3px solid #555';
                btn.style.boxShadow = 'none';
                btn.style.color = '#888';
                btn.style.cursor = 'not-allowed';
                btn.style.opacity = '0.6';
                btn.style.transform = 'scale(1)';
                btn.style.animation = 'none';
                icon.style.color = ultimateData.color;
                icon.style.textShadow = `0 0 5px ${ultimateData.color}`;
                chargeEl.style.fontSize = '11px';
                chargeEl.style.color = '#aaa';
                chargeEl.style.textShadow = 'none';
                btn.dataset.animating = '';
            }
        }
        
        // ===== ASCENSION SYSTEM =====
        
        const ASCENSION_DATA = {
            1: {
                name: 'Ascension I',
                debuffs: [
                    { name: 'Fragile Hull', desc: 'Max HP and HP upgrades -30%', icon: 'fa-heartbeat' }
                ],
                coreMultiplier: 2.0,
                scoreMultiplier: 2.0
            },
            2: {
                name: 'Ascension II',
                debuffs: [
                    { name: 'Power Drain', desc: 'Base damage -20%', icon: 'fa-battery-quarter' },
                    { name: 'Sluggish Systems', desc: 'Movement speed -15%', icon: 'fa-turtle' }
                ],
                coreMultiplier: 3.0,
                scoreMultiplier: 3.0
            },
            3: {
                name: 'Ascension III',
                debuffs: [
                    { name: 'Aggressive Swarms', desc: 'Enemies spawn 15% faster', icon: 'fa-users' },
                    { name: 'Weakened Shields', desc: 'Shield recharge delay +50%', icon: 'fa-shield-virus' },
                    { name: 'Energy Leak', desc: 'Ultimate charges 20% slower', icon: 'fa-bolt-slash' }
                ],
                coreMultiplier: 4.0,
                scoreMultiplier: 4.0
            },
            4: {
                name: 'Ascension IV',
                debuffs: [
                    { name: 'Brittle Armor', desc: 'Start with -1 shield charge', icon: 'fa-shield-alt' },
                    { name: 'Overloaded Circuits', desc: 'Weapon fire rate -15%', icon: 'fa-plug' },
                    { name: 'Leaky Shields', desc: 'Shields only block 50% of damage', icon: 'fa-shield-virus' },
                    { name: 'Compressed Field', desc: 'Weapon area and area upgrades -15%', icon: 'fa-compress' }
                ],
                coreMultiplier: 5.0,
                scoreMultiplier: 5.0
            },
            5: {
                name: 'Ascension V',
                debuffs: [
                    { name: 'Ticking Doom', desc: 'Lose 1 HP per second', icon: 'fa-hourglass-half' },
                    { name: 'Overcharged Enemies', desc: 'All enemies deal +20% damage', icon: 'fa-radiation' },
                    { name: 'Accelerated Enemies', desc: 'All enemies move 15% faster', icon: 'fa-running' },
                    { name: 'Empowered Titans', desc: 'Titan Champions have +25% HP and damage', icon: 'fa-dragon' },
                    { name: 'Critical Weakness', desc: 'Enemies have +15% crit chance vs you', icon: 'fa-crosshairs' }
                ],
                coreMultiplier: 6.0,
                scoreMultiplier: 6.0
            }
        };
        
        function showAscensionScreen() {
            const ascensionScreen = document.getElementById('ascension-screen');
            const container = document.getElementById('ascension-levels-container');
            const highestAscension = parseInt(localStorage.getItem('neonrogue_highestAscension') || '0');
            
            // Clear container
            container.innerHTML = '';
            
            // Add "Normal Mode" option (always collapsed, no augments)
            const normalOption = createAscensionOption(0, 'Normal Mode', [], 1.0, highestAscension);
            container.appendChild(normalOption);
            
            // Add Ascension levels 1-5 (expandable with augment slots)
            for (let i = 1; i <= 5; i++) {
                const data = ASCENSION_DATA[i];
                const option = createAscensionOption(i, data.name, data.debuffs, data.coreMultiplier, highestAscension);
                container.appendChild(option);
            }
            
            // Auto-select the last used ascension level
            selectAscension(selectedAscensionLevel);
            
            ascensionScreen.classList.add('active');
        }
        
        function createAscensionOption(level, name, debuffs, coreMultiplier, highestAscension) {
            const div = document.createElement('div');
            const isLocked = level > highestAscension + 1;
            const isSelected = level === selectedAscensionLevel;
            
            div.className = `ascension-option p-3 border-2 rounded-lg transition-all ${
                isLocked ? 'border-gray-700 bg-gray-900/60 opacity-60 cursor-not-allowed' : 
                isSelected ? 'border-purple-500 bg-purple-900/30' : 
                'border-gray-600 bg-gray-800'
            }`;
            
            // Required augment slots for this level
            const requiredSlots = level === 0 ? 0 : level === 1 ? 1 : level === 2 ? 2 : 3;
            
            if (level === 0) {
                // Normal Mode - Simple card, not expandable
                div.innerHTML = `
                    <div class="flex justify-between items-center cursor-pointer" data-level="0">
                        <div>
                            <div class="text-lg font-bold ${isSelected ? 'text-teal-400' : 'text-teal-300'}">${name}</div>
                            <div class="text-xs text-gray-400 mt-0.5">Standard difficulty ‚Ä¢ No augments required</div>
                        </div>
                        <div class="text-right">
                            <div class="text-xs text-gray-500">Rewards</div>
                            <div class="text-lg font-bold text-white">√ó1.0</div>
                        </div>
                    </div>
                `;
                
                if (!isLocked) {
                    div.querySelector('[data-level]').onclick = () => selectAscension(level);
                }
            } else {
                // Ascension Level - Expandable card
                const isExpanded = isSelected; // Auto-expand when selected
                
                div.innerHTML = `
                    <div class="cursor-pointer" data-level="${level}">
                        <!-- Header (always visible) -->
                        <div class="flex justify-between items-center">
                            <div class="flex items-center gap-2">
                                <i class="fas fa-chevron-${isExpanded ? 'down' : 'right'} text-purple-400 text-sm transition-transform"></i>
                                <div>
                                    <div class="text-lg font-bold ${isLocked ? 'text-gray-500' : 'text-purple-400'}">${name}</div>
                                    <div class="text-xs text-gray-400">${requiredSlots} Augment${requiredSlots > 1 ? 's' : ''} Required</div>
                                </div>
                            </div>
                            <div class="text-right">
                                <div class="text-xs text-gray-500">Rewards</div>
                                <div class="text-xl font-bold ${isLocked ? 'text-gray-500' : 'text-yellow-400'}">√ó${coreMultiplier.toFixed(1)}</div>
                            </div>
                        </div>
                        
                        ${isLocked ? `
                            <div class="mt-2 text-center text-gray-500 text-sm py-2">
                                <i class="fas fa-lock mr-2"></i>Complete Ascension ${level - 1} to unlock
                            </div>
                        ` : `
                            <!-- Expanded content (shown when selected) -->
                            <div class="expandable-content mt-3 pt-3 border-t border-gray-700" style="display: ${isExpanded ? 'block' : 'none'};">
                                <!-- Augment Slots -->
                                <div class="mb-3">
                                    <h4 class="text-xs font-bold text-purple-300 mb-2">
                                        <i class="fas fa-flask mr-1"></i>AUGMENT LOADOUT
                                    </h4>
                                    <div class="space-y-2" data-augment-slots="${level}">
                                        <!-- Slots will be inserted here by refreshAscensionAugments -->
                                    </div>
                                </div>
                                
                                <!-- Debuffs -->
                                <div>
                                    <h4 class="text-xs font-bold text-red-300 mb-2">
                                        <i class="fas fa-exclamation-triangle mr-1"></i>DEBUFFS (${debuffs.length})
                                    </h4>
                                    <div class="space-y-2">
                                        ${debuffs.map(debuff => `
                                            <div class="bg-red-900/20 border border-red-700 rounded p-2">
                                                <div class="text-red-400 font-bold text-sm mb-0.5">
                                                    <i class="fas ${debuff.icon} mr-1"></i>${debuff.name}
                                                </div>
                                                <div class="text-xs text-gray-400 leading-tight">${debuff.desc}</div>
                                            </div>
                                        `).join('')}
                                    </div>
                                </div>
                            </div>
                        `}
                    </div>
                `;
                
                if (!isLocked) {
                    div.querySelector('[data-level]').onclick = () => {
                        selectAscension(level);
                    };
                }
            }
            
            div.dataset.level = level;
            return div;
        }
        
        function refreshAscensionAugments(level) {
            const slotsContainer = document.querySelector(`[data-augment-slots="${level}"]`);
            if (!slotsContainer) return;
            
            const requiredSlots = level === 1 ? 1 : level === 2 ? 2 : 3;
            slotsContainer.innerHTML = '';
            
            // Only show the required number of slots (not all 3)
            for (let i = 0; i < requiredSlots; i++) {
                const equippedId = augmentProgress.loadout[i];
                
                const slotDiv = document.createElement('div');
                
                if (equippedId) {
                    const augment = augmentDefs[equippedId];
                    const tier = augmentProgress.unlocked[equippedId] || 0;
                    slotDiv.className = 'bg-gray-800 border border-purple-600 rounded p-2 flex items-center justify-between cursor-pointer hover:bg-gray-700 transition-all';
                    slotDiv.innerHTML = `
                        <div class="flex items-center gap-2">
                            <i class="fas ${augment.icon} text-purple-400"></i>
                            <div>
                                <p class="text-xs font-bold text-white">${augment.name}</p>
                                <p class="text-[9px] text-gray-400">Tier ${tier} ‚Ä¢ ${augment.category}</p>
                            </div>
                        </div>
                        <i class="fas fa-edit text-gray-500 text-xs"></i>
                    `;
                    slotDiv.onclick = () => openAugmentSelector(i);
                } else {
                    slotDiv.className = 'bg-gray-800 border border-gray-600 rounded p-2 flex items-center justify-between cursor-pointer hover:bg-gray-700 transition-all';
                    slotDiv.innerHTML = `
                        <div class="flex items-center gap-2">
                            <i class="fas fa-circle text-gray-600"></i>
                            <span class="text-xs text-gray-400">Slot ${i + 1} - Tap to select</span>
                        </div>
                        <i class="fas fa-chevron-right text-gray-600 text-xs"></i>
                    `;
                    slotDiv.onclick = () => openAugmentSelector(i);
                }
                
                slotsContainer.appendChild(slotDiv);
            }
        }
        
        let selectedAscensionLevel = parseInt(localStorage.getItem('neonrogue_lastAscension') || '0'); // Load last used level
        
        function selectAscension(level) {
            selectedAscensionLevel = level;
            
            // Save selected ascension level to localStorage
            localStorage.setItem('neonrogue_lastAscension', level.toString());
            
            // Update visual selection for all cards
            document.querySelectorAll('.ascension-option').forEach(opt => {
                const optLevel = parseInt(opt.dataset.level);
                const isLocked = opt.classList.contains('cursor-not-allowed');
                
                if (isLocked) {
                    return; // Keep locked styling
                }
                
                if (optLevel === level) {
                    // SELECTED - purple border
                    opt.className = 'ascension-option p-3 border-2 rounded-lg transition-all border-purple-500 bg-purple-900/30';
                    
                    // Auto-expand if not Normal Mode
                    if (level > 0) {
                        const expandable = opt.querySelector('.expandable-content');
                        const chevron = opt.querySelector('.fa-chevron-right, .fa-chevron-down');
                        if (expandable) {
                            expandable.style.display = 'block';
                            if (chevron) {
                                chevron.classList.remove('fa-chevron-right');
                                chevron.classList.add('fa-chevron-down');
                            }
                            refreshAscensionAugments(level);
                        }
                    }
                } else {
                    // NOT SELECTED - gray border
                    opt.className = 'ascension-option p-3 border-2 rounded-lg transition-all border-gray-600 bg-gray-800';
                    
                    // Collapse if expanded
                    const expandable = opt.querySelector('.expandable-content');
                    const chevron = opt.querySelector('.fa-chevron-down');
                    if (expandable) {
                        expandable.style.display = 'none';
                    }
                    if (chevron) {
                        chevron.classList.remove('fa-chevron-down');
                        chevron.classList.add('fa-chevron-right');
                    }
                }
            });
        }
        
        function refreshAugmentSection() {
            // This function is now replaced by refreshAscensionAugments
            // Called after augment selection to refresh the display
            if (selectedAscensionLevel > 0) {
                refreshAscensionAugments(selectedAscensionLevel);
            }
        }
        
        // Ascension Start Button
        document.getElementById('ascension-start-btn').onclick = () => {
            // Validate augment loadout before starting
            const requiredSlots = selectedAscensionLevel === 0 ? 0 : selectedAscensionLevel === 1 ? 1 : selectedAscensionLevel === 2 ? 2 : 3;
            const filledSlots = augmentProgress.loadout.filter(id => id !== null).length;
            
            if (filledSlots < requiredSlots) {
                alert(`‚ö†Ô∏è LOADOUT INCOMPLETE\n\nAscension ${selectedAscensionLevel} requires ${requiredSlots} augment${requiredSlots > 1 ? 's' : ''}.\nYou have ${filledSlots} equipped.\n\nPlease visit the Augment Lab to complete your loadout.`);
                return;
            }
            
            document.getElementById('ascension-screen').classList.remove('active');
            state.activeAscension = selectedAscensionLevel;
            console.log('üî• Starting run with Ascension Level:', selectedAscensionLevel);
            initGame();
        };
        
        // Ascension Back Button
        document.getElementById('ascension-back-btn').onclick = () => {
            document.getElementById('ascension-screen').classList.remove('active');
            document.getElementById('menu-screen').classList.add('active');
            // Don't reset selection - keep last used level persistent
        };
        
        function showVictory() {
            // CRITICAL: Save weaponStats immediately before anything else can reset it
            const savedWeaponStats = JSON.parse(JSON.stringify(state.weaponStats || {}));
            console.log('üíæ Saved weaponStats for victory screen:', savedWeaponStats);
            
            // TEST MODE: Don't save any progress
            if (testModeEnabled) {
                console.log('üß™ TEST MODE: Victory achieved but NOT saving progress');
                state.screen = 'gameover';
                
                // Change title to VICTORY
                const gameoverTitle = document.querySelector('#gameover-screen h2');
                if (gameoverTitle) {
                    gameoverTitle.textContent = 'VICTORY (TEST MODE - NOT SAVED)';
                    gameoverTitle.className = 'text-4xl text-yellow-400 font-black mb-1 drop-shadow-[0_0_20px_rgba(234,179,8,0.5)]';
                }
                
                // Hide level display for victory
                document.getElementById('final-level').parentElement.style.display = 'none';
                
                // Set score and time
                document.getElementById('final-score').innerText = formatScore(state.score);
                const t = Math.floor((state.gameTime)/1000);
                const mins = Math.floor(t/60).toString().padStart(2, '0');
                const secs = (t%60).toString().padStart(2, '0');
                document.getElementById('final-time').innerText = `${mins}:${secs}`;
                
                document.getElementById('gameover-screen').classList.add('active');
                return; // Skip all saving logic
            }
            
            // NORMAL MODE: Save progress
            // Check if this is the first victory
            const hasBeatenBoss = localStorage.getItem('neonrogue_hasBeatenBoss');
            const isFirstVictory = !hasBeatenBoss || hasBeatenBoss === 'false';
            
            // Mark boss as beaten
            if (isFirstVictory) {
                localStorage.setItem('neonrogue_hasBeatenBoss', 'true');
                window.justUnlockedSystems = true; // Flag for unlock notification
            } else {
                window.justUnlockedSystems = false;
            }
            
            state.screen = 'gameover';
            
            // Change title to VICTORY
            const gameoverTitle = document.querySelector('#gameover-screen h2');
            if (gameoverTitle) {
                gameoverTitle.textContent = 'VICTORY';
                gameoverTitle.className = 'text-4xl text-teal-400 font-black mb-1 drop-shadow-[0_0_20px_rgba(0,209,178,0.5)]';
            }
            
            // Remove any existing victory message
            const existingVictoryMsg = document.getElementById('victory-message');
            if (existingVictoryMsg) existingVictoryMsg.remove();
            
            // Hide level display for victory
            document.getElementById('final-level').parentElement.style.display = 'none';
            
            // Set score and time
            document.getElementById('final-score').innerText = formatScore(state.score);
            const t = Math.floor((state.gameTime)/1000);
            const mins = Math.floor(t/60).toString().padStart(2, '0');
            const secs = (t%60).toString().padStart(2, '0');
            document.getElementById('final-time').innerText = `${mins}:${secs}`;
            
            // Add victory message after h2
            const victoryMessage = document.createElement('div');
            victoryMessage.id = 'victory-message';
            victoryMessage.className = 'mb-3 text-center';
            
            // Handle Ascension progression
            const highestAscension = parseInt(localStorage.getItem('neonrogue_highestAscension') || '0');
            const currentAscension = state.activeAscension || 0;
            let ascensionUnlockMessage = '';
            
            // If player beat the game on an ascension level equal to their highest, unlock next level
            if (currentAscension > 0 && currentAscension === highestAscension + 1 && currentAscension < 5) {
                localStorage.setItem('neonrogue_highestAscension', currentAscension);
                ascensionUnlockMessage = `
                    <div style="color: #a855f7; font-size: 16px; font-weight: bold; margin-top: 8px;">
                        <i class="fas fa-star"></i> Ascension ${currentAscension + 1} Unlocked! <i class="fas fa-star"></i>
                    </div>
                `;
            } else if (currentAscension === 5 && highestAscension < 5) {
                // First time beating Ascension 5
                localStorage.setItem('neonrogue_highestAscension', 5);
                ascensionUnlockMessage = `
                    <div style="color: #ffd700; font-size: 18px; font-weight: bold; margin-top: 8px; text-shadow: 0 0 20px rgba(255, 215, 0, 0.8);">
                        <i class="fas fa-trophy"></i> ASCENSION COMPLETE <i class="fas fa-trophy"></i>
                    </div>
                    <div style="color: #a855f7; font-size: 14px; margin-top: 4px;">
                        You have conquered all Ascension levels!
                    </div>
                `;
            }
            
            const ascensionDisplay = currentAscension > 0 ? `
                <div style="color: #a855f7; font-size: 14px; margin-bottom: 8px;">
                    Ascension ${currentAscension} Completed
                </div>
            ` : '';
            
            victoryMessage.innerHTML = `
                ${ascensionDisplay}
                <div style="color: #00d1b2; font-size: 18px; font-weight: bold; margin-bottom: 8px;">
                    ‚ú® NEXUS PRIME DEFEATED ‚ú®
                </div>
                <div style="color: #ffd700; font-size: 16px;">
                    +1 Quantum Singularity
                </div>
                ${ascensionUnlockMessage}
            `;
            
            // Insert victory message after title
            if (gameoverTitle && gameoverTitle.parentElement) {
                gameoverTitle.parentElement.insertBefore(victoryMessage, gameoverTitle.nextSibling);
            }
            
            // Populate weapon stats breakdown (same as gameOver)
            const statsList = document.getElementById('weapon-stats-list');
            if (!statsList) {
                console.error('‚ùå weapon-stats-list element not found in victory!');
                return;
            }
            statsList.innerHTML = '';
            
            // Weapon display names - only actual weapons
            const weaponNames = {
                'ion': 'Ion Cannon',
                'turret': 'Auto-Turret',
                'emp': 'EMP Pulse',
                'barrier': 'Kinetic Barrier',
                'orbital': 'Bladestorm',
                'surge': 'Elemental Surge',
                'beam': 'Plasma Beam',
                'seeker': 'Seeker Missiles',
                'rad': 'Radiation Field',
                'tesla': 'Tesla Coils',
                'whip': 'Plasma Whip',
                'meteor': 'Meteor Strike',
                'railgun': 'Railgun',
                'flak': 'Flak Cannon',
                'pylons': 'Energy Pylons',
                'mines': 'Collapsar Mines',
                'gas': 'Toxic Barrage',
                'ricochet': 'Ricochet Disc',
                'drones': 'Combat Drones'
            };
            
            console.log('üéâ Victory weaponStats:', savedWeaponStats);
            console.log('üéâ Victory weaponStats keys:', Object.keys(savedWeaponStats));
            console.log('üéâ Victory weaponStats entries:', Object.entries(savedWeaponStats));
            
            // Filter to only actual weapons and sort by damage
            const weaponArray = Object.entries(savedWeaponStats || {})
                .filter(([weapon, stats]) => {
                    const hasName = weaponNames[weapon];
                    console.log(`  Checking weapon "${weapon}": hasName=${hasName}, stats=`, stats);
                    return hasName;
                })
                .map(([weapon, stats]) => ({ weapon, ...stats }))
                .sort((a, b) => (b.damage || 0) - (a.damage || 0));
            
            console.log('üéâ Victory weaponArray length:', weaponArray.length);
            
            // Calculate totals
            const totalDamage = weaponArray.reduce((sum, w) => sum + (w.damage || 0), 0);
            const totalKills = weaponArray.reduce((sum, w) => sum + (w.kills || 0), 0);
            
            console.log('üéâ Victory Total damage:', totalDamage, 'Total kills:', totalKills);
            
            // Create table structure with proper header - 4 columns only
            const table = document.createElement('div');
            table.className = 'w-full font-mono text-xs'; // Smaller font (text-xs instead of text-sm)
            
            // Header row - 4 columns: Weapon, Damage, %, Kills
            const header = document.createElement('div');
            header.className = 'grid grid-cols-[120px_75px_40px_50px] gap-2 px-2 py-2 border-b border-gray-600 text-gray-400 font-bold uppercase';
            header.innerHTML = `
                <span class="text-left">Weapon</span>
                <span class="text-right">Damage</span>
                <span class="text-right">%</span>
                <span class="text-right">Kills</span>
            `;
            table.appendChild(header);
            
            // Display each weapon as table row
            if (weaponArray.length > 0) {
                weaponArray.forEach(w => {
                    const weaponName = weaponNames[w.weapon];
                    const damagePercent = totalDamage > 0 ? ((w.damage / totalDamage) * 100).toFixed(0) : 0; // No decimal
                    
                    const row = document.createElement('div');
                    row.className = 'grid grid-cols-[120px_75px_40px_50px] gap-2 px-2 py-1 bg-gray-900 bg-opacity-30 hover:bg-opacity-50 rounded mb-1';
                    row.innerHTML = `
                        <span class="text-teal-300 font-bold text-left truncate" title="${weaponName}">${weaponName}</span>
                        <span class="text-orange-400 text-right">${Math.floor(w.damage || 0).toLocaleString()}</span>
                        <span class="text-gray-500 text-right">${damagePercent}%</span>
                        <span class="text-red-400 text-right">${w.kills || 0}</span>
                    `;
                    table.appendChild(row);
                });
            } else {
                // Show message if no weapons were used
                const noDataRow = document.createElement('div');
                noDataRow.className = 'px-2 py-4 text-center text-gray-500';
                noDataRow.textContent = 'No weapon data recorded';
                table.appendChild(noDataRow);
            }
            
            // Add totals row (only if there's data)
            if (weaponArray.length > 0) {
                const totalsRow = document.createElement('div');
                totalsRow.className = 'grid grid-cols-[120px_75px_40px_50px] gap-2 px-2 py-2 mt-2 border-t border-gray-600 font-bold';
                totalsRow.innerHTML = `
                    <span class="text-white text-left">TOTAL</span>
                    <span class="text-orange-300 text-right">${Math.floor(totalDamage).toLocaleString()}</span>
                    <span class="text-gray-600 text-right">-</span>
                    <span class="text-red-300 text-right">${totalKills}</span>
                `;
                table.appendChild(totalsRow);
            }
            
            statsList.appendChild(table);
            console.log('üéâ Victory table appended, innerHTML length:', statsList.innerHTML.length);
            
            // Update meta progression stats
            updateMetaStats();
            
            // Show the screen
            document.getElementById('gameover-screen').classList.add('active');
            document.getElementById('hud').style.display = 'none';
        }

        function gameOver() {
            console.log('üî¥ gameOver() called, state.screen:', state.screen);
            console.log('üî¥ IMMEDIATE CHECK - state.weaponStats:', JSON.stringify(state.weaponStats, null, 2));
            console.log('üî¥ IMMEDIATE CHECK - typeof state.weaponStats:', typeof state.weaponStats);
            console.log('üî¥ IMMEDIATE CHECK - Object.keys:', Object.keys(state.weaponStats || {}));
            
            // Prevent multiple calls
            if (state.screen === 'gameover') {
                console.log('‚ö†Ô∏è gameOver() blocked - already on gameover screen');
                return;
            }
            
            try {
                console.log('üî¥ Setting screen to gameover...');
                state.screen = 'gameover';
                
                // Ensure weaponStats exists
                if (!state.weaponStats) {
                    console.error('‚ùå state.weaponStats was undefined! Creating empty object');
                    state.weaponStats = {};
                }
                
                console.log('üî¥ Updating DOM elements...');
                // Reset title to TERMINATED for normal death
                const gameoverTitle = document.querySelector('#gameover-screen h2');
                if (gameoverTitle) {
                    gameoverTitle.textContent = 'TERMINATED';
                    gameoverTitle.className = 'text-5xl text-red-600 font-black mb-2 drop-shadow-[0_0_20px_rgba(255,56,96,0.5)]';
                }
                
                // Remove victory message if present
                const victoryMsg = document.getElementById('victory-message');
                if (victoryMsg) victoryMsg.remove();
                
                // Show level for normal death
                const levelElement = document.getElementById('final-level').parentElement;
                if (levelElement) levelElement.style.display = '';
                
                console.log('üî¥ Displaying stats...');
                document.getElementById('final-level').innerText = state.level;
                document.getElementById('final-score').innerText = formatScore(state.score);
                
                // Format and display run time
                const totalSeconds = Math.floor(state.gameTime / 1000);
                const minutes = Math.floor(totalSeconds / 60);
                const seconds = totalSeconds % 60;
                document.getElementById('final-time').innerText = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                
                console.log('üî¥ Processing weapon stats...');
                // Populate weapon stats breakdown
                const statsList = document.getElementById('weapon-stats-list');
                if (!statsList) {
                    console.error('‚ùå weapon-stats-list element not found!');
                    return;
                }
                statsList.innerHTML = '';
                
                // Weapon display names - only actual weapons
                const weaponNames = {
                    'ion': 'Ion Cannon',
                    'turret': 'Auto-Turret',
                    'emp': 'EMP Pulse',
                    'barrier': 'Kinetic Barrier',
                    'orbital': 'Bladestorm',
                    'surge': 'Elemental Surge',
                    'beam': 'Plasma Beam',
                    'seeker': 'Seeker Missiles',
                    'rad': 'Radiation Field',
                    'tesla': 'Tesla Coils',
                    'whip': 'Plasma Whip',
                    'meteor': 'Meteor Strike',
                    'railgun': 'Railgun',
                    'flak': 'Flak Cannon',
                    'pylons': 'Energy Pylons',
                    'mines': 'Collapsar Mines',
                    'gas': 'Toxic Barrage',
                    'ricochet': 'Ricochet Disc',
                    'drones': 'Combat Drones'
                };
                
                console.log('üî¥ weaponStats:', state.weaponStats);
                console.log('üî¥ weaponStats keys:', Object.keys(state.weaponStats));
                
                // Filter to only actual weapons and sort by damage
                const weaponArray = Object.entries(state.weaponStats || {})
                    .filter(([weapon, stats]) => weaponNames[weapon]) // Only known weapons
                    .map(([weapon, stats]) => ({ weapon, ...stats }))
                    .sort((a, b) => (b.damage || 0) - (a.damage || 0));
                
                console.log('üî¥ weaponArray length:', weaponArray.length);
                console.log('üî¥ weaponArray:', weaponArray);
                
                // Calculate totals
                const totalDamage = weaponArray.reduce((sum, w) => sum + (w.damage || 0), 0);
                const totalKills = weaponArray.reduce((sum, w) => sum + (w.kills || 0), 0);
                
                console.log('üî¥ Creating weapon table...');
                console.log('üî¥ Total damage:', totalDamage, 'Total kills:', totalKills);
                
                // Create table structure with proper header - 4 columns only
                const table = document.createElement('div');
                table.className = 'w-full font-mono text-xs'; // Smaller font (text-xs instead of text-sm)
                
                // Header row - 4 columns: Weapon, Damage, %, Kills
                const header = document.createElement('div');
                header.className = 'grid grid-cols-[120px_75px_40px_50px] gap-2 px-2 py-2 border-b border-gray-600 text-gray-400 font-bold uppercase';
                header.innerHTML = `
                    <span class="text-left">Weapon</span>
                    <span class="text-right">Damage</span>
                    <span class="text-right">%</span>
                    <span class="text-right">Kills</span>
                `;
                table.appendChild(header);
                
                // Display each weapon as table row
                if (weaponArray.length > 0) {
                    weaponArray.forEach(w => {
                        const weaponName = weaponNames[w.weapon];
                        const damagePercent = totalDamage > 0 ? ((w.damage / totalDamage) * 100).toFixed(0) : 0; // No decimal
                        
                        const row = document.createElement('div');
                        row.className = 'grid grid-cols-[120px_75px_40px_50px] gap-2 px-2 py-1 bg-gray-900 bg-opacity-30 hover:bg-opacity-50 rounded mb-1';
                        row.innerHTML = `
                            <span class="text-teal-300 font-bold text-left truncate" title="${weaponName}">${weaponName}</span>
                            <span class="text-orange-400 text-right">${Math.floor(w.damage || 0).toLocaleString()}</span>
                            <span class="text-gray-500 text-right">${damagePercent}%</span>
                            <span class="text-red-400 text-right">${w.kills || 0}</span>
                        `;
                        table.appendChild(row);
                    });
                } else {
                    // Show message if no weapons were used
                    const noDataRow = document.createElement('div');
                    noDataRow.className = 'px-2 py-4 text-center text-gray-500';
                    noDataRow.textContent = 'No weapon data recorded';
                    table.appendChild(noDataRow);
                }
                
                // Add totals row (only if there's data)
                if (weaponArray.length > 0) {
                    const totalsRow = document.createElement('div');
                    totalsRow.className = 'grid grid-cols-[120px_75px_40px_50px] gap-2 px-2 py-2 mt-2 border-t border-gray-600 font-bold';
                    totalsRow.innerHTML = `
                        <span class="text-white text-left">TOTAL</span>
                        <span class="text-orange-300 text-right">${Math.floor(totalDamage).toLocaleString()}</span>
                        <span class="text-gray-600 text-right">-</span>
                        <span class="text-red-300 text-right">${totalKills}</span>
                    `;
                    table.appendChild(totalsRow);
                }
                
                statsList.appendChild(table);
                console.log('üî¥ Table appended to statsList, innerHTML length:', statsList.innerHTML.length);
                
                console.log('üî¥ Updating meta stats...');
                // Update meta progression stats
                updateMetaStats();
                
                console.log('üî¥ Showing gameover screen...');
                document.getElementById('gameover-screen').classList.add('active');
                
                console.log('‚úÖ gameOver() completed successfully');
            } catch (error) {
                console.error('‚ùå ERROR in gameOver():', error);
                console.error('Error stack:', error.stack);
                // Still try to show the game over screen
                document.getElementById('gameover-screen').classList.add('active');
            }
        }


        // --- Input ---
        const handleStart = (x,y) => { 
            input.active=true; input.origin={x,y}; input.current={x,y}; input.vector={x:0,y:0}; document.getElementById('start-hint').style.display='none'; 
        };
        const handleMove = (x,y) => {
            if(!input.active) return;
            input.current = {x, y}; // Track current position for joystick visual
            const dx = x - input.origin.x; const dy = y - input.origin.y;
            const dist = Math.sqrt(dx*dx + dy*dy); const max = 60;
            if(dist>0) { const l = Math.min(dist,max); input.vector.x=(dx/dist)*(l/max); input.vector.y=(dy/dist)*(l/max); }
        };
        const handleEnd = () => { input.active=false; input.vector={x:0,y:0}; };


        window.addEventListener('touchstart', e=>{if(state.screen==='game') handleStart(e.touches[0].clientX,e.touches[0].clientY)},{passive:false});
        window.addEventListener('touchmove', e=>{if(state.screen==='game') handleMove(e.touches[0].clientX,e.touches[0].clientY)},{passive:false});
        window.addEventListener('touchend', handleEnd);
        window.addEventListener('mousedown', e=>{if(state.screen==='game') handleStart(e.clientX,e.clientY)});
        window.addEventListener('mousemove', e=>{if(state.screen==='game') handleMove(e.clientX,e.clientY)});
        window.addEventListener('mouseup', handleEnd);


        const startBtn = document.getElementById('start-btn');
        console.log('Start button:', startBtn ? 'found' : 'NOT FOUND');
        
        // Test Mode System
        let testModeEnabled = false;
        const testModeSettings = {
            level: 50,
            ship: 'pathfinder',
            weapons: [null, null, null, null], // 4 weapon slots
            elements: ['random', 'random', 'random', 'random'], // Element for each weapon
            weaponLevel: 10,
            ultimate: 'random',
            ultimateCharge: 90,
            instantUltRecharge: false, // Instant ultimate recharge (3s after use)
            godMode: true
        };
        
        // Ship to starting weapon mapping
        const shipStartingWeapons = {
            'pathfinder': 'ion',
            'engineer': 'turret',
            'disruptor': 'emp',
            'vanguard': 'barrier',
            'reaper': 'orbital',
            'catalyst': 'surge'
        };
        
        // All available weapons for dropdowns
        const allWeapons = [
            { id: 'ion', name: 'Ion Cannon' },
            { id: 'turret', name: 'Auto-Turret' },
            { id: 'emp', name: 'EMP Pulse' },
            { id: 'barrier', name: 'Kinetic Barrier' },
            { id: 'orbital', name: 'Bladestorm' },
            { id: 'surge', name: 'Elemental Surge' },
            { id: 'beam', name: 'Plasma Beam' },
            { id: 'seeker', name: 'Seeker Swarm' },
            { id: 'rad', name: 'Rad-Field' },
            { id: 'tesla', name: 'Tesla Coil' },
            { id: 'whip', name: 'Plasma Whip' },
            { id: 'meteor', name: 'Meteor Strike' },
            { id: 'railgun', name: 'Railgun' },
            { id: 'flak', name: 'Flak Cannon' },
            { id: 'pylons', name: 'Energy Pylons' },
            { id: 'ricochet', name: 'Ricochet Disc' },
            { id: 'drones', name: 'Combat Drones' },
            { id: 'mines', name: 'Collapsar Mines' },
            { id: 'gas', name: 'Toxic Barrage' }
        ];
        
        // Populate weapon dropdowns
        function populateWeaponDropdowns() {
            for (let i = 1; i <= 4; i++) {
                const select = document.getElementById(`test-weapon-${i}`);
                if (select) {
                    // Clear existing options except first
                    select.innerHTML = `<option value="">-- Slot ${i}${i === 1 ? ' (Starting Weapon)' : ''} --</option>`;
                    
                    allWeapons.forEach(weapon => {
                        const option = document.createElement('option');
                        option.value = weapon.id;
                        option.textContent = weapon.name;
                        select.appendChild(option);
                    });
                }
            }
        }
        
        // Initialize test mode UI
        populateWeaponDropdowns();
        
        // Test Mode Toggle
        const testModeToggle = document.getElementById('test-mode-toggle');
        const testModeStatus = document.getElementById('test-mode-status');
        if (testModeToggle) {
            testModeToggle.onclick = () => {
                testModeEnabled = !testModeEnabled;
                testModeStatus.textContent = testModeEnabled ? 'ON' : 'OFF';
                testModeToggle.style.borderColor = testModeEnabled ? '#14b8a6' : '#374151';
                testModeToggle.style.color = testModeEnabled ? '#14b8a6' : '#9ca3af';
            };
        }
        
        // Test Mode Settings Button
        const testSettingsBtn = document.getElementById('test-mode-settings-btn');
        const testSettingsModal = document.getElementById('test-mode-settings-modal');
        const testSettingsClose = document.getElementById('test-settings-close');
        
        if (testSettingsBtn) {
            testSettingsBtn.onclick = () => {
                testSettingsModal.classList.add('active');
                // Load current settings into UI
                document.getElementById('test-level-slider').value = testModeSettings.level;
                document.getElementById('test-level-value').textContent = testModeSettings.level;
                document.getElementById('test-ship-select').value = testModeSettings.ship;
                document.getElementById('test-weapon-level-slider').value = testModeSettings.weaponLevel;
                document.getElementById('test-weapon-level-value').textContent = testModeSettings.weaponLevel;
                document.getElementById('test-ultimate-select').value = testModeSettings.ultimate;
                document.getElementById('test-ult-charge-slider').value = testModeSettings.ultimateCharge;
                document.getElementById('test-ult-charge-value').textContent = testModeSettings.ultimateCharge + '%';
                document.getElementById('test-instant-ult').checked = testModeSettings.instantUltRecharge;
                document.getElementById('test-god-mode').checked = testModeSettings.godMode;
                
                // Load weapons and elements
                for (let i = 0; i < 4; i++) {
                    const weaponSelect = document.getElementById(`test-weapon-${i + 1}`);
                    const elementSelect = document.getElementById(`test-element-${i + 1}`);
                    if (weaponSelect) weaponSelect.value = testModeSettings.weapons[i] || '';
                    if (elementSelect) elementSelect.value = testModeSettings.elements[i] || 'random';
                }
            };
        }
        
        if (testSettingsClose) {
            testSettingsClose.onclick = () => {
                testSettingsModal.classList.remove('active');
            };
        }
        
        // Settings sliders
        const levelSlider = document.getElementById('test-level-slider');
        const levelValue = document.getElementById('test-level-value');
        if (levelSlider) {
            levelSlider.oninput = () => {
                levelValue.textContent = levelSlider.value;
            };
        }
        
        const weaponLevelSlider = document.getElementById('test-weapon-level-slider');
        const weaponLevelValue = document.getElementById('test-weapon-level-value');
        if (weaponLevelSlider) {
            weaponLevelSlider.oninput = () => {
                weaponLevelValue.textContent = weaponLevelSlider.value;
            };
        }
        
        const ultChargeSlider = document.getElementById('test-ult-charge-slider');
        const ultChargeValue = document.getElementById('test-ult-charge-value');
        if (ultChargeSlider) {
            ultChargeSlider.oninput = () => {
                ultChargeValue.textContent = ultChargeSlider.value + '%';
            };
        }
        
        // Randomize Weapons Button
        const randomizeBtn = document.getElementById('test-randomize-weapons');
        if (randomizeBtn) {
            randomizeBtn.onclick = () => {
                const shuffled = [...allWeapons].sort(() => Math.random() - 0.5);
                for (let i = 0; i < 4; i++) {
                    const select = document.getElementById(`test-weapon-${i + 1}`);
                    if (select) select.value = shuffled[i].id;
                }
            };
        }
        
        // Apply Settings Button
        const applyBtn = document.getElementById('test-settings-apply');
        if (applyBtn) {
            applyBtn.onclick = () => {
                testModeSettings.level = parseInt(document.getElementById('test-level-slider').value);
                testModeSettings.ship = document.getElementById('test-ship-select').value;
                testModeSettings.weaponLevel = parseInt(document.getElementById('test-weapon-level-slider').value);
                testModeSettings.ultimate = document.getElementById('test-ultimate-select').value;
                testModeSettings.ultimateCharge = parseInt(document.getElementById('test-ult-charge-slider').value);
                testModeSettings.instantUltRecharge = document.getElementById('test-instant-ult').checked;
                testModeSettings.godMode = document.getElementById('test-god-mode').checked;
                
                // Save weapons and elements
                for (let i = 0; i < 4; i++) {
                    const weaponSelect = document.getElementById(`test-weapon-${i + 1}`);
                    const elementSelect = document.getElementById(`test-element-${i + 1}`);
                    testModeSettings.weapons[i] = weaponSelect ? (weaponSelect.value || null) : null;
                    testModeSettings.elements[i] = elementSelect ? elementSelect.value : 'random';
                }
                
                testSettingsModal.classList.remove('active');
                console.log('‚úÖ Test mode settings saved:', testModeSettings);
            };
        }
        
        // Reset Settings Button
        const resetBtn = document.getElementById('test-settings-reset');
        if (resetBtn) {
            resetBtn.onclick = () => {
                testModeSettings.level = 50;
                testModeSettings.ship = 'pathfinder';
                testModeSettings.weapons = [null, null, null, null];
                testModeSettings.elements = ['random', 'random', 'random', 'random'];
                testModeSettings.weaponLevel = 10;
                testModeSettings.ultimate = 'random';
                testModeSettings.ultimateCharge = 90;
                testModeSettings.instantUltRecharge = false;
                testModeSettings.godMode = true;
                
                // Update UI
                document.getElementById('test-level-slider').value = 50;
                document.getElementById('test-level-value').textContent = '50';
                document.getElementById('test-ship-select').value = 'pathfinder';
                document.getElementById('test-weapon-level-slider').value = 10;
                document.getElementById('test-weapon-level-value').textContent = '10';
                document.getElementById('test-ultimate-select').value = 'random';
                document.getElementById('test-ult-charge-slider').value = 90;
                document.getElementById('test-ult-charge-value').textContent = '90%';
                document.getElementById('test-instant-ult').checked = false;
                document.getElementById('test-god-mode').checked = true;
                
                for (let i = 1; i <= 4; i++) {
                    const weaponSelect = document.getElementById(`test-weapon-${i}`);
                    const elementSelect = document.getElementById(`test-element-${i}`);
                    if (weaponSelect) weaponSelect.value = '';
                    if (elementSelect) elementSelect.value = 'random';
                }
            };
        }
        
        if (startBtn) {
            startBtn.onclick = () => {
                console.log('Start button clicked!');
                
                // If test mode is enabled, apply test settings but still go through normal flow
                if (testModeEnabled) {
                    console.log('üß™ TEST MODE ENABLED - Applying settings:', testModeSettings);
                    
                    // Override ship selection
                    const shipIndex = ships.findIndex(s => s.name.toLowerCase() === testModeSettings.ship);
                    if (shipIndex >= 0) {
                        currentShipIndex = shipIndex;
                        updateShipDisplay();
                    }
                }
                
                // Save selected ship
                const selectedShip = ships[currentShipIndex];
                if (!selectedShip.locked) {
                    localStorage.setItem('neonrogue_selectedShip', selectedShip.name);
                }
                
                // Normal flow - check if Ascension mode is unlocked
                const singularities = parseInt(localStorage.getItem('neonrogue_singularities') || '0');
                
                if (singularities > 0) {
                    // Show Ascension selection screen
                    document.getElementById('menu-screen').classList.remove('active');
                    showAscensionScreen();
                } else {
                    // Go directly to game
                    document.getElementById('menu-screen').classList.remove('active'); 
                    initGame();
                }
            };
        }
        
        const restartBtn = document.getElementById('restart-btn');
        if (restartBtn) {
            restartBtn.onclick = () => { 
                document.getElementById('gameover-screen').classList.remove('active');
                
                // Check if player just beat the boss for the first time (stored in showVictory)
                if (window.justUnlockedSystems) {
                    window.justUnlockedSystems = false; // Clear flag
                    document.getElementById('unlock-notification-screen').classList.add('active');
                } else {
                    document.getElementById('menu-screen').classList.add('active');
                }
            };
        }
        
        // Death Recap Button
        const deathRecapBtn = document.getElementById('death-recap-btn');
        const deathRecapModal = document.getElementById('death-recap-modal');
        const closeDeathRecap = document.getElementById('close-death-recap');
        
        if (deathRecapBtn && deathRecapModal) {
            deathRecapBtn.onclick = () => {
                // Populate death recap
                const recapList = document.getElementById('death-recap-list');
                recapList.innerHTML = '';
                
                if (player.damageLog && player.damageLog.length > 0) {
                    // Show only last 5 damage instances - OLDEST FIRST (fatal damage at bottom)
                    const recentDamage = player.damageLog.slice(-5); // Last 5, chronological order
                    
                    recentDamage.forEach((entry, index) => {
                        const entryDiv = document.createElement('div');
                        entryDiv.className = `p-3 rounded ${entry.wasFatal ? 'bg-red-900 bg-opacity-50 border-2 border-red-500' : 'bg-gray-800 bg-opacity-50 border border-gray-700'}`;
                        
                        const timeAgo = Math.round((Date.now() - entry.timestamp) / 1000);
                        const isFatal = entry.wasFatal;
                        
                        entryDiv.innerHTML = `
                            <div class="flex justify-between items-center mb-2">
                                <div class="flex items-center gap-3">
                                    ${isFatal ? '<i class="fas fa-skull text-red-500 text-lg"></i>' : '<span class="text-gray-600 text-xs">#' + (index + 1) + '</span>'}
                                    <span class="text-white font-bold text-lg">${entry.damage} <span class="text-red-400">DMG</span></span>
                                    ${entry.isCrit ? '<span class="text-red-300 font-bold text-sm ml-2 px-2 py-1 bg-red-950 border border-red-700 rounded">[CRIT!]</span>' : ''}
                                    ${isFatal ? '<span class="text-red-400 font-bold text-sm ml-2 px-2 py-1 bg-red-950 rounded">[FATAL]</span>' : ''}
                                </div>
                                <span class="text-gray-500 text-xs">${timeAgo}s ago</span>
                            </div>
                            <div class="flex items-center gap-2 text-sm">
                                <div class="flex items-center gap-2">
                                    <i class="fas fa-crosshairs text-teal-400"></i>
                                    <span class="text-teal-300 font-mono">${entry.source}</span>
                                </div>
                                <span class="text-gray-600">‚Ä¢</span>
                                <div class="flex items-center gap-2">
                                    <i class="fas fa-skull-crossbones text-orange-400"></i>
                                    <span class="text-orange-300 font-mono">${entry.enemyType}</span>
                                </div>
                            </div>
                            <div class="mt-2 text-xs">
                                <span class="text-gray-500">HP After:</span> 
                                <span class="font-mono ${entry.hpAfter <= 0 ? 'text-red-500' : entry.hpAfter < 30 ? 'text-yellow-400' : 'text-green-400'}">${entry.hpAfter}</span>
                            </div>
                        `;
                        
                        recapList.appendChild(entryDiv);
                    });
                    
                    // Auto-scroll to bottom (fatal damage)
                    setTimeout(() => {
                        recapList.scrollTop = recapList.scrollHeight;
                    }, 50);
                } else {
                    recapList.innerHTML = '<p class="text-gray-500 text-center py-8">No damage data available</p>';
                }
                
                deathRecapModal.classList.add('active');
            };
            
            closeDeathRecap.onclick = () => {
                deathRecapModal.classList.remove('active');
            };
        }
        
        
        // ===== SAVE/LOAD SYSTEM =====
        
        // Save data structure for meta progression
        function getSaveData() {
            const saveData = {
                version: 2, // Bumped for augment system
                timestamp: Date.now(),
                metaProgress: {
                    totalRuns: parseInt(localStorage.getItem('neonrogue_totalRuns') || '0'),
                    totalKills: parseInt(localStorage.getItem('neonrogue_totalKills') || '0'),
                    highestLevel: parseInt(localStorage.getItem('neonrogue_highestLevel') || '0'),
                    highestScore: parseInt(localStorage.getItem('neonrogue_highestScore') || '0'),
                    totalPlaytime: parseInt(localStorage.getItem('neonrogue_totalPlaytime') || '0'),
                    nexusCores: parseInt(localStorage.getItem('neonrogue_nexusCores') || '0'),
                    singularities: parseInt(localStorage.getItem('neonrogue_singularities') || '0'),
                    fourElementsAchieved: localStorage.getItem('neonrogue_4elementsAchieved') === 'true',
                    highestAscension: parseInt(localStorage.getItem('neonrogue_highestAscension') || '0'),
                    lastAscension: parseInt(localStorage.getItem('neonrogue_lastAscension') || '0')
                },
                // Augment system data
                augmentProgress: augmentProgress // Save entire augment progress object
            };
            console.log('üì¶ Exporting save data:', saveData);
            return saveData;
        }
        
        // Load save data from object
        function loadSaveData(data) {
            if (!data || !data.metaProgress) {
                alert('Invalid save file!');
                return false;
            }
            
            console.log('üì• Importing save data:', data);
            
            // Load meta progression data - REPLACE (not add to) current values
            const meta = data.metaProgress;
            localStorage.setItem('neonrogue_totalRuns', meta.totalRuns || 0);
            localStorage.setItem('neonrogue_totalKills', meta.totalKills || 0);
            localStorage.setItem('neonrogue_highestLevel', meta.highestLevel || 0);
            localStorage.setItem('neonrogue_highestScore', meta.highestScore || 0);
            localStorage.setItem('neonrogue_totalPlaytime', meta.totalPlaytime || 0);
            localStorage.setItem('neonrogue_nexusCores', meta.nexusCores || 0); // REPLACE not add
            localStorage.setItem('neonrogue_singularities', meta.singularities || 0); // REPLACE not add
            
            console.log(`‚úÖ Loaded currency: ${meta.nexusCores} cores, ${meta.singularities} singularities`);
            
            // Load elemental mastery achievement (Catalyst unlock)
            if (meta.fourElementsAchieved === true) {
                localStorage.setItem('neonrogue_4elementsAchieved', 'true');
                console.log('‚úÖ Loaded Catalyst unlock');
            }
            
            // Load Ascension progression
            if (meta.highestAscension !== undefined) {
                localStorage.setItem('neonrogue_highestAscension', meta.highestAscension || 0);
                console.log('‚úÖ Loaded highest Ascension level:', meta.highestAscension);
            }
            
            if (meta.lastAscension !== undefined) {
                localStorage.setItem('neonrogue_lastAscension', meta.lastAscension || 0);
                console.log('‚úÖ Loaded last used Ascension level:', meta.lastAscension);
            }
            
            // Load augment progress - REPLACE entire augment system state
            if (data.augmentProgress) {
                augmentProgress = data.augmentProgress;
                saveAugmentProgress(); // Save to localStorage
                console.log('‚úÖ Loaded augment progress:', augmentProgress);
            } else {
                console.log('‚ö†Ô∏è No augment data in save file (old save format)');
            }
            
            return true;
        }
        
        // Export save to file
        function exportSave() {
            const saveData = getSaveData();
            const dataStr = JSON.stringify(saveData, null, 2);
            const blob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = `neonrogue_save_${Date.now()}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            // Visual feedback
            const btn = document.getElementById('export-btn');
            const originalText = btn.innerHTML;
            btn.innerHTML = '<i class="fas fa-check mr-2"></i>EXPORTED!';
            btn.classList.add('bg-teal-600');
            setTimeout(() => {
                btn.innerHTML = originalText;
                btn.classList.remove('bg-teal-600');
            }, 2000);
        }
        
        // Import save from file
        function importSave(file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const data = JSON.parse(e.target.result);
                    if (loadSaveData(data)) {
                        // Show detailed feedback
                        const meta = data.metaProgress;
                        let msg = `Save imported successfully!\n\n` +
                            `Total Runs: ${meta.totalRuns || 0}\n` +
                            `Total Kills: ${meta.totalKills || 0}\n` +
                            `Highest Level: ${meta.highestLevel || 0}\n` +
                            `Highest Score: ${meta.highestScore || 0}\n` +
                            `Nexus Cores: ${meta.nexusCores || 0}\n` +
                            `Quantum Singularities: ${meta.singularities || 0}\n`;
                        
                        // Add Catalyst unlock status if present
                        if (meta.fourElementsAchieved === true) {
                            msg += `\n‚ú® CATALYST ship unlocked!\n`;
                        }
                        
                        msg += `\nPage will reload to apply changes.`;
                        alert(msg);
                        // Refresh the page to apply changes
                        location.reload();
                    }
                } catch (err) {
                    alert('Error reading save file: ' + err.message);
                }
            };
            reader.readAsText(file);
        }
        
        // Display stats screen
        function showStats() {
            const nexusCores = parseInt(localStorage.getItem('neonrogue_nexusCores') || '0');
            const totalRuns = parseInt(localStorage.getItem('neonrogue_totalRuns') || '0');
            const totalKills = parseInt(localStorage.getItem('neonrogue_totalKills') || '0');
            const highestLevel = parseInt(localStorage.getItem('neonrogue_highestLevel') || '0');
            const highestScore = parseInt(localStorage.getItem('neonrogue_highestScore') || '0');
            const totalPlaytime = parseInt(localStorage.getItem('neonrogue_totalPlaytime') || '0');
            const singularities = parseInt(localStorage.getItem('neonrogue_singularities') || '0');
            
            // Update display
            document.getElementById('stat-singularities').textContent = singularities.toLocaleString();
            document.getElementById('stat-cores').textContent = nexusCores.toLocaleString();
            document.getElementById('stat-runs').textContent = totalRuns.toLocaleString();
            document.getElementById('stat-kills').textContent = totalKills.toLocaleString();
            document.getElementById('stat-level').textContent = highestLevel;
            document.getElementById('stat-score').textContent = highestScore.toLocaleString();
            
            // Format playtime
            const hours = Math.floor(totalPlaytime / 3600);
            const minutes = Math.floor((totalPlaytime % 3600) / 60);
            document.getElementById('stat-time').textContent = `${hours}h ${minutes}m`;
            
            // Show modal
            document.getElementById('stats-screen').classList.add('active');
        }
        
        // Export button handlers
        document.getElementById('export-btn').addEventListener('click', exportSave);
        document.getElementById('gameover-export-btn').addEventListener('click', exportSave);
        
        // Ultimate button handlers
        const ultimateBtn = document.getElementById('ultimate-btn');
        
        ultimateBtn.addEventListener('click', (e) => {
            e.stopPropagation(); // Prevent click from bubbling to canvas (slow-motion mode)
            if (player.ultimate && player.ultimateCharge >= 100 && !player.ultimateActive) {
                console.log('üî• Ultimate activated:', player.ultimate);
                fireUltimate();
            }
        });
        
        ultimateBtn.addEventListener('touchend', (e) => {
            e.preventDefault();
            e.stopPropagation(); // Prevent touch from bubbling
            if (player.ultimate && player.ultimateCharge >= 100 && !player.ultimateActive) {
                console.log('üî• Ultimate activated:', player.ultimate);
                fireUltimate();
            }
        });
        
        // Import button handler
        document.getElementById('import-btn').addEventListener('click', () => {
            document.getElementById('import-file-input').click();
        });
        
        document.getElementById('import-file-input').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                importSave(file);
            }
            // Reset input so same file can be selected again
            e.target.value = '';
        });
        
        // ===== AUGMENT SYSTEM FUNCTIONS =====
        
        // Load augment progress from localStorage
        function loadAugmentProgress() {
            const saved = localStorage.getItem('neonrogue_augmentProgress');
            if (saved) {
                try {
                    augmentProgress = JSON.parse(saved);
                    console.log('‚úÖ Loaded augment progress:', augmentProgress);
                } catch (e) {
                    console.error('Failed to load augment progress:', e);
                    augmentProgress = { unlocked: {}, loadout: [null, null, null] };
                }
            }
            
            // Load last ascension for slot availability
            lastAscension = parseInt(localStorage.getItem('neonrogue_lastAscension') || '0');
        }
        
        // Save augment progress to localStorage
        function saveAugmentProgress() {
            localStorage.setItem('neonrogue_augmentProgress', JSON.stringify(augmentProgress));
            console.log('üíæ Saved augment progress');
        }
        
        // Get available augment slots based on last ascension
        function getAvailableSlots() {
            if (lastAscension === 0) return 0;
            if (lastAscension === 1) return 1;
            if (lastAscension === 2) return 2;
            return 3; // Ascension 3-5
        }
        
        // Open Augment Lab
        function openAugmentLab() {
            document.getElementById('menu-screen').classList.remove('active');
            document.getElementById('augment-lab-screen').classList.add('active');
            updateLabCurrency();
            renderAugmentBrowse();
        }
        
        // Close Augment Lab
        function closeAugmentLab() {
            document.getElementById('augment-lab-screen').classList.remove('active');
            document.getElementById('menu-screen').classList.add('active');
        }
        
        // Update currency display in lab
        function updateLabCurrency() {
            const cores = parseInt(localStorage.getItem('neonrogue_nexusCores') || '0');
            const singularities = parseInt(localStorage.getItem('neonrogue_singularities') || '0');
            document.getElementById('lab-cores').textContent = cores;
            document.getElementById('lab-singularities').textContent = singularities;
        }
        
        // Render Browse Tab with augment cards
        function renderAugmentBrowse(filter = 'all') {
            const container = document.getElementById('augment-cards-grid');
            container.innerHTML = '';
            
            const cores = parseInt(localStorage.getItem('neonrogue_nexusCores') || '0');
            const singularities = parseInt(localStorage.getItem('neonrogue_singularities') || '0');
            
            // Rarity colors
            const rarityColors = {
                common: 'border-gray-500',
                rare: 'border-blue-500',
                epic: 'border-purple-500'
            };
            
            // Category icons
            const categoryIcons = {
                offense: 'fa-crosshairs',
                defense: 'fa-shield',
                utility: 'fa-tools'
            };
            
            Object.values(augmentDefs).forEach(augment => {
                // Apply category filter
                if (filter !== 'all' && augment.category !== filter) return;
                
                const currentTier = augmentProgress.unlocked[augment.id] || 0;
                const nextTier = currentTier + 1;
                const maxTier = augment.tiers.length;
                const isMaxed = currentTier >= maxTier;
                
                const nextTierData = isMaxed ? null : augment.tiers[nextTier - 1];
                const canAfford = nextTierData && 
                    cores >= nextTierData.costCores && 
                    singularities >= nextTierData.costSingularities;
                
                const colorClass = rarityColors[augment.rarity];
                const categoryIcon = categoryIcons[augment.category];
                
                const card = document.createElement('div');
                card.className = `bg-gray-800 border ${colorClass} rounded`;
                
                // Build card HTML with separated header and body
                let cardHTML = `
                    <!-- Header section with lighter background -->
                    <div class="bg-gray-750 p-3 relative">
                        <!-- Floating unlock button in top right -->
                        <div class="absolute top-3 right-3">
                            ${!isMaxed ? `
                                <button 
                                    onclick="unlockAugmentTier('${augment.id}')"
                                    class="${canAfford ? 'bg-purple-600 hover:bg-purple-500' : 'bg-gray-700 cursor-not-allowed'} text-white text-xs font-bold py-1.5 px-4 rounded whitespace-nowrap transition-all"
                                    ${!canAfford ? 'disabled' : ''}
                                >
                                    ${canAfford ? (currentTier > 0 ? 'UPGRADE' : 'UNLOCK') : 'LOCKED'}
                                </button>
                            ` : `
                                <div class="text-teal-400 text-xl">
                                    <i class="fas fa-check-circle"></i>
                                </div>
                            `}
                        </div>
                        
                        <!-- Header content with fixed icon width -->
                        <div class="flex gap-3 pr-20">
                            <!-- Fixed-width icon container -->
                            <div class="flex-shrink-0 w-12 flex items-start justify-center pt-0.5">
                                <i class="fas ${augment.icon} ${augment.rarity === 'common' ? 'text-gray-300' : augment.rarity === 'rare' ? 'text-blue-400' : 'text-purple-400'} text-3xl"></i>
                            </div>
                            
                            <!-- Title and subtitle -->
                            <div class="flex-1 min-w-0">
                                <!-- Title -->
                                <h3 class="font-bold text-base ${augment.rarity === 'common' ? 'text-gray-200' : augment.rarity === 'rare' ? 'text-blue-300' : 'text-purple-300'} mb-0.5">${augment.name}</h3>
                                
                                <!-- Category icon + Rarity -->
                                <div class="flex items-center gap-1.5 ${augment.rarity === 'common' ? 'text-gray-400' : augment.rarity === 'rare' ? 'text-blue-400' : 'text-purple-400'}">
                                    <i class="fas ${categoryIcon} text-xs"></i>
                                    <span class="text-[10px] uppercase font-bold">${augment.rarity}</span>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Divider -->
                    <div class="border-t border-gray-700"></div>
                    
                    <!-- Body section with tier descriptions -->
                    <div class="p-3 space-y-1">
                        <!-- Current tier if unlocked -->
                        ${currentTier > 0 ? `
                            <div class="text-xs">
                                <span class="font-bold text-teal-400">Tier ${currentTier}:</span>
                                <span class="text-teal-300"> ${augment.tiers[currentTier - 1].desc}</span>
                            </div>
                        ` : ''}
                        
                        <!-- Next tier info -->
                        ${!isMaxed ? `
                            <div class="text-xs">
                                <span class="font-bold text-gray-400">${currentTier === 0 ? 'Tier 1:' : `Next:`}</span>
                                <span class="text-gray-300"> ${nextTierData.desc}</span>
                            </div>
                            <div class="flex gap-2 text-[10px] mt-1">
                                <span class="${cores >= nextTierData.costCores ? 'text-purple-400' : 'text-red-400'}">
                                    <i class="fas fa-circle"></i> ${nextTierData.costCores}
                                </span>
                                ${nextTierData.costSingularities > 0 ? `
                                    <span class="${singularities >= nextTierData.costSingularities ? 'text-yellow-300' : 'text-red-400'}">
                                        <i class="fas fa-gem"></i> ${nextTierData.costSingularities}
                                    </span>
                                ` : ''}
                            </div>
                        ` : `
                            <div class="text-xs text-teal-400 font-bold">‚úì FULLY UPGRADED</div>
                        `}
                    </div>
                `;
                
                card.innerHTML = cardHTML;
                container.appendChild(card);
            });
        }
        
        // Unlock augment tier
        window.unlockAugmentTier = function(augmentId) {
            const augment = augmentDefs[augmentId];
            if (!augment) return;
            
            const currentTier = augmentProgress.unlocked[augmentId] || 0;
            const nextTier = currentTier + 1;
            
            if (nextTier > augment.tiers.length) {
                console.log('‚ö†Ô∏è Augment already maxed');
                return;
            }
            
            const tierData = augment.tiers[nextTier - 1];
            const cores = parseInt(localStorage.getItem('neonrogue_nexusCores') || '0');
            const singularities = parseInt(localStorage.getItem('neonrogue_singularities') || '0');
            
            // Check affordability
            if (cores < tierData.costCores || singularities < tierData.costSingularities) {
                console.log('‚ö†Ô∏è Cannot afford this tier');
                return;
            }
            
            // Deduct resources
            localStorage.setItem('neonrogue_nexusCores', cores - tierData.costCores);
            localStorage.setItem('neonrogue_singularities', singularities - tierData.costSingularities);
            
            // Unlock tier
            augmentProgress.unlocked[augmentId] = nextTier;
            saveAugmentProgress();
            
            console.log(`‚úÖ Unlocked ${augment.name} Tier ${nextTier}`);
            
            // Refresh displays
            updateLabCurrency();
            renderAugmentBrowse(currentBrowseFilter);
            // Note: Loadout display updates automatically when augment selector is opened
        };
        
        // Track current browse filter
        let currentBrowseFilter = 'all';
        
        // Augment selector for ascension screen
        let currentSelectingSlot = null;
        
        window.openAugmentSelector = function(slotIndex) {
            currentSelectingSlot = slotIndex;
            document.getElementById('selector-slot-number').textContent = slotIndex + 1;
            
            const modal = document.getElementById('augment-selector-modal');
            const listContainer = document.getElementById('augment-selector-list');
            
            // Get all unlocked augments
            const unlockedAugments = Object.keys(augmentProgress.unlocked)
                .filter(id => augmentProgress.unlocked[id] > 0)
                .map(id => ({ id, ...augmentDefs[id] }));
            
            // Get currently equipped augments
            const equippedIds = augmentProgress.loadout.filter(id => id !== null);
            
            listContainer.innerHTML = '';
            
            if (unlockedAugments.length === 0) {
                listContainer.innerHTML = `
                    <div class="text-center text-gray-400 py-8">
                        <i class="fas fa-flask text-4xl mb-2"></i>
                        <p>No augments unlocked yet</p>
                        <p class="text-xs text-gray-500 mt-1">Visit the Augment Lab to unlock augments</p>
                    </div>
                `;
            } else {
                unlockedAugments.forEach(augment => {
                    const tier = augmentProgress.unlocked[augment.id];
                    const tierData = augment.tiers[tier - 1];
                    const isEquipped = equippedIds.includes(augment.id);
                    const isCurrent = augmentProgress.loadout[slotIndex] === augment.id;
                    
                    const card = document.createElement('div');
                    card.className = `bg-gray-800 border ${isCurrent ? 'border-teal-500 bg-teal-900/30' : isEquipped ? 'border-gray-600 opacity-50' : 'border-gray-600 hover:border-purple-500'} rounded p-3 ${isEquipped && !isCurrent ? 'cursor-not-allowed' : 'cursor-pointer'} transition-all`;
                    
                    card.innerHTML = `
                        <div class="flex items-center gap-3">
                            <i class="fas ${augment.icon} text-purple-400 text-xl"></i>
                            <div class="flex-1">
                                <div class="flex items-center gap-2 mb-1">
                                    <p class="text-sm font-bold text-white">${augment.name}</p>
                                    <span class="text-[9px] text-gray-500 uppercase">${augment.category} ‚Ä¢ ${augment.rarity}</span>
                                </div>
                                <p class="text-xs text-purple-300 mb-1">Tier ${tier}</p>
                                <p class="text-[10px] text-gray-400">${tierData.desc}</p>
                                ${isEquipped && !isCurrent ? '<p class="text-[9px] text-red-400 mt-1"><i class="fas fa-exclamation-circle mr-1"></i>Already equipped in another slot</p>' : ''}
                            </div>
                            ${isCurrent ? '<i class="fas fa-check text-teal-400 text-xl"></i>' : ''}
                        </div>
                    `;
                    
                    if (!isEquipped || isCurrent) {
                        card.onclick = () => selectAugmentForSlot(augment.id);
                    }
                    
                    listContainer.appendChild(card);
                });
            }
            
            modal.classList.add('active');
        };
        
        window.selectAugmentForSlot = function(augmentId) {
            augmentProgress.loadout[currentSelectingSlot] = augmentId;
            saveAugmentProgress();
            closeAugmentSelector();
            // Refresh augment slots for the currently selected ascension
            if (selectedAscensionLevel > 0) {
                refreshAscensionAugments(selectedAscensionLevel);
            }
            console.log(`‚úÖ Equipped ${augmentDefs[augmentId].name} to slot ${currentSelectingSlot + 1}`);
        };
        
        window.clearAugmentSlot = function() {
            augmentProgress.loadout[currentSelectingSlot] = null;
            saveAugmentProgress();
            closeAugmentSelector();
            // Refresh augment slots for the currently selected ascension
            if (selectedAscensionLevel > 0) {
                refreshAscensionAugments(selectedAscensionLevel);
            }
            console.log(`üîΩ Cleared slot ${currentSelectingSlot + 1}`);
        };
        
        window.closeAugmentSelector = function() {
            document.getElementById('augment-selector-modal').classList.remove('active');
            currentSelectingSlot = null;
        };
        
        // Augment Lab event listeners
        document.getElementById('augment-lab-btn').addEventListener('click', openAugmentLab);
        document.getElementById('close-lab-btn').addEventListener('click', closeAugmentLab);
        
        // Unlock Notification continue button
        document.getElementById('unlock-notification-continue-btn').addEventListener('click', () => {
            document.getElementById('unlock-notification-screen').classList.remove('active');
            document.getElementById('menu-screen').classList.add('active');
        });
        
        // Category filter buttons
        document.querySelectorAll('.augment-filter-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                // Update active state
                document.querySelectorAll('.augment-filter-btn').forEach(b => {
                    b.classList.remove('active', 'text-white');
                    b.classList.add('text-gray-400');
                });
                btn.classList.add('active', 'text-white');
                btn.classList.remove('text-gray-400');
                
                // Apply filter
                const category = btn.dataset.category;
                currentBrowseFilter = category;
                renderAugmentBrowse(category);
            });
        });
        
        // Load augment progress on page load
        loadAugmentProgress();
        
        // Stats screen handlers
        document.getElementById('view-stats-btn').addEventListener('click', showStats);
        document.getElementById('close-stats-btn').addEventListener('click', () => {
            document.getElementById('stats-screen').classList.remove('active');
        });
        
        // Ship carousel (currently locked, for future expansion)
        console.log('Initializing ship system...');
        let currentShipIndex = 0;
        
        // Use ship data from global shipDataMap
        const ships = [
            shipDataMap['PATHFINDER'],
            shipDataMap['ENGINEER'],
            shipDataMap['DISRUPTOR'],
            shipDataMap['VANGUARD'],
            shipDataMap['REAPER'],
            shipDataMap['CATALYST']
        ];
        window.ships = ships; // Make globally accessible for inline onclick
        console.log('Ships defined:', ships.length, 'ships');
        
        // Sync currentShipIndex with saved ship selection
        const savedShipName = localStorage.getItem('neonrogue_selectedShip');
        if (savedShipName) {
            const savedShipIndex = ships.findIndex(s => s.name === savedShipName);
            if (savedShipIndex !== -1) {
                currentShipIndex = savedShipIndex;
                console.log('Loaded saved ship:', savedShipName, 'at index', savedShipIndex);
            }
        }
        
        // Draw ship on canvas
        function drawShipIcon() {
            console.log('drawShipIcon called');
            const canvas = document.getElementById('ship-canvas');
            if (!canvas) {
                console.error('Canvas not found!');
                return;
            }
            console.log('Canvas found, drawing ship:', ships[currentShipIndex].name);
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            const ship = ships[currentShipIndex];
            
            // Center the ship
            ctx.save();
            ctx.translate(35, 35);
            ctx.scale(1.8, 1.8);
            
            if (ship.name === 'PATHFINDER') {
                // PATHFINDER - Sleek Arrowhead Fighter (Teal/Cyan)
                
                // Main body - sharp arrowhead
                ctx.fillStyle = '#0d3b47';
                ctx.strokeStyle = '#00d1b2';
                ctx.lineWidth = 2.5;
                ctx.shadowColor = '#00d1b2';
                ctx.shadowBlur = 15;
                ctx.beginPath();
                ctx.moveTo(14, 0);    // Sharp front
                ctx.lineTo(-6, 7);    // Bottom wing
                ctx.lineTo(-3, 0);    // Back center
                ctx.lineTo(-6, -7);   // Top wing
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
                
                // Glowing engine
                ctx.fillStyle = '#00fff5';
                ctx.shadowBlur = 20;
                ctx.shadowColor = '#00fff5';
                ctx.beginPath();
                ctx.arc(-2, 0, 3, 0, Math.PI * 2);
                ctx.fill();
                
            } else if (ship.name === 'ENGINEER') {
                // ENGINEER - Hexagonal Utility Ship (Orange/Bronze)
                
                // Hexagon body
                ctx.fillStyle = '#4a2511';
                ctx.strokeStyle = '#ff8800';
                ctx.lineWidth = 2.5;
                ctx.shadowColor = '#ff8800';
                ctx.shadowBlur = 15;
                ctx.beginPath();
                for (let i = 0; i < 6; i++) {
                    const angle = (Math.PI / 3) * i;
                    const x = Math.cos(angle) * 8;
                    const y = Math.sin(angle) * 8;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
                
                // Orange core
                ctx.fillStyle = '#ff8800';
                ctx.shadowBlur = 20;
                ctx.shadowColor = '#ff8800';
                ctx.beginPath();
                ctx.arc(0, 0, 4, 0, Math.PI * 2);
                ctx.fill();
                
            } else if (ship.name === 'DISRUPTOR') {
                // DISRUPTOR - Diamond Lightning Ship (Purple/Violet)
                
                // Diamond body
                ctx.fillStyle = '#2d1b4e';
                ctx.strokeStyle = '#a855f7';
                ctx.lineWidth = 2.5;
                ctx.shadowColor = '#a855f7';
                ctx.shadowBlur = 15;
                ctx.beginPath();
                ctx.moveTo(12, 0);    // Front
                ctx.lineTo(0, 8);     // Bottom
                ctx.lineTo(-8, 0);    // Back
                ctx.lineTo(0, -8);    // Top
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
                
                // Purple energy core
                ctx.fillStyle = '#c084fc';
                ctx.shadowBlur = 20;
                ctx.shadowColor = '#a855f7';
                ctx.beginPath();
                ctx.arc(0, 0, 4, 0, Math.PI * 2);
                ctx.fill();
                
            } else if (ship.name === 'VANGUARD') {
                // VANGUARD - Octagonal Heavy Tank (Steel/Silver Armor)
                
                // Octagonal armored body (8 sides, not hexagon like Engineer)
                ctx.fillStyle = '#2a3845';
                ctx.strokeStyle = '#8b9dc3';
                ctx.lineWidth = 3;
                ctx.shadowColor = '#5b7ba8';
                ctx.shadowBlur = 15;
                ctx.beginPath();
                for (let i = 0; i < 8; i++) {
                    const angle = (Math.PI / 4) * i;
                    const x = Math.cos(angle) * 9;
                    const y = Math.sin(angle) * 9;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
                
                // Front armor wedge (bright steel)
                ctx.fillStyle = '#c0cfe0';
                ctx.beginPath();
                ctx.moveTo(11, 0);
                ctx.lineTo(6, -3);
                ctx.lineTo(6, 3);
                ctx.closePath();
                ctx.fill();
                
                // Shield emitter nodes (4 corners - blue glow)
                const nodeAngles = [Math.PI/4, 3*Math.PI/4, 5*Math.PI/4, 7*Math.PI/4];
                nodeAngles.forEach(angle => {
                    const nx = Math.cos(angle) * 7;
                    const ny = Math.sin(angle) * 7;
                    ctx.fillStyle = '#5b9bd5';
                    ctx.shadowBlur = 12;
                    ctx.beginPath();
                    ctx.arc(nx, ny, 2, 0, Math.PI * 2);
                    ctx.fill();
                });
                
                // Steel/blue core
                ctx.fillStyle = '#8b9dc3';
                ctx.shadowBlur = 20;
                ctx.shadowColor = '#5b7ba8';
                ctx.beginPath();
                ctx.arc(0, 0, 4, 0, Math.PI * 2);
                ctx.fill();
                
            } else if (ship.name === 'REAPER') {
                // REAPER - Aggressive Glass Cannon (Red/Gold)
                
                // Main body - aggressive wedge
                ctx.fillStyle = '#4a1111';
                ctx.strokeStyle = '#ff3333';
                ctx.lineWidth = 2.5;
                ctx.shadowColor = '#ff3333';
                ctx.shadowBlur = 15;
                ctx.beginPath();
                ctx.moveTo(16, 0);     // Sharp aggressive front
                ctx.lineTo(-4, 6);     // Bottom wing
                ctx.lineTo(-8, 4);     // Bottom back
                ctx.lineTo(-6, 0);     // Center back
                ctx.lineTo(-8, -4);    // Top back
                ctx.lineTo(-4, -6);    // Top wing
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
                
                // Gold accent blades
                ctx.strokeStyle = '#ffcc00';
                ctx.lineWidth = 2;
                ctx.shadowColor = '#ffcc00';
                ctx.shadowBlur = 10;
                ctx.beginPath();
                ctx.moveTo(12, 0);
                ctx.lineTo(6, -4);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(12, 0);
                ctx.lineTo(6, 4);
                ctx.stroke();
                
                // Red energy core
                ctx.fillStyle = '#ff6666';
                ctx.shadowBlur = 20;
                ctx.shadowColor = '#ff3333';
                ctx.beginPath();
                ctx.arc(0, 0, 3, 0, Math.PI * 2);
                ctx.fill();
                
                // Gold engine glow
                ctx.fillStyle = '#ffcc00';
                ctx.shadowBlur = 15;
                ctx.shadowColor = '#ffcc00';
                ctx.beginPath();
                ctx.arc(-5, 0, 2, 0, Math.PI * 2);
                ctx.fill();
                
            } else if (ship.name === 'CATALYST') {
                // CATALYST - Crystalline Prism Ship (Rainbow/Purple core)
                
                // Faceted prism body - diamond/crystal shape
                ctx.fillStyle = '#1a1a2e';
                ctx.strokeStyle = '#a855f7';
                ctx.lineWidth = 2.5;
                ctx.shadowColor = '#a855f7';
                ctx.shadowBlur = 15;
                ctx.beginPath();
                // Front point
                ctx.moveTo(12, 0);
                // Upper right facet
                ctx.lineTo(4, -6);
                ctx.lineTo(-4, -6);
                // Back point
                ctx.lineTo(-8, 0);
                // Lower left facet
                ctx.lineTo(-4, 6);
                ctx.lineTo(4, 6);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
                
                // Inner facet lines for crystal effect
                ctx.strokeStyle = '#c084fc';
                ctx.lineWidth = 1;
                ctx.shadowBlur = 8;
                ctx.beginPath();
                ctx.moveTo(12, 0);
                ctx.lineTo(0, 0);
                ctx.moveTo(4, -6);
                ctx.lineTo(0, 0);
                ctx.lineTo(4, 6);
                ctx.stroke();
                
                // Glowing elemental core (cycles colors - 4 elements only)
                const coreColors = ['#ff5722', '#00e5ff', '#ffeb3b', '#39ff14'];
                const coreColorIndex = Math.floor(Date.now() / 500) % 4; // Cycle every 0.5s
                ctx.fillStyle = coreColors[coreColorIndex];
                ctx.shadowBlur = 25;
                ctx.shadowColor = coreColors[coreColorIndex];
                ctx.beginPath();
                ctx.arc(0, 0, 4, 0, Math.PI * 2);
                ctx.fill();
                
                // Small prismatic particles around ship
                ctx.globalAlpha = 0.6;
                [0, 120, 240].forEach((angle, i) => {
                    const rad = (angle + Date.now() / 30) * Math.PI / 180;
                    const px = Math.cos(rad) * 10;
                    const py = Math.sin(rad) * 10;
                    ctx.fillStyle = coreColors[(coreColorIndex + i) % 4];
                    ctx.shadowBlur = 10;
                    ctx.beginPath();
                    ctx.arc(px, py, 1.5, 0, Math.PI * 2);
                    ctx.fill();
                });
                ctx.globalAlpha = 1;
            }
            
            ctx.shadowBlur = 0;
            ctx.restore();
        }
        
        // Draw ship icon on page load
        drawShipIcon();
        
        // Check if ships are unlocked
        function checkShipUnlocks() {
            const nexusCores = parseInt(localStorage.getItem('neonrogue_nexusCores') || '0');
            const singularities = parseInt(localStorage.getItem('neonrogue_singularities') || '0');
            const highestLevel = parseInt(localStorage.getItem('neonrogue_highestLevel') || '0');
            const totalRuns = parseInt(localStorage.getItem('neonrogue_totalRuns') || '0');
            
            // Load unlocked ships from localStorage
            const unlockedShipsJSON = localStorage.getItem('neonrogue_unlockedShips');
            const unlockedShips = unlockedShipsJSON ? JSON.parse(unlockedShipsJSON) : [];
            
            ships.forEach(ship => {
                // Check if ship has unlock requirements (cores or singularities)
                if (ship.unlockCores !== undefined || ship.unlockSingularities !== undefined) {
                    // Check if already unlocked (saved in localStorage)
                    if (unlockedShips.includes(ship.name)) {
                        ship.locked = false;
                    } else {
                        // Check currency requirements
                        let currencyUnlocked = false;
                        if (ship.unlockSingularities !== undefined) {
                            currencyUnlocked = singularities >= ship.unlockSingularities;
                        } else if (ship.unlockCores !== undefined) {
                            currencyUnlocked = nexusCores >= ship.unlockCores;
                        }
                        
                        // Check achievement requirement (level OR runs OR elements)
                        let achievementUnlocked = false;
                        if (ship.unlockAchievement.includes('Level')) {
                            // Level requirement
                            achievementUnlocked = highestLevel >= parseInt(ship.unlockAchievement.match(/\d+/)[0]);
                        } else if (ship.unlockAchievement.includes('Runs')) {
                            // Run count requirement
                            achievementUnlocked = totalRuns >= parseInt(ship.unlockAchievement.match(/\d+/)[0]);
                        } else if (ship.unlockAchievement.includes('Proc 4 elements')) {
                            // CATALYST: 4 elements achievement
                            achievementUnlocked = localStorage.getItem('neonrogue_4elementsAchieved') === 'true';
                        }
                        
                        ship.canUnlock = currencyUnlocked && achievementUnlocked;
                        // Ship stays locked until player manually unlocks it (and spends currency)
                        if (ship.locked === undefined) ship.locked = true; // Default to locked
                    }
                }
            });
        }
        
        // Unlock a ship (spend cores or singularities)
        function unlockShip(ship) {
            // Double check unlock availability
            const nexusCores = parseInt(localStorage.getItem('neonrogue_nexusCores') || '0');
            const singularities = parseInt(localStorage.getItem('neonrogue_singularities') || '0');
            const highestLevel = parseInt(localStorage.getItem('neonrogue_highestLevel') || '0');
            const totalRuns = parseInt(localStorage.getItem('neonrogue_totalRuns') || '0');
            
            // Check currency requirements
            let currencyUnlocked = false;
            let currencyType = '';
            let currencyCost = 0;
            
            if (ship.unlockSingularities !== undefined) {
                currencyUnlocked = singularities >= ship.unlockSingularities;
                currencyType = 'singularities';
                currencyCost = ship.unlockSingularities;
            } else if (ship.unlockCores !== undefined) {
                currencyUnlocked = nexusCores >= ship.unlockCores;
                currencyType = 'cores';
                currencyCost = ship.unlockCores;
            }
            
            // Check achievement requirement (level OR runs OR elements)
            let achievementUnlocked = false;
            if (ship.unlockAchievement.includes('Level')) {
                achievementUnlocked = highestLevel >= parseInt(ship.unlockAchievement.match(/\d+/)[0]);
            } else if (ship.unlockAchievement.includes('Runs')) {
                achievementUnlocked = totalRuns >= parseInt(ship.unlockAchievement.match(/\d+/)[0]);
            } else if (ship.unlockAchievement.includes('Proc 4 elements')) {
                // CATALYST: 4 elements achievement
                achievementUnlocked = localStorage.getItem('neonrogue_4elementsAchieved') === 'true';
            }
            
            if (!currencyUnlocked || !achievementUnlocked) {
                alert('Requirements not met!');
                return;
            }
            
            // Deduct currency
            if (currencyType === 'singularities') {
                const newSingularities = singularities - currencyCost;
                localStorage.setItem('neonrogue_singularities', newSingularities.toString());
            } else if (currencyType === 'cores') {
                const newCores = nexusCores - currencyCost;
                localStorage.setItem('neonrogue_nexusCores', newCores.toString());
            }
            
            // Unlock ship
            ship.locked = false;
            
            // Save unlocked ships to localStorage
            const unlockedShipsJSON = localStorage.getItem('neonrogue_unlockedShips');
            const unlockedShips = unlockedShipsJSON ? JSON.parse(unlockedShipsJSON) : [];
            if (!unlockedShips.includes(ship.name)) {
                unlockedShips.push(ship.name);
                localStorage.setItem('neonrogue_unlockedShips', JSON.stringify(unlockedShips));
            }
            
            // Refresh display
            checkShipUnlocks();
            updateShipDisplay();
        }
        window.unlockShip = unlockShip; // Make globally accessible for inline onclick
        
        // Update ship display
        function updateShipDisplay() {
            const ship = ships[currentShipIndex];
            document.getElementById('ship-name').textContent = ship.locked ? 'CLASSIFIED' : ship.name;
            document.getElementById('ship-desc').textContent = ship.locked ? 'Requirements not met' : ship.desc;
            
            if (ship.locked) {
                const nexusCores = parseInt(localStorage.getItem('neonrogue_nexusCores') || '0');
                const singularities = parseInt(localStorage.getItem('neonrogue_singularities') || '0');
                const totalRuns = parseInt(localStorage.getItem('neonrogue_totalRuns') || '0');
                const canUnlock = ship.canUnlock;
                
                // Determine currency requirement
                let currencyText = '';
                let currencyButton = '';
                if (ship.unlockSingularities !== undefined) {
                    currencyText = `${ship.unlockSingularities} Quantum Singularity ${canUnlock ? `(You have ${singularities})` : ''}`;
                    currencyButton = `UNLOCK (Spend ${ship.unlockSingularities} Singularity)`;
                } else if (ship.unlockCores !== undefined) {
                    currencyText = `${ship.unlockCores} Nexus Cores ${canUnlock ? `(You have ${nexusCores})` : ''}`;
                    currencyButton = `UNLOCK (Spend ${ship.unlockCores} Cores)`;
                }
                
                // Show runs progress if needed
                let runsProgress = '';
                if (ship.unlockRuns !== undefined) {
                    const runsColor = totalRuns >= ship.unlockRuns ? 'text-teal-400' : 'text-gray-400';
                    runsProgress = `<div class="text-xs ${runsColor}">Runs: ${totalRuns}/${ship.unlockRuns}</div>`;
                }
                
                document.getElementById('ship-stats').innerHTML = `
                    <div class="${canUnlock ? 'text-teal-400' : 'text-red-400'}">${canUnlock ? 'READY TO UNLOCK' : 'LOCKED'}</div>
                    <div class="text-xs">Requires: ${currencyText}</div>
                    ${runsProgress}
                    <div class="text-xs">${ship.unlockAchievement}</div>
                    ${canUnlock ? `<button onclick="unlockShip(ships[${currentShipIndex}])" class="mt-2 px-4 py-2 bg-teal-500 hover:bg-teal-600 text-white rounded font-bold">${currencyButton}</button>` : ''}
                `;
            } else {
                // Determine shield count for display
                let shieldCount = 2; // Default for Pathfinder/Engineer
                if (ship.name === 'DISRUPTOR') shieldCount = 1;
                else if (ship.name === 'VANGUARD') shieldCount = 3;
                else if (ship.name === 'REAPER') shieldCount = 0;
                
                // Generate shield icons
                let shieldIcons = '';
                for (let i = 0; i < shieldCount; i++) {
                    shieldIcons += '<i class="fas fa-shield-alt" style="color: #00d1b2; font-size: 10px;"></i> ';
                }
                if (shieldCount === 0) {
                    shieldIcons = '<span class="text-red-400">NONE</span>';
                }
                
                document.getElementById('ship-stats').innerHTML = `
                    <div>HP: <span class="text-white">${ship.hp}</span> ‚Ä¢ DMG: <span class="text-white">${ship.dmg}</span> ‚Ä¢ SPD: <span class="text-white">${ship.spd}</span></div>
                    <div>SHIELDS: ${shieldIcons}</div>
                    <div>WEAPON: <span class="text-teal-400">${ship.weapon}</span></div>
                    <div class="text-[9px] text-gray-400 mt-0.5 leading-tight" style="max-width: 200px; margin: 0 auto; text-align: center;">${ship.weaponDesc || ''}</div>
                `;
            }
            
            drawShipIcon();
            
            // Update arrow states
            document.getElementById('ship-prev').disabled = currentShipIndex === 0;
            document.getElementById('ship-next').disabled = currentShipIndex === ships.length - 1;
        }
        
        // Check unlocks on load
        checkShipUnlocks();
        updateShipDisplay();
        
        // Ship Details Modal
        const shipDetailsBtn = document.getElementById('ship-details-btn');
        const shipDetailsModal = document.getElementById('ship-details-modal');
        const closeDetailsBtn = document.getElementById('close-details-btn');
        
        if (shipDetailsBtn) {
            shipDetailsBtn.addEventListener('click', () => {
                const ship = ships[currentShipIndex];
                if (ship.locked) return; // Don't show details for locked ships
                
                document.getElementById('modal-ship-name').textContent = ship.name;
                
                // Build detailed stats
                let shieldCount = 2;
                if (ship.name === 'DISRUPTOR') shieldCount = 1;
                else if (ship.name === 'VANGUARD') shieldCount = 3;
                else if (ship.name === 'CATALYST') shieldCount = 2;
                else if (ship.name === 'REAPER') shieldCount = 0;
                
                const details = `
                    <div class="mb-4">
                        <h4 class="text-teal-400 font-bold mb-2">SHIP STATS</h4>
                        <div class="font-mono text-xs space-y-1">
                            <div>Max HP: <span class="text-white">${ship.hp}</span></div>
                            <div>Base Damage: <span class="text-white">${ship.dmg}</span></div>
                            <div>Movement Speed: <span class="text-white">${ship.spd}</span></div>
                            <div>Shield Charges: <span class="text-white">${shieldCount}${shieldCount === 0 ? ' (No shields)' : ''}</span></div>
                        </div>
                    </div>
                    <div>
                        <h4 class="text-teal-400 font-bold mb-2">STARTING WEAPON</h4>
                        <div class="mb-2 font-bold text-white">${ship.weapon}</div>
                        <div class="text-xs text-gray-400 leading-relaxed space-y-2">
                            ${(ship.weaponDetails || ship.weaponDesc || '').split('\n\n').map(p => `<p>${p}</p>`).join('')}
                        </div>
                    </div>
                `;
                
                document.getElementById('modal-ship-details').innerHTML = details;
                shipDetailsModal.style.display = 'flex';
            });
        }
        
        if (closeDetailsBtn) {
            closeDetailsBtn.addEventListener('click', () => {
                shipDetailsModal.style.display = 'none';
            });
        }
        
        // Close modal when clicking outside
        if (shipDetailsModal) {
            shipDetailsModal.addEventListener('click', (e) => {
                if (e.target === shipDetailsModal) {
                    shipDetailsModal.style.display = 'none';
                }
            });
        }
        
        const shipPrevBtn = document.getElementById('ship-prev');
        const shipNextBtn = document.getElementById('ship-next');
        
        if (shipPrevBtn) {
            shipPrevBtn.addEventListener('click', () => {
                if (currentShipIndex > 0) {
                    currentShipIndex--;
                    checkShipUnlocks(); // Refresh unlock status
                    updateShipDisplay();
                }
            });
        }
        
        if (shipNextBtn) {
            shipNextBtn.addEventListener('click', () => {
                if (currentShipIndex < ships.length - 1) {
                    currentShipIndex++;
                    checkShipUnlocks(); // Refresh unlock status
                    updateShipDisplay();
                }
            });
        }
        
        // Corner icon buttons - open modals
        const saveCornerBtn = document.getElementById('save-corner-btn');
        
        if (saveCornerBtn) {
            saveCornerBtn.addEventListener('click', () => {
                document.getElementById('save-modal').classList.add('active');
            });
        }
        
        // Modal close buttons
        const saveCloseBtn = document.getElementById('save-close-btn');
        
        if (saveCloseBtn) {
            saveCloseBtn.addEventListener('click', () => {
                document.getElementById('save-modal').classList.remove('active');
            });
        }
        
        // Auto-save stats after each run (you can call this from game over)
        function updateMetaStats() {
            // TEST MODE: Don't save any stats
            if (testModeEnabled) {
                console.log('üß™ TEST MODE: Stats NOT saved');
                return;
            }
            
            // NORMAL MODE: Save stats
            // Increment total runs
            const totalRuns = parseInt(localStorage.getItem('neonrogue_totalRuns') || '0') + 1;
            localStorage.setItem('neonrogue_totalRuns', totalRuns);
            
            // Update highest level
            const highestLevel = parseInt(localStorage.getItem('neonrogue_highestLevel') || '0');
            if (state.level > highestLevel) {
                localStorage.setItem('neonrogue_highestLevel', state.level);
            }
            
            // Check and save "4 elements in one run" achievement for CATALYST
            if (state.elementsProcced && state.elementsProcced.size >= 4) {
                console.log('üéØ Achievement unlocked: Proc 4 elements in one run!', Array.from(state.elementsProcced));
                localStorage.setItem('neonrogue_4elementsAchieved', 'true');
            }
            
            // Update highest score
            const highestScore = parseInt(localStorage.getItem('neonrogue_highestScore') || '0');
            if (state.score > highestScore) {
                localStorage.setItem('neonrogue_highestScore', state.score);
            }
            
            // Update total playtime (in seconds)
            const totalPlaytime = parseInt(localStorage.getItem('neonrogue_totalPlaytime') || '0');
            const runTime = Math.floor((Date.now() - state.startTime) / 1000);
            localStorage.setItem('neonrogue_totalPlaytime', totalPlaytime + runTime);
            
            // Total kills - you'll need to track this in your enemy death code
            // For now, just use score as a proxy
            const totalKills = parseInt(localStorage.getItem('neonrogue_totalKills') || '0');
            localStorage.setItem('neonrogue_totalKills', totalKills + Math.floor(state.score / 10));
        }
        
        // ===== END SAVE/LOAD SYSTEM =====
        
        // Initialize UI based on whether player has beaten the boss
        function initializePostGameSystems() {
            const hasBeatenBoss = localStorage.getItem('neonrogue_hasBeatenBoss') === 'true';
            const highestAscension = parseInt(localStorage.getItem('neonrogue_highestAscension') || '0');
            const augmentLabBtn = document.getElementById('augment-lab-btn');
            
            // Load augment progress to check if any augments are unlocked
            let hasUnlockedAugments = false;
            try {
                const savedProgress = localStorage.getItem('neonrogue_augmentProgress');
                if (savedProgress) {
                    const progress = JSON.parse(savedProgress);
                    hasUnlockedAugments = progress.unlocked && Object.keys(progress.unlocked).length > 0;
                }
            } catch (e) {
                console.error('Error loading augment progress:', e);
            }
            
            // Show post-game systems if:
            // 1. Player has beaten boss, OR
            // 2. Player has any ascension level (legacy saves), OR
            // 3. Player has any augments unlocked (legacy saves)
            const shouldShowSystems = hasBeatenBoss || highestAscension > 0 || hasUnlockedAugments;
            
            if (!shouldShowSystems) {
                // Hide Augment Lab button until first victory
                if (augmentLabBtn) {
                    augmentLabBtn.style.display = 'none';
                }
                console.log('üìå Post-game systems locked until first Nexus Prime victory');
            } else {
                // Show Augment Lab button
                if (augmentLabBtn) {
                    augmentLabBtn.style.display = 'block';
                }
                console.log('‚úÖ Post-game systems unlocked');
            }
        }
        
        // Call on page load
        initializePostGameSystems();
        
        document.getElementById('pause-btn').onclick = togglePause;
        document.getElementById('resume-btn').onclick = togglePause;
        document.getElementById('quit-btn').onclick = () => { 
            document.getElementById('pause-screen').classList.remove('active'); 
            document.getElementById('menu-screen').classList.add('active'); 
            state.screen='menu'; 
            document.getElementById('hud').style.display='none';
        };
        
        // ===== DEBUG COMMANDS =====
        // Type these in browser console (F12) during gameplay
        
        window.testBoss = function() {
            console.log('üéÆ DEBUG: Jumping to level 50 boss fight...');
            state.level = 50;
            state.finalBossTriggered = false;
            state.finalBossActive = false;
            // Give player strong build for testing
            player.damage = 100;
            player.maxHp = 500;
            player.hp = 500;
            console.log('‚úÖ Set to level 50. Boss will trigger on next level-up logic.');
        };
        
        window.godMode = function() {
            console.log('üéÆ DEBUG: God mode activated');
            player.maxHp = 99999;
            player.hp = 99999;
            player.damage = 500;
            player.armor = 80;
            console.log('‚úÖ Player buffed: 99999 HP, 500 DMG, 80% Armor');
        };
        
        window.killAll = function() {
            console.log('üéÆ DEBUG: Killing all enemies');
            entities.enemies.forEach(e => e.hp = 0);
            console.log('‚úÖ All enemies killed');
        };
        
        window.levelUp = function(levels = 1) {
            console.log(`üéÆ DEBUG: Leveling up ${levels} time(s)`);
            for (let i = 0; i < levels; i++) {
                gainXp(state.xpToNext);
            }
            console.log(`‚úÖ Leveled up to ${state.level}`);
        };
        
        window.randomLoadout = function() {
            console.log('üéÆ DEBUG: Generating random level 10 loadout...');
            
            // All possible weapons
            const allWeapons = ['ion_cannons', 'railgun', 'plasma_whip', 'flak', 'proximity_mines', 
                               'meteor', 'emp_pulse', 'seeker', 'marker_cannon', 'orbital_strike'];
            
            // Pick 4 random weapons
            const selectedWeapons = [];
            const shuffled = [...allWeapons].sort(() => Math.random() - 0.5);
            for (let i = 0; i < 4; i++) {
                selectedWeapons.push(shuffled[i]);
            }
            
            // Clear ONLY combat weapons (not ship systems)
            allWeapons.forEach(w => {
                player.weapons[w] = 0;
            });
            
            // Set selected weapons to level 10
            selectedWeapons.forEach(w => {
                player.weapons[w] = 10;
            });
            
            console.log('üî´ Weapons reset!');
            console.log('Active weapons:', Object.keys(player.weapons).filter(w => player.weapons[w] > 0));
            
            // Random stat upgrades (30 total upgrades at level 50)
            const statUpgrades = {
                damage: 0, maxHp: 0, armor: 0, regen: 0,
                critChance: 0, critMult: 0, multicast: 0, elementalMult: 0
            };
            
            // Distribute 30 random upgrades
            for (let i = 0; i < 30; i++) {
                const stats = Object.keys(statUpgrades);
                const randomStat = stats[Math.floor(Math.random() * stats.length)];
                statUpgrades[randomStat]++;
            }
            
            // Apply stat upgrades (additive, don't reset base values)
            player.damage += (statUpgrades.damage * 10);
            
            let maxHpBonus = statUpgrades.maxHp * 25;
            // ASCENSION 1: FRAGILE HULL - reduce HP upgrades by 25%
            if (state.activeAscension === 1) {
                maxHpBonus = Math.floor(maxHpBonus * 0.75);
            }
            player.maxHp += maxHpBonus;
            player.hp = player.maxHp;
            
            player.armor += (statUpgrades.armor * 3);
            player.regen += (statUpgrades.regen * 2);
            player.critChance += (statUpgrades.critChance * 0.03);
            player.critMult += (statUpgrades.critMult * 0.1);
            player.multicast += (statUpgrades.multicast * 0.02);
            player.elementalMult += (statUpgrades.elementalMult * 0.15);
            
            console.log('‚úÖ Random loadout generated!');
            console.log('Weapons (Lvl 10):', selectedWeapons.join(', '));
            console.log('Stats:', {
                damage: Math.floor(player.damage),
                hp: player.maxHp,
                armor: Math.floor(player.armor),
                regen: player.regen,
                crit: `${(player.critChance * 100).toFixed(0)}% x${player.critMult.toFixed(1)}`,
                multicast: `${(player.multicast * 100).toFixed(0)}%`,
                elemental: `${(player.elementalMult * 100).toFixed(0)}%`
            });
        };
        
        window.particlePoolStats = function() {
            const stats = particlePool.getStats();
            console.log(`
‚ö° PARTICLE POOL PERFORMANCE
=============================
Pooled Particles: ${stats.pooled}
Max Pool Size: ${stats.maxSize}
Utilization: ${stats.utilizationPercent}%
Active Particles: ${entities.particles.length}

How it works:
- Dead particles are recycled instead of GC'd
- New particles reuse pooled objects
- Reduces memory allocation overhead
- Smoother frame times (less GC pauses)
            `);
        };
        
        window.spatialGridStats = function() {
            const stats = spatialGrid.getStats();
            console.log(`
‚ö° SPATIAL GRID PERFORMANCE
=============================
Cell Size: ${spatialGrid.cellSize}px
Active Cells: ${stats.cells}
Total Entities: ${stats.totalEntities}
Avg per Cell: ${stats.avgPerCell}
Max in Cell: ${stats.maxInCell}

Performance Impact:
- Old: ${stats.totalEntities} checks per projectile
- New: ~${Math.ceil(stats.avgPerCell * 9)} checks per projectile
- Reduction: ~${((1 - (stats.avgPerCell * 9) / stats.totalEntities) * 100).toFixed(0)}%
            `);
        };
        
        window.showDebugHelp = function() {
            console.log(`
üéÆ NEON ROGUE - DEBUG COMMANDS
================================
testBoss()           - Jump to level 50 (boss will trigger)
triggerNexusPrime()  - Manually spawn boss immediately
godMode()            - Max HP, damage, armor
killAll()            - Kill all enemies on screen
levelUp(n)           - Level up n times (default 1)
randomLoadout()      - Give 4 random lvl 10 weapons + stats
spatialGridStats()   - Show collision optimization stats
particlePoolStats()  - Show particle pooling stats
showDebugHelp()      - Show this help

USAGE EXAMPLES:
  testBoss()           ‚Üí Sets level to 50
  randomLoadout()      ‚Üí Random build for testing
  levelUp(10)          ‚Üí Gain 10 levels
  godMode()            ‚Üí Become invincible
  spatialGridStats()   ‚Üí Check collision performance
  particlePoolStats()  ‚Üí Check particle system
            `);
        };
        
        console.log('üéÆ NEON ROGUE Debug Commands Loaded! Type showDebugHelp() for help.');
    </script>
</body>
</html>