<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>NEON ROGUE: Undertrained. Overkill.</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <script>
        window.getMetaStats = () => {
            return { hp: 0, dmg: 0, range: 0, reroll: 0 };
        };
    </script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');


        body { margin: 0; overflow: hidden; background-color: #020202; font-family: 'Orbitron', sans-serif; touch-action: none; user-select: none; -webkit-user-select: none; }
        #gameCanvas { display: block; width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }


        .modal { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.95); backdrop-filter: blur(10px); display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 100; pointer-events: auto; opacity: 0; visibility: hidden; transition: opacity 0.3s; }
        .modal.active { opacity: 1; visibility: visible; }


        /* Boss Bar */
        #boss-hud {
            position: absolute; top: 80px; left: 50%; transform: translateX(-50%);
            width: 60%; max-width: 600px; display: none; flex-direction: column; align-items: center; z-index: 20; pointer-events: none;
        }
        #boss-hud.active { display: flex; }
        .boss-name { color: #ff0000; font-weight: 900; letter-spacing: 2px; margin-bottom: 5px; text-shadow: 0 0 10px #ff0000; font-size: 0.8rem; }
        .boss-bar-container { width: 100%; height: 15px; background: #300; border: 2px solid #f00; border-radius: 4px; overflow: hidden; position: relative; }
        .boss-bar-fill { width: 100%; height: 100%; background: #f00; transition: width 0.2s; box-shadow: 0 0 20px #f00; }
        .boss-phase-marker { position: absolute; left: 50%; top: 0; width: 3px; height: 100%; background: #fff; box-shadow: 0 0 10px #fff, 0 0 5px #fff; z-index: 10; }


        .overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; display: flex; flex-direction: column; justify-content: space-between; padding: 20px; box-sizing: border-box; z-index: 50; }
        .bar-container { background: rgba(0, 0, 0, 0.6); height: 20px; width: 160px; border-radius: 4px; overflow: hidden; border: 1px solid rgba(255, 255, 255, 0.1); position: relative; display: flex; align-items: center; justify-content: center; }
        .hp-bar-fill { background: linear-gradient(90deg, #ff3860, #ff829d); height: 100%; width: 100%; transition: width 0.2s; position: absolute; left: 0; top: 0; }
        .hp-text-inner { position: relative; z-index: 10; font-size: 11px; color: #fff; text-shadow: 0 1px 2px rgba(0,0,0,0.8); font-family: monospace; font-weight: bold; }
        .xp-bar-fill { background: linear-gradient(90deg, #00d1b2, #48c774); height: 100%; width: 0%; transition: width 0.2s; }
        
        /* Weapon Slots */
        .weapon-bar { display: flex; align-items: center; gap: 8px; margin-top: auto; pointer-events: auto; position: relative; z-index: 60; }
        .weapon-slot { width: 40px; height: 40px; background: rgba(0,0,0,0.5); border: 1px solid rgba(255,255,255,0.2); border-radius: 4px; display: flex; align-items: center; justify-content: center; color: #555; position: relative; overflow: hidden; }
        .weapon-slot.active { color: #fff; border-color: #fff; }
        
        /* Mod Slot */
        .mod-separator { width: 1px; height: 40px; background: rgba(255,255,255,0.3); margin: 0 4px; }
        .weapon-slot.mod-slot { 
            width: 40px; 
            height: 40px; 
            border-radius: 50%; 
            border: 2px solid #ffdd57; 
            box-shadow: 0 0 10px rgba(255, 221, 87, 0.4), inset 0 0 8px rgba(255, 221, 87, 0.1);
            background: linear-gradient(135deg, rgba(255, 221, 87, 0.15), rgba(0, 0, 0, 0.7));
            cursor: default;
            transition: all 0.2s;
            position: relative;
        }
        .weapon-slot.mod-slot:hover { 
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(255, 221, 87, 0.7), inset 0 0 15px rgba(255, 221, 87, 0.2);
        }
        .weapon-slot.mod-slot.active { 
            background: linear-gradient(135deg, rgba(255, 221, 87, 0.25), rgba(0, 0, 0, 0.5)); 
            color: #ffdd57;
            animation: modPulse 2s infinite;
        }
        @keyframes modPulse {
            0%, 100% { box-shadow: 0 0 15px rgba(255, 221, 87, 0.5), inset 0 0 10px rgba(255, 221, 87, 0.1); }
            50% { box-shadow: 0 0 25px rgba(255, 221, 87, 0.8), inset 0 0 15px rgba(255, 221, 87, 0.3); }
        }
        .weapon-slot.mod-slot i { font-size: 1.6rem; }
        
        /* Mod Cooldown Timer */
        .mod-cooldown-text {
            position: absolute;
            bottom: -18px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 10px;
            font-weight: bold;
            color: #ffdd57;
            text-shadow: 0 0 5px rgba(0, 0, 0, 0.8);
            pointer-events: none;
        }


        .weapon-slot .level-badge { 
            position: absolute; 
            bottom: 2px; 
            right: 2px; 
            background: #000; 
            color: #fff; 
            font-size: 9px; 
            font-weight: bold;
            padding: 0px 3px; 
            border-radius: 2px; 
            border: 1px solid #555; 
            z-index: 5; 
            line-height: 1;
        }
        .weapon-slot i { z-index: 2; position: relative; }
        
        /* Cooldown Overlay */
        .cooldown-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 3; pointer-events: none;
            transition: background 0.1s linear;
        }


        /* Element Borders */
        .weapon-slot.fire { border-color: #ff5722; }
        .weapon-slot.ice { border-color: #88d8ff; }
        .weapon-slot.volt { border-color: #ffeb3b; }
        .weapon-slot.bio { border-color: #00cc44; }
        .weapon-slot.hack { border-color: #00ffff; }

        /* Stacked List of Cards */
        .cards-grid {
            display: flex;
            flex-direction: column;
            gap: 16px;
            width: 100%;
            max-width: 550px;
            margin: 0 auto;
            padding: 20px;
        }

        /* Horizontal Card with Diamond Icon */
        .card { 
            background: linear-gradient(90deg, #1a1d2e 0%, #0f1016 100%);
            border: 2px solid #2a2d3e;
            border-left: none;
            border-radius: 0 8px 8px 0;
            padding: 0;
            cursor: pointer;
            position: relative;
            overflow: visible;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.6);
            display: flex;
            align-items: stretch;
            min-height: 85px;
            padding-left: 65px;
            margin: 4px 0 4px 45px;
        }
        
        .card:hover {
            transform: translateX(8px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.8);
        }
        
        .card:active { 
            transform: translateX(4px) scale(0.98); 
        }
        
        .card.disabled { 
            pointer-events: none; 
            opacity: 0.5;
            filter: grayscale(0.5);
        }
        
        /* Diamond Icon - Left edge of card */
        .card-header {
            position: absolute;
            left: -35px;
            top: 50%;
            transform: translateY(-50%) rotate(45deg);
            width: 70px;
            height: 70px;
            background: linear-gradient(135deg, #2a2d3e 0%, #1a1d2e 100%);
            border: 2px solid;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.8);
            z-index: 5;
        }
        
        .card i { 
            font-size: 2rem;
            transform: rotate(-45deg);
            filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.8));
        }
        
        /* Card Content - Left Aligned, Maximized Width */
        .card-content { 
            flex: 1;
            padding: 9px 12px 12px 0px;
            text-align: left;
            display: flex;
            flex-direction: column;
            justify-content: center;
            gap: 4px;
        }
        
        .card h3 { 
            color: #fff;
            margin: 0;
            font-size: 1.05rem;
            font-weight: 700;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.8);
            line-height: 1.3;
        }
        
        .card p { 
            color: #a0aec0;
            font-size: 0.75rem;
            margin: 0;
            line-height: 1.35;
        }
        
        /* No rarity label - color is shown through borders only */
        
        /* Rarity-based styling - Colors affect card border, diamond, icon, and title */
        .card.common { border-color: #9ca3af; color: #9ca3af; }
        .card.common .card-header { border-color: #9ca3af; background: linear-gradient(135deg, #6b7280 0%, #4b5563 100%); }
        .card.common i { color: #d1d5db; }
        .card.common h3 { color: #d1d5db; }
        
        .card.uncommon { border-color: #10b981; color: #10b981; }
        .card.uncommon .card-header { border-color: #10b981; background: linear-gradient(135deg, #059669 0%, #047857 100%); }
        .card.uncommon i { color: #34d399; }
        .card.uncommon h3 { color: #34d399; }
        
        .card.rare { border-color: #3b82f6; color: #3b82f6; }
        .card.rare .card-header { border-color: #3b82f6; background: linear-gradient(135deg, #2563eb 0%, #1e40af 100%); }
        .card.rare i { color: #60a5fa; }
        .card.rare h3 { color: #60a5fa; }
        .card.rare { box-shadow: 0 4px 15px rgba(59, 130, 246, 0.3); }
        .card.rare:hover { box-shadow: 0 6px 20px rgba(59, 130, 246, 0.5); }
        
        .card.epic { border-color: #a855f7; color: #a855f7; }
        .card.epic .card-header { border-color: #a855f7; background: linear-gradient(135deg, #9333ea 0%, #7e22ce 100%); }
        .card.epic i { color: #c084fc; }
        .card.epic h3 { color: #c084fc; }
        .card.epic { box-shadow: 0 4px 15px rgba(168, 85, 247, 0.4); }
        .card.epic:hover { box-shadow: 0 6px 20px rgba(168, 85, 247, 0.6); }
        
        .card.legendary { 
            border-color: #fbbf24;
            color: #fbbf24;
            background: linear-gradient(90deg, #2c2505 0%, #1a1d2e 100%);
            box-shadow: 0 4px 20px rgba(251, 191, 36, 0.4), inset 0 0 40px rgba(251, 191, 36, 0.08);
        }
        .card.legendary .card-header { 
            border-color: #fbbf24; 
            background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
            box-shadow: 0 0 15px rgba(251, 191, 36, 0.6);
        }
        .card.legendary i { color: #fbbf24; }
        .card.legendary h3 { color: #fbbf24; }
        .card.legendary:hover { box-shadow: 0 6px 25px rgba(251, 191, 36, 0.6); }
        
        .card.elemental { 
            border-color: #ef4444;
            color: #ef4444;
            background: linear-gradient(90deg, #29080d 0%, #1a1d2e 100%);
        }
        .card.elemental .card-header { 
            border-color: #ef4444;
            background: linear-gradient(135deg, #dc2626 0%, #b91c1c 100%);
        }
        .card.elemental i { color: #f87171; }
        .card.elemental h3 { color: #f87171; }

        
        /* Legendary Particle Effect */
        @keyframes legendaryFloat {
            0%, 100% { transform: translateY(0) translateX(0); opacity: 0; }
            10% { opacity: 1; }
            90% { opacity: 0.7; }
            100% { transform: translateY(-60px) translateX(var(--drift-x)); opacity: 0; }
        }
        .legendary-particle {
            position: absolute;
            width: 4px;
            height: 4px;
            background: #ffdd57;
            border-radius: 50%;
            pointer-events: none;
            box-shadow: 0 0 4px #ffdd57;
            animation: legendaryFloat 2s ease-out infinite;
            bottom: 0;
            left: var(--start-x);
            --drift-x: 0;
            animation-delay: var(--delay);
        }
        
        /* Elemental Card Backgrounds */
        /* Elemental Augment Cards - Match element colors */
        .card.elem-fire { 
            border-color: #ff5722;
            color: #ff5722;
            background: linear-gradient(90deg, #1a0a05 0%, #0f1016 100%);
        }
        .card.elem-fire .card-header { 
            border-color: #ff5722; 
            background: linear-gradient(135deg, #ff5722 0%, #e64a19 100%);
        }
        .card.elem-fire i { color: #ff7043; }
        .card.elem-fire h3 { color: #ff7043; }
        
        .card.elem-ice {
            border-color: #88d8ff;
            color: #88d8ff;
            background: linear-gradient(90deg, #0a1a25 0%, #0f1016 100%);
        }
        .card.elem-ice .card-header { 
            border-color: #88d8ff; 
            background: linear-gradient(135deg, #88d8ff 0%, #5ab8e6 100%);
        }
        .card.elem-ice i { color: #b3e6ff; }
        .card.elem-ice h3 { color: #b3e6ff; }
        
        .card.elem-volt {
            border-color: #ffeb3b;
            color: #ffeb3b;
            background: linear-gradient(90deg, #1f1a05 0%, #0f1016 100%);
        }
        .card.elem-volt .card-header { 
            border-color: #ffeb3b; 
            background: linear-gradient(135deg, #ffeb3b 0%, #fdd835 100%);
        }
        .card.elem-volt i { color: #fff176; }
        .card.elem-volt h3 { color: #fff176; }
        
        .card.elem-bio {
            border-color: #00cc44;
            color: #00cc44;
            background: linear-gradient(90deg, #051a0f 0%, #0f1016 100%);
        }
        .card.elem-bio .card-header { 
            border-color: #00cc44; 
            background: linear-gradient(135deg, #00cc44 0%, #00a036 100%);
        }
        .card.elem-bio i { color: #33ff66; }
        .card.elem-bio h3 { color: #33ff66; }
        
        .card.elem-hack {
            border-color: #00ffff;
            color: #00ffff;
            background: linear-gradient(90deg, #051f1f 0%, #0f1016 100%);
        }
        .card.elem-hack .card-header { 
            border-color: #00ffff; 
            background: linear-gradient(135deg, #00ffff 0%, #00cccc 100%);
        }
        .card.elem-hack i { color: #66ffff; }
        .card.elem-hack h3 { color: #66ffff; }
        
        /* Animated Diamond Icons */
        @keyframes iconPulse {
            0%, 100% { transform: rotate(-45deg) scale(1); }
            50% { transform: rotate(-45deg) scale(1.1); }
        }
        
        @keyframes iconGlow {
            0%, 100% { filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.8)); }
            50% { filter: drop-shadow(0 0 12px currentColor) drop-shadow(0 2px 4px rgba(0, 0, 0, 0.8)); }
        }
        
        /* Apply subtle pulse to rare+ cards */
        .card.rare i,
        .card.epic i,
        .card.legendary i {
            animation: iconPulse 3s ease-in-out infinite;
        }
        
        /* Apply glow pulse to legendary */
        .card.legendary i {
            animation: iconPulse 2s ease-in-out infinite, iconGlow 2s ease-in-out infinite;
        }
            animation: binaryFlash 1.5s infinite;
        }
        @keyframes binaryFlash {
            0%, 100% { content: '01'; opacity: 0.2; }
            33% { content: '10'; opacity: 0.3; }
            66% { content: '11'; opacity: 0.25; }
        }
        
        #reroll-btn { margin-top: 15px; background: #ffdd57; color: #000; border: none; padding: 12px 30px; font-family: 'Orbitron'; font-weight: bold; font-size: 0.9rem; cursor: pointer; clip-path: polygon(10% 0, 100% 0, 90% 100%, 0% 100%); display: flex; align-items: center; gap: 8px; }
        #reroll-btn:disabled { opacity: 0.5; cursor: not-allowed; filter: grayscale(1); }
        #save-btn { margin-top: 15px; background: #00d1b2; color: #000; border: none; padding: 12px 30px; font-family: 'Orbitron'; font-weight: bold; font-size: 0.9rem; cursor: pointer; clip-path: polygon(10% 0, 100% 0, 90% 100%, 0% 100%); display: flex; align-items: center; gap: 8px; }
        #save-btn:disabled { opacity: 0.5; cursor: not-allowed; filter: grayscale(1); }
        .upgrade-buttons { display: flex; gap: 10px; justify-content: center; margin-top: 15px; }
        .card.save-mode { border: 2px solid #00d1b2; box-shadow: 0 0 20px rgba(0, 209, 178, 0.5); }
        .card.saved { border: 3px solid #00d1b2; box-shadow: 0 0 30px rgba(0, 209, 178, 0.8); }
        #pause-btn { pointer-events: auto; background: rgba(0,0,0,0.5); border: 1px solid rgba(255,255,255,0.2); color: #fff; width: 40px; height: 40px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 1.2rem; cursor: pointer; transition: all 0.2s; }
        
        .vignette { position: absolute; top: 0; left: 0; width:100%; height:100%; background: radial-gradient(circle, rgba(0,0,0,0) 50%, rgba(0,0,0,0.8) 100%); pointer-events: none; z-index: 15; }
        #damage-flash { position: absolute; top:0; left:0; width:100%; height:100%; pointer-events: none; background: #ff0000; opacity: 0; transition: opacity 0.1s; z-index: 19; mix-blend-mode: overlay; }
        .joystick-hint { position: absolute; bottom: 15%; left: 50%; transform: translateX(-50%); color: rgba(255,255,255,0.4); font-size: 0.9rem; letter-spacing: 2px; pointer-events: none; animation: pulse 2s infinite; }
        @keyframes pulse { 0% { opacity: 0.2; } 50% { opacity: 0.7; } 100% { opacity: 0.2; } }
        
        #boss-warning {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: red; font-size: 3rem; font-weight: 900; display: none; pointer-events: none;
            text-shadow: 0 0 20px red; letter-spacing: 6px; animation: flash 0.5s infinite; z-index: 200;
            text-align: center; width: 100%;
        }
        @keyframes flash { 0% {opacity: 1;} 50% {opacity: 0.2;} 100% {opacity: 1;} }


        #stats-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px 30px; margin: 0 auto 20px auto; width: 80%; max-width: 500px; }
        .stat-row { display: flex; justify-content: space-between; border-bottom: 1px solid rgba(255,255,255,0.1); padding-bottom: 4px; }
        .stat-label { color: #888; font-size: 0.8rem; }
        .stat-val { color: #fff; font-weight: bold; font-family: monospace; }
        .stat-val.gold { color: #ffdd57; }
        
        #mod-confirm-screen { z-index: 250; }


        /* Toggle Switch */
        .toggle-container { display: flex; align-items: center; gap: 10px; margin-bottom: 15px; cursor: pointer; }
        .toggle-switch { position: relative; width: 40px; height: 20px; background: #333; border-radius: 10px; transition: 0.3s; }
        .toggle-switch::after { content: ''; position: absolute; top: 2px; left: 2px; width: 16px; height: 16px; background: #fff; border-radius: 50%; transition: 0.3s; }
        .toggle-active .toggle-switch { background: #00d1b2; }
        .toggle-active .toggle-switch::after { transform: translateX(20px); }
        .toggle-disabled { opacity: 0.5; pointer-events: none; }


        /* Glossary */
        .glossary-item { margin-bottom: 15px; border-bottom: 1px solid rgba(255,255,255,0.1); padding-bottom: 10px; }
        .g-title { color: #fff; font-weight: bold; display: flex; align-items: center; gap: 10px; }
        .g-desc { color: #aaa; font-size: 0.8rem; margin-left: 24px; }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div class="vignette"></div>
    <div id="damage-flash"></div>
    <div id="boss-warning">WARNING<br>CHAMPION INCOMING!</div>


    <!-- HUD -->
    <div class="overlay" id="hud" style="display:none;">
        <div id="boss-hud">
            <div id="boss-name-display" class="boss-name">OMEGA UNIT</div>
            <div class="boss-bar-container">
                <div class="boss-phase-marker"></div>
                <div id="boss-bar" class="boss-bar-fill"></div>
            </div>
        </div>


        <div class="flex justify-between items-start w-full">
            <!-- Left side: HP and shields -->
            <div class="flex gap-3 items-start">
                <!-- Heart icon -->
                <div class="flex flex-col" style="padding-top: 3px;">
                    <i class="fas fa-heart text-red-500 w-4" style="font-size: 14px;"></i>
                </div>
                <!-- HP bar and shields -->
                <div class="flex flex-col gap-1">
                    <div class="bar-container">
                        <div id="hp-bar" class="hp-bar-fill"></div>
                        <div id="hp-text" class="hp-text-inner">150 / 150</div>
                    </div>
                    <!-- Shield charges and level below HP bar -->
                    <div class="flex justify-between items-center">
                        <!-- Shield charges - left aligned, shield-shaped -->
                        <div class="flex gap-2">
                            <i id="shield-orb-1" class="fas fa-shield-alt" style="font-size: 14px; color: #00d1b2; filter: drop-shadow(0 0 6px #00d1b2); transition: all 0.3s;"></i>
                            <i id="shield-orb-2" class="fas fa-shield-alt" style="font-size: 14px; color: #00d1b2; filter: drop-shadow(0 0 6px #00d1b2); transition: all 0.3s;"></i>
                        </div>
                        <!-- Level text - right aligned -->
                        <div id="lvl-text" class="text-[10px] text-gray-400 font-mono">LVL 1</div>
                    </div>
                </div>
            </div>
            
            <!-- Right side: Score and time aligned to top of HP bar -->
            <div class="flex flex-col items-end" style="padding-top: 0px;">
                <div id="score" class="text-3xl text-white font-black tracking-widest drop-shadow-[0_0_10px_rgba(255,255,255,0.5)]" style="line-height: 1;">0</div>
                <div id="time" class="text-xs text-gray-500 font-mono" style="margin-top: 2px;">00:00</div>
            </div>
        </div>
        
        <!-- Bottom UI Bar - Center-aligned: Mod | Weapons | Pause -->
        <div style="position: absolute; bottom: 40px; left: 0; right: 0; display: flex; align-items: center; justify-content: center; gap: 40px; pointer-events: none;">
            <!-- Mod Slot - Left -->
            <div id="mod-slot-container" style="pointer-events: auto;"></div>
            
            <!-- Weapon Slots - Center -->
            <div id="weapon-slots" class="weapon-bar"></div>
            
            <!-- Pause Button - Right -->
            <button id="pause-btn" style="pointer-events: auto;"><i class="fas fa-pause"></i></button>
        </div>
        
        <!-- XP Bar - Bottom of screen, full width -->
        <div style="position: absolute; bottom: 0; left: 0; right: 0; height: 8px; background: rgba(0,0,0,0.7); border-top: 1px solid rgba(0,209,178,0.3);">
            <div id="xp-bar" class="xp-bar-fill" style="height: 100%;"></div>
        </div>

        <div id="start-hint" class="joystick-hint">ENGAGE THRUSTERS</div>
    </div>


    <!-- Main Menu -->
    <div id="menu-screen" class="modal active">
        <!-- Title - Pinned to Top -->
        <div class="absolute top-12 left-0 right-0 flex justify-center">
            <h1 class="text-6xl text-transparent bg-clip-text bg-gradient-to-r from-teal-400 to-blue-500 font-black tracking-tighter filter drop-shadow-[0_0_15px_rgba(0,209,178,0.5)]">NEON<br>ROGUE</h1>
        </div>
        
        <!-- Seed Icon Button - Bottom Left Corner (Pinned) -->
        <button id="seed-corner-btn" class="absolute bottom-6 left-6 w-12 h-12 bg-gray-800 hover:bg-gray-700 text-gray-400 hover:text-teal-400 rounded-lg border border-gray-700 flex items-center justify-center transition-all">
            <i class="fas fa-hashtag text-lg"></i>
        </button>
        
        <!-- Save Icon Button - Bottom Right Corner (Pinned) -->
        <button id="save-corner-btn" class="absolute bottom-6 right-6 w-12 h-12 bg-gray-800 hover:bg-gray-700 text-gray-400 hover:text-teal-400 rounded-lg border border-gray-700 flex items-center justify-center transition-all">
            <i class="fas fa-save text-lg"></i>
        </button>
        
        <!-- Centered Content Area -->
        <div class="flex flex-col items-center justify-center" style="min-height: 100vh; padding: 180px 0 100px 0;">
            <!-- Ship Selection Carousel - Vertical Layout -->
            <div class="mb-8 w-80 relative">
                <!-- Navigation Arrows - Inside edges -->
                <button id="ship-prev" class="absolute left-2 top-1/2 -translate-y-1/2 text-2xl z-10 transition-all disabled:text-gray-800 disabled:cursor-not-allowed text-teal-400 hover:text-teal-300" disabled>
                    <i class="fas fa-chevron-circle-left"></i>
                </button>
                <button id="ship-next" class="absolute right-2 top-1/2 -translate-y-1/2 text-2xl z-10 transition-all disabled:text-gray-800 disabled:cursor-not-allowed text-teal-400 hover:text-teal-300" disabled>
                    <i class="fas fa-chevron-circle-right"></i>
                </button>
                
                <!-- Ship Display - Vertical Layout -->
                <div class="flex flex-col items-center">
                    <!-- Ship Icon (Canvas) - Top -->
                    <div class="mb-3">
                        <canvas id="ship-canvas" width="70" height="70"></canvas>
                    </div>
                    
                    <!-- Ship Info - Bottom, Centered -->
                    <div class="text-center">
                        <h3 id="ship-name" class="text-base font-bold text-teal-400 mb-1 tracking-wide">PATHFINDER</h3>
                        <p id="ship-desc" class="text-xs text-gray-400 mb-2">Balanced all-around vessel</p>
                        <div id="ship-stats" class="text-[10px] text-gray-500 font-mono space-y-0.5">
                            <div>HP: <span class="text-white">150</span> • DMG: <span class="text-white">100%</span> • SPD: <span class="text-white">100%</span></div>
                            <div>WEAPON: <span class="text-teal-400">Ion Cannons</span></div>
                        </div>
                    </div>
                </div>
                <p class="text-[10px] text-gray-700 text-center mt-4">More ships unlock via progression</p>
            </div>
            
            <div class="flex flex-col gap-4 w-64">
                <button id="start-btn" class="bg-teal-500 hover:bg-teal-400 text-black font-bold py-4 rounded-sm skew-x-[-10deg] shadow-[0_0_30px_rgba(0,209,178,0.3)] transition-all">
                    <span class="inline-block skew-x-[10deg]">DEPLOY</span>
                </button>
                
                <button id="view-stats-btn" class="bg-gray-800 hover:bg-gray-700 text-gray-400 hover:text-teal-400 text-sm font-bold py-2 rounded transition-all border border-gray-700">
                    <i class="fas fa-chart-bar mr-2"></i>VIEW STATS
                </button>
            </div>
        </div>
    </div>
    
    <!-- Seed Options Modal -->
    <div id="seed-modal" class="modal">
        <h2 class="text-3xl text-teal-400 font-black mb-6 tracking-widest">SEED OPTIONS</h2>
        <div class="flex flex-col gap-3 w-72">
            <input 
                id="seed-input" 
                type="text" 
                placeholder="Random" 
                maxlength="6"
                class="bg-gray-800 border border-gray-700 text-teal-400 text-center py-3 px-4 rounded font-mono focus:border-teal-500 focus:outline-none text-lg"
                style="letter-spacing: 0.3em;"
            />
            <p class="text-sm text-gray-500 text-center">Leave blank for random run</p>
            <button id="seed-close-btn" class="mt-4 border border-gray-500 text-gray-400 hover:text-white hover:border-white py-2 px-8 rounded transition-all">
                CLOSE
            </button>
        </div>
    </div>
    
    <!-- Save Management Modal -->
    <div id="save-modal" class="modal">
        <h2 class="text-3xl text-teal-400 font-black mb-6 tracking-widest">SAVE MANAGEMENT</h2>
        <div class="flex flex-col gap-3 w-72">
            <button id="export-btn" class="bg-gray-700 hover:bg-gray-600 text-white font-bold py-3 rounded transition-all">
                <i class="fas fa-download mr-2"></i>EXPORT SAVE
            </button>
            <button id="import-btn" class="bg-gray-700 hover:bg-gray-600 text-white font-bold py-3 rounded transition-all">
                <i class="fas fa-upload mr-2"></i>IMPORT SAVE
            </button>
            <input type="file" id="import-file-input" accept=".json" style="display: none;">
            <button id="save-close-btn" class="mt-4 border border-gray-500 text-gray-400 hover:text-white hover:border-white py-2 px-8 rounded transition-all">
                CLOSE
            </button>
        </div>
    </div>
    
    <!-- Mod Confirmation -->
    <div id="mod-confirm-screen" class="modal">
        <div id="mod-confirm-content" class="mb-6 text-center"></div>
        <!-- Old buttons hidden, using inline HTML from triggerModPickup -->
        <div class="flex gap-4" style="display: none;">
            <button id="mod-equip-btn" class="bg-teal-500 text-black font-bold py-3 px-6 rounded">EQUIP</button>
            <button id="mod-discard-btn" class="border border-gray-500 text-gray-400 py-3 px-6 rounded">DISCARD</button>
        </div>
    </div>
    
    <!-- Weapon Replace -->
    <div id="swap-screen" class="modal">
        <h2 class="text-3xl text-red-500 font-bold mb-2">SLOTS FULL</h2>
        <p class="text-gray-400 mb-6">Select a weapon to DISCARD</p>
        <div id="swap-container" class="w-full flex flex-col items-center"></div>
        <button onclick="cancelSwap()" class="mt-4 text-gray-500 hover:text-white">CANCEL</button>
    </div>


    <!-- Pause -->
    <div id="pause-screen" class="modal">
        <h2 class="text-4xl text-white font-bold mb-4 tracking-widest">SYSTEM PAUSED</h2>
        
        <!-- Tab buttons -->
        <div class="flex gap-4 mb-6 justify-center">
            <button id="stats-tab-btn" class="tab-btn active px-6 py-2 border-b-2 border-teal-500 text-teal-500 font-bold">STATS</button>
            <button id="kit-tab-btn" class="tab-btn px-6 py-2 border-b-2 border-transparent text-gray-400 font-bold hover:text-white">KIT</button>
        </div>
        
        <!-- Stats Tab -->
        <div id="stats-tab" class="tab-content">
            <div id="stats-grid"></div>
        </div>
        
        <!-- Kit Tab -->
        <div id="kit-tab" class="tab-content hidden">
            <div id="kit-grid" class="grid grid-cols-1 gap-4 max-w-2xl mx-auto mb-6 max-h-96 overflow-y-auto px-4"></div>
        </div>
        
        <button id="glossary-btn" class="border border-yellow-400 text-yellow-400 hover:bg-yellow-400/20 font-bold py-2 px-8 rounded mb-4">GLOSSARY</button>
        <button id="resume-btn" class="bg-teal-500 hover:bg-teal-400 text-black font-bold py-3 px-10 rounded-sm skew-x-[-10deg] transition-all mb-4">RESUME</button>
        <button id="quit-btn" class="border-2 border-red-500 text-red-500 hover:bg-red-500 hover:text-white font-bold py-3 px-10 rounded-sm skew-x-[-10deg] transition-all">ABORT</button>
    </div>


    <!-- Glossary -->
    <div id="glossary-screen" class="modal">
        <h2 class="text-3xl text-white font-bold mb-6">ELEMENTAL DATABASE</h2>
        <div class="w-full max-w-md h-96 overflow-y-auto px-4">
            <div class="glossary-item">
                <div class="g-title"><i class="fas fa-fire text-[#ff5722]"></i> PYRO</div>
                <div class="g-desc">Applies DOT. Damage increases the longer it remains active. Can't Crit.</div>
            </div>
            <div class="glossary-item">
                <div class="g-title"><i class="fas fa-snowflake text-[#00e5ff]"></i> CRYO</div>
                <div class="g-desc">Applies 60% slow that spreads to nearby enemies. Enemies slowed for 2s freeze solid, becoming obstacles. Can't Crit.</div>
            </div>
            <div class="glossary-item">
                <div class="g-title"><i class="fas fa-bolt text-[#ffeb3b]"></i> VOLT</div>
                <div class="g-desc">Strikes cause chain lightning to nearby enemies. Chain chance decreases with each jump.</div>
            </div>
            <div class="glossary-item">
                <div class="g-title"><i class="fas fa-biohazard text-[#39ff14]"></i> BIO</div>
                <div class="g-desc">High initial decay damage. If the host dies, the infection spreads once. Can't Crit.</div>
            </div>
            <div class="glossary-item">
                <div class="g-title"><i class="fas fa-terminal text-[#00ffaa]"></i> HACK</div>
                <div class="g-desc">50% chance to scramble enemy AI, causing them to move erratically and damage other enemies.</div>
            </div>
        </div>
        <button onclick="closeGlossary()" class="mt-6 text-gray-400 hover:text-white border border-gray-600 px-6 py-2 rounded">BACK</button>
    </div>


    <!-- Level Up -->
    <div id="levelup-screen" class="modal">
        <h2 id="lvl-title" class="text-3xl text-yellow-400 font-bold mb-1 drop-shadow-[0_0_10px_rgba(255,221,87,0.5)]">SYSTEM UPGRADE</h2>
        <p id="lvl-subtitle" class="text-sm text-gray-500 mb-6 uppercase tracking-widest">Select Augmentation</p>
        
        <div id="lock-kit-toggle" class="toggle-container" onclick="toggleLockKit()" style="display:none;">
            <div class="toggle-switch"></div>
            <div class="text-gray-300 text-sm font-bold">LOCK KIT (NO NEW WEAPONS)</div>
        </div>


        <div id="cards-container" class="cards-grid"></div>
        <div class="upgrade-buttons">
            <button id="reroll-btn" onclick="rerollUpgrades()"><i class="fas fa-dice"></i> REROLL (<span id="reroll-count">3</span>)</button>
            <button id="save-btn" onclick="toggleSaveMode()"><i class="fas fa-save"></i> SAVE (<span id="save-count">3</span>)</button>
        </div>
    </div>


    <!-- Game Over -->
    <div id="gameover-screen" class="modal">
        <h2 class="text-5xl text-red-600 font-black mb-2 drop-shadow-[0_0_20px_rgba(255,56,96,0.5)]">TERMINATED</h2>
        <div class="flex gap-6 mb-2 font-mono text-gray-300">
            <p>LEVEL: <span id="final-level" class="text-white text-xl">1</span></p>
            <p>SCORE: <span id="final-score" class="text-white text-xl">0</span></p>
            <p>TIME: <span id="final-time" class="text-white text-xl">00:00</span></p>
        </div>
        
        <!-- Seed Display -->
        <div class="mb-4 flex items-center justify-center gap-3">
            <span class="text-gray-500 text-xs font-mono">SEED:</span>
            <span id="final-seed" class="text-teal-400 font-mono font-bold text-lg tracking-widest">000000</span>
            <button id="copy-seed-btn" class="text-xs bg-gray-800 hover:bg-gray-700 text-gray-400 hover:text-teal-400 px-2 py-1 rounded border border-gray-700 transition-all font-mono">
                <i class="fas fa-copy"></i> COPY
            </button>
        </div>
        
        <!-- Weapon Stats Breakdown -->
        <div id="weapon-breakdown" class="mb-6 max-h-80 overflow-y-auto bg-black bg-opacity-40 p-4 rounded border border-gray-700">
            <h3 class="text-xl text-teal-400 font-bold mb-3 font-mono">WEAPON PERFORMANCE</h3>
            <div id="weapon-stats-list" class="space-y-2 text-left font-mono text-sm">
                <!-- Will be populated by JavaScript -->
            </div>
        </div>
        
        <div class="flex flex-col gap-3 w-64">
            <button id="restart-btn" class="border-2 border-teal-500 text-teal-500 hover:bg-teal-500 hover:text-white font-bold py-3 px-10 rounded-sm skew-x-[-10deg] transition-all"><span class="inline-block skew-x-[10deg]">RETURN</span></button>
            <button id="gameover-export-btn" class="bg-gray-700 hover:bg-gray-600 text-white text-sm font-bold py-2 rounded transition-all">
                <i class="fas fa-download mr-2"></i>EXPORT SAVE
            </button>
        </div>
    </div>


    <!-- Stats Screen -->
    <div id="stats-screen" class="modal">
        <h2 class="text-4xl text-teal-400 font-black mb-6 tracking-widest">PROGRESSION STATS</h2>
        <div class="bg-gray-900 bg-opacity-80 border border-teal-500 rounded-lg p-6 w-80 font-mono">
            <div class="space-y-3 text-left">
                <div class="flex justify-between border-b border-gray-700 pb-2">
                    <span class="text-gray-400">Nexus Cores:</span>
                    <span id="stat-cores" class="text-purple-400 font-bold">0</span>
                </div>
                <div class="flex justify-between border-b border-gray-700 pb-2">
                    <span class="text-gray-400">Total Runs:</span>
                    <span id="stat-runs" class="text-white font-bold">0</span>
                </div>
                <div class="flex justify-between border-b border-gray-700 pb-2">
                    <span class="text-gray-400">Total Kills:</span>
                    <span id="stat-kills" class="text-orange-400 font-bold">0</span>
                </div>
                <div class="flex justify-between border-b border-gray-700 pb-2">
                    <span class="text-gray-400">Highest Level:</span>
                    <span id="stat-level" class="text-yellow-400 font-bold">0</span>
                </div>
                <div class="flex justify-between border-b border-gray-700 pb-2">
                    <span class="text-gray-400">Highest Score:</span>
                    <span id="stat-score" class="text-teal-400 font-bold">0</span>
                </div>
                <div class="flex justify-between">
                    <span class="text-gray-400">Total Playtime:</span>
                    <span id="stat-time" class="text-blue-400 font-bold">0h 0m</span>
                </div>
            </div>
        </div>
        <button id="close-stats-btn" class="mt-6 border border-gray-500 text-gray-400 hover:text-white hover:border-white py-2 px-8 rounded transition-all">
            CLOSE
        </button>
    </div>


    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d', { alpha: false });
        let width, height;
        const resize = () => { width = canvas.width = window.innerWidth; height = canvas.height = window.innerHeight; };
        window.addEventListener('resize', resize); resize();

        // SEEDED RNG SYSTEM
        // Allows for reproducible runs by using a seed instead of seededRandom()
        let rngSeed = 0;
        
        function seededRandom() {
            // Linear Congruential Generator (LCG)
            rngSeed = (rngSeed * 9301 + 49297) % 233280;
            return rngSeed / 233280;
        }
        
        function setSeed(seed) {
            rngSeed = seed;
        }
        
        function generateSeed() {
            // Generate 6-digit seed using true randomness (not seeded)
            const trueRandom = Math.random;
            return Math.floor(100000 + trueRandom() * 900000);
        }

        const state = {
            screen: 'menu', score: 0, startTime: 0, level: 1, xp: 0, xpToNext: 10,
            lastTime: 0, camera: { x: 0, y: 0 }, shake: 0, frameCount: 0, rerolls: 3,
            paused: false, timeScale: 1.0, pendingLevelUps: 0, zoom: 0.70,
            pendingSwap: null, bossActive: false, bossWave: 0,
            gameTime: 0,
            pendingMod: null, lastTap: 0,
            weaponStats: {}, // Track damage and kills per weapon
            kitLocked: false,
            lockUsed: false,
            breathingRoomTimer: 0,
            saveCharges: 3,
            savedUpgrade: null,
            seed: 0 // Current run seed
        };


        const input = { active: false, origin: {x:0,y:0}, current: {x:0,y:0}, vector: {x:0,y:0} };


        let player;
        let entities = { enemies: [], projectiles: [], enemyProjectiles: [], particles: [], pickups: [], texts: [], lightnings: [], gasClouds: [] };
        let animationFrameId;


        // --- Defs ---
        const weaponDefs = {
            ion: { id: 'ion', type: 'weapon', name: 'Ion Cannon', icon: 'fa-crosshairs', desc: 'Stationed turrets firing energy blasts.', offensive: true, validUpgrades: ['dmg', 'rate'], shipLocked: 'PATHFINDER' },
            turret: { id: 'turret', type: 'weapon', name: 'Auto-Turret', icon: 'fa-chess-rook', desc: 'Deploys stationary turrets that auto-fire.', offensive: true, validUpgrades: ['dmg', 'rate', 'area'], shipLocked: 'ENGINEER' },
            emp: { id: 'emp', type: 'weapon', name: 'EMP Pulse', icon: 'fa-bullseye', desc: 'Slowing pulses that create lingering fields.', offensive: true, validUpgrades: ['dmg', 'rate', 'area'], shipLocked: 'DISRUPTOR' },
            beam: { id: 'beam', type: 'weapon', name: 'Plasma Beam', icon: 'fa-fire', desc: 'Continuous energy beam.', offensive: true, validUpgrades: ['dmg', 'rate', 'area'] },
            seeker: { id: 'seeker', type: 'weapon', name: 'Seeker Swarm', icon: 'fa-rocket', desc: 'Launches homing missiles.', offensive: true, validUpgrades: ['dmg', 'rate', 'area'] },
            rad: { id: 'rad', type: 'weapon', name: 'Rad-Field', icon: 'fa-radiation', desc: 'Emits a damaging aura.', offensive: true, validUpgrades: ['dmg', 'area'] },
            tesla: { id: 'tesla', type: 'weapon', name: 'Tesla Coil', icon: 'fa-bolt', desc: 'Zaps nearby enemies.', offensive: true, validUpgrades: ['dmg', 'rate', 'area'] },

            whip: { id: 'whip', type: 'weapon', name: 'Plasma Whip', icon: 'fa-slash', desc: 'Energy whip slashes in a wide arc.', offensive: true, validUpgrades: ['dmg', 'rate', 'area'] },
            meteor: { id: 'meteor', type: 'weapon', name: 'Meteor Strike', icon: 'fa-meteor', desc: 'Calls down an orbital strike.', offensive: true, validUpgrades: ['dmg', 'rate', 'area'] },
            railgun: { id: 'railgun', type: 'weapon', name: 'Railgun', icon: 'fa-long-arrow-alt-right', desc: 'Fires a piercing high-velocity slug.', offensive: true, validUpgrades: ['dmg', 'rate', 'area'] },
            flak: { id: 'flak', type: 'weapon', name: 'Flak Cannon', icon: 'fa-bomb', desc: 'Fires a shell that bursts into shrapnel.', offensive: true, validUpgrades: ['dmg', 'rate', 'area'] },
            pylons: { id: 'pylons', type: 'weapon', name: 'Energy Pylons', icon: 'fa-project-diagram', desc: 'Energy pylons damage enemies crossing between them.', offensive: true, validUpgrades: ['dmg', 'rate', 'area'] },
            ricochet: { id: 'ricochet', type: 'weapon', name: 'Ricochet Disc', icon: 'fa-circle-notch', desc: 'Bouncing projectile chains between enemies.', offensive: true, validUpgrades: ['dmg', 'rate', 'area'] },
            drones: { id: 'drones', type: 'weapon', name: 'Combat Drones', icon: 'fa-fighter-jet', desc: 'Autonomous drones fire at nearby enemies.', offensive: true, validUpgrades: ['dmg', 'rate', 'area'] },
            mines: { id: 'mines', type: 'weapon', name: 'Collapsar Mines', icon: 'fa-gem', desc: 'Hovering mines pull enemies in before detonating.', offensive: true, validUpgrades: ['dmg', 'rate', 'area'] },
            gas: { id: 'gas', type: 'weapon', name: 'Toxic Barrage', icon: 'fa-cloud', desc: 'Carpets enemy clusters with poison clouds.', offensive: true, validUpgrades: ['dmg', 'rate', 'area'] }
        };


        const modDefs = {
            repulsor: { id: 'repulsor', name: 'Repulsor Field', icon: 'fa-shield-alt', desc: 'Constantly pushes drones and swarms away.' },
            overclock: { id: 'overclock', name: 'Overclock Module', icon: 'fa-tachometer-alt', desc: '+25% fire rate for all weapons.' },
            chrono: { id: 'chrono', name: 'Chrono Shield', icon: 'fa-clock', desc: 'Time slows 50% for 10s at low HP, but YOU stay at 100% speed. 60s cooldown.' },
            revive: { id: 'revive', name: 'Second Chance', icon: 'fa-heart', desc: 'Survive fatal damage once per 2 min, restore 50% HP.' },
            laststand: { id: 'laststand', name: 'Last Stand', icon: 'fa-heart-pulse', desc: '+30% damage when below 30% HP.' },
            shieldburst: { id: 'shieldburst', name: 'Shield Burst', icon: 'fa-wind', desc: 'Taking damage releases AOE pushback.' },
            cascade: { id: 'cascade', name: 'Cascade Amplifier', icon: 'fa-sitemap', desc: 'Multistrikes can chain. +25% multistrike chance, +25% multistrike damage.' }
        };


        const statDefs = [
            { id: 'hp', type: 'stat', name: 'Hull Repair', desc: 'Max HP & Heal', icon: 'fa-heart', offensive: false },
            // Multistrike is now a core stat, always available
            { id: 'multi', type: 'stat', name: 'Overclock', desc: 'Multistrike Chance', icon: 'fa-microchip', offensive: true },
            // Global damage and cooldown removed - weapon-specific only
            { id: 'spd', type: 'stat', name: 'Thrusters', desc: 'Speed', icon: 'fa-wind', offensive: false },
            { id: 'armor', type: 'stat', name: 'Plating', desc: 'Armor', icon: 'fa-shield-alt', offensive: false },
            { id: 'pickup', type: 'stat', name: 'Magnet Range', desc: 'Pickup Radius', icon: 'fa-magnet', offensive: false },
            { id: 'regen', type: 'stat', name: 'Nano-Bots', desc: 'Health Regen', icon: 'fa-plus-square', offensive: false },
            { id: 'luck', type: 'stat', name: 'Fortune Algo', desc: 'Luck & Drop Rate', icon: 'fa-clover', offensive: false },
            { id: 'xp', type: 'stat', name: 'Data Miner', desc: 'XP Gain', icon: 'fa-database', offensive: false },
            { id: 'multi', type: 'stat', name: 'Overclock', desc: 'Multistrike Chance', icon: 'fa-microchip', offensive: true },
            { id: 'crit', type: 'stat', name: 'Precision Lens', desc: 'Crit Chance', icon: 'fa-bullseye', offensive: true },
            { id: 'elem', type: 'stat', name: 'Flux Emitter', desc: 'Elemental Chance', icon: 'fa-wifi', offensive: false }
        ];


        const elementalDefs = [
            { id: 'fire', name: 'Pyro Mod', desc: 'Burns for ramping damage over time.', icon: 'fa-fire', color: '#ff5722' },
            { id: 'ice', name: 'Cryo Mod', desc: 'Slows enemies, spreads to nearby, freezes after 2s.', icon: 'fa-snowflake', color: '#88d8ff' },
            { id: 'volt', name: 'Volt Mod', desc: 'Chains lightning to nearby enemies.', icon: 'fa-bolt', color: '#ffeb3b' },
            { id: 'bio', name: 'Bio Mod', desc: 'Decay damage spreads once to nearest enemy.', icon: 'fa-biohazard', color: '#00cc44' },
            { id: 'hack', name: 'Cyber Hack', desc: 'Turns weaker enemies to fight for you temporarily.', icon: 'fa-terminal', color: '#9c27b0' }
        ];


        const masteryDefs = {
            fire: { id: 'fire', type: 'mastery', name: 'Pyro Mastery', desc: '+2s burn duration, +0.5% HP/tick', icon: 'fa-fire-alt', offensive: true },
            ice: { id: 'ice', type: 'mastery', name: 'Cryo Control', desc: '+50% aura range, frozen take +50% damage', icon: 'fa-snowflake', offensive: true },
            volt: { id: 'volt', type: 'mastery', name: 'Volt Amplifier', desc: '+1 chain jump, +30% chain damage', icon: 'fa-bolt', offensive: true },
            bio: { id: 'bio', type: 'mastery', name: 'Bio Accelerator', desc: 'Ticks 50% faster, +1% starting damage', icon: 'fa-biohazard', offensive: true },
            hack: { id: 'hack', type: 'mastery', name: 'Hack Override', desc: '+2s duration, +67% damage, can hack elite enemies (tanks, voidwalkers)', icon: 'fa-terminal', offensive: true }
        };

        const synergyDefs = {
            pyro_cryo: { id: 'pyro_cryo', type: 'synergy', name: 'Thermal Shock', desc: 'Enemy with both explodes for 50% HP AOE, freezes nearby', icon: 'fa-burst', offensive: true, elements: ['fire', 'ice'] },
            pyro_volt: { id: 'pyro_volt', type: 'synergy', name: 'Pyroclasm', desc: 'Burning enemies shocked deal AOE damage, chains apply 50% burn', icon: 'fa-bolt', offensive: true, elements: ['fire', 'volt'] },
            pyro_bio: { id: 'pyro_bio', type: 'synergy', name: 'Meltdown', desc: 'Bio ticks apply 50% pyro, burning enemies spread bio on death', icon: 'fa-radiation', offensive: true, elements: ['fire', 'bio'] },
            pyro_hack: { id: 'pyro_hack', type: 'synergy', name: 'Digital Inferno', desc: 'Hacked burn 2x faster, burning 50% easier to hack', icon: 'fa-fire', offensive: true, elements: ['fire', 'hack'] },
            cryo_volt: { id: 'cryo_volt', type: 'synergy', name: 'Storm Surge', desc: 'Chains prioritize frozen, +100% damage to frozen enemies', icon: 'fa-bolt', offensive: true, elements: ['ice', 'volt'] },
            cryo_bio: { id: 'cryo_bio', type: 'synergy', name: 'Frozen Plague', desc: 'Freeze spreads bio 100 range, frozen take +100% bio damage', icon: 'fa-snowflake', offensive: true, elements: ['ice', 'bio'] },
            cryo_hack: { id: 'cryo_hack', type: 'synergy', name: 'Shatter Protocol', desc: 'Frozen hack instantly, hacked emit freeze pulses every 2s', icon: 'fa-microchip', offensive: true, elements: ['ice', 'hack'] },
            volt_bio: { id: 'volt_bio', type: 'synergy', name: 'Bioshock', desc: 'Every 3rd bio tick triggers chain, chains double bio rate 2s', icon: 'fa-bolt', offensive: true, elements: ['volt', 'bio'] },
            volt_hack: { id: 'volt_hack', type: 'synergy', name: 'Corrupted Circuitry', desc: 'Hacked emit chains every 2s, volt 25% hack chance', icon: 'fa-bolt', offensive: true, elements: ['volt', 'hack'] },
            bio_hack: { id: 'bio_hack', type: 'synergy', name: 'Necrosis', desc: 'Hacked take double bio, hack end resets bio duration', icon: 'fa-biohazard', offensive: true, elements: ['bio', 'hack'] }
        };


        // --- Game Classes ---
        class Player {
            constructor() {
                this.x = 0; this.y = 0; this.radius = 16; this.speed = 2.5; // Base move speed (increased from 2.2) 
                this.hp = 150; this.maxHp = 150; this.armor = 15; // Base Armor increased from 10 to 15
                this.shield1 = 100; // Shield bar 1 (0-100%)
                this.shield2 = 100; // Shield bar 2 (0-100%)
                this.shield1RechargeTimer = 0; // Time until bar 1 starts recharging
                this.shield2RechargeTimer = 0; // Time until bar 2 starts recharging
                this.shieldRechargeDelay = 600; // 10 seconds (60fps × 10)
                this.shieldRechargeRate = 20; // 20% per second (100% in 5 seconds) 
                this.regen = 0; this.regenTimer = 60; // Ticks every 1 second (60 frames)
                this.lastDamageTime = 0; // Track last time damage was taken for regen
                this.luck = 0; this.xpGain = 0; 
                this.multicast = 0.07; // Base 7% multistrike (buffed from 5%)
                this.critChance = 0.07; 
                this.critMult = 1.50; 
                this.elementalMult = 1.0; 
                this.invulnTimer = 0; this.pickupRadius = 120; // Slightly increased for better feel
                this.pickupUpgradeCount = 0; // Track magnet upgrades for hard cap

                // Ship selection
                this.selectedShip = localStorage.getItem('neonrogue_selectedShip') || 'PATHFINDER';
                
                // Apply ship stat modifiers
                const shipData = ships.find(s => s.name === this.selectedShip);
                if (shipData) {
                    // HP modifier
                    this.maxHp = shipData.hp;
                    this.hp = shipData.hp;
                    
                    // Damage modifier (stored as multiplier)
                    this.shipDamageMult = parseFloat(shipData.dmg) / 100;
                    
                    // Speed modifier (stored as multiplier)
                    this.shipSpeedMult = parseFloat(shipData.spd) / 100;
                } else {
                    // Defaults if ship not found
                    this.shipDamageMult = 1.0;
                    this.shipSpeedMult = 1.0;
                }

                this.weapons = { ion: 0, turret: 0, emp: 0, shield: 0, tesla: 0, seeker: 0, rad: 0, beam: 0, whip: 0, meteor: 0, railgun: 0, flak: 0, pylons: 0, mines: 0, gas: 0, ricochet: 0, drones: 0 };
                
                // Set starting weapon based on ship
                if (this.selectedShip === 'PATHFINDER') this.weapons.ion = 1;
                else if (this.selectedShip === 'ENGINEER') this.weapons.turret = 1;
                else if (this.selectedShip === 'DISRUPTOR') this.weapons.emp = 1;
                
                this.weaponAugments = {}; // Single augment per weapon: { ion: 'fire', beam: 'ice', ... }
                this.weaponStats = {};
                Object.keys(this.weapons).forEach(k => {
                     this.weaponAugments[k] = null; // null = no augment yet
                     this.weaponStats[k] = { dmg: 1.0, rate: 1.0, area: 1.0, speed: 1.0 };
                });
                
                // Turret tracking (for Engineer)
                this.turrets = []; // Array of deployed turrets
                this.turretTimer = 0;
                
                // EMP tracking (for Disruptor)
                this.empFields = []; // Array of active EMP fields
                
                // Elemental Masteries (once per element)
                this.elementalMasteries = {
                    fire: false,
                    ice: false,
                    volt: false,
                    bio: false,
                    hack: false
                };
                
                // Synergies (once per pair)
                this.synergies = {
                    pyro_cryo: false,
                    pyro_volt: false,
                    pyro_bio: false,
                    pyro_hack: false,
                    cryo_volt: false,
                    cryo_bio: false,
                    cryo_hack: false,
                    volt_bio: false,
                    volt_hack: false,
                    bio_hack: false
                };
                
                this.activeMod = null; 
                this.nukeTimer = 0; 
                this.maxNukeTimer = 7200; // 2 minutes
                this.repulserTimer = 0;
                this.repulserActive = false;
                this.repulserDuration = 0;
                this.empTimer = 0;
                this.overdriveTimer = 0;
                this.overdriveActive = false;
                this.overdriveDuration = 0; 


                this.fireRate = 500; this.lastShot = 0; // Increased from 340 to slow down rapid fire
                this.damage = 15 * this.shipDamageMult; // Apply ship damage modifier
                
                // Apply Overclock mod: +25% fire rate
                if (this.activeMod === 'overclock') {
                    this.fireRate *= 1.25; // 25% faster
                }
                this.projectileSpeed = 12; this.range = 450; this.pierce = 0;
                
                this.teslaTimer = 0; this.maxTeslaTimer = 150; // Increased from 110
                this.seekerTimer = 0; this.maxSeekerTimer = 110; // Increased from 90 (slower base cooldown - nerf) 
                this.beamActive = false; this.beamTimer = 0; this.beamCooldown = 0; this.beamTarget = null;
                this.beamTargets = [];
                this.beamRampMap = new Map(); // Track damage ramp per enemy
                this.beamTickCounter = 0; // Time dilation compliant tick counter
                
                this.whipTimer = 0;
                this.whipVisualTimer = 0; // Visual feedback for whip slash
                this.whipVisualAngle = 0;
                this.meteorTimer = 0; this.maxMeteorTimer = 300;
                this.railgunTimer = 0; this.maxRailgunTimer = 300;
                this.flakTimer = 0; this.maxFlakTimer = 160;
                this.pylonTimer = 0; this.maxPylonTimer = 300; this.pylons = []; this.maxPylons = 3;
                this.pylonTickCounter = 0; // Time dilation compliant tick counter
                this.radTickCounter = 0; // Time dilation compliant tick counter
                this.minesTimer = 0; this.maxMinesTimer = 240; // 4 seconds base deployment rate
                this.gasTimer = 0; this.maxGasTimer = 390; // 6.5 seconds base lob rate (since clouds last 5s)
                this.ricochetTimer = 0;
                this.drones = []; // Will be initialized when drones weapon is acquired
                
                this.angle = 0; this.cannons = []; this.shieldOrbs = []; this.fireIndex = 0; this.cannonAngle = 0;
                
                // Passive mod flags
                this.hasLastStand = false;
                this.hasShieldBurst = false;
            }


            heal(amount, allowOvershield=false) {
                if (this.hp < this.maxHp) {
                    const needed = this.maxHp - this.hp;
                    const applied = Math.min(needed, amount);
                    this.hp += applied;
                }
                // Note: allowOvershield parameter kept for compatibility but no longer used
                // Shields are now separate system with their own recharge mechanic
            }


            takeHit(amount) {
                if (this.invulnTimer > 0) return;
                
                // Check if we have any FULL shield bars (100% = fully charged)
                const hasShield1 = this.shield1 >= 100;
                const hasShield2 = this.shield2 >= 100;
                
                // Check if any shield is actively charging (can't be interrupted)
                const shield1Charging = this.shield1 < 100 && this.shield1RechargeTimer <= 0;
                const shield2Charging = this.shield2 < 100 && this.shield2RechargeTimer <= 0;
                
                // If we have at least one full shield bar, consume it and block damage
                // Deplete from RIGHT to LEFT (shield2 → shield1)
                // CRITICAL: Never deplete a shield that is actively charging
                if (hasShield1 || hasShield2) {
                    // Deplete shield2 (right) first if it's full and not charging
                    if (hasShield2 && !shield2Charging) {
                        this.shield2 = 0;
                        // Start 5-second delay before recharge
                        this.shield2RechargeTimer = this.shieldRechargeDelay;
                    } 
                    // Otherwise deplete shield1 (left) if it's full and not charging
                    else if (hasShield1 && !shield1Charging) {
                        this.shield1 = 0;
                        // Start 5-second delay before recharge
                        this.shield1RechargeTimer = this.shieldRechargeDelay;
                    }
                    // Edge case: Shield is full but charging (shouldn't happen, but for safety deplete it)
                    else if (hasShield2) {
                        this.shield2 = 0;
                        this.shield2RechargeTimer = this.shieldRechargeDelay;
                    } else {
                        this.shield1 = 0;
                        this.shield1RechargeTimer = this.shieldRechargeDelay;
                    }
                    
                    // Visual feedback - shield hit
                    const flash = document.getElementById('damage-flash');
                    flash.style.opacity = 0.3; // Lighter flash for shield hit
                    flash.style.background = '#00d1b2'; // Cyan for shield
                    setTimeout(() => {
                        flash.style.opacity = 0;
                        flash.style.background = '#ff0000'; // Reset to red
                    }, 100);
                    
                    this.invulnTimer = 60;
                    return; // No HP damage taken
                }
                
                // No full shields - take HP damage
                // PASSIVE DEFENSIVE SCALING: After level 20, player gains passive damage reduction
                // This helps counter enemy scaling and incentivizes reaching higher levels
                // Caps at 25% reduction at level 30+
                let defensiveScaling = 1.0;
                if (state.level > 20) {
                    const levelsPast20 = Math.min(10, state.level - 20); // Cap at level 30
                    defensiveScaling = 1.0 - (levelsPast20 * 0.025); // 2.5% reduction per level (max 25%)
                }
                
                const reduction = Math.min(this.armor, 80) / 100;
                let actualDmg = amount * (1 - reduction) * defensiveScaling;
                
                if (actualDmg > 0) {
                    this.hp -= actualDmg; state.shake = 10;
                    this.lastDamageTime = Date.now(); // Track when damage was taken
                    const flash = document.getElementById('damage-flash');
                    flash.style.opacity = 0.6; setTimeout(() => flash.style.opacity = 0, 100);
                    this.invulnTimer = 30; // Back to 0.5 seconds - was 60 (1 second)
                    
                    // Start recharge timers for depleted shields that aren't already charging
                    if (this.shield1 < 100 && this.shield1RechargeTimer > 0) {
                        // Shield needs charging but isn't charging yet - reset delay
                        this.shield1RechargeTimer = this.shieldRechargeDelay;
                    }
                    if (this.shield2 < 100 && this.shield2RechargeTimer > 0) {
                        // Shield needs charging but isn't charging yet - reset delay
                        this.shield2RechargeTimer = this.shieldRechargeDelay;
                    }
                    // Note: If a shield is actively charging (timer <= 0), we don't touch its timer
                    
                    // SHIELD BURST: Push enemies away when taking damage
                    if (this.hasShieldBurst) {
                        const burstRadius = 200;
                        const burstPower = 25;
                        
                        entities.enemies.forEach(e => {
                            const dx = e.x - this.x;
                            const dy = e.y - this.y;
                            const dist = Math.sqrt(dx*dx + dy*dy);
                            
                            if (dist < burstRadius && dist > 0) {
                                const strength = (burstRadius - dist) / burstRadius;
                                const pushForce = burstPower * strength;
                                e.pushX = (dx/dist) * pushForce;
                                e.pushY = (dy/dist) * pushForce;
                            }
                        });
                        
                        // Visual feedback for shield burst
                        entities.particles.push(new Shockwave(this.x, this.y, burstRadius, 'rgba(0, 229, 255, 0.4)'));
                        createExplosion(this.x, this.y, '#88d8ff', 15);
                    }
                }
                
                // SECOND CHANCE MOD: Survive fatal damage
                if (this.hp <= 0 && this.activeMod === 'revive') {
                    if (!this.reviveCooldown) this.reviveCooldown = 0;
                    
                    if (this.reviveCooldown <= 0) {
                        // REVIVE!
                        this.hp = this.maxHp * 0.5; // Restore to 50% HP
                        this.reviveCooldown = 7200; // 2 minute cooldown (60 fps * 120 seconds)
                        this.invulnTimer = 120; // 2 seconds invulnerability
                        
                        // Visual feedback
                        createExplosion(this.x, this.y, '#00ff00', 40);
                        entities.particles.push(new Shockwave(this.x, this.y, 150, '#00ff00'));
                        
                        // Screen flash
                        const flash = document.getElementById('damage-flash');
                        flash.style.background = 'rgba(0, 255, 0, 0.5)';
                        flash.style.opacity = 0.8;
                        setTimeout(() => {
                            flash.style.background = 'rgba(255, 0, 0, 0.5)';
                            flash.style.opacity = 0;
                        }, 200);
                        
                        return; // Don't die!
                    }
                }
                
                if(this.hp <= 0) gameOver();
            }



            update(dt) {
                // Reset volt chain counter each frame for performance
                this.voltChainsThisFrame = 0;
                
                if (this.invulnTimer > 0) this.invulnTimer -= dt/16;
                
                // SHIELD RECHARGE SYSTEM
                // Once a shield STARTS charging (timer <= 0), it NEVER stops until 100%
                // Only ONE shield can be charging at a time
                // Priority when both depleted: Left (shield1) charges first
                
                // Determine which shield is actively charging
                const shield1Charging = this.shield1 < 100 && this.shield1RechargeTimer <= 0;
                const shield2Charging = this.shield2 < 100 && this.shield2RechargeTimer <= 0;
                
                // Shield 1 recharge (LEFT)
                if (shield1Charging) {
                    // Actively charging - NEVER STOPS
                    this.shield1 += this.shieldRechargeRate * (dt/16) / 60; // 20% per second
                    if (this.shield1 >= 100) {
                        this.shield1 = 100;
                        // Shield 1 finished - if shield 2 needs charging, start its timer
                        if (this.shield2 < 100 && this.shield2RechargeTimer > 0) {
                            this.shield2RechargeTimer = this.shieldRechargeDelay; // Reset to 5 sec delay
                        }
                    }
                } else if (this.shield1 < 100 && this.shield1RechargeTimer > 0 && !shield2Charging) {
                    // Waiting to start charging (only count down if no other shield is charging)
                    this.shield1RechargeTimer -= dt/16;
                }
                
                // Shield 2 recharge (RIGHT) - only if shield 1 is NOT charging
                if (shield2Charging && !shield1Charging) {
                    // Actively charging - NEVER STOPS
                    this.shield2 += this.shieldRechargeRate * (dt/16) / 60; // 20% per second
                    if (this.shield2 >= 100) {
                        this.shield2 = 100;
                        // Shield 2 finished - if shield 1 needs charging, start its timer
                        if (this.shield1 < 100 && this.shield1RechargeTimer > 0) {
                            this.shield1RechargeTimer = this.shieldRechargeDelay; // Reset to 5 sec delay
                        }
                    }
                } else if (this.shield2 < 100 && this.shield2RechargeTimer > 0 && !shield1Charging && !shield2Charging) {
                    // Waiting to start charging (only count down if no shield is charging)
                    this.shield2RechargeTimer -= dt/16;
                }
                
                if (this.regen > 0) {
                    this.regenTimer -= dt/16; // Properly affected by time dilation
                    if (this.regenTimer <= 0) { this.heal(this.regen, false); this.regenTimer = 60; } // Ticks every 1 second
                }
                
                // PASSIVE MOD EFFECTS
                if (this.activeMod === 'repulsor') {
                    // Repulsor Field: Passive constant push on drones and swarms
                    entities.enemies.forEach(e => {
                        if ((e.type === 'drone' || e.type === 'swarm') && !e.hackState.active) {
                            const dx = e.x - this.x;
                            const dy = e.y - this.y;
                            const dist = Math.sqrt(dx*dx + dy*dy);
                            if (dist < 150 && dist > 0) { // Increased from 120
                                const pushStrength = (150 - dist) / 150;
                                const pushForce = 0.35 * pushStrength; // Increased from 0.15 - much stronger
                                e.pushX += (dx/dist) * pushForce;
                                e.pushY += (dy/dist) * pushForce;
                            }
                        }
                    });
                }
                
                if (this.activeMod === 'chrono') {
                    // Chrono Shield: Slow time for 10s when HP drops below 30%, 60s cooldown
                    if (!this.chronoCooldown) this.chronoCooldown = 0;
                    
                    const hpPercent = this.hp / this.maxHp;
                    
                    // Trigger if below 30% HP and cooldown ready
                    if (hpPercent < 0.3 && !this.chronoActive && this.chronoCooldown <= 0) {
                        this.chronoActive = true;
                        this.chronoDuration = 600; // 10 seconds (60 fps * 10)
                    }
                    
                    // Handle active duration
                    if (this.chronoActive) {
                        this.chronoDuration -= dt/16;
                        if (this.chronoDuration <= 0) {
                            this.chronoActive = false;
                            this.chronoCooldown = 3600; // 60 second cooldown starts NOW (60 fps * 60)
                        }
                    } else {
                        // Count down cooldown only when NOT active
                        if (this.chronoCooldown > 0) {
                            this.chronoCooldown -= dt/16;
                        }
                    }
                }
                
                if (this.activeMod === 'revive') {
                    // Second Chance: Count down cooldown
                    if (!this.reviveCooldown) this.reviveCooldown = 0;
                    if (this.reviveCooldown > 0) {
                        this.reviveCooldown -= dt/16;
                    }
                }

                // Calculate effective speed (apply ship multiplier)
                const effectiveSpeed = this.speed * this.shipSpeedMult;

                if (input.active) {
                    this.x += input.vector.x * effectiveSpeed * (dt/16);
                    this.y += input.vector.y * effectiveSpeed * (dt/16);
                    this.angle = Math.atan2(input.vector.y, input.vector.x);
                    if (state.frameCount % 5 === 0) {
                        const backAngle = this.angle + Math.PI;
                        entities.particles.push(new Particle(this.x + Math.cos(backAngle)*15, this.y + Math.sin(backAngle)*15, '#00d1b2', 0.8));
                    }
                }
                if(Number.isNaN(this.x)) this.x = 0; 
                if(Number.isNaN(this.y)) this.y = 0;


                // ION
                if (this.weapons.ion > 0) this.cannonAngle += 0.02 * (dt/16);
                const cannonCount = Math.min(4, Math.max(1, this.weapons.ion));
                if (this.cannons.length !== cannonCount) this.cannons = Array(cannonCount).fill(0).map((_, i) => ({ recoil: 0 }));
                this.cannons.forEach(c => { c.recoil *= 0.8; });
                
                if(this.weapons.ion > 0) {
                    this.lastShot -= dt;
                    if (this.lastShot <= 0) {
                        // Each cannon fires in sequence with independent targeting
                        const cIdx = this.fireIndex % cannonCount;
                        const formationRadius = 24;
                        const offsetAngle = this.cannonAngle + (cIdx * (Math.PI*2/cannonCount));
                        const cannonX = this.x + Math.cos(offsetAngle) * formationRadius;
                        const cannonY = this.y + Math.sin(offsetAngle) * formationRadius;
                        
                        // Find closest enemy to THIS cannon's position
                        let target = null;
                        let minDist = this.range * this.weaponStats.ion.area;
                        entities.enemies.forEach(e => {
                            if (e.hp <= 0) return;
                            const dx = e.x - cannonX;
                            const dy = e.y - cannonY;
                            const dist = Math.sqrt(dx*dx + dy*dy);
                            if (dist < minDist) {
                                minDist = dist;
                                target = e;
                            }
                        });
                        
                        if (target) {
                            const shootFn = (tgt, cascadeBonus = 1.0) => {
                                const c = this.cannons[cIdx];
                                const formationRadius = 24;
                                const offsetAngle = this.cannonAngle + (cIdx * (Math.PI*2/cannonCount));
                                const cx = this.x + Math.cos(offsetAngle) * formationRadius;
                                const cy = this.y + Math.sin(offsetAngle) * formationRadius;
                                
                                const angle = Math.atan2(tgt.y - cy, tgt.x - cx);
                                c.recoil = 8;
                                entities.particles.push(new MuzzleFlash(cx + Math.cos(angle)*10, cy + Math.sin(angle)*10));
                                
                                // Damage falloff per cannon: 4 cannons total max
                                // 1 cannon = 100%, 2 = 65%, 3 = 55%, 4 = 50%
                                // Total DPS: 1x, 1.3x, 1.65x, 2.0x
                                const cannonPenalty = cannonCount === 1 ? 1.0 : 
                                                      cannonCount === 2 ? 0.65 : 
                                                      cannonCount === 3 ? 0.55 : 0.50;
                                
                                const dmg = this.damage * this.weaponStats.ion.dmg * cannonPenalty * cascadeBonus;
                                entities.projectiles.push(new Projectile(cx, cy, Math.cos(angle) * this.projectileSpeed, Math.sin(angle) * this.projectileSpeed, dmg, this.pierce, 'ion', null, 'ion'));
                            };
                            
                            const shootWithMulti = (dmgMult = 1.0, depth = 0) => {
                                shootFn(target, dmgMult); // Use the target found for THIS cannon
                                checkMultistrike(shootWithMulti, 1.25, depth);
                            };
                            
                            shootWithMulti();
                            
                            // Cooldown divided by cannon count - creates sequential rapid fire
                            const rate = this.fireRate / (this.weaponStats.ion.rate * Math.min(4, Math.max(1, this.weapons.ion)));
                            this.lastShot = rate;
                            this.fireIndex++;
                        }
                    }
                }


                // TESLA - FORKING CHAIN LIGHTNING
                if (this.weapons.tesla > 0) {
                    this.teslaTimer -= dt/16;
                    if (this.teslaTimer <= 0) {
                        // Number of bolts: 1 at level 1-2, 2 at level 3-5, 3 at level 6+
                        const numBolts = this.weapons.tesla >= 6 ? 3 : this.weapons.tesla >= 3 ? 2 : 1;
                        
                        const fireTesla = (depth = 0, cascadeDmg = null) => {
                            const range = (250 + (this.weapons.tesla * 25)) * this.weaponStats.tesla.area;
                            const baseDmg = this.damage * 2.5 * this.weaponStats.tesla.dmg;
                            const dmg = cascadeDmg || baseDmg; // Use cascade damage if provided
                            
                            // Recursive forking chain function
                            const chainFork = (source, sourceX, sourceY, hitEnemies, currentDepth, damageMult) => {
                                if (currentDepth >= 3) return; // Max 3 chain depths for 1>2>4 pattern
                                
                                // Find candidates within chain range that haven't been hit
                                // Base 80, scales significantly with area upgrades
                                const chainRange = 80 * this.weaponStats.tesla.area;
                                const candidates = entities.enemies.filter(e => 
                                    !hitEnemies.has(e) && 
                                    e.hp > 0 &&
                                    Math.sqrt((e.x - sourceX)**2 + (e.y - sourceY)**2) < chainRange
                                );
                                
                                // Chains jump to RANDOM enemies within range (not nearest!)
                                // Shuffle candidates
                                for (let i = candidates.length - 1; i > 0; i--) {
                                    const j = Math.floor(seededRandom() * (i + 1));
                                    [candidates[i], candidates[j]] = [candidates[j], candidates[i]];
                                }
                                
                                // Fork to 2 enemies (creates 1>2>4 pattern)
                                const forkCount = Math.min(2, candidates.length);
                                for (let i = 0; i < forkCount; i++) {
                                    const target = candidates[i];
                                    hitEnemies.add(target);
                                    
                                    // Damage decreases: 100% -> 80% -> 64%
                                    const newDamageMult = damageMult * 0.8;
                                    this.dealElementalDamage(target, dmg * newDamageMult, 'tesla', '#ffffff');
                                    entities.lightnings.push(new LightningBolt(sourceX, sourceY, target.x, target.y));
                                    
                                    // Recursively chain from this target
                                    setTimeout(() => {
                                        chainFork(target, target.x, target.y, hitEnemies, currentDepth + 1, newDamageMult);
                                    }, 50); // Small delay for visual effect
                                }
                            };
                            
                            // Fire multiple bolts - each gets its own chain
                            const usedEnemies = new Set(); // Track enemies hit across all bolts
                            
                            for (let boltIdx = 0; boltIdx < numBolts; boltIdx++) {
                                // Find CLOSEST enemy within range (exclude already targeted) - ONLY for initial hit
                                const candidates = entities.enemies.filter(e => 
                                    !usedEnemies.has(e) && 
                                    e.hp > 0 &&
                                    Math.sqrt((e.x - this.x)**2 + (e.y - this.y)**2) < range
                                );
                                
                                // Sort by distance and pick closest (ONLY for initial target)
                                candidates.sort((a, b) => {
                                    const distA = Math.sqrt((a.x - this.x)**2 + (a.y - this.y)**2);
                                    const distB = Math.sqrt((b.x - this.x)**2 + (b.y - this.y)**2);
                                    return distA - distB;
                                });
                                
                                const initial = candidates[0];
                                
                                if(initial) {
                                    usedEnemies.add(initial);
                                    const hitEnemies = new Set([initial]);
                                    
                                    // Stagger bolt firing with 500ms delay between each
                                    setTimeout(() => {
                                        this.dealElementalDamage(initial, dmg, 'tesla', '#ffffff');
                                        entities.lightnings.push(new LightningBolt(this.x, this.y, initial.x, initial.y));
                                        
                                        // Start forking chains after 50ms
                                        setTimeout(() => {
                                            chainFork(initial, initial.x, initial.y, hitEnemies, 0, 1.0);
                                        }, 50);
                                    }, boltIdx * 500); // 500ms between bolts (was 30ms)
                                }
                            }
                        };
                        
                        const fireTeslaWithMulti = (dmgMult = 1.0, depth = 0) => {
                            const baseDmg = this.damage * 2.5 * this.weaponStats.tesla.dmg;
                            fireTesla(depth, baseDmg * dmgMult);
                            checkMultistrike(fireTeslaWithMulti, 1.25, depth);
                        };
                        
                        fireTeslaWithMulti();
                        this.maxTeslaTimer = Math.max(40, 180 / this.weaponStats.tesla.rate); // Increased from 150 (20% longer cooldown)
                        this.teslaTimer = this.maxTeslaTimer;
                    }
                }


                // RAD
                if (this.weapons.rad > 0) {
                    const radius = (60 + (this.weapons.rad * 15)) * this.weaponStats.rad.area;
                    const baseDotDmg = (this.damage * 0.08 * this.weaponStats.rad.dmg) * (dt/16); // Reduced from 0.15 back to 0.08 (more balanced)
                    
                    // Tick counter that respects time dilation
                    if (!this.radTickCounter) this.radTickCounter = 0;
                    this.radTickCounter += dt/16;
                    
                    if(this.radTickCounter >= 20) {
                        this.radTickCounter -= 20;
                         for(let e of entities.enemies) {
                            const distSq = (e.x-this.x)**2 + (e.y-this.y)**2;
                            if (distSq < radius*radius) {
                                // Distance-based damage multiplier: 1.5x at center, 0.75x at edge (less extreme)
                                const dist = Math.sqrt(distSq);
                                const distanceRatio = 1 - (dist / radius); // 1.0 at center, 0.0 at edge
                                const damageMultiplier = 0.75 + (distanceRatio * 0.75); // 1.5x at center, 0.75x at edge
                                const tickDmg = baseDotDmg * 20 * damageMultiplier;
                                this.dealElementalDamage(e, tickDmg, 'rad', '#ffffff', false); 
                            }
                        }
                    }
                }


                // SEEKER
                if (this.weapons.seeker > 0) {
                    this.seekerTimer -= dt/16;
                    if (this.seekerTimer <= 0) {
                        const fireSeeker = (dmgMult = 1.0, depth = 0) => {
                            const count = Math.min(4, this.weapons.seeker); // Cap at 4 missiles instead of 5
                            
                            // Target ANY visible enemies on screen - no distance limit
                            const visibleEnemies = entities.enemies.filter(e => e.hp > 0);
                            
                            if (visibleEnemies.length === 0) return false; // Return false = didn't fire
                            
                            // PRIORITY TARGETING: Champions > Clusters
                            let bestTarget;
                            let clusterEnemies;
                            
                            // Check for champions first
                            const champions = visibleEnemies.filter(e => e.isChampion);
                            if (champions.length > 0) {
                                // Target champion(s)
                                bestTarget = champions[0];
                                clusterEnemies = champions;
                            } else if (visibleEnemies.length === 1) {
                                // Simple case: only one enemy (like a boss) - target it directly
                                bestTarget = visibleEnemies[0];
                                clusterEnemies = [bestTarget];
                            } else {
                                // Find cluster (densest area)
                                bestTarget = null;
                                let bestDensity = 0;
                                
                                for (let e of visibleEnemies) {
                                    const nearby = visibleEnemies.filter(e2 => {
                                        const dist = Math.sqrt((e.x - e2.x)**2 + (e.y - e2.y)**2);
                                        return dist < 150; // Cluster radius
                                    }).length;
                                    
                                    if (nearby >= bestDensity) {
                                        bestDensity = nearby;
                                        bestTarget = e;
                                    }
                                }
                                
                                if (!bestTarget) bestTarget = visibleEnemies[0];
                                
                                // Get enemies near the cluster center for targeting
                                clusterEnemies = visibleEnemies.filter(e => {
                                    const dist = Math.sqrt((e.x - bestTarget.x)**2 + (e.y - bestTarget.y)**2);
                                    return dist < 200;
                                });
                                
                                // Ensure we always have at least the best target
                                if (clusterEnemies.length === 0) {
                                    clusterEnemies = [bestTarget];
                                }
                            }
                            
                            const targets = clusterEnemies.slice(0, count + 2);
                            const dmg = this.damage * 3.0 * this.weaponStats.seeker.dmg * dmgMult; // Nerfed from 3.5x
                            
                            for(let i=0; i<count; i++) {
                                const target = targets[i % targets.length] || null;
                                const spread = (Math.PI/6) * (i - (count-1)/2) * 0.5; 
                                const fireAngle = this.angle + spread;
                                const vx = Math.cos(fireAngle) * 8; 
                                const vy = Math.sin(fireAngle) * 8;
                                entities.projectiles.push(new Projectile(
                                    this.x + Math.cos(this.angle)*20, 
                                    this.y + Math.sin(this.angle)*20, 
                                    vx, vy, dmg, 0, 'seeker', target, 'seeker'
                                ));
                            }
                            
                            // Check for multistrike with decay
                            checkMultistrike(fireSeeker, 1.25, depth);
                            
                            return true; // Return true = successfully fired
                        };
                        
                        const didFire = fireSeeker();
                        
                        // Only reset timer if we actually fired
                        if (didFire) {
                            this.maxSeekerTimer = 110 / this.weaponStats.seeker.rate;
                            this.seekerTimer = this.maxSeekerTimer;
                        } else {
                            // Didn't fire - try again sooner
                            this.seekerTimer = 10; // Try again in 10 frames
                        }
                    }
                }



                // PLASMA WHIP - Wide arc slash in front of player
                if (this.weapons.whip > 0) {
                    this.whipTimer -= dt/16;
                    if (this.whipTimer <= 0) {
                        const range = (100 + (this.weapons.whip * 5)) * this.weaponStats.whip.area; // Much slower scaling: 5 per level
                        const dmg = this.damage * 2.5 * this.weaponStats.whip.dmg; // High damage for cooldown weapon
                        const arcAngle = Math.PI * 2; // Full 360 degrees
                        
                        const fireWhip = (damageBonus = 1.0) => {
                            const centerAngle = this.angle;
                            const startAngle = centerAngle - arcAngle / 2;
                            const finalDmg = dmg * damageBonus;
                            
                            // Plasma whip has 2x crit chance multiplier and +25% crit damage
                            const originalCrit = this.critChance;
                            const originalCritMult = this.critMult;
                            this.critChance *= 2;
                            this.critMult *= 1.25; // +25% crit damage
                            
                            // PROJECTILE DEFLECTION: Check for enemy projectiles in whip arc
                            entities.enemyProjectiles.forEach(proj => {
                                const dist = Math.sqrt((proj.x - this.x)**2 + (proj.y - this.y)**2);
                                if (dist < range && !proj.deflected) {
                                    const angleToProj = Math.atan2(proj.y - this.y, proj.x - this.x);
                                    let angleDiff = angleToProj - centerAngle;
                                    while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                                    while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
                                    
                                    if (Math.abs(angleDiff) <= arcAngle / 2) {
                                        // Store the original shooter as the target
                                        const originEnemy = entities.enemies.find(e => e === proj.shooter);
                                        let targetEnemy = originEnemy;
                                        
                                        if (originEnemy && originEnemy.hp > 0) {
                                            // Origin enemy is alive, target them
                                            const angle = Math.atan2(originEnemy.y - proj.y, originEnemy.x - proj.x);
                                            proj.vx = Math.cos(angle) * 12;
                                            proj.vy = Math.sin(angle) * 12;
                                        } else {
                                            // If origin enemy is dead or not found, find nearest enemy
                                            let nearestEnemy = null;
                                            let minDist = Infinity;
                                            entities.enemies.forEach(e => {
                                                if (e.hp > 0) {
                                                    const d = Math.sqrt((e.x - proj.x)**2 + (e.y - proj.y)**2);
                                                    if (d < minDist) {
                                                        minDist = d;
                                                        nearestEnemy = e;
                                                    }
                                                }
                                            });
                                            if (nearestEnemy) {
                                                targetEnemy = nearestEnemy;
                                                const angle = Math.atan2(nearestEnemy.y - proj.y, nearestEnemy.x - proj.x);
                                                proj.vx = Math.cos(angle) * 12;
                                                proj.vy = Math.sin(angle) * 12;
                                            }
                                        }
                                        
                                        proj.deflected = true; // Mark as deflected
                                        proj.originEnemy = targetEnemy; // Track target for homing (always set to valid enemy)
                                        proj.deflectedDamage = finalDmg; // Full whip damage
                                        proj.color = '#ff00ff'; // Change to plasma whip purple
                                        proj.hitEnemies = []; // Track hit enemies to avoid double-hitting
                                        
                                        // Visual feedback
                                        createExplosion(proj.x, proj.y, '#ff00ff', 15);
                                    }
                                }
                            });
                            
                            // Hit all enemies in arc
                            entities.enemies.forEach(e => {
                                if (e.hp > 0) {
                                    const dist = Math.sqrt((e.x - this.x)**2 + (e.y - this.y)**2);
                                    if (dist < range) {
                                        const angleToEnemy = Math.atan2(e.y - this.y, e.x - this.x);
                                        let angleDiff = angleToEnemy - centerAngle;
                                        while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                                        while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
                                        
                                        if (Math.abs(angleDiff) <= arcAngle / 2) {
                                            this.dealElementalDamage(e, finalDmg, 'whip', '#ff00ff');
                                        }
                                    }
                                }
                            });
                            
                            // Restore original crit stats
                            this.critChance = originalCrit;
                            this.critMult = originalCritMult;
                            
                            // VISUAL: Energy whip arc - create bright visible slash
                            const numParticles = 30; // More particles
                            for (let i = 0; i <= numParticles; i++) {
                                const angle = startAngle + (arcAngle * i / numParticles);
                                
                                // Create particles at multiple distances for thickness
                                for (let d = 0.5; d <= 1.0; d += 0.25) {
                                    const dist = range * d;
                                    const px = this.x + Math.cos(angle) * dist;
                                    const py = this.y + Math.sin(angle) * dist;
                                    
                                    entities.particles.push({
                                        x: px, y: py,
                                        vx: Math.cos(angle) * 4,
                                        vy: Math.sin(angle) * 4,
                                        color: '#ff00ff', 
                                        life: 20, 
                                        size: 8,
                                        update: function(dt) {
                                            this.x += this.vx * (dt/16);
                                            this.y += this.vy * (dt/16);
                                            this.life -= dt/16;
                                            this.vx *= 0.90;
                                            this.vy *= 0.90;
                                            this.size *= 0.97;
                                            return this.life > 0;
                                        },
                                        draw: function(ctx) {
                                            ctx.fillStyle = this.color;
                                            ctx.shadowBlur = 15;
                                            ctx.shadowColor = this.color;
                                            ctx.beginPath();
                                            ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                                            ctx.fill();
                                            ctx.shadowBlur = 0;
                                        }
                                    });
                                }
                            }
                        };
                        
                        const fireWhipWithMulti = (dmgMult = 1.0, depth = 0) => {
                            fireWhip(dmgMult);
                            checkMultistrike(fireWhipWithMulti, 1.25, depth);
                        };
                        
                        fireWhipWithMulti();
                        this.whipTimer = Math.max(40, 120 / this.weaponStats.whip.rate);
                        
                // Set visual timer for drawing
                        this.whipVisualTimer = 30; // Show for 30 frames (0.5 seconds) - was 15
                        this.whipVisualAngle = this.angle;
                    }
                }


                // METEOR SHOWER (5 meteors in cluster)
                if (this.weapons.meteor > 0) {
                    this.meteorTimer -= dt/16;
                    if (this.meteorTimer <= 0) {
                        const fireMeteorShower = (damageBonus = 1.0) => {
                            // Filter enemies closer to center of screen (within 60% of visible area)
                            const visibleEnemies = entities.enemies.filter(e => {
                                 return Math.abs(e.x - this.x) < width/state.zoom/2.5 && Math.abs(e.y - this.y) < height/state.zoom/2.5;
                            });
                            
                            // Find best cluster: enemy with most nearby allies
                            let bestTarget = null;
                            let maxNearby = 0;
                            
                            visibleEnemies.forEach(e => {
                                let nearbyCount = 0;
                                visibleEnemies.forEach(other => {
                                    if (other !== e) {
                                        const dist = Math.sqrt((e.x - other.x)**2 + (e.y - other.y)**2);
                                        if (dist < 150) nearbyCount++; // Count enemies within 150 units
                                    }
                                });
                                if (nearbyCount > maxNearby) {
                                    maxNearby = nearbyCount;
                                    bestTarget = e;
                                }
                            });
                            
                            // Use clustered target if found, otherwise pick random from visible, fallback to near player
                            let centerX, centerY;
                            if (bestTarget) {
                                centerX = bestTarget.x;
                                centerY = bestTarget.y;
                            } else if (visibleEnemies.length > 0) {
                                const target = visibleEnemies[Math.floor(seededRandom() * visibleEnemies.length)];
                                centerX = target.x;
                                centerY = target.y;
                            } else {
                                // Fallback: near player but not too far
                                centerX = this.x + (seededRandom()-0.5) * 150;
                                centerY = this.y + (seededRandom()-0.5) * 150;
                            }
                            
                            const rad = (30 + (this.weapons.meteor * 8)) * this.weaponStats.meteor.area; // Reduced base: 40→30
                            const baseDmg = 30 + (this.weapons.meteor * 15); // Level scaling: 45, 60, 75, 90, 105
                            const dmg = baseDmg * this.weaponStats.meteor.dmg * damageBonus; // Apply cascade bonus
                            const clusterSpread = 80; // Meteors land within 80 units of center
                            
                            // Fire 5 meteors in cluster with increased delays
                            for (let i = 0; i < 5; i++) {
                                setTimeout(() => {
                                    const offsetX = (seededRandom() - 0.5) * clusterSpread;
                                    const offsetY = (seededRandom() - 0.5) * clusterSpread;
                                    const tx = centerX + offsetX;
                                    const ty = centerY + offsetY;
                                    
                                    entities.projectiles.push(new Projectile(
                                        tx, ty, 0, 0, dmg, 999, 'meteor_warning', { radius: rad }, 'meteor'
                                    ));
                                }, i * 120); // Increased delay: 80ms → 120ms
                            }
                        };
                        
                        const fireMeteorWithMulti = (dmgMult = 1.0, depth = 0) => {
                            fireMeteorShower(dmgMult);
                            checkMultistrike(fireMeteorWithMulti, 1.25, depth);
                        };
                        
                        fireMeteorWithMulti();
                        this.maxMeteorTimer = Math.max(120, 300 / this.weaponStats.meteor.rate); 
                        this.meteorTimer = this.maxMeteorTimer;
                    }
                }


                // RAILGUN
                if (this.weapons.railgun > 0) {
                    this.railgunTimer -= dt/16;
                    if (this.railgunTimer <= 0) {
                        const fireRailgun = (damageBonus = 1.0, depth = 0) => {
                            // Find dense enemy clusters to target
                            const visibleRadius = Math.min(canvas.width, canvas.height) * 0.4;
                            const maxSearchRadius = 500; // Railgun has longer range
                            
                            // Find enemies in visible range
                            const visibleEnemies = entities.enemies.filter(e => {
                                const dist = Math.sqrt((e.x - this.x)**2 + (e.y - this.y)**2);
                                return dist < visibleRadius && e.hp > 0;
                            });
                            
                            let targetPool = visibleEnemies.length > 0 ? visibleEnemies : entities.enemies.filter(e => {
                                const dist = Math.sqrt((e.x - this.x)**2 + (e.y - this.y)**2);
                                return dist < maxSearchRadius && e.hp > 0;
                            });
                            
                            if (targetPool.length === 0) return; // No targets
                            
                            // Find cluster (densest area)
                            let bestTarget = null;
                            let bestDensity = 0;
                            
                            for (let e of targetPool) {
                                const nearby = targetPool.filter(e2 => {
                                    const dist = Math.sqrt((e.x - e2.x)**2 + (e.y - e2.y)**2);
                                    return dist < 200; // Cluster radius
                                }).length;
                                
                                if (nearby > bestDensity) {
                                    bestDensity = nearby;
                                    bestTarget = e;
                                }
                            }
                            
                            if (!bestTarget) bestTarget = targetPool[0];
                            
                            const angle = Math.atan2(bestTarget.y - this.y, bestTarget.x - this.x);
                            const vx = Math.cos(angle); 
                            const vy = Math.sin(angle);
                            const dmg = 150 * this.weaponStats.railgun.dmg * damageBonus; // Increased from 100 - devastating single shot
                            entities.projectiles.push(new Projectile(
                                this.x, this.y, vx, vy, dmg, 999, 'railgun', { level: this.weapons.railgun }, 'railgun'
                            ));
                            entities.particles.push(new MuzzleFlash(this.x + vx*20, this.y + vy*20));
                            
                            // Check for multistrike with depth parameter
                            checkMultistrike(fireRailgun, 1.25, depth);
                        };
                        fireRailgun();

                        const rateMod = (400 / this.fireRate); 
                        this.maxRailgunTimer = (203 / this.weaponStats.railgun.rate) * rateMod; // Reduced from 270 (25% faster)
                        this.railgunTimer = this.maxRailgunTimer;
                    }
                }


                // FLAK CANNON
                if (this.weapons.flak > 0) {
                    this.flakTimer -= dt/16;
                    if (this.flakTimer <= 0) {
                        // Find dense enemy clusters to target
                        const visibleRadius = Math.min(canvas.width, canvas.height) * 0.4;
                        const maxSearchRadius = 450;
                        
                        // Find enemies in visible range
                        const visibleEnemies = entities.enemies.filter(e => {
                            const dist = Math.sqrt((e.x - this.x)**2 + (e.y - this.y)**2);
                            return dist < visibleRadius && e.hp > 0;
                        });
                        
                        let targetPool = visibleEnemies.length > 0 ? visibleEnemies : entities.enemies.filter(e => {
                            const dist = Math.sqrt((e.x - this.x)**2 + (e.y - this.y)**2);
                            return dist < maxSearchRadius && e.hp > 0;
                        });
                        
                        // Find cluster (densest area)
                        let bestTarget = null;
                        let bestDensity = 0;
                        
                        if (targetPool.length > 0) {
                            for (let e of targetPool) {
                                const nearby = targetPool.filter(e2 => {
                                    const dist = Math.sqrt((e.x - e2.x)**2 + (e.y - e2.y)**2);
                                    return dist < 200; // Cluster radius
                                }).length;
                                
                                if (nearby > bestDensity) {
                                    bestDensity = nearby;
                                    bestTarget = e;
                                }
                            }
                            
                            if (!bestTarget) bestTarget = targetPool[0];
                        }
                        
                        let baseAngle = this.angle;
                        if (bestTarget) {
                            baseAngle = Math.atan2(bestTarget.y - this.y, bestTarget.x - this.x);
                        }

                        const fireFlak = (dmgMult = 1.0, depth = 0) => {
                            // Fire 3 pellets in a spread pattern
                            const pelletCount = 3;
                            const spreadAngle = Math.PI / 12; // 15 degrees spread
                            
                            for (let i = 0; i < pelletCount; i++) {
                                const angleOffset = (i - 1) * spreadAngle; // -15°, 0°, +15°
                                const angle = baseAngle + angleOffset;
                                const vx = Math.cos(angle) * 10;
                                const vy = Math.sin(angle) * 10;
                                
                                // Base damage: 30, scales 30% per level
                                const dmg = 30 * this.weaponStats.flak.dmg * dmgMult;
                                entities.projectiles.push(new Projectile(
                                    this.x, this.y, vx, vy, dmg, 0, 'flak_shell', { range: 300, level: this.weapons.flak }, 'flak'
                                ));
                                entities.particles.push(new MuzzleFlash(this.x + vx, this.y + vy));
                            }
                            
                            checkMultistrike(fireFlak, 1.25, depth);
                        };
                        fireFlak();
                        
                        this.maxFlakTimer = Math.max(100, 166 / this.weaponStats.flak.rate); // Reduced from 200 (17% faster)
                        this.flakTimer = this.maxFlakTimer;
                    }
                }


                // PLASMA BEAM
                if (this.weapons.beam > 0) {
                    if (this.beamActive) {
                        this.beamTimer -= dt;
                        if (this.beamTimer <= 0) { 
                            this.beamActive = false; 
                            this.beamCooldown = 3000 / this.weaponStats.beam.rate; 
                            this.beamTargets = [];
                            this.beamRampMap.clear(); // Reset ramp when beam ends
                        } 
                        else {
                            // Tick counter that respects time dilation
                            if (!this.beamTickCounter) this.beamTickCounter = 0;
                            this.beamTickCounter += dt/16; // Use scaled dt
                            
                            if (this.beamTickCounter >= 20) {
                                this.beamTickCounter -= 20;
                                
                                const maxTargets = Math.min(3, this.weapons.beam);
                                const possibleTargets = entities.enemies.filter(e => Math.sqrt((e.x-this.x)**2 + (e.y-this.y)**2) < (300 + this.weapons.beam * 30) * this.weaponStats.beam.area);
                                possibleTargets.sort((a,b) => {
                                    const da = Math.sqrt((a.x-this.x)**2 + (a.y-this.y)**2);
                                    const db = Math.sqrt((b.x-this.x)**2 + (b.y-this.y)**2);
                                    return da - db;
                                });
                                
                                const newTargets = possibleTargets.slice(0, maxTargets);
                                
                                // Clear ramp for enemies no longer targeted
                                const currentTargetIds = new Set(newTargets.map(t => t));
                                for (let [enemy, ramp] of this.beamRampMap.entries()) {
                                    if (!currentTargetIds.has(enemy)) {
                                        this.beamRampMap.delete(enemy);
                                    }
                                }
                                
                                this.beamTargets = newTargets;
                                const baseDmg = this.damage * 1.0 * this.weaponStats.beam.dmg; // Buffed from 0.5x to 1.0x

                                // Check if targeting a boss - if so, count number of beams hitting it
                                const bossTarget = this.beamTargets.find(t => t.type === 'boss');
                                const bossBeamCount = bossTarget ? this.beamTargets.filter(t => t === bossTarget).length : 0;
                                
                                this.beamTargets.forEach(t => {
                                    // Track damage ramp: increases from 0.75x to 2.0x over 3 seconds (180 frames)
                                    if (!this.beamRampMap.has(t)) {
                                        this.beamRampMap.set(t, 0);
                                    }
                                    let rampFrames = this.beamRampMap.get(t);
                                    rampFrames += 20; // Increment by tick interval
                                    this.beamRampMap.set(t, rampFrames);
                                    
                                    // Damage multiplier: 0.75x → 2.0x over 180 frames (linear ramp)
                                    const rampProgress = Math.min(rampFrames / 180, 1.0);
                                    const damageMultiplier = 0.75 + (rampProgress * 1.25); // 0.75x → 2.0x
                                    
                                    let finalDmg = baseDmg * damageMultiplier;
                                    
                                    // MULTI-BEAM BOSS BONUS: Each beam on the boss multiplies damage
                                    // All beams focus the boss = 2 beams = 2x damage, 3 beams = 3x damage
                                    if (t.type === 'boss' && bossBeamCount > 0) {
                                        const beamCountMultiplier = Math.min(maxTargets, this.weapons.beam); // Use actual beam count
                                        finalDmg *= beamCountMultiplier;
                                    }
                                    
                                    this.dealElementalDamage(t, finalDmg, 'beam', '#ffffff');
                                });
                            }
                        }
                    } else {
                        this.beamCooldown -= dt;
                        if (this.beamCooldown <= 0) { this.beamActive = true; this.beamTimer = 3000; this.beamTickCounter = 0; }
                    }
                }

                // ENERGY PYLONS
                if (this.weapons.pylons > 0) {
                    this.pylonTimer -= dt/16;
                    if (this.pylonTimer <= 0) {
                        // Place new pylon at current location
                        this.pylons.push({ x: this.x, y: this.y, life: 99999 });
                        
                        // Remove oldest if over max
                        const maxPylons = Math.min(6, 3 + Math.floor(this.weapons.pylons / 2));
                        while (this.pylons.length > maxPylons) {
                            this.pylons.shift();
                        }
                        
                        this.maxPylonTimer = Math.max(200, 300 / this.weaponStats.pylons.rate);
                        this.pylonTimer = this.maxPylonTimer;
                    }
                    
                    // Damage enemies crossing pylon lines
                    // Tick counter that respects time dilation
                    if (!this.pylonTickCounter) this.pylonTickCounter = 0;
                    this.pylonTickCounter += dt/16;
                    
                    if (this.pylonTickCounter >= 10 && this.pylons.length >= 2) {
                        this.pylonTickCounter -= 10;
                        
                        for (let i = 0; i < this.pylons.length - 1; i++) {
                            const p1 = this.pylons[i];
                            const p2 = this.pylons[i + 1];
                            
                            for (let e of entities.enemies) {
                                // Check if enemy is near the line segment
                                const dist = this.distanceToLineSegment(e.x, e.y, p1.x, p1.y, p2.x, p2.y);
                                if (dist < 18 * this.weaponStats.pylons.area) { // Base 18, balanced between old and new
                                    this.dealElementalDamage(e, this.damage * 0.5 * this.weaponStats.pylons.dmg, 'pylons', '#ff64ff', false);
                                }
                            }
                        }
                    }
                }

                // COLLAPSAR MINES - Launch toward enemy clusters
                if (this.weapons.mines > 0) {
                    this.minesTimer -= dt/16;
                    if (this.minesTimer <= 0) {
                        const mineCount = 1; // Always 1 mine for balance
                        
                        const deployMine = (dmgMult = 1.0, depth = 0) => {
                            // Find dense enemy clusters to target
                            const visibleRadius = Math.min(canvas.width, canvas.height) * 0.4;
                            const maxSearchRadius = 450; // Slightly longer range than gas
                            
                            // Find enemies in visible range
                            const visibleEnemies = entities.enemies.filter(e => {
                                const dist = Math.sqrt((e.x - this.x)**2 + (e.y - this.y)**2);
                                return dist < visibleRadius && e.hp > 0;
                            });
                            
                            let targetPool = visibleEnemies.length > 0 ? visibleEnemies : entities.enemies.filter(e => {
                                const dist = Math.sqrt((e.x - this.x)**2 + (e.y - this.y)**2);
                                return dist < maxSearchRadius && e.hp > 0;
                            });
                            
                            if (targetPool.length === 0) return; // No targets
                            
                            // Find cluster (densest area) - each mine targets independently
                            let bestTarget = null;
                            let bestDensity = 0;
                            
                            for (let e of targetPool) {
                                const nearby = targetPool.filter(e2 => {
                                    const dist = Math.sqrt((e.x - e2.x)**2 + (e.y - e2.y)**2);
                                    return dist < 200; // Cluster radius
                                }).length;
                                
                                if (nearby > bestDensity) {
                                    bestDensity = nearby;
                                    bestTarget = e;
                                }
                            }
                            
                            if (!bestTarget) bestTarget = targetPool[0];
                            
                            // Deploy mine
                            const baseAngle = Math.atan2(bestTarget.y - this.y, bestTarget.x - this.x);
                            const speed = 12;
                            const vx = Math.cos(baseAngle) * speed;
                            const vy = Math.sin(baseAngle) * speed;
                            
                            // Balanced damage - not too weak, not OP
                            const levelScaling = 1 + (this.weapons.mines * 0.15); // +15% per level
                            const baseDmg = this.damage * 3.0 * levelScaling * this.weaponStats.mines.dmg * dmgMult;
                            const detectionRadius = 60 + (this.weaponStats.mines.area * 10);
                            const blastRadius = 80 + (this.weaponStats.mines.area * 20);
                            
                            entities.projectiles.push(new Projectile(
                                this.x, this.y, vx, vy, baseDmg, blastRadius, 'mine', bestTarget, 'mines', detectionRadius
                            ));
                            
                            checkMultistrike(deployMine, 1.25, depth);
                        };
                        
                        deployMine();
                        
                        this.maxMinesTimer = Math.max(90, 180 / this.weaponStats.mines.rate); // 180 frames base (3 seconds)
                        this.minesTimer = this.maxMinesTimer;
                    }
                }

                // TOXIC BARRAGE - Smart-targeted line of overlapping gas clouds
                if (this.weapons.gas > 0) {
                    this.gasTimer -= dt/16;
                    if (this.gasTimer <= 0) {
                        const lobBarrage = (damageBonus = 1.0) => {
                            // Prioritize enemies within visible range, then find densest cluster
                            const visibleRadius = Math.min(canvas.width, canvas.height) * 0.4;
                            const maxSearchRadius = 400;
                            
                            const visibleEnemies = entities.enemies.filter(e => {
                                const dist = Math.sqrt((e.x - this.x)**2 + (e.y - this.y)**2);
                                return dist < visibleRadius;
                            });
                            
                            const searchPool = visibleEnemies.length > 0 ? visibleEnemies : entities.enemies;
                            const searchLimit = visibleEnemies.length > 0 ? visibleRadius : maxSearchRadius;
                            
                            let bestTarget = null;
                            let bestCount = 0;
                            
                            searchPool.forEach(e => {
                                const distToPlayer = Math.sqrt((e.x - this.x)**2 + (e.y - this.y)**2);
                                if (distToPlayer > searchLimit) return;
                                
                                const nearbyCount = entities.enemies.filter(ne => {
                                    const dist = Math.sqrt((ne.x - e.x)**2 + (ne.y - e.y)**2);
                                    return dist < 120;
                                }).length;
                                
                                if (nearbyCount > bestCount || (nearbyCount === bestCount && (!bestTarget || distToPlayer < Math.sqrt((bestTarget.x - this.x)**2 + (bestTarget.y - this.y)**2)))) {
                                    bestCount = nearbyCount;
                                    bestTarget = e;
                                }
                            });
                            
                            if (!bestTarget && visibleEnemies.length > 0) {
                                bestTarget = visibleEnemies[0];
                                let minDist = Math.sqrt((bestTarget.x - this.x)**2 + (bestTarget.y - this.y)**2);
                                visibleEnemies.forEach(e => {
                                    const dist = Math.sqrt((e.x - this.x)**2 + (e.y - this.y)**2);
                                    if (dist < minDist) {
                                        minDist = dist;
                                        bestTarget = e;
                                    }
                                });
                            }
                            
                            if (bestTarget) {
                                // Calculate line perpendicular to player-target vector
                                const toTargetAngle = Math.atan2(bestTarget.y - this.y, bestTarget.x - this.x);
                                const perpAngle = toTargetAngle + Math.PI / 2; // Perpendicular angle
                                
                                // Number of grenades: 3-5 based on weapon level
                                const numGrenades = Math.min(5, 3 + Math.floor(this.weapons.gas / 2));
                                
                                // Line length scales with weapon level and area
                                const lineLength = (180 + this.weapons.gas * 30) * this.weaponStats.gas.area;
                                
                                const cloudRadius = 65 + (this.weaponStats.gas.area * 15);
                                const tickDamage = this.damage * 1.0 * this.weaponStats.gas.dmg * damageBonus; // Apply cascade bonus
                                
                                // Launch grenades in staggered pattern along the line
                                for (let i = 0; i < numGrenades; i++) {
                                    // Position along perpendicular line through target
                                    const lineProgress = (i / (numGrenades - 1)) - 0.5; // -0.5 to +0.5
                                    const lineOffset = lineProgress * lineLength;
                                    
                                    // Add stagger offset (zigzag pattern for overlap)
                                    const staggerOffset = (i % 2 === 0 ? 1 : -1) * 25;
                                    
                                    // Target point on the line
                                    const targetX = bestTarget.x + Math.cos(perpAngle) * lineOffset + Math.cos(toTargetAngle) * staggerOffset;
                                    const targetY = bestTarget.y + Math.sin(perpAngle) * lineOffset + Math.sin(toTargetAngle) * staggerOffset;
                                    
                                    // Calculate trajectory to target point
                                    const angle = Math.atan2(targetY - this.y, targetX - this.x);
                                    const speed = 8;
                                    const vx = Math.cos(angle) * speed;
                                    const vy = Math.sin(angle) * speed;
                                    
                                    // Create virtual target for this grenade
                                    const grenadeTarget = { x: targetX, y: targetY, hp: 1 };
                                    
                                    // Stagger launch timing for visual effect
                                    const launchDelay = i * 50; // 50ms between each grenade
                                    
                                    setTimeout(() => {
                                        entities.projectiles.push(new Projectile(
                                            this.x, this.y, vx, vy, tickDamage, cloudRadius, 'gas_grenade', grenadeTarget, 'gas'
                                        ));
                                    }, launchDelay);
                                }
                            }
                        };
                        
                        const lobBarrageWithMulti = (dmgMult = 1.0, depth = 0) => {
                            lobBarrage(dmgMult);
                            checkMultistrike(lobBarrageWithMulti, 1.25, depth);
                        };
                        
                        lobBarrageWithMulti();
                        this.maxGasTimer = Math.max(180, 390 / this.weaponStats.gas.rate); // 390 frames base (6.5 seconds)
                        this.gasTimer = this.maxGasTimer;
                    }
                }

                // RICOCHET DISC - Bouncing projectile that chains between enemies
                if (this.weapons.ricochet > 0) {
                    this.ricochetTimer -= dt/16;
                    if (this.ricochetTimer <= 0) {
                        const fireRicochet = (damageBonus = 1.0) => {
                            // Disc count: 1/1/2/2/3 by level
                            const discCount = this.weapons.ricochet <= 2 ? 1 : this.weapons.ricochet <= 4 ? 2 : 3;
                            const maxBounces = Math.min(12, 5 + this.weapons.ricochet * 2); // Much higher: 7-12 bounces
                            // Damage per disc nerfed when multiple discs: 2.25 → 1.8 → 1.5
                            const dmgPerDisc = discCount === 1 ? 2.25 : discCount === 2 ? 1.8 : 1.5;
                            const baseDmg = this.damage * dmgPerDisc * this.weaponStats.ricochet.dmg * damageBonus;
                            const bounceRange = (600 + this.weapons.ricochet * 150) * this.weaponStats.ricochet.area; // MASSIVE: 750-1350 range!
                            
                            // Track which enemies are already targeted
                            const targetedEnemies = new Set();
                            
                            for (let discIdx = 0; discIdx < discCount; discIdx++) {
                                // Find different target for each disc
                                let bestTarget = null;
                                let bestScore = -Infinity;
                                const searchRange = 500;
                                
                                entities.enemies.forEach(e => {
                                    if (e.hp > 0 && !targetedEnemies.has(e)) {
                                        const dist = Math.sqrt((e.x - this.x)**2 + (e.y - this.y)**2);
                                        if (dist < searchRange) {
                                            // Score based on: distance (closer is better) + cluster density
                                            let nearbyCount = 0;
                                            entities.enemies.forEach(e2 => {
                                                if (e2.hp > 0 && e2 !== e) {
                                                    const d = Math.sqrt((e2.x - e.x)**2 + (e2.y - e.y)**2);
                                                    if (d < 200) nearbyCount++;
                                                }
                                            });
                                            
                                            const score = nearbyCount * 10 - (dist / 10); // Prioritize clusters, then proximity
                                            if (score > bestScore) {
                                                bestScore = score;
                                                bestTarget = e;
                                            }
                                        }
                                    }
                                });
                                
                                const initialTarget = bestTarget || this.getNearestEnemy(500);
                                if (!initialTarget) continue;
                                
                                targetedEnemies.add(initialTarget); // Mark as targeted
                                
                                // Spread discs in an arc pattern
                                const angle = Math.atan2(initialTarget.y - this.y, initialTarget.x - this.x);
                                const spreadAngle = (discIdx - (discCount - 1) / 2) * 0.4; // Wider spread
                                const vx = Math.cos(angle + spreadAngle) * 12;
                                const vy = Math.sin(angle + spreadAngle) * 12;
                                
                                const proj = new Projectile(
                                    this.x, this.y, vx, vy, baseDmg, 0, 'ricochet', 
                                    initialTarget,
                                    'ricochet'
                                );
                                
                                // Add bounce tracking to the projectile
                                proj.bounces = 0;
                                proj.maxBounces = maxBounces;
                                proj.bounceRange = bounceRange;
                                proj.hitEnemies = new Set();
                                
                                entities.projectiles.push(proj);
                            }
                        };
                        
                        const fireRicochetWithMulti = (dmgMult = 1.0, depth = 0) => {
                            fireRicochet(dmgMult);
                            checkMultistrike(fireRicochetWithMulti, 1.25, depth);
                        };
                        
                        fireRicochetWithMulti();
                        this.ricochetTimer = Math.max(60, 150 / this.weaponStats.ricochet.rate);
                    }
                }

                // COMBAT DRONES - Autonomous flying drones that hunt enemies
                if (this.weapons.drones > 0) {
                    const droneCount = Math.min(3, this.weapons.drones); // Max 3 drones
                    const droneDmg = this.damage * 0.85 * this.weaponStats.drones.dmg; // Further nerfed from 1.0 to 0.85
                    const droneRange = (250 + this.weapons.drones * 25) * this.weaponStats.drones.area; // 275-350 range
                    const droneSpeed = 8; // Faster movement - was 6
                    const fireRate = 28 / this.weaponStats.drones.rate; // Even faster fire rate - was 35
                    
                    // Initialize drones array if needed
                    if (!this.drones) {
                        this.drones = [];
                    }
                    
                    // Add new drones if weapon leveled up
                    while (this.drones.length < droneCount) {
                        const angle = (Math.PI * 2 / droneCount) * this.drones.length;
                        this.drones.push({
                            x: this.x + Math.cos(angle) * 80,
                            y: this.y + Math.sin(angle) * 80,
                            vx: 0,
                            vy: 0,
                            target: null,
                            fireTimer: seededRandom() * fireRate,
                            orbitAngle: angle,
                            shotsFired: 0 // Track for mini-rocket
                        });
                    }
                    
                    // Remove excess drones
                    while (this.drones.length > droneCount) {
                        this.drones.pop();
                    }
                    
                    // Update each drone
                    this.drones.forEach((drone, idx) => {
                        // Keep drones within visible area (with small margin)
                        const screenMargin = 25;
                        const minX = this.x - (width / state.zoom / 2) + screenMargin;
                        const maxX = this.x + (width / state.zoom / 2) - screenMargin;
                        const minY = this.y - (height / state.zoom / 2) + screenMargin;
                        const maxY = this.y + (height / state.zoom / 2) - screenMargin;
                        
                        // Find target if we don't have one or current target is dead
                        if (!drone.target || drone.target.hp <= 0) {
                            // Priority targeting influenced by proximity to player
                            const priorityOrder = (enemy) => {
                                // Skip invulnerable voidwalkers
                                if (enemy.type === 'voidwalker' && enemy.cloaked) return -1; // Never target cloaked voidwalkers
                                
                                let priority = 0;
                                if (enemy.isChampion) priority = 7;
                                else if (enemy.type === 'voidwalker') priority = 6; // Only if not cloaked
                                else if (enemy.type === 'tank') priority = 5;
                                else if (enemy.type === 'splitter') priority = 4;
                                else if (enemy.type === 'swarmer') priority = 3.5; // Higher than drones even with proximity boost
                                else if (enemy.type === 'drone') priority = 2;
                                else if (enemy.isHacked) priority = 1;
                                
                                // Boost priority if enemy is close to player (protector role)
                                const distToPlayer = Math.sqrt((enemy.x - this.x)**2 + (enemy.y - this.y)**2);
                                if (distToPlayer < 150) priority += 0.5; // Small boost for nearby threats
                                
                                return priority;
                            };
                            
                            let bestTarget = null;
                            let bestPriority = -1;
                            let minDist = droneRange;
                            
                            entities.enemies.forEach(e => {
                                if (e.hp > 0) {
                                    const dist = Math.sqrt((e.x - drone.x)**2 + (e.y - drone.y)**2);
                                    if (dist < droneRange) {
                                        const priority = priorityOrder(e);
                                        // Skip enemies with priority -1 (invulnerable)
                                        if (priority < 0) return;
                                        // Take higher priority, or if same priority, closer distance
                                        if (priority > bestPriority || (priority === bestPriority && dist < minDist)) {
                                            bestPriority = priority;
                                            minDist = dist;
                                            bestTarget = e;
                                        }
                                    }
                                }
                            });
                            
                            drone.target = bestTarget;
                        }
                        
                        // Move drone with more aggressive AI
                        if (drone.target) {
                            // Chase target more actively
                            const dx = drone.target.x - drone.x;
                            const dy = drone.target.y - drone.y;
                            const dist = Math.sqrt(dx*dx + dy*dy);
                            
                            // Stay at optimal range (120-180px from target) - farther back
                            const optimalDist = 150;
                            if (dist > optimalDist + 20) {
                                // Too far, move closer aggressively
                                drone.vx += (dx / dist) * 0.7;
                                drone.vy += (dy / dist) * 0.7;
                            } else if (dist < optimalDist - 20) {
                                // Too close, back off
                                drone.vx -= (dx / dist) * 0.5;
                                drone.vy -= (dy / dist) * 0.5;
                            }
                            
                            // Gentle pull toward player to keep them nearby
                            const toPlayerX = this.x - drone.x;
                            const toPlayerY = this.y - drone.y;
                            const playerDist = Math.sqrt(toPlayerX*toPlayerX + toPlayerY*toPlayerY);
                            if (playerDist > 200) { // If getting far from player
                                const pullStrength = 0.15; // Gentle pull
                                drone.vx += (toPlayerX / playerDist) * pullStrength;
                                drone.vy += (toPlayerY / playerDist) * pullStrength;
                            }
                        } else {
                            // No target, orbit player faster
                            drone.orbitAngle += 0.03 * (dt/16); // Faster orbit - was 0.02
                            const targetX = this.x + Math.cos(drone.orbitAngle) * 80;
                            const targetY = this.y + Math.sin(drone.orbitAngle) * 80;
                            const dx = targetX - drone.x;
                            const dy = targetY - drone.y;
                            drone.vx += dx * 0.08; // More responsive - was 0.05
                            drone.vy += dy * 0.08;
                        }
                        
                        // Apply velocity with less damping for snappier movement
                        drone.vx *= 0.92; // Less damping - was 0.9
                        drone.vy *= 0.92;
                        const speed = Math.sqrt(drone.vx**2 + drone.vy**2);
                        if (speed > droneSpeed) {
                            drone.vx = (drone.vx / speed) * droneSpeed;
                            drone.vy = (drone.vy / speed) * droneSpeed;
                        }
                        
                        drone.x += drone.vx * (dt/16);
                        drone.y += drone.vy * (dt/16);
                        
                        // Enforce screen boundaries - pull drones back if too far
                        if (drone.x < minX) {
                            drone.x = minX;
                            drone.vx = Math.abs(drone.vx) * 0.5; // Bounce back gently
                        } else if (drone.x > maxX) {
                            drone.x = maxX;
                            drone.vx = -Math.abs(drone.vx) * 0.5;
                        }
                        if (drone.y < minY) {
                            drone.y = minY;
                            drone.vy = Math.abs(drone.vy) * 0.5;
                        } else if (drone.y > maxY) {
                            drone.y = maxY;
                            drone.vy = -Math.abs(drone.vy) * 0.5;
                        }
                        
                        // Prevent drones from overlapping each other
                        this.drones.forEach((otherDrone, otherIdx) => {
                            if (otherIdx !== idx) {
                                const dx = otherDrone.x - drone.x;
                                const dy = otherDrone.y - drone.y;
                                const dist = Math.sqrt(dx*dx + dy*dy);
                                const minSeparation = 30; // Minimum distance between drones
                                
                                if (dist < minSeparation && dist > 0) {
                                    // Push drones apart
                                    const pushStrength = (minSeparation - dist) / minSeparation * 0.5;
                                    drone.vx -= (dx / dist) * pushStrength;
                                    drone.vy -= (dy / dist) * pushStrength;
                                }
                            }
                        });
                        
                        // Fire at target
                        drone.fireTimer -= dt/16;
                        if (drone.fireTimer <= 0 && drone.target) {
                            drone.shotsFired = (drone.shotsFired || 0) + 1;
                            
                            // Every 3rd shot fires a mini-rocket
                            const isMiniRocket = (drone.shotsFired % 3 === 0);
                            
                            const angle = Math.atan2(drone.target.y - drone.y, drone.target.x - drone.x);
                            const vx = Math.cos(angle) * (isMiniRocket ? 14 : 12);
                            const vy = Math.sin(angle) * (isMiniRocket ? 14 : 12);
                            
                            if (isMiniRocket) {
                                // Mini-rocket: more damage, faster, orange
                                entities.projectiles.push(new Projectile(
                                    drone.x, drone.y, vx, vy, droneDmg * 1.8, 0, 'drone_rocket', drone.target, 'drones'
                                ));
                                createExplosion(drone.x, drone.y, '#ff8800', 8);
                            } else {
                                // Normal shot
                                entities.projectiles.push(new Projectile(
                                    drone.x, drone.y, vx, vy, droneDmg, 0, 'drone_shot', drone.target, 'drones'
                                ));
                            }
                            
                            drone.fireTimer = fireRate;
                        }
                    });
                }

                // AUTO-TURRET (Engineer weapon)
                if (this.weapons.turret > 0) {
                    const maxTurrets = Math.min(3, this.weapons.turret); // Max 3 turrets
                    const deployInterval = Math.max(120, 240 / this.weaponStats.turret.rate); // 4 sec base, faster with upgrades
                    const turretRange = (200 + this.weapons.turret * 25) * this.weaponStats.turret.area;
                    const turretDmg = this.damage * 0.7 * this.weaponStats.turret.dmg; // 70% base damage
                    const turretFireRate = 30; // Fires every 0.5 seconds
                    
                    // Deploy turret on cooldown
                    this.turretTimer -= dt/16;
                    if (this.turretTimer <= 0) {
                        // Deploy turret at current position
                        this.turrets.push({
                            x: this.x,
                            y: this.y,
                            life: 1200, // 20 seconds lifespan
                            fireTimer: 0
                        });
                        
                        // Remove oldest if over limit
                        while (this.turrets.length > maxTurrets) {
                            this.turrets.shift();
                        }
                        
                        this.turretTimer = deployInterval;
                        createExplosion(this.x, this.y, '#ff8800', 15);
                    }
                    
                    // Update and fire turrets
                    this.turrets = this.turrets.filter(turret => {
                        turret.life -= dt/16;
                        if (turret.life <= 0) return false;
                        
                        turret.fireTimer -= dt/16;
                        if (turret.fireTimer <= 0) {
                            // Find nearest enemy in range
                            let target = null;
                            let minDist = turretRange;
                            
                            entities.enemies.forEach(e => {
                                if (e.hp > 0) {
                                    const dist = Math.sqrt((e.x - turret.x)**2 + (e.y - turret.y)**2);
                                    if (dist < minDist) {
                                        minDist = dist;
                                        target = e;
                                    }
                                }
                            });
                            
                            if (target) {
                                const angle = Math.atan2(target.y - turret.y, target.x - turret.x);
                                const vx = Math.cos(angle) * 10;
                                const vy = Math.sin(angle) * 10;
                                entities.projectiles.push(new Projectile(
                                    turret.x, turret.y, vx, vy, turretDmg, 0, 'turret_shot', target, 'turret'
                                ));
                                turret.fireTimer = turretFireRate;
                            }
                        }
                        
                        return true;
                    });
                }
                
                // EMP PULSE (Disruptor weapon)
                if (this.weapons.emp > 0) {
                    if (!this.empTimer) this.empTimer = 0;
                    const fireInterval = Math.max(60, 90 / this.weaponStats.emp.rate); // 1.5 sec base
                    const empDmg = this.damage * 0.8 * this.weaponStats.emp.dmg; // 80% base damage
                    const fieldRadius = (150 + this.weapons.emp * 15) * this.weaponStats.emp.area;
                    
                    this.empTimer -= dt/16;
                    if (this.empTimer <= 0) {
                        // Find nearest enemy
                        let target = null;
                        let minDist = 600;
                        
                        entities.enemies.forEach(e => {
                            if (e.hp > 0) {
                                const dist = Math.sqrt((e.x - this.x)**2 + (e.y - this.y)**2);
                                if (dist < minDist) {
                                    minDist = dist;
                                    target = e;
                                }
                            }
                        });
                        
                        if (target) {
                            const angle = Math.atan2(target.y - this.y, target.x - this.x);
                            const vx = Math.cos(angle) * 8;
                            const vy = Math.sin(angle) * 8;
                            entities.projectiles.push(new Projectile(
                                this.x, this.y, vx, vy, empDmg, 0, 'emp_pulse', target, 'emp'
                            ));
                        }
                        
                        this.empTimer = fireInterval;
                    }
                    
                    // Update EMP fields
                    if (!this.empFields) this.empFields = [];
                    this.empFields = this.empFields.filter(field => {
                        field.life -= dt/16;
                        return field.life > 0;
                    });
                }

            }


            getActiveWeaponCount() {
                let c = 0; 
                const keys = ['ion', 'beam', 'seeker', 'rad', 'tesla', 'whip', 'meteor', 'railgun', 'flak', 'pylons', 'mines', 'gas', 'ricochet', 'drones'];
                keys.forEach(k => { if(this.weapons[k] > 0) c++; });
                return c;
            }

            distanceToLineSegment(px, py, x1, y1, x2, y2) {
                const A = px - x1;
                const B = py - y1;
                const C = x2 - x1;
                const D = y2 - y1;
                const dot = A * C + B * D;
                const lenSq = C * C + D * D;
                let param = -1;
                if (lenSq !== 0) param = dot / lenSq;
                let xx, yy;
                if (param < 0) { xx = x1; yy = y1; }
                else if (param > 1) { xx = x2; yy = y2; }
                else { xx = x1 + param * C; yy = y1 + param * D; }
                const dx = px - xx;
                const dy = py - yy;
                return Math.sqrt(dx * dx + dy * dy);
            }



            getNearestEnemy(range) {
                let nearest = null; let minDist = range;
                let nearestHacked = null; let minHackedDist = range;
                let nearestChampion = null; let minChampionDist = range;
                let nearestTank = null; let minTankDist = range;
                let nearestSplitter = null; let minSplitterDist = range;
                
                for(let e of entities.enemies) {
                    const d = Math.sqrt((e.x-this.x)**2 + (e.y-this.y)**2);
                    if(d < minDist) {
                        if(e.hackState.active) {
                            // Track hacked enemies separately (lowest priority)
                            if(d < minHackedDist) {
                                minHackedDist = d;
                                nearestHacked = e;
                            }
                        } else if (e.isChampion) {
                            // Track champions separately (highest priority)
                            if (d < minChampionDist) {
                                minChampionDist = d;
                                nearestChampion = e;
                            }
                        } else if (e.type === 'tank') {
                            // Track tanks separately (high priority)
                            if (d < minTankDist) {
                                minTankDist = d;
                                nearestTank = e;
                            }
                        } else if (e.type === 'splitter') {
                            // Track splitters separately (high priority due to range)
                            if (d < minSplitterDist) {
                                minSplitterDist = d;
                                nearestSplitter = e;
                            }
                        } else {
                            // Normal enemies
                            minDist = d;
                            nearest = e;
                        }
                    }
                }
                
                // Priority: 1. Champions, 2. Tanks, 3. Splitters, 4. Normal enemies, 5. Hacked enemies
                // Give champions 1.7x, tanks 1.5x, splitters 1.3x effective range
                if (nearestChampion && minChampionDist < range * 1.7) {
                    return nearestChampion;
                }
                if (nearestTank && minTankDist < range * 1.5) {
                    return nearestTank;
                }
                if (nearestSplitter && minSplitterDist < range * 1.3) {
                    return nearestSplitter;
                }
                return nearest || nearestHacked;
            }

            triggerCryoShatter(enemy) {
                // Controlled shatter - spreads freeze to nearby enemies, no explosion damage
                createExplosion(enemy.x, enemy.y, '#88d8ff', 15);
                
                const shatterRadius = 150;
                const freezeChance = 0.7; // 70% chance to freeze nearby
                const maxTargets = 6;
                
                // Find nearby enemies
                const nearbyEnemies = entities.enemies
                    .filter(e => e !== enemy && e.hp > 0)
                    .map(e => ({
                        enemy: e,
                        dist: Math.sqrt((e.x - enemy.x)**2 + (e.y - enemy.y)**2)
                    }))
                    .filter(({dist}) => dist < shatterRadius)
                    .sort((a, b) => a.dist - b.dist)
                    .slice(0, maxTargets);
                
                // Spread freeze to nearby enemies (no damage)
                nearbyEnemies.forEach(({enemy: e, dist}) => {
                    // Chance to freeze nearby enemies
                    if (seededRandom() < freezeChance && e.type !== 'boss' && !e.isChampion && e.cryoState.frozenTimer <= 0) {
                        e.cryoState.frozenTimer = 90; // 1.5s freeze
                        createExplosion(e.x, e.y, '#88d8ff', 5);
                    }
                });
                
                // Ice particles for visual feedback
                for (let i = 0; i < 6; i++) {
                    const angle = (Math.PI * 2 / 6) * i;
                    const speed = 2 + seededRandom() * 2;
                    entities.particles.push({
                        x: enemy.x,
                        y: enemy.y,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed,
                        color: '#88d8ff',
                        life: 15,
                        size: 2,
                        update: function(dt) {
                            this.x += this.vx * (dt/16);
                            this.y += this.vy * (dt/16);
                            this.life -= dt/16;
                            this.vx *= 0.92;
                            this.vy *= 0.92;
                            return this.life > 0;
                        },
                        draw: function(ctx) {
                            ctx.fillStyle = this.color;
                            ctx.shadowBlur = 4;
                            ctx.shadowColor = this.color;
                            ctx.beginPath();
                            ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.shadowBlur = 0;
                        }
                    });
                }
            }

            dealElementalDamage(enemy, dmg, sourceId, color, allowCrit = true, type = 'normal') {
                let isCrit = false;
                let finalDmg = dmg;
                
                // CHAMPION ELEMENTAL DAMAGE CAP
                // Champions take massive damage from elementals - cap it to prevent instant kills
                if (enemy.isChampion) {
                    const maxElementalDmg = enemy.maxHp * 0.08; // Max 8% of max HP per hit (reduced from 15%)
                    if (finalDmg > maxElementalDmg) {
                        finalDmg = maxElementalDmg;
                    }
                }
                
                // CRYO SHATTER: Cryo weapons hitting frozen enemies trigger shatter explosion
                // This is the NEW controlled shatter mechanic
                if (enemy.cryoState.frozenTimer > 0) {
                    const cryoWeapons = ['ice']; // Weapons with ice augment
                    const isCryoSource = this.weaponAugments[sourceId] === 'ice';
                    
                    if (isCryoSource) {
                        // Bonus damage to frozen target (buffed since no more shatter damage)
                        finalDmg *= 2.0; // 100% bonus damage to frozen enemies (was 50%)
                        
                        // Trigger shatter (now just spreads freeze)
                        this.triggerCryoShatter(enemy);
                    }
                }
                
                // LAST STAND: Damage bonus when player is low HP
                if (this.hasLastStand) {
                    const hpPercent = this.hp / this.maxHp;
                    if (hpPercent < 0.30) {
                        finalDmg *= 1.30; // 30% damage bonus
                    }
                }
                
                // BOSS FOCUS BONUS: When fighting a boss alone, weapons deal significantly more damage
                // This makes single-target weapons more viable against bosses without changing mob clear
                if (enemy.type === 'boss') {
                    const otherEnemiesCount = entities.enemies.filter(e => e.type !== 'boss' && e.hp > 0).length;
                    if (otherEnemiesCount === 0) {
                        // Boss is alone - apply weapon-specific boss damage bonuses
                        const bossBonuses = {
                            'ion': 1.4,        // Precision weapon
                            'beam': 1.6,       // Sustained damage weapon (plus multi-beam bonus)
                            'seeker': 1.5,     // Homing weapon
                            'railgun': 1.8,    // Anti-armor weapon
                            'tesla': 1.3,      // Chain weapon (less effective solo)
                            'rad': 1.5,        // Aura weapon
                            'whip': 1.8,       // Melee-range weapon - HIGH RISK HIGH REWARD
                            'meteor': 1.2,     // AOE weapon (less effective solo)
                            'flak': 1.2,       // Shotgun weapon
                            'pylons': 1.4,     // Trap weapon
                            'mines': 1.5,      // Burst damage weapon
                            'gas': 1.6,        // DOT weapon
                            'ricochet': 1.3,   // Bouncing weapon (less effective solo)
                            'drones': 1.4      // Sustained DPS weapon
                        };
                        const bossBonus = bossBonuses[sourceId] || 1.3; // Default 30% bonus
                        finalDmg *= bossBonus;
                    }
                }
                
                if(allowCrit) {
                    isCrit = seededRandom() < this.critChance;
                    finalDmg = isCrit ? finalDmg * this.critMult : finalDmg;
                }


                // Apply damage with crit flag and sourceId for weapon coloring
                enemy.takeDamage(finalDmg, color, isCrit, type, sourceId, null); 


                const augElement = this.weaponAugments[sourceId]; // Single element or null
                if (!augElement) return; // No augment on this weapon


                // Base Chance 50% * Multiplier
                const chance = 0.5 * this.elementalMult;
                const isDirect = (sourceId !== 'mod'); // Prevent chaining from detonations


                if (isDirect && augElement === 'fire' && !enemy.pyroState.active) { 
                    if (seededRandom() < chance) {
                        const baseDuration = 360;
                        const duration = this.elementalMasteries.fire ? baseDuration + 120 : baseDuration; // +2s with mastery
                        enemy.pyroState.active = true;
                        enemy.pyroState.timer = duration;
                        enemy.pyroState.level = 1;
                        enemy.pyroState.baseDmg = this.damage * 0.4;
                    }
                }
                // CRYO: Spreading Slow → Freeze
                if (isDirect && augElement === 'ice' && !enemy.cryoState.frozen) {
                    if (seededRandom() < chance) {
                        // Apply 60% slow instantly
                        enemy.cryoState.slowed = true;
                        
                        // Chill aura radius (with mastery boost)
                        const auraRadius = this.elementalMasteries.ice ? 150 : 100;
                        
                        // Spread 30% slow to nearby enemies
                        entities.enemies.forEach(e => {
                            if (e !== enemy && e.hp > 0 && !e.cryoState.frozen) {
                                const dist = Math.sqrt((e.x - enemy.x)**2 + (e.y - enemy.y)**2);
                                if (dist < auraRadius) {
                                    e.cryoState.slowed = true;
                                }
                            }
                        });
                        
                        // Frozen Plague synergy: Freeze spreads bio to nearby enemies
                        if (player.synergies.cryo_bio && enemy.cryoState.slowed) {
                            entities.enemies.forEach(e => {
                                if (e !== enemy && e.hp > 0 && !e.bioState.active && Math.sqrt((e.x-enemy.x)**2 + (e.y-enemy.y)**2) < 100) {
                                    e.bioState.active = true;
                                    e.bioState.timer = 300;
                                    e.bioState.level = 1;
                                    e.bioState.jumpCount = 0;
                                    e.bioState.maxDmg = this.damage * 0.5 * 4;
                                }
                            });
                        }
                    }
                }
                // Bio Spread (type check) bypasses chance, Initial Hit uses chance
                if (isDirect && augElement === 'bio' && !enemy.bioState.active) {
                    if (type === 'bio_spread' || seededRandom() < chance) {
                        enemy.bioState.active = true; enemy.bioState.timer = 300; enemy.bioState.level = 1;
                        enemy.bioState.jumpCount = 0; 
                        enemy.bioState.maxDmg = this.damage * 0.5 * 4; 
                    }
                }
                if (isDirect && augElement === 'volt') {
                    if (seededRandom() < chance) {
                        this.chainVolt(enemy, finalDmg * 0.7, 0, 1); // Reduced from 0.75 to 0.7 (moderate nerf with chance decay)
                        
                        // Pyroclasm: Burning enemies shocked deal AOE damage
                        if (player.synergies.pyro_volt && enemy.pyroState.active) {
                            createExplosion(enemy.x, enemy.y, '#ffaa00', 15);
                            // AOE damage equal to current burn tick
                            const enemyMaxHp = enemy.maxHp || enemy.hp || 100;
                            const burnDmg = enemyMaxHp * 0.015; // Approximate burn tick
                            entities.enemies.forEach(e => {
                                if (e !== enemy && e.hp > 0 && Math.sqrt((e.x-enemy.x)**2 + (e.y-enemy.y)**2) < 80) {
                                    e.takeDamage(burnDmg, '#ffaa00');
                                }
                            });
                        }
                    }
                    
                    // Pyroclasm: Chains apply 50% burn
                    if (player.synergies.pyro_volt && !enemy.pyroState.active && seededRandom() < 0.5) {
                        enemy.pyroState.active = true;
                        enemy.pyroState.timer = this.elementalMasteries.fire ? 480 : 360;
                        enemy.pyroState.level = 1;
                        enemy.pyroState.baseDmg = this.damage * 0.2; // 50% of normal pyro
                    }
                }
                // HACK: Tier-based system
                // Basic: Always hackable (drone, swarm, splitter)
                // Elite: Only with mastery (tank, voidwalker)
                // Boss: Never hackable
                const canHack = enemy.tier === 'basic' || 
                               (enemy.tier === 'elite' && this.elementalMasteries.hack);
                
                if (isDirect && augElement === 'hack' && canHack && !enemy.hackState.active) {
                    // Digital Inferno: Burning enemies 50% easier to hack
                    let hackChance = chance;
                    if (player.synergies.pyro_hack && enemy.pyroState.active) {
                        hackChance *= 1.5;
                    }
                    
                    // Cap hacked enemies at 10
                    const currentHackedCount = entities.enemies.filter(e => e.hackState.active).length;
                    if (currentHackedCount >= 10) {
                        // Don't hack if we're at the cap
                    } else if ((state.gameTime - enemy.lastHackTime > 5000) && seededRandom() < hackChance) {
                        // Determine duration based on enemy tier
                        let baseDuration = 300; // 5s base duration for basic
                        if (enemy.tier === 'elite') baseDuration = 150; // 2.5s for elite
                        
                        // Hack Override: +2s duration with mastery (basic only)
                        if (this.elementalMasteries.hack && enemy.tier === 'basic') {
                            baseDuration += 120; // +2s with mastery
                        }
                        
                        // If this damage would kill the enemy, save them temporarily
                        const wouldDie = enemy.hp - finalDmg <= 0;
                        if (wouldDie) {
                            enemy.hp = 1; // Set to 1 HP to prevent death
                            // Voidwalkers should detonate, not die after hack
                            const shouldDieAfter = enemy.type !== 'voidwalker';
                            enemy.hackState = { active: true, timer: baseDuration, diesAfter: shouldDieAfter }; // Mark to die after (unless voidwalker)
                        } else {
                            enemy.hackState = { active: true, timer: baseDuration, diesAfter: false };
                        }
                        enemy.lastHackTime = state.gameTime;
                        // Don't apply damage yet if it would kill
                        if (wouldDie) {
                            finalDmg = 0; // Nullify this damage
                        }
                    }
                }
            }



            chainVolt(target, dmg, depth, level) {
                // Performance safeguard: Limit chain calls per frame
                if (!this.voltChainsThisFrame) this.voltChainsThisFrame = 0;
                if (this.voltChainsThisFrame > 30) return; // Cap at 30 chains per frame to prevent hitching
                this.voltChainsThisFrame++;
                
                if(depth > 0) entities.particles.push(new Particle(target.x, target.y, '#ffeb3b', 1));
                
                // Volt Amplifier: +25% chain damage (moderate buff)
                let chainDmg = this.elementalMasteries.volt ? dmg * 1.25 : dmg;
                
                // Storm Surge: +100% damage to frozen enemies
                if (player.synergies.cryo_volt && target.cryoState.frozen) {
                    chainDmg *= 2;
                }
                
                if(depth > 0) {
                    target.takeDamage(chainDmg, '#ffeb3b', false, 'normal', null, 'volt');
                    
                    // Bioshock: Volt chains double bio tick rate for 2s
                    if (player.synergies.volt_bio && target.bioState.active) {
                        target.bioState.voltBuff = 120; // 2 seconds
                    }
                    
                    // Corrupted Circuitry: Volt chains have 25% chance to hack
                    // TIER CHECK: basic always, elite with mastery, boss never
                    if (player.synergies.volt_hack && !target.hackState.active && seededRandom() < 0.25) {
                        const canHackChain = target.tier === 'basic' || 
                                           (target.tier === 'elite' && this.elementalMasteries.hack);
                        
                        if (canHackChain) {
                            let hackDuration = 300; // 5s base duration for basic
                            if (target.tier === 'elite') hackDuration = 150; // 2.5s for elite
                            if (this.elementalMasteries.hack && target.tier === 'basic') hackDuration += 120; // +2s with mastery (basic only)
                            target.hackState = { active: true, timer: hackDuration, diesAfter: false };
                            target.lastHackTime = state.gameTime;
                        }
                    }
                }
                
                // Volt Amplifier: +1 max depth
                const maxDepth = this.elementalMasteries.volt ? 6 : 5;
                if (depth > maxDepth) return;
                
                // DIMINISHING CHAIN CHANCE - decreases with each hop
                let baseChance = 0.5 + (this.multicast * 0.1); // 50-60% base
                let depthPenalty = depth * 0.15; // -15% per chain depth
                let chance = Math.max(0.2, baseChance - depthPenalty); // Minimum 20% chance
                
                if (depth === 0) chance = 1.0; // First chain always succeeds
                
                // Chance decay example:
                // Depth 0: 100% (guaranteed)
                // Depth 1: 50-60% (base)
                // Depth 2: 35-45% (-15%)
                // Depth 3: 20-30% (-30%)
                // Depth 4+: 20% (floor)
                
                if (seededRandom() < chance) {
                    // Storm Surge: Prioritize frozen enemies
                    let neighbor;
                    if (player.synergies.cryo_volt) {
                        // First try to find frozen enemy
                        neighbor = entities.enemies.find(n => n !== target && n.hp > 0 && n.cryoState.frozen && Math.sqrt((n.x-target.x)**2 + (n.y-target.y)**2) < 150);
                    }
                    // Fallback to any enemy
                    if (!neighbor) {
                        neighbor = entities.enemies.find(n => n !== target && n.hp > 0 && Math.sqrt((n.x-target.x)**2 + (n.y-target.y)**2) < 150);
                    }
                    if (neighbor) {
                        entities.lightnings.push(new LightningBolt(target.x, target.y, neighbor.x, neighbor.y));
                        this.chainVolt(neighbor, dmg * 0.7, depth + 1, level); // Moderate falloff (was 0.65, now 0.7)
                    }
                }
            }


            draw(ctx) {
                // WHIP VISUAL - Dramatic curved sweep with extreme momentum (SLOWED DOWN)
                if (this.whipVisualTimer > 0) {
                    const range = (100 + (this.weapons.whip * 5)) * this.weaponStats.whip.area;
                    const arcAngle = Math.PI * 2; // Full 360 degrees
                    const centerAngle = this.whipVisualAngle;
                    const startAngle = centerAngle - arcAngle / 2;
                    
                    // Calculate current sweep position (0 to 1) - now over 30 frames
                    const sweepProgress = 1 - (this.whipVisualTimer / 30);
                    
                    const alpha = Math.min(1, this.whipVisualTimer / 20); // Fade at end
                    
                    ctx.save();
                    ctx.translate(this.x, this.y);
                    
                    // Draw segments with BOTH angle lag AND distance variation for arc
                    const segments = 12; // More segments for smoother arc
                    for (let seg = 0; seg < segments; seg++) {
                        const segmentRatio = (seg + 1) / segments;
                        
                        // Distance varies - creates arc by having inner segments shorter
                        // Start at 60% range, build to 100% at tip
                        const segmentRange = range * (0.6 + segmentRatio * 0.4);
                        
                        // Angle lag - outer segments lag behind
                        const lagAmount = Math.pow(segmentRatio, 2.5) * 0.4;
                        const segmentProgress = Math.max(0, Math.min(1, sweepProgress - lagAmount));
                        const currentAngle = startAngle + (arcAngle * segmentProgress);
                        
                        // Uniform blade width
                        const bladeWidth = 0.25;
                        const segmentAlpha = alpha * (0.3 + segmentRatio * 0.7);
                        
                        // Draw glowing arc segment
                        ctx.fillStyle = `rgba(255, 0, 255, ${segmentAlpha * 0.6})`;
                        ctx.shadowBlur = 35 + (segmentRatio * 25);
                        ctx.shadowColor = '#ff00ff';
                        ctx.beginPath();
                        ctx.moveTo(0, 0);
                        ctx.arc(0, 0, segmentRange, currentAngle - bladeWidth, currentAngle + bladeWidth);
                        ctx.closePath();
                        ctx.fill();
                        
                        // Draw the edge lines for structure
                        if (seg % 3 === 0) {
                            ctx.strokeStyle = `rgba(255, 180, 255, ${segmentAlpha * 0.9})`;
                            ctx.lineWidth = 4;
                            ctx.beginPath();
                            ctx.moveTo(Math.cos(currentAngle) * segmentRange * 0.4, Math.sin(currentAngle) * segmentRange * 0.4);
                            ctx.lineTo(Math.cos(currentAngle) * segmentRange, Math.sin(currentAngle) * segmentRange);
                            ctx.stroke();
                        }
                    }
                    
                    ctx.shadowBlur = 0;
                    ctx.restore();
                    
                    this.whipVisualTimer--;
                }
                
                // PYLON RENDERING
                if (this.weapons.pylons > 0 && this.pylons.length > 0) {
                    // Draw pylons with golden/orange energy theme
                    this.pylons.forEach((pylon, idx) => {
                        ctx.save();
                        ctx.translate(pylon.x, pylon.y);
                        
                        // Hexagonal base platform
                        const hexSize = 12;
                        ctx.fillStyle = 'rgba(50, 50, 50, 0.8)';
                        ctx.strokeStyle = 'rgba(255, 180, 50, 0.6)';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        for (let i = 0; i < 6; i++) {
                            const angle = (Math.PI / 3) * i;
                            const x = Math.cos(angle) * hexSize;
                            const y = Math.sin(angle) * hexSize;
                            if (i === 0) ctx.moveTo(x, y);
                            else ctx.lineTo(x, y);
                        }
                        ctx.closePath();
                        ctx.fill();
                        ctx.stroke();
                        
                        // Outer energy glow ring - golden/orange
                        const glowPulse = 0.4 + Math.sin(state.frameCount * 0.08 + idx) * 0.3;
                        const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, 16);
                        gradient.addColorStop(0, `rgba(200, 100, 255, ${glowPulse * 0.4})`); // Purple instead of orange
                        gradient.addColorStop(0.5, `rgba(180, 50, 200, ${glowPulse * 0.3})`); // Magenta
                        gradient.addColorStop(1, 'rgba(150, 0, 200, 0)');
                        ctx.fillStyle = gradient;
                        ctx.shadowBlur = 25;
                        ctx.shadowColor = '#cc00cc'; // Magenta glow
                        ctx.beginPath();
                        ctx.arc(0, 0, 16, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Middle energy layer - bright purple
                        ctx.fillStyle = `rgba(255, 100, 255, ${0.7 + glowPulse * 0.2})`;
                        ctx.shadowBlur = 15;
                        ctx.shadowColor = '#ff00ff';
                        ctx.beginPath();
                        ctx.arc(0, 0, 9, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Core crystal - white/magenta
                        ctx.fillStyle = '#ffccff';
                        ctx.shadowBlur = 10;
                        ctx.shadowColor = '#ff77ff';
                        ctx.beginPath();
                        ctx.arc(0, 0, 4, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Energy particles orbiting - purple sparks
                        const orbitSpeed = state.frameCount * 0.05 + idx * 2;
                        for (let j = 0; j < 4; j++) {
                            const angle = orbitSpeed + (j * Math.PI * 2 / 4);
                            const orbitRadius = 13;
                            const px = Math.cos(angle) * orbitRadius;
                            const py = Math.sin(angle) * orbitRadius;
                            ctx.fillStyle = `rgba(255, 100, 255, ${0.9})`;
                            ctx.shadowBlur = 6;
                            ctx.shadowColor = '#cc00cc';
                            ctx.beginPath();
                            ctx.arc(px, py, 2.5, 0, Math.PI * 2);
                            ctx.fill();
                        }
                        
                        // Vertical energy beam effect
                        const beamHeight = 8 + Math.sin(state.frameCount * 0.1 + idx) * 3;
                        ctx.fillStyle = `rgba(255, 100, 255, ${0.3 + glowPulse * 0.2})`;
                        ctx.fillRect(-2, -beamHeight, 4, beamHeight);
                        
                        ctx.shadowBlur = 0;
                        ctx.restore();
                    });
                    
                    // Draw energy beams between pylons - PURPLE/MAGENTA lightning (changed from golden/orange)
                    if (this.pylons.length >= 2) {
                        for (let i = 0; i < this.pylons.length - 1; i++) {
                            const p1 = this.pylons[i];
                            const p2 = this.pylons[i + 1];
                            const pulse = 0.4 + Math.sin(state.frameCount * 0.12 + i) * 0.3;
                            
                            // Outer beam - magenta glow
                            ctx.strokeStyle = `rgba(200, 50, 200, ${pulse * 0.5})`;
                            ctx.lineWidth = 10 * this.weaponStats.pylons.area;
                            ctx.shadowBlur = 20;
                            ctx.shadowColor = '#cc00cc';
                            ctx.beginPath();
                            ctx.moveTo(p1.x, p1.y);
                            ctx.lineTo(p2.x, p2.y);
                            ctx.stroke();
                            
                            // Inner beam - bright purple
                            ctx.strokeStyle = `rgba(255, 100, 255, ${pulse})`;
                            ctx.lineWidth = 5 * this.weaponStats.pylons.area;
                            ctx.shadowBlur = 12;
                            ctx.shadowColor = '#ff66ff';
                            ctx.beginPath();
                            ctx.moveTo(p1.x, p1.y);
                            ctx.lineTo(p2.x, p2.y);
                            ctx.stroke();
                            
                            ctx.shadowBlur = 0;
                        }
                    }
                }
                
                // Rad-Field Visual (Pulse Cloud)
                if (this.weapons.rad > 0) {
                     const radius = (60 + (this.weapons.rad * 15)) * this.weaponStats.rad.area;
                     ctx.save();
                     ctx.translate(this.x, this.y);
                     
                     // Create 3 concentric ripples that pulse outward
                     const numRipples = 3;
                     for (let i = 0; i < numRipples; i++) {
                         const phase = (state.frameCount * 0.03 + i * (Math.PI * 2 / numRipples)) % (Math.PI * 2);
                         const rippleRadius = radius * (0.3 + (phase / (Math.PI * 2)) * 0.7);
                         const alpha = 0.3 * (1 - (phase / (Math.PI * 2)));
                         
                         ctx.strokeStyle = `rgba(57, 255, 20, ${alpha})`;
                         ctx.lineWidth = 3 + Math.sin(phase) * 2;
                         ctx.shadowColor = 'rgba(57, 255, 20, 0.6)';
                         ctx.shadowBlur = 20;
                         ctx.beginPath();
                         ctx.arc(0, 0, rippleRadius, 0, Math.PI * 2);
                         ctx.stroke();
                     }
                     
                     ctx.restore();
                }


                if (this.invulnTimer > 0 && Math.floor(state.frameCount / 4) % 2 === 0) return;
                ctx.save(); ctx.translate(this.x, this.y);
                
                // LAST STAND VISUAL - Red pulsing aura when below 30% HP
                if (this.hasLastStand && (this.hp / this.maxHp) < 0.30) {
                    const pulsePhase = state.frameCount * 0.08;
                    const auraRadius = 50;
                    
                    // Outer pulsing red ring
                    const pulseAlpha = 0.4 + Math.sin(pulsePhase) * 0.3;
                    ctx.strokeStyle = `rgba(255, 50, 50, ${pulseAlpha})`;
                    ctx.lineWidth = 3;
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = '#ff0000';
                    ctx.beginPath();
                    ctx.arc(0, 0, auraRadius, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    // Inner danger glow
                    const dangerGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, auraRadius);
                    dangerGradient.addColorStop(0, 'rgba(255, 0, 0, 0.15)');
                    dangerGradient.addColorStop(0.6, 'rgba(255, 50, 0, 0.08)');
                    dangerGradient.addColorStop(1, 'rgba(255, 0, 0, 0)');
                    ctx.fillStyle = dangerGradient;
                    ctx.beginPath();
                    ctx.arc(0, 0, auraRadius, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Rapid pulse rings (danger indicator)
                    for (let i = 0; i < 2; i++) {
                        const ringProgress = ((pulsePhase * 1.5 + i * 0.5) % 1);
                        const ringRadius = auraRadius * (0.3 + ringProgress * 0.7);
                        const ringAlpha = (1 - ringProgress) * 0.4;
                        ctx.strokeStyle = `rgba(255, 80, 80, ${ringAlpha})`;
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.arc(0, 0, ringRadius, 0, Math.PI * 2);
                        ctx.stroke();
                    }
                    
                    ctx.shadowBlur = 0;
                }
                
                // REPULSOR FIELD VISUAL - Draw before everything else
                if (this.activeMod === 'repulsor') {
                    const pulsePhase = state.frameCount * 0.05;
                    const fieldRadius = 150;
                    
                    // Multiple expanding wave rings
                    for (let i = 0; i < 3; i++) {
                        const waveProgress = ((pulsePhase * 0.5 + i * 0.33) % 1);
                        const waveRadius = fieldRadius * (0.5 + waveProgress * 0.5);
                        const waveAlpha = (1 - waveProgress) * 0.25;
                        ctx.strokeStyle = `rgba(0, 255, 255, ${waveAlpha})`;
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.arc(0, 0, waveRadius, 0, Math.PI * 2);
                        ctx.stroke();
                    }
                    
                    // Inner glow gradient
                    const fieldGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, fieldRadius);
                    fieldGradient.addColorStop(0, 'rgba(0, 229, 255, 0)');
                    fieldGradient.addColorStop(0.7, 'rgba(0, 229, 255, 0.02)');
                    fieldGradient.addColorStop(1, 'rgba(0, 229, 255, 0.08)');
                    ctx.fillStyle = fieldGradient;
                    ctx.beginPath();
                    ctx.arc(0, 0, fieldRadius, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                if(this.weapons.ion > 0) {
                    const cannonVisualCount = Math.min(4, this.weapons.ion);
                    for(let i = 0; i < cannonVisualCount; i++) {
                        const formationRadius = 24; 
                        const offsetAngle = this.cannonAngle + (i * (Math.PI*2/cannonVisualCount));
                        const c = this.cannons[i] || {recoil: 0};
                        const cx = Math.cos(offsetAngle) * (formationRadius - c.recoil); 
                        const cy = Math.sin(offsetAngle) * (formationRadius - c.recoil);
                        ctx.fillStyle = '#0ff'; ctx.shadowBlur = 8; ctx.shadowColor = '#0ff';
                        ctx.beginPath(); ctx.arc(cx, cy, 4, 0, Math.PI*2); ctx.fill(); ctx.shadowBlur = 0;
                    }
                }
                

                // COMBAT DRONES - Draw at their actual positions (not orbiting)
                if (this.weapons.drones > 0 && this.drones && this.drones.length > 0) {
                    this.drones.forEach((drone, idx) => {
                        ctx.save();
                        // Drones are at absolute positions, need to translate relative to player
                        ctx.translate(drone.x - this.x, drone.y - this.y);
                        
                        // Drone facing direction (toward velocity or target)
                        let droneAngle = 0;
                        if (drone.target) {
                            droneAngle = Math.atan2(drone.target.y - drone.y, drone.target.x - drone.x);
                        } else if (Math.abs(drone.vx) > 0.1 || Math.abs(drone.vy) > 0.1) {
                            droneAngle = Math.atan2(drone.vy, drone.vx);
                        }
                        ctx.rotate(droneAngle);
                        
                        // Glow
                        ctx.shadowBlur = 12;
                        ctx.shadowColor = '#00aaff';
                        
                        // Drone body (small triangle)
                        ctx.fillStyle = '#003366';
                        ctx.strokeStyle = '#00aaff';
                        ctx.lineWidth = 1.5;
                        ctx.beginPath();
                        ctx.moveTo(8, 0);  // Front (larger)
                        ctx.lineTo(-5, -5); // Back left
                        ctx.lineTo(-4, 0);  // Back center
                        ctx.lineTo(-5, 5);  // Back right
                        ctx.closePath();
                        ctx.fill();
                        ctx.stroke();
                        
                        // Core light
                        ctx.fillStyle = '#00ddff';
                        ctx.shadowBlur = 6;
                        ctx.beginPath();
                        ctx.arc(0, 0, 2.5, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Engine glow (if moving)
                        if (Math.abs(drone.vx) > 0.5 || Math.abs(drone.vy) > 0.5) {
                            ctx.fillStyle = 'rgba(0, 170, 255, 0.4)';
                            ctx.beginPath();
                            ctx.arc(-4, 0, 3, 0, Math.PI * 2);
                            ctx.fill();
                        }
                        
                        // Spotting ring - make drones easy to see
                        ctx.strokeStyle = 'rgba(0, 170, 255, 0.6)';
                        ctx.lineWidth = 2;
                        ctx.shadowBlur = 8;
                        ctx.shadowColor = '#00aaff';
                        ctx.beginPath();
                        ctx.arc(0, 0, 12, 0, Math.PI * 2);
                        ctx.stroke();
                        
                        ctx.shadowBlur = 0;
                        ctx.restore();
                    });
                }
                
                // DRAW TURRETS (if Engineer)
                if (this.turrets && this.turrets.length > 0) {
                    this.turrets.forEach(turret => {
                        ctx.save();
                        ctx.translate(turret.x - this.x, turret.y - this.y); // Relative to player
                        
                        // Hexagonal base
                        ctx.fillStyle = '#4a2511';
                        ctx.strokeStyle = '#ff8800';
                        ctx.lineWidth = 2;
                        ctx.shadowBlur = 10;
                        ctx.shadowColor = '#ff8800';
                        ctx.beginPath();
                        for (let i = 0; i < 6; i++) {
                            const angle = (Math.PI / 3) * i;
                            const x = Math.cos(angle) * 8;
                            const y = Math.sin(angle) * 8;
                            if (i === 0) ctx.moveTo(x, y);
                            else ctx.lineTo(x, y);
                        }
                        ctx.closePath();
                        ctx.fill();
                        ctx.stroke();
                        
                        // Rotating barrel
                        const barrelAngle = state.frameCount * 0.1;
                        ctx.rotate(barrelAngle);
                        ctx.fillStyle = '#ff8800';
                        ctx.fillRect(-2, -1, 8, 2);
                        
                        ctx.shadowBlur = 0;
                        ctx.restore();
                    });
                }
                
                // DRAW EMP FIELDS (if Disruptor)
                if (this.empFields && this.empFields.length > 0) {
                    this.empFields.forEach(field => {
                        ctx.save();
                        ctx.translate(field.x - this.x, field.y - this.y); // Relative to player
                        
                        const alpha = field.life / 150;
                        const pulse = 0.7 + Math.sin(state.frameCount * 0.1) * 0.3;
                        
                        // Outer field ring
                        ctx.strokeStyle = `rgba(168, 85, 247, ${alpha * 0.5})`;
                        ctx.lineWidth = 3;
                        ctx.shadowBlur = 15;
                        ctx.shadowColor = '#a855f7';
                        ctx.beginPath();
                        ctx.arc(0, 0, field.radius, 0, Math.PI * 2);
                        ctx.stroke();
                        
                        // Inner glow
                        const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, field.radius);
                        gradient.addColorStop(0, `rgba(168, 85, 247, ${alpha * 0.3 * pulse})`);
                        gradient.addColorStop(0.6, `rgba(168, 85, 247, ${alpha * 0.1})`);
                        gradient.addColorStop(1, 'rgba(168, 85, 247, 0)');
                        ctx.fillStyle = gradient;
                        ctx.beginPath();
                        ctx.arc(0, 0, field.radius, 0, Math.PI * 2);
                        ctx.fill();
                        
                        ctx.shadowBlur = 0;
                        ctx.restore();
                    });
                }
                
                // SHIELD GLOW INDICATOR - Visible soft glow when at least one shield is up
                const hasShield = this.shield1 > 0 || this.shield2 > 0;
                if (hasShield) {
                    const pulseIntensity = 0.7 + Math.sin(state.frameCount * 0.08) * 0.3;
                    const glowRadius = 28;
                    
                    // Brighter radial glow - visible but soft, no hard edges
                    const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, glowRadius);
                    gradient.addColorStop(0, `rgba(0, 255, 245, ${0.3 * pulseIntensity})`); // Brighter cyan at center
                    gradient.addColorStop(0.4, `rgba(0, 209, 178, ${0.25 * pulseIntensity})`); 
                    gradient.addColorStop(0.7, `rgba(0, 209, 178, ${0.15 * pulseIntensity})`);
                    gradient.addColorStop(1, 'rgba(0, 209, 178, 0)');
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(0, 0, glowRadius, 0, Math.PI * 2);
                    ctx.fill();
                }

                ctx.rotate(this.angle);
                ctx.fillStyle = '#1a1a2e'; ctx.strokeStyle = '#00d1b2'; ctx.lineWidth = 2;
                ctx.beginPath(); ctx.moveTo(10, 0); ctx.lineTo(-8, 8); ctx.lineTo(-5, 0); ctx.lineTo(-8, -8); ctx.closePath();
                ctx.fill(); ctx.stroke(); ctx.fillStyle = '#00fff5'; ctx.shadowColor = '#00fff5'; ctx.shadowBlur = 15;
                ctx.beginPath(); ctx.arc(0, 0, 4, 0, Math.PI*2); ctx.fill();
                ctx.restore();
            }
        }


        class Enemy {
            constructor(type) {
                const angle = seededRandom() * Math.PI * 2;
                const dist = width/state.zoom/2 + 50 + seededRandom() * 100; 
                this.x = player.x + Math.cos(angle) * dist; this.y = player.y + Math.sin(angle) * dist;
                this.type = type; this.vx = 0; this.vy = 0; this.pushX = 0; this.pushY = 0;
                this.flash = 0; this.animTick = seededRandom() * 100;
                this.frozen = 0; this.burn = 0; this.disease = 0; this.lastShot = 0;


                this.pyroState = { active: false, timer: 0, level: 0, baseDmg: 0 };
                this.cryoState = { 
                    slowed: false,        // Is enemy currently slowed?
                    slowDuration: 0,      // How long they've been slowed (counts up to 120 frames = 2s)
                    frozen: false,        // Are they frozen solid?
                    frozenTimer: 0        // Freeze duration countdown
                };
                this.bioState = { active: false, timer: 0, level: 0, maxDmg: 0, jumpCount: 0 };
                this.hackState = { active: false, timer: 0 };
                this.empState = { active: false, timer: 0 }; // EMP disables enemy
                this.ionState = { active: false, timer: 0 }; // Ion debuff: +30% damage taken
                this.lastHackTime = 0; 

                // BOSS AI STATE
                this.actionState = 'cooldown'; 
                this.actionTimer = 120;
                this.currentAttack = 0;
                this.phase = 1; // Track boss phase (1 or 2)
                this.phase2Triggered = false; // Ensure phase 2 only triggers once


                // Boss Ability Pool (Choose 2 for Phase 1, gain 2 more in Phase 2)
                this.abilities = [];
                this.phase2Abilities = []; // Additional abilities for phase 2
                this.abilityNames = ["VORTEX", "BURST", "BREAKER", "OPTIC", "HIVE", "SHOTGUN", "PULSE", "SEEKER", "BARRAGE", "METEOR"];
                
                if (type === 'boss') {
                    // 0: Spiral, 1: Nova, 2: Charge, 3: Laser, 4: Minion, 5: Shotgun, 6: Ring Pulse, 7: Homing
                    // 8: Barrage (new), 9: Meteor Rain (new)
                    
                    // Phase 1: Choose 2 abilities
                    while(this.abilities.length < 2) {
                        const r = Math.floor(seededRandom() * 10);
                        if(!this.abilities.includes(r)) this.abilities.push(r);
                    }
                    
                    // Phase 2: Choose 2 additional abilities (will be added at phase transition)
                    const allAbilities = [0,1,2,3,4,5,6,7,8,9];
                    const availablePhase2 = allAbilities.filter(a => !this.abilities.includes(a));
                    while(this.phase2Abilities.length < 2 && availablePhase2.length > 0) {
                        const idx = Math.floor(seededRandom() * availablePhase2.length);
                        this.phase2Abilities.push(availablePhase2[idx]);
                        availablePhase2.splice(idx, 1);
                    }
                }


                this.chargeState = 0; this.chargeTimer = 0; this.chargeTarget = {x:0,y:0}; this.chargeAngle = 0;
                
                // Splitter attack timer
                this.splitterAttackTimer = 0;
                this.splitterMaxAttackTimer = 150; // 2.5 seconds between shots


                const mins = state.gameTime / 60000;
                const speedMult = 1 + (mins * 0.02); 
                
                // SCALING: Post lvl 20 harder (reduced from 0.05 to 0.03 for smoother difficulty curve)
                // This prevents the damage spike at level 25+ that makes defenses feel inadequate
                const scaling = state.level > 20 ? 1.0 + (state.level-20)*0.03 : 1.0;


                // Enemy HP REBALANCED - SLIGHT INCREASE (1.8x)
                // TIER SYSTEM: basic (hackable), elite (hackable with mastery), boss (never hackable)
                if (type === 'boss') {
                    this.tier = 'boss'; // Never hackable
                    this.speed = 0.45 * speedMult; 
                    this.hp = (3000 + (state.level * 300)) * 2.5 * scaling; // Increased from 1.8x to 2.5x
                    this.radius = 60; this.color = '#ff0000'; this.xp = 0; this.dmg = 30 * scaling;
                    this.maxHp = this.hp;
                }
                else if (type === 'champion') {
                    // Champion: Mini-boss that spawns with regular enemies
                    this.tier = 'elite'; // Hackable with mastery
                    this.speed = 0.55 * speedMult; 
                    this.hp = (1200 + (state.level * 120)) * 2.0 * scaling; // Tankier champion - 53% of boss HP
                    this.radius = 40; 
                    this.color = '#ff6600'; // Orange-red (stands out)
                    this.xp = 50; // Generous XP reward
                    this.dmg = 20 * scaling; // 66% of boss damage
                    this.maxHp = this.hp;
                    // Champion only gets ONE ability (set in spawn logic)
                    this.isChampion = true; // Flag for special rendering
                }
                else if (type === 'drone') { 
                    this.tier = 'basic'; // Always hackable
                    this.speed = 0.65 * speedMult; this.hp = (20 + (state.level*5)) * 1.8 * scaling; this.radius = 12; this.color = '#ff3860'; this.xp = 2; this.dmg = (8 + state.level * 1.5) * scaling; 
                }
                else if (type === 'tank') { 
                    this.tier = 'elite'; // Hackable with mastery
                    this.speed = 0.8 * speedMult; this.hp = (150 + (state.level*30)) * 1.8 * scaling; this.radius = 28; this.color = '#ffaa00'; this.xp = 12; this.dmg = 40 * scaling; 
                } 
                else if (type === 'swarm') { 
                    this.tier = 'basic'; // Always hackable
                    this.speed = 1.5 * speedMult; this.hp = (10 + (state.level*2)) * 1.8 * 0.67 * scaling; this.radius = 8; this.color = '#bf5af2'; this.xp = 3; this.dmg = (6 + state.level * 1.2) * scaling; 
                }
                else if (type === 'splitter') { 
                    this.tier = 'basic'; // Always hackable
                    this.speed = 1.0 * speedMult; this.hp = (45 + (state.level*6)) * 1.8 * scaling; this.radius = 16; this.color = '#ff9500'; this.xp = 10; this.dmg = (12 + state.level * 2) * scaling; 
                } 
                else if (type === 'voidwalker') {
                    this.tier = 'elite'; // Hackable with mastery
                    this.speed = 0; // Doesn't walk, only teleports
                    this.hp = (60 + (state.level*5)) * 1.8 * scaling;
                    this.radius = 16; 
                    this.color = '#9933ff'; // Purple
                    this.xp = 4;
                    this.dmg = 50; // Base explosion damage to player (NOT scaled)
                    this.enemyDmg = 100 * scaling; // Explosion damage to enemies
                    this.blastRadius = 120;
                    
                    // Phase state machine
                    this.phaseState = 'phased'; // 'phased', 'materializing', 'countdown', 'detonating'
                    this.phaseTimer = 300; // 5 seconds phased (60fps × 5)
                    this.countdownTimer = 120; // 2 seconds countdown (60fps × 2)
                    this.materializeRange = [60, 80]; // Distance from target
                    
                    // Visual
                    this.pulsePhase = seededRandom() * Math.PI * 2;
                    this.opacity = 0.3; // Start semi-transparent
                    this.warningCircleRadius = 0;
                    
                    // Target tracking
                    this.driftTarget = null; // Where it's drifting toward
                    this.hasBeenHacked = false; // Track if hack teleport has triggered
                }
            }
            
            triggerDetonation() {
                // VOIDWALKER DETONATION - Enhanced animation
                const explosionColor = this.hackState.active ? '#00ff00' : '#9933ff';
                const brightColor = this.hackState.active ? '#88ffcc' : '#ff66ff';
                
                // Multi-layered explosion
                createExplosion(this.x, this.y, explosionColor, 60); // More particles
                createExplosion(this.x, this.y, brightColor, 40); // Bright center
                createExplosion(this.x, this.y, '#ffffff', 20); // White core
                
                // Multiple shockwaves at different speeds
                entities.particles.push(new Shockwave(this.x, this.y, this.blastRadius, explosionColor));
                entities.particles.push(new Shockwave(this.x, this.y, this.blastRadius * 0.7, brightColor));
                entities.particles.push(new Shockwave(this.x, this.y, this.blastRadius * 0.4, '#ffffff'));
                
                // Radial burst effect
                for (let i = 0; i < 12; i++) {
                    const angle = (i / 12) * Math.PI * 2;
                    const speed = 8 + seededRandom() * 4;
                    entities.particles.push({
                        x: this.x,
                        y: this.y,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed,
                        life: 30,
                        color: explosionColor,
                        size: 4,
                        update: function(dt) {
                            this.x += this.vx * (dt/16);
                            this.y += this.vy * (dt/16);
                            this.life -= dt/16;
                            this.vx *= 0.95;
                            this.vy *= 0.95;
                            return this.life > 0;
                        },
                        draw: function(ctx) {
                            ctx.fillStyle = this.color;
                            ctx.globalAlpha = this.life / 30;
                            ctx.beginPath();
                            ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.globalAlpha = 1;
                        }
                    });
                }
                
                // Damage player (only if not hacked)
                if (!this.hackState.active) {
                    const distToPlayer = Math.sqrt((player.x - this.x)**2 + (player.y - this.y)**2);
                    if (distToPlayer < this.blastRadius && player.invulnTimer <= 0) {
                        const falloff = 1 - (distToPlayer / this.blastRadius) * 0.4; // 40% falloff at edge
                        player.takeHit(this.dmg * falloff);
                    }
                }
                
                // Damage enemies (always, including when not hacked)
                entities.enemies.forEach(e => {
                    if (e !== this && e.hp > 0) {
                        const dist = Math.sqrt((e.x - this.x)**2 + (e.y - this.y)**2);
                        if (dist < this.blastRadius) {
                            const falloff = 1 - (dist / this.blastRadius) * 0.4; // 40% falloff
                            e.takeDamage(this.enemyDmg * falloff, explosionColor, false, 'normal', 'voidwalker');
                        }
                    }
                });
            }
            
            takeDamage(amt, color = '#ffffff', isCrit = false, type = 'normal', sourceId = null, elementType = null) {
                // VOIDWALKER PHASE PROTECTION: Invulnerable while phased out
                if (this.type === 'voidwalker' && this.phaseState === 'phased') {
                    return; // No damage while phased
                }
                
                // HACK PROTECTION: Hacked enemies cannot die from player damage (except hack damage itself)
                // Voidwalkers when hacked are also immune until hack expires
                if (this.hackState.active && sourceId !== 'hack' && elementType !== 'hack') {
                    // Prevent death - set HP to minimum 1
                    if (this.hp - amt <= 0) {
                        this.hp = 1;
                        return; // Don't apply damage that would kill
                    }
                }
                
                // Boss Damage Resistance: Bosses take 35% less damage from all sources
                if (this.type === 'boss') {
                    amt *= 0.65;
                }
                
                // Ionization: Enemies hit by Ion take +30% damage from all sources
                if (this.ionState.active) {
                    amt *= 1.3;
                }
                
                // Cryo Control: Frozen enemies take +50% damage
                if (player.elementalMasteries.ice && this.cryoState.frozen) {
                    amt *= 1.5;
                }
                
                // Weapon-specific colors (only for direct weapon hits, not DOTs)
                const weaponColors = {
                    'ion': '#ffffff',      // White (default weapon)
                    'tesla': '#ffeb3b',    // Yellow/electric
                    'beam': '#ff00ff',     // Magenta/plasma
                    'rad': '#00ff00',      // Green/radioactive
                    'seeker': '#ff5500',   // Orange/rocket
                    'whip': '#ff00ff',  // Magenta (plasma whip)
                    'meteor': '#ff8800',   // Orange/fire
                    'railgun': '#00aaff',  // Blue (matches beam)
                    'flak': '#ffaa00',     // Gold/explosive
                    'pylons': '#ff64ff',   // Magenta (matches pylon beams)
                    'mines': '#ff44cc',    // Brighter magenta (matches mine visuals)
                    'gas': '#99ff33',      // Toxic green
                    'ricochet': '#ff8800', // Orange (bouncing disc)
                    'drones': '#00aaff',   // Blue (drone shots)
                    'marker': '#ffaa00',   // Orange (matches targeting theme)
                };
                
                // Determine display color: 
                // Priority: crit > elemental DOT (keep original color) > weapon color > default
                let displayColor = color;
                if (isCrit) {
                    displayColor = '#ffdd00'; // Crit override
                } else if (type === 'dot' && elementType) {
                    // DOTs keep their elemental color (already passed in)
                    displayColor = color;
                } else if (sourceId && weaponColors[sourceId]) {
                    // Weapon hits get weapon color
                    displayColor = weaponColors[sourceId];
                }
                
                this.hp -= amt; this.flash = 2;
                
                // TRACK WEAPON DAMAGE
                if (sourceId && sourceId !== 'voidwalker' && sourceId !== 'kamikaze') {
                    if (!state.weaponStats[sourceId]) {
                        state.weaponStats[sourceId] = { damage: 0, kills: 0 };
                    }
                    state.weaponStats[sourceId].damage += amt;
                }
                
                // Always show DOT damage, or show regular damage if >= 1 or 10% chance
                if (type === 'dot' || amt >= 1 || seededRandom() < 0.1) {
                    entities.texts.push(new FloatingText(this.x, this.y - 20, Math.ceil(amt), displayColor, isCrit, type, sourceId, elementType));
                }
                if(this.hp <= 0) {
                    // TRACK WEAPON KILLS
                    if (sourceId && sourceId !== 'voidwalker' && sourceId !== 'kamikaze') {
                        if (!state.weaponStats[sourceId]) {
                            state.weaponStats[sourceId] = { damage: 0, kills: 0 };
                        }
                        state.weaponStats[sourceId].kills++;
                    }
                    
                    createExplosion(this.x, this.y, this.color, 6);
                    
                    // Elemental Detonator removed - synergies handle this now

                    // BIO SPREAD
                    if (this.bioState.active && this.bioState.jumpCount < 1) { 
                        let neighbor = entities.enemies.find(n => n !== this && n.hp > 0 && Math.sqrt((n.x-this.x)**2 + (n.y-this.y)**2) < 200);
                        if (neighbor) {
                            neighbor.bioState = { ...this.bioState, timer: 300, jumpCount: this.bioState.jumpCount + 1 }; 
                            // Spore Projectile Effect - PASS 'bio_spread' type to ensure it applies
                            entities.projectiles.push(new Projectile(this.x, this.y, 0,0, 0, 0, 'bio_spore', neighbor, 'bio'));
                        }
                    }
                    
                    // CRYO - Frozen enemies just die cleanly, no auto-shatter
                    // Shatter is now triggered by cryo weapons hitting frozen targets (see dealElementalDamage)
                    
                    // === SYNERGY EFFECTS ===
                    
                    // Thermal Shock (Pyro + Cryo): Enemy with both explodes for 50% HP AOE, freezes nearby
                    if (player.synergies.pyro_cryo && this.pyroState.active && (this.cryoState.slowed || this.cryoState.frozen)) {
                        createExplosion(this.x, this.y, '#ff00ff', 30);
                        const explosionDmg = (this.maxHp || 100) * 0.5;
                        entities.enemies.forEach(e => {
                            if (e !== this && e.hp > 0 && Math.sqrt((e.x-this.x)**2 + (e.y-this.y)**2) < 100) {
                                e.takeDamage(explosionDmg, '#ff00ff');
                                // Apply freeze to nearby enemies
                                if (e.type !== 'boss') {
                                    e.cryoState.frozen = true;
                                    e.cryoState.frozenTimer = 120; // 2s freeze
                                    e.cryoState.slowed = false;
                                    e.cryoState.slowDuration = 0;
                                }
                            }
                        });
                    }
                    
                    // Meltdown (Pyro + Bio): Burning enemies spread bio on death
                    if (player.synergies.pyro_bio && this.pyroState.active) {
                        let neighbor = entities.enemies.find(n => n !== this && n.hp > 0 && Math.sqrt((n.x-this.x)**2 + (n.y-this.y)**2) < 150);
                        if (neighbor && !neighbor.bioState.active) {
                            neighbor.bioState = { active: true, timer: 300, level: 1, jumpCount: 0, maxDmg: player.damage * 0.5 * 4 };
                            entities.projectiles.push(new Projectile(this.x, this.y, 0, 0, 0, 0, 'bio_spore', neighbor, 'bio'));
                        }
                    }
                    
                    if (this.type === 'boss' || this.isChampion) {
                        state.bossActive = false;
                        document.getElementById('boss-hud').classList.remove('active');
                        state.breathingRoomTimer = 300; // 5 seconds peace
                        
                        // Grant one save charge for defeating boss/champion
                        state.saveCharges++;
                        
                        // NEXUS CORE DROP - 1 per boss kill
                        entities.pickups.push(new Pickup(this.x - 20, this.y, 0, 'nexus_core'));
                        
                        // DROP MOD CRATE (only if one doesn't already exist on the map)
                        const existingModCrate = entities.pickups.find(p => p.type === 'mod_crate');
                        if (!existingModCrate) {
                            entities.pickups.push(new Pickup(this.x, this.y, 0, 'mod_crate')); 
                        }
                        // And normal Data
                        entities.pickups.push(new Pickup(this.x+20, this.y, 0, 'core')); 
                    } else if (this.type === 'splitter') {
                        // SPLITTER: Spawns 3 swarm enemies on death
                        for (let i = 0; i < 3; i++) {
                            const angle = (Math.PI * 2 / 3) * i;
                            const offsetDist = 30;
                            const newX = this.x + Math.cos(angle) * offsetDist;
                            const newY = this.y + Math.sin(angle) * offsetDist;
                            const swarm = new Enemy('swarm');
                            swarm.x = newX;
                            swarm.y = newY;
                            entities.enemies.push(swarm);
                        }
                        createExplosion(this.x, this.y, this.color, 12); // Bigger explosion for split effect
                        
                        // Still drop XP shards for the splitter itself
                        let shards = 5;
                        if (this.xp > 0) {
                            for(let i=0; i<shards; i++) {
                                const sx = this.x + (seededRandom()-0.5)*20; const sy = this.y + (seededRandom()-0.5)*20;
                                entities.pickups.push(new Pickup(sx, sy, this.xp / shards, 'xp'));
                            }
                        }
                    } else if (this.type === 'voidwalker') {
                        // VOIDWALKER: Explodes on death (if in countdown state)
                        if (this.phaseState === 'countdown' || this.phaseState === 'detonating') {
                            this.triggerDetonation();
                        }
                        
                        // Drop XP shards
                        if (this.xp > 0) {
                            for(let i=0; i<4; i++) {
                                const sx = this.x + (seededRandom()-0.5)*20; 
                                const sy = this.y + (seededRandom()-0.5)*20;
                                entities.pickups.push(new Pickup(sx, sy, this.xp / 4, 'xp'));
                            }
                        }
                    } else {
                        let shards = 1;
                        if(this.type === 'swarm') shards = 4; 
                        if(this.type === 'tank') shards = 10; 
                        if (this.xp > 0) {
                            for(let i=0; i<shards; i++) {
                                const sx = this.x + (seededRandom()-0.5)*20; const sy = this.y + (seededRandom()-0.5)*20;
                                entities.pickups.push(new Pickup(sx, sy, this.xp / shards, 'xp'));
                            }
                            // Magnet drop rate scales down over time as kill volume increases
                            // Starts at 0.2%, scales to 0.05% by 10 minutes
                            const timeMinutes = state.gameTime / 60000;
                            const timeScale = Math.max(0.25, 1 - (timeMinutes / 15)); // 1.0 → 0.25 over 15 minutes
                            const magnetThreshold = 0.998 + (0.001 * (1 - timeScale)); // 0.998 → 0.999
                            
                            const r = seededRandom() + (player.luck * 0.003); // Reduced from 0.005 (40% nerf)
                            
                            // Hard cap: Max 3 magnet pickups on ground at once
                            const magnetCount = entities.pickups.filter(p => p.type === 'magnet').length;
                            
                            if (r > magnetThreshold && magnetCount < 3) entities.pickups.push(new Pickup(this.x, this.y, 0, 'magnet')); // Scaled drop rate with cap
                            else if (r > 0.9975) entities.pickups.push(new Pickup(this.x, this.y, 0, 'shield_cell')); // 0.25% drop rate
                            else if (r > 0.99) entities.pickups.push(new Pickup(this.x, this.y, 0, 'health')); // 1% + luck
                        }
                    }
                    
                    this.xp = 0;
                }
            }
            
            update(dt) {
                this.animTick += 0.1 * (dt/16);
                
                if (this.pyroState.active) {
                    this.pyroState.timer -= dt/16;
                    
                    // Digital Inferno: Hacked enemies burn 2x faster
                    if (player.synergies.pyro_hack && this.hackState.active) {
                        this.pyroState.timer -= dt/16; // Double tick rate
                    }
                    
                    if (this.pyroState.timer <= 0) this.pyroState.active = false;
                    else if (Math.floor(this.pyroState.timer) % 20 === 0) {
                        // Pyro: Sustained damage that ramps up over time
                        const progress = 1 - (this.pyroState.timer / 360);
                        
                        // CRITICAL: Ensure maxHp exists
                        const enemyMaxHp = this.maxHp || this.hp || 100;
                        
                        let dmg;
                        
                        // BOSS PROTECTION: Bosses take flat damage instead of % max HP
                        if (this.type === 'boss') {
                            // Flat damage that scales with player power and ramps up
                            const baseFlatDmg = (this.pyroState.baseDmg || player.damage) * 1.2;
                            dmg = baseFlatDmg * (1 + progress * 0.5); // Slight ramp
                            
                            // Mastery still applies but moderately
                            if (player.elementalMasteries.fire) {
                                dmg *= 1.3; // +30% instead of the % HP bonus
                            }
                        } else {
                            // Normal enemies: % max HP + weapon damage
                            // Base damage from weapon (scales with player damage AND progress)
                            const weaponDmg = (this.pyroState.baseDmg || 0) * (1 + progress); // Ramps up!
                            
                            // % max HP damage (1% → 1.5% over time, +0.5% with mastery)
                            const basePercent = 0.01 * (1 + progress * 0.5); // 1% → 1.5%
                            const masteryBonus = player.elementalMasteries.fire ? 0.005 : 0; // +0.5% with mastery
                            const hpPercent = basePercent + masteryBonus;
                            const hpDmg = enemyMaxHp * hpPercent;
                            
                            // Combine both sources
                            dmg = weaponDmg + hpDmg;
                        }
                        
                        // ABSOLUTE GUARANTEE: No NaN can pass
                        if (!dmg || isNaN(dmg) || dmg <= 0) {
                            dmg = player.damage * 0.6; // Fallback to flat damage
                        }
                        
                        this.takeDamage(dmg, '#ff5722', false, 'dot', null, 'fire');
                        if(seededRandom()<0.3) entities.particles.push(new Particle(this.x, this.y, '#ff5722', 0.5));
                    }
                }
                let cryoSlow = 1.0;
                
                // EMP SLOW: Apply diminishing stacking slow from EMP fields
                let empSlow = 1.0;
                if (this.empSlowStacks > 0) {
                    // Diminishing returns on stacking
                    // 1 field: 35% slow (move at 65%)
                    // 2 fields: 55% slow (move at 45%)
                    // 3+ fields: 65% slow (move at 35%)
                    if (this.empSlowStacks === 1) empSlow = 0.65;
                    else if (this.empSlowStacks === 2) empSlow = 0.45;
                    else empSlow = 0.35; // Hard cap
                }
                
                // CRYO: Slow duration tracking and freeze trigger
                if (this.cryoState.frozen) {
                    // Frozen solid - no movement
                    cryoSlow = 0.0;
                    this.cryoState.frozenTimer -= dt/16;
                    
                    // Unfreeze after 2 seconds (120 frames)
                    if (this.cryoState.frozenTimer <= 0) {
                        this.cryoState.frozen = false;
                        this.cryoState.slowed = false;
                        this.cryoState.slowDuration = 0;
                    }
                    
                    // Bosses and tanks can still move slowly when frozen
                    if (this.type === 'boss' || this.type === 'tank' || this.isChampion) cryoSlow = 0.5;
                    
                } else if (this.cryoState.slowed) {
                    // Count up slow duration
                    this.cryoState.slowDuration += dt/16;
                    
                    // Base 60% slow
                    let slowAmount = 0.40; // Move at 40% speed (60% slow)
                    
                    // Check for nearby slowed enemies to amplify effect
                    const nearbySlowed = entities.enemies.filter(e => {
                        if (e === this || !e.cryoState.slowed) return false;
                        const dist = Math.sqrt((e.x - this.x)**2 + (e.y - this.y)**2);
                        return dist < 150;
                    }).length;
                    
                    // 2+ slowed enemies nearby = 70% slow (move at 30%)
                    if (nearbySlowed >= 1) {
                        slowAmount = 0.30;
                    }
                    
                    cryoSlow = slowAmount;
                    
                    // Trigger freeze after 2 seconds (120 frames) of being slowed
                    if (this.cryoState.slowDuration >= 120 && this.type !== 'boss') {
                        this.cryoState.frozen = true;
                        this.cryoState.frozenTimer = 120; // 2s freeze
                        this.cryoState.slowed = false;
                        
                        // Shatter Protocol: Frozen enemies can be hacked instantly
                        const canHackInstantly = this.tier === 'basic' || 
                                                (this.tier === 'elite' && player.elementalMasteries.hack);
                        
                        if (player.synergies.cryo_hack && !this.hackState.active && canHackInstantly) {
                            const currentHackedCount = entities.enemies.filter(e => e.hackState.active).length;
                            if (currentHackedCount < 10) {
                                let hackDuration = 300;
                                if (this.tier === 'elite') hackDuration = 150;
                                if (player.elementalMasteries.hack && this.tier === 'basic') hackDuration += 120;
                                this.hackState = { active: true, timer: hackDuration, diesAfter: false };
                                this.lastHackTime = state.gameTime;
                            }
                        }
                    }
                    
                    // Slow naturally decays after 3 seconds without refreshing
                    if (state.gameTime % 180 === 0) {
                        this.cryoState.slowed = false;
                        this.cryoState.slowDuration = 0;
                    }
                }
                
                if (this.bioState.active) {
                    this.bioState.timer -= dt/16;
                    if (this.bioState.timer <= 0) this.bioState.active = false;
                    
                    // Bioshock: Volt chains double bio tick rate for 2s
                    if (this.bioState.voltBuff > 0) {
                        this.bioState.voltBuff -= dt/16;
                    }
                    
                    // Bio Accelerator: Ticks 50% faster (every 13 frames vs 20)
                    let tickInterval = player.elementalMasteries.bio ? 13 : 20;
                    // Bioshock buff: Double rate (half interval)
                    if (this.bioState.voltBuff > 0) {
                        tickInterval = Math.floor(tickInterval / 2);
                    }
                    
                    else if (Math.floor(this.bioState.timer) % tickInterval === 0) {
                        // Bio: High burst % max HP damage that decays
                        const progress = (this.bioState.timer / 300); 
                        
                        // CRITICAL: Ensure maxHp exists
                        const enemyMaxHp = this.maxHp || this.hp || 100;
                        
                        let dmg;
                        
                        // BOSS PROTECTION: Bosses take flat damage instead of % max HP
                        if (this.type === 'boss') {
                            // Flat damage that scales with player power, not boss HP
                            const baseFlatDmg = player.damage * 1.5; // Reasonable damage
                            dmg = baseFlatDmg * (1 + progress * 0.5); // Slightly stronger at start
                            
                            // Synergies still apply but with reduced effectiveness
                            if (player.synergies.bio_hack && this.hackState.active) {
                                dmg *= 1.5; // +50% instead of +100%
                            }
                            if (player.synergies.cryo_bio && this.cryoState.frozenTimer > 0) {
                                dmg *= 1.5; // +50% instead of +100%
                            }
                        } else {
                            // Normal enemies: % max HP damage
                            // Bio Accelerator: +2% starting damage (6% → 8%)
                            const startPercent = player.elementalMasteries.bio ? 0.08 : 0.06;
                            const endPercent = 0.02; // Increased from 0.01
                            const currentPercent = endPercent + ((startPercent - endPercent) * progress);
                            
                            // % max HP damage + flat damage scaling with player power
                            const percentDmg = enemyMaxHp * currentPercent;
                            const flatDmg = (player.damage * 0.3) * (1 + progress); // More at start, scales with player
                            dmg = percentDmg + flatDmg;
                            
                            // Necrosis: Hacked enemies take double bio damage
                            if (player.synergies.bio_hack && this.hackState.active) {
                                dmg *= 2;
                            }
                            
                            // Frozen Plague: Frozen enemies take +100% bio damage
                            if (player.synergies.cryo_bio && this.cryoState.frozenTimer > 0) {
                                dmg *= 2;
                            }
                        }
                        
                        // ABSOLUTE GUARANTEE: No NaN can pass
                        if (!dmg || isNaN(dmg) || dmg <= 0) {
                            dmg = player.damage * 0.5; // Fallback to flat damage
                        }
                        
                        this.takeDamage(dmg, '#00cc44', false, 'dot', null, 'bio');
                        if(seededRandom()<0.3) entities.particles.push(new Particle(this.x, this.y, '#00cc44', 0.3));
                        
                        // Bioshock: Every 3rd bio tick triggers volt chain
                        if (!this.bioState.tickCount) this.bioState.tickCount = 0;
                        this.bioState.tickCount++;
                        if (player.synergies.volt_bio && this.bioState.tickCount % 3 === 0) {
                            player.chainVolt(this, player.damage * 0.5, 0, 1);
                        }
                        
                        // Meltdown: Bio ticks apply 50% pyro
                        if (player.synergies.pyro_bio && !this.pyroState.active && seededRandom() < 0.3) {
                            this.pyroState.active = true;
                            this.pyroState.timer = player.elementalMasteries.fire ? 480 : 360;
                            this.pyroState.level = 1;
                            this.pyroState.baseDmg = player.damage * 0.2; // 50% of normal
                        }
                    }
                }
                if (this.hackState.active) {
                    this.hackState.timer -= dt/16;
                    if (this.hackState.timer <= 0) {
                        this.hackState.active = false;
                        
                        // Reset voidwalker hack flag
                        if (this.type === 'voidwalker') {
                            this.hasBeenHacked = false;
                        }
                        
                        // Necrosis: Hack end resets bio duration
                        if (player.synergies.bio_hack && this.bioState.active) {
                            this.bioState.timer = 300; // Reset to full duration
                        }
                        
                        // If enemy was marked to die after hack, kill it now
                        if (this.hackState.diesAfter) {
                            this.hp = 0;
                            this.takeDamage(0, '#00ffff'); // Trigger death
                        }
                    }
                    else {
                        // Splitter hack behavior - ranged attack targeting enemy clusters
                        if (this.type === 'splitter') {
                            // Find densest enemy cluster (similar to gas grenade/mines)
                            let bestTarget = null;
                            let bestCount = 0;
                            const maxSearchRadius = 400;
                            
                            entities.enemies.forEach(e => {
                                if (e !== this && e.hp > 0 && !e.hackState.active) {
                                    const distToSplitter = Math.sqrt((e.x - this.x)**2 + (e.y - this.y)**2);
                                    if (distToSplitter > maxSearchRadius) return;
                                    
                                    // Count nearby enemies to this potential target
                                    const nearbyCount = entities.enemies.filter(ne => {
                                        if (ne === this || ne === e || ne.hackState.active || ne.hp <= 0) return false;
                                        const dist = Math.sqrt((ne.x - e.x)**2 + (ne.y - e.y)**2);
                                        return dist < 150; // Cluster detection radius
                                    }).length;
                                    
                                    // Prefer denser clusters, then closer targets
                                    if (nearbyCount > bestCount || 
                                        (nearbyCount === bestCount && (!bestTarget || distToSplitter < Math.sqrt((bestTarget.x - this.x)**2 + (bestTarget.y - this.y)**2)))) {
                                        bestCount = nearbyCount;
                                        bestTarget = e;
                                    }
                                }
                            });
                            
                            if (bestTarget) {
                                const dx = bestTarget.x - this.x;
                                const dy = bestTarget.y - this.y;
                                const dist = Math.sqrt(dx*dx + dy*dy);
                                
                                // Keep distance (200-300 range), kite backwards if too close
                                const idealDist = 250;
                                const tooClose = 180;
                                
                                if (dist > idealDist) {
                                    // Move closer
                                    if (dist > 0) { 
                                        this.vx = (dx/dist) * this.speed * 0.8; 
                                        this.vy = (dy/dist) * this.speed * 0.8; 
                                    }
                                } else if (dist < tooClose) {
                                    // Kite backwards
                                    if (dist > 0) { 
                                        this.vx = -(dx/dist) * this.speed * 0.6; 
                                        this.vy = -(dy/dist) * this.speed * 0.6; 
                                    }
                                } else {
                                    // In ideal range - slow down
                                    this.vx *= 0.9;
                                    this.vy *= 0.9;
                                }
                                
                                // Fire projectile at other enemies (FASTER when hacked)
                                this.splitterAttackTimer += dt/16;
                                const hackedFireRate = this.splitterMaxAttackTimer * 0.5; // 2x faster when hacked
                                if (this.splitterAttackTimer >= hackedFireRate && dist < 350) {
                                    const angle = Math.atan2(dy, dx);
                                    
                                    // Create PIERCING projectile targeting enemy cluster
                                    entities.enemyProjectiles.push({
                                        x: this.x,
                                        y: this.y,
                                        vx: Math.cos(angle) * 3.5,
                                        vy: Math.sin(angle) * 3.5,
                                        radius: 9,
                                        color: '#00ffff', // Hacked color (cyan/green)
                                        life: 150,
                                        splitterShot: true,
                                        glowPhase: 0,
                                        targetWasPlayer: false, // Flag: this targets enemies
                                        piercing: true, // NEW: Pierces through all enemies
                                        hitEnemies: new Set(), // Track which enemies we've hit
                                        shooter: this // Track origin enemy for whip deflection
                                    });
                                    
                                    // Visual feedback
                                    for(let i=0; i<8; i++) {
                                        const particleAngle = (Math.PI * 2 / 8) * i;
                                        entities.particles.push(new Particle(
                                            this.x + Math.cos(particleAngle) * 15,
                                            this.y + Math.sin(particleAngle) * 15,
                                            '#00ffff',
                                            1.2
                                        ));
                                    }
                                    
                                    this.splitterAttackTimer = 0;
                                }
                            } else {
                                // No target - wander
                                const dx = player.x - this.x;
                                const dy = player.y - this.y;
                                const dist = Math.sqrt(dx*dx + dy*dy);
                                if (dist > 0) { 
                                    this.vx = (dx/dist) * this.speed * 0.5; 
                                    this.vy = (dy/dist) * this.speed * 0.5; 
                                }
                            }
                            
                            // Move
                            this.x += this.vx * (dt/16);
                            this.y += this.vy * (dt/16);
                            return;
                        }
                        
                        // Special behavior for hacked tanks - charge attack
                        if (this.type === 'tank') {
                            // Find nearest non-hacked enemy
                            let nearest = null;
                            let nearestDist = Infinity;
                            
                            entities.enemies.forEach(e => {
                                if (e !== this && e.hp > 0 && !e.hackState.active) {
                                    const dist = Math.sqrt((e.x-this.x)**2 + (e.y-this.y)**2);
                                    if (dist < nearestDist && dist < 600) { // Longer detection range
                                        nearest = e;
                                        nearestDist = dist;
                                    }
                                }
                            });
                            
                            if (nearest) {
                                // Initialize charge state if needed
                                if (!this.hackChargeState) this.hackChargeState = 0;
                                
                                if (this.hackChargeState === 0) {
                                    // Start windup
                                    this.hackChargeState = 1;
                                    this.chargeTimer = 15; // 0.25s windup
                                    this.chargeAngle = Math.atan2(nearest.y-this.y, nearest.x-this.x);
                                    this.vx = 0; this.vy = 0;
                                } else if (this.hackChargeState === 1) {
                                    // Windup - track target perfectly
                                    this.chargeTimer -= (dt/16);
                                    this.chargeAngle = Math.atan2(nearest.y - this.y, nearest.x - this.x);
                                    
                                    if (this.chargeTimer <= 0) {
                                        this.hackChargeState = 2;
                                        this.chargeTimer = 25; // Dash duration
                                        const dashSpeed = 16; // Very fast
                                        this.vx = Math.cos(this.chargeAngle) * dashSpeed;
                                        this.vy = Math.sin(this.chargeAngle) * dashSpeed;
                                    }
                                } else if (this.hackChargeState === 2) {
                                    // Dashing - deal collision damage to ALL enemies in path
                                    this.chargeTimer -= (dt/16);
                                    if(state.frameCount % 2 === 0) entities.particles.push(new Particle(this.x, this.y, '#00ffff', 0.6));
                                    
                                    // Check collision with all non-hacked enemies
                                    entities.enemies.forEach(e => {
                                        if (e !== this && e.hp > 0 && !e.hackState.active) {
                                            const dist = Math.sqrt((e.x - this.x)**2 + (e.y - this.y)**2);
                                            if (dist < this.radius + e.radius + 10) {
                                                // Deal massive collision damage based on target's max HP
                                                const targetMaxHp = e.maxHp || e.hp || 100;
                                                const collisionDmg = targetMaxHp * 0.20; // 20% max HP per collision
                                                e.takeDamage(collisionDmg, '#00ffff', false, 'normal', null, 'hack');
                                                createExplosion(e.x, e.y, '#00ffff', 10);
                                                entities.particles.push(new Shockwave(e.x, e.y, 80, '#00ffff'));
                                            }
                                        }
                                    });
                                    
                                    // Move during dash
                                    this.x += this.vx * (dt/16);
                                    this.y += this.vy * (dt/16);
                                    
                                    if (this.chargeTimer <= 0) {
                                        this.hackChargeState = 0; // Reset to find new target
                                        this.vx = 0; this.vy = 0;
                                    }
                                }
                            } else {
                                // No target - wander
                                this.hackChargeState = 0;
                                if (seededRandom() < 0.1) {
                                    const angle = seededRandom() * Math.PI * 2;
                                    this.vx = Math.cos(angle) * this.speed;
                                    this.vy = Math.sin(angle) * this.speed;
                                }
                                this.x += this.vx * (dt/16);
                                this.y += this.vy * (dt/16);
                            }
                        } else {
                            // Standard hack behavior for non-tank enemies
                            // Corrupted Circuitry: Hacked enemies emit volt chains every 2s
                            if (player.synergies.volt_hack) {
                                if (!this.hackState.chainTimer) this.hackState.chainTimer = 0;
                                this.hackState.chainTimer++;
                                if (this.hackState.chainTimer >= 120) { // Every 2 seconds
                                    player.chainVolt(this, player.damage * 0.5, 0, 1);
                                    this.hackState.chainTimer = 0;
                                }
                            }
                            
                            // Shatter Protocol: Hacked enemies emit freeze pulses every 2s
                            if (player.synergies.cryo_hack) {
                                if (!this.hackState.freezeTimer) this.hackState.freezeTimer = 0;
                                this.hackState.freezeTimer++;
                                if (this.hackState.freezeTimer >= 120) { // Every 2 seconds
                                    entities.enemies.forEach(e => {
                                        if (e !== this && e.hp > 0 && e.type !== 'boss' && Math.sqrt((e.x-this.x)**2 + (e.y-this.y)**2) < 100) {
                                            e.cryoState.frozenTimer = 60; // 1s freeze pulse
                                        }
                                    });
                                    this.hackState.freezeTimer = 0;
                                }
                            }
                            
                            // Find CLOSEST enemy that's not hacked
                            let nearest = null;
                            let nearestDist = 400; // Max detection range
                        
                        entities.enemies.forEach(e => {
                            if (e !== this && e.hp > 0 && !e.hackState.active) {
                                const dist = Math.sqrt((e.x-this.x)**2 + (e.y-this.y)**2);
                                if (dist < nearestDist) {
                                    nearest = e;
                                    nearestDist = dist;
                                }
                            }
                        });
                        
                        if (nearest) {
                            const dx = nearest.x - this.x; const dy = nearest.y - this.y;
                            const attackRange = this.radius + nearest.radius + 15;
                            
                            // If in attack range, stop and attack
                            if (nearestDist < attackRange) {
                                this.vx = 0;
                                this.vy = 0;
                                // Deal damage every 20 frames (not every frame)
                                if (!this.hackAttackTimer) this.hackAttackTimer = 0;
                                this.hackAttackTimer++;
                                
                                if (this.hackAttackTimer >= 20) {
                                    // Scale damage to target's max HP: 5% per tick (7.5% with mastery)
                                    const targetMaxHp = nearest.maxHp || nearest.hp || 100;
                                    const hpPercent = player.elementalMasteries.hack ? 0.075 : 0.05;
                                    const hackDmg = targetMaxHp * hpPercent;
                                    nearest.takeDamage(hackDmg, '#00ffff', false, 'normal', null, 'hack'); // Add hack element icon
                                    this.hackAttackTimer = 0;
                                }
                                
                                // Visual feedback
                                if(state.frameCount % 4 === 0) {
                                    entities.particles.push(new Particle(nearest.x, nearest.y, '#00ffff', 1.0));
                                }
                            } else {
                                // Reset attack timer when moving
                                this.hackAttackTimer = 0;
                                // Move toward target
                                this.vx = (dx/nearestDist) * this.speed * 2.0;
                                this.vy = (dy/nearestDist) * this.speed * 2.0;
                            }
                        } else {
                            // Random wander if no target
                            if (seededRandom() < 0.1) { 
                                const angle = seededRandom() * Math.PI * 2; 
                                this.vx = Math.cos(angle) * this.speed; 
                                this.vy = Math.sin(angle) * this.speed; 
                            }
                        }
                        this.x += this.vx * (dt/16); this.y += this.vy * (dt/16);
                        } // Close else block for non-tank hack behavior
                        return;
                    }
                }

                // EMP State: Enemy is completely disabled
                if (this.empState.active) {
                    this.empState.timer -= dt/16;
                    if (this.empState.timer <= 0) {
                        this.empState.active = false;
                    } else {
                        // Completely immobilized - don't move at all
                        return;
                    }
                }
                
                // Ion State: Enemy takes +30% damage from all sources
                if (this.ionState.active) {
                    this.ionState.timer -= dt/16;
                    if (this.ionState.timer <= 0) {
                        this.ionState.active = false;
                    }
                }

                // Repulser: Strong push away from player
                if (player.repulserActive) {
                    const dx = this.x - player.x;
                    const dy = this.y - player.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    if (dist < 300) { // Push radius
                        const pushStrength = (300 - dist) / 300; // Stronger when closer
                        const pushForce = 20 * pushStrength; // Very strong push
                        this.pushX = (dx/dist) * pushForce;
                        this.pushY = (dy/dist) * pushForce;
                    }
                }

                // VOIDWALKER BEHAVIOR - Phase-based teleporting bomb
                if (this.type === 'voidwalker') {
                    this.pulsePhase += 0.15 * (dt/16);
                    
                    // IMMEDIATE TELEPORT WHEN HACKED
                    if (this.hackState.active && !this.hasBeenHacked) {
                        this.hasBeenHacked = true; // Flag to prevent repeated teleports
                        
                        // Find densest enemy cluster
                        let bestTarget = null;
                        let bestCount = 0;
                        
                        entities.enemies.forEach(e => {
                            if (e !== this && e.hp > 0 && !e.hackState.active) {
                                const nearbyCount = entities.enemies.filter(ne => {
                                    if (ne === this || ne === e || ne.hackState.active || ne.hp <= 0) return false;
                                    const dist = Math.sqrt((ne.x - e.x)**2 + (ne.y - e.y)**2);
                                    return dist < 120;
                                }).length;
                                
                                if (nearbyCount > bestCount) {
                                    bestCount = nearbyCount;
                                    bestTarget = e;
                                }
                            }
                        });
                        
                        if (bestTarget) {
                            // Teleport to cluster center
                            const angle = seededRandom() * Math.PI * 2;
                            this.x = bestTarget.x + Math.cos(angle) * 20;
                            this.y = bestTarget.y + Math.sin(angle) * 20;
                            
                            // Force countdown state
                            this.phaseState = 'countdown';
                            this.countdownTimer = 60; // 1 second
                            this.opacity = 1.0;
                            this.warningCircleRadius = 0;
                            this.driftTarget = bestTarget;
                            
                            // Visual feedback
                            createExplosion(this.x, this.y, '#00ff00', 30);
                            entities.particles.push(new Shockwave(this.x, this.y, 80, '#00ff00'));
                        }
                    }
                    
                    // PHASE STATE MACHINE
                    if (this.phaseState === 'phased') {
                        // PHASED OUT - Invulnerable, drifting toward target
                        this.opacity = 0.3; // Semi-transparent
                        
                        // Determine target (player or enemy cluster if hacked)
                        let target = player;
                        if (this.hackState.active) {
                            // Find densest enemy cluster
                            let bestTarget = null;
                            let bestCount = 0;
                            
                            entities.enemies.forEach(e => {
                                if (e !== this && e.hp > 0 && !e.hackState.active) {
                                    const nearbyCount = entities.enemies.filter(ne => {
                                        if (ne === this || ne === e || ne.hackState.active || ne.hp <= 0) return false;
                                        const dist = Math.sqrt((ne.x - e.x)**2 + (ne.y - e.y)**2);
                                        return dist < 120;
                                    }).length;
                                    
                                    if (nearbyCount > bestCount) {
                                        bestCount = nearbyCount;
                                        bestTarget = e;
                                    }
                                }
                            });
                            
                            if (bestTarget) target = bestTarget;
                        }
                        
                        this.driftTarget = target;
                        
                        // Slow drift toward target
                        const dx = target.x - this.x;
                        const dy = target.y - this.y;
                        const dist = Math.sqrt(dx*dx + dy*dy);
                        if (dist > 0) {
                            const driftSpeed = 0.4;
                            this.vx = (dx/dist) * driftSpeed;
                            this.vy = (dy/dist) * driftSpeed;
                        }
                        
                        // Count down phase timer
                        this.phaseTimer -= dt/16;
                        
                        if (this.phaseTimer <= 0) {
                            // MATERIALIZE!
                            this.phaseState = 'countdown';
                            
                            // Materialize at random point within range of target
                            const angle = seededRandom() * Math.PI * 2;
                            const distance = this.materializeRange[0] + seededRandom() * (this.materializeRange[1] - this.materializeRange[0]);
                            
                            // For hacked voidwalkers, materialize closer (center of cluster)
                            if (this.hackState.active && target !== player) {
                                this.x = target.x + Math.cos(angle) * 20; // Very close to cluster center
                                this.y = target.y + Math.sin(angle) * 20;
                                this.countdownTimer = 60; // 1 second for hacked
                            } else {
                                this.x = target.x + Math.cos(angle) * distance;
                                this.y = target.y + Math.sin(angle) * distance;
                                this.countdownTimer = 120; // 2 seconds for normal
                            }
                            
                            this.opacity = 1.0; // Fully visible
                            this.warningCircleRadius = 0;
                            
                            // Visual/audio feedback
                            createExplosion(this.x, this.y, this.hackState.active ? '#00ff00' : '#9933ff', 20);
                            entities.particles.push(new Shockwave(this.x, this.y, 60, this.hackState.active ? '#00ff00' : '#9933ff'));
                        }
                    } 
                    
                    // COUNTDOWN STATE (note: not else if, so it can run same frame after hack teleport)
                    if (this.phaseState === 'countdown') {
                        // COUNTDOWN - Vulnerable, drifting toward target, warning circle
                        this.opacity = 1.0; // Fully visible and vulnerable
                        
                        // Slow drift toward target
                        if (this.driftTarget) {
                            const dx = this.driftTarget.x - this.x;
                            const dy = this.driftTarget.y - this.y;
                            const dist = Math.sqrt(dx*dx + dy*dy);
                            if (dist > 0) {
                                const driftSpeed = 0.6;
                                this.vx = (dx/dist) * driftSpeed;
                                this.vy = (dy/dist) * driftSpeed;
                            }
                        }
                        
                        // Animate warning circle
                        const maxTimer = this.hackState.active ? 60 : 120;
                        const progress = 1 - (this.countdownTimer / maxTimer);
                        this.warningCircleRadius = this.blastRadius * (0.8 + Math.sin(progress * Math.PI * 8) * 0.2);
                        
                        // Countdown
                        this.countdownTimer -= dt/16;
                        
                        if (this.countdownTimer <= 0) {
                            // DETONATE!
                            this.triggerDetonation();
                            this.hp = 0; // Kill self
                            return; // Don't continue update
                        }
                    }
                }

                if (this.type === 'tank' || (this.type === 'boss' && this.chargeState > 0)) {
                    if (this.chargeState === 0) {
                        // TANK MOVEMENT (Slow chase)
                        const dist = Math.sqrt((player.x - this.x)**2 + (player.y - this.y)**2);
                        this.vx = ((player.x - this.x)/dist) * this.speed;
                        this.vy = ((player.y - this.y)/dist) * this.speed;
                        
                        const triggerDist = this.type === 'boss' ? 500 : 400;
                        const chance = this.type === 'boss' ? 0.05 : 0.01;
                        if (dist < triggerDist && dist > 100 && seededRandom() < chance) {
                            this.chargeState = 1; this.chargeTimer = (this.type==='boss') ? 60 : 40; // Boss: 60 frames (1s), Tank: 40 frames - increased for more reaction time
                            this.chargeTarget = {x:player.x, y:player.y};
                            this.chargeAngle = Math.atan2(player.y-this.y, player.x-this.x);
                            this.vx=0; this.vy=0;
                        }
                    }
                    else if (this.chargeState === 1) {
                        this.chargeTimer -= (dt/16);
                        const targetAngle = Math.atan2(player.y - this.y, player.x - this.x);
                        let diff = targetAngle - this.chargeAngle;
                        while (diff <= -Math.PI) diff += Math.PI*2; while (diff > Math.PI) diff -= Math.PI*2;
                        
                        // Decay Tracking (Lazy Lock)
                        const maxTimer = (this.type==='boss') ? 60 : 40; // Updated boss timer
                        const trackCutoff = maxTimer * 0.3; 
                        let trackStrength = 0;
                        if(this.chargeTimer > trackCutoff) {
                            trackStrength = 0.1 * ((this.chargeTimer - trackCutoff) / (maxTimer - trackCutoff));
                        }
                        this.chargeAngle += diff * trackStrength;


                        if (this.chargeTimer <= 0) {
                            this.chargeState = 2; this.chargeTimer = (this.type === 'boss') ? 20 : 30; // Boss: 20 frames (reduced from 30 to prevent off-screen)
                            const dashSpeed = this.type === 'boss' ? 24 : 12; // Boss speed: 24 (reduced from 28 for more forgiving dodging)
                            this.vx = Math.cos(this.chargeAngle)*dashSpeed; this.vy = Math.sin(this.chargeAngle)*dashSpeed;
                        }
                    }
                    else if (this.chargeState === 2) {
                        this.chargeTimer -= (dt/16);
                        if(state.frameCount%3===0) entities.particles.push(new Particle(this.x, this.y, '#ffaa00', 0.5));
                        if (this.chargeTimer <= 0) { 
                            this.chargeState = 3; 
                            this.chargeTimer = 420; // 7s CD
                            this.vx=0; this.vy=0; 
                        }
                    }
                    else if (this.chargeState === 3) {
                        this.chargeTimer -= (dt/16);
                        // MOVEMENT DURING COOLDOWN
                        const dist = Math.sqrt((player.x - this.x)**2 + (player.y - this.y)**2);
                        this.vx = ((player.x - this.x)/dist) * this.speed;
                        this.vy = ((player.y - this.y)/dist) * this.speed;
                        if (this.chargeTimer <= 0) this.chargeState = 0;
                    }
                } 
                
                if (this.type === 'boss' || this.isChampion) {
                    state.bossTimer++;
                    const hpPercent = (this.hp / this.maxHp * 100);
                    document.getElementById('boss-bar').style.width = hpPercent + '%';
                    
                    // Champions have orange health bar, bosses have red/magenta
                    if (this.isChampion) {
                        document.getElementById('boss-bar').style.background = '#ff6600';
                        document.getElementById('boss-bar').style.boxShadow = '0 0 20px #ff6600';
                    } else {
                        // Change health bar color in phase 2 (boss only)
                        if (this.phase === 2) {
                            document.getElementById('boss-bar').style.background = '#ff00ff';
                            document.getElementById('boss-bar').style.boxShadow = '0 0 20px #ff00ff';
                        }
                    }
                    
                    // PHASE 2 TRANSITION at 50% HP (boss only, not champion)
                    if (!this.isChampion && this.hp <= this.maxHp * 0.5 && !this.phase2Triggered) {
                        this.phase2Triggered = true;
                        this.phase = 2;
                        this.color = '#ff00ff'; // Change to magenta in phase 2
                        
                        // Add phase 2 abilities to pool
                        this.abilities = [...this.abilities, ...this.phase2Abilities];
                        
                        // Summon 5 elite drones
                        for (let i = 0; i < 5; i++) {
                            const angle = (i / 5) * Math.PI * 2;
                            const spawnDist = 150;
                            const spawnX = this.x + Math.cos(angle) * spawnDist;
                            const spawnY = this.y + Math.sin(angle) * spawnDist;
                            const elite = new Enemy('drone');
                            elite.x = spawnX;
                            elite.y = spawnY;
                            elite.hp *= 1.5; // Elite drones are 50% tougher
                            elite.maxHp = elite.hp;
                            elite.color = '#ff00ff'; // Match boss phase 2 color
                            entities.enemies.push(elite);
                        }
                        
                        // Visual effect
                        for (let i = 0; i < 30; i++) {
                            entities.particles.push(new Particle(this.x, this.y, '#ff00ff', 2.0));
                        }
                        createExplosion(this.x, this.y, '#ff00ff', 60);
                    }
                    
                    // State Machine
                    if (this.actionState === 'cooldown') {
                        // Movement during cooldown: Chase slowly
                        const dx = player.x - this.x; const dy = player.y - this.y;
                        const dist = Math.sqrt(dx*dx + dy*dy);
                        this.vx = (dx/dist) * this.speed * 0.5; 
                        this.vy = (dy/dist) * this.speed * 0.5;
                        
                        this.actionTimer -= (dt/16);
                        if (this.actionTimer <= 0) {
                            // Pick Attack from Random Pool
                            this.actionState = 'attacking';
                            this.currentAttack = this.abilities[Math.floor(seededRandom() * this.abilities.length)];


                            if (this.currentAttack === 2) { // Charge
                                this.chargeState = 1; this.chargeTimer = 60; // Updated to match new timing
                                this.chargeAngle = Math.atan2(player.y-this.y, player.x-this.x);
                                this.vx = 0; this.vy = 0;
                                this.actionTimer = 200; 
                            } else {
                                this.actionTimer = 240; // Attack Duration
                            }
                        }
                    } else if (this.actionState === 'attacking') {
                        this.actionTimer -= (dt/16);
                        
                        if (this.currentAttack === 0) { // Spiral - Reduced density
                            this.vx *= 0.9; this.vy *= 0.9;
                            if (Math.floor(this.actionTimer) % 12 === 0) {
                                const spiralAngle = this.actionTimer * 0.2;
                                for(let k=0; k<2; k++) {
                                     const ang = spiralAngle + (k * (Math.PI*2/2));
                                     entities.enemyProjectiles.push({ x: this.x, y: this.y, vx: Math.cos(ang)*5, vy: Math.sin(ang)*5, radius: 8, color: '#ff00ff', life: 200, shooter: this });
                                }
                            }
                        } else if (this.currentAttack === 1) { // Nova - Reduced frequency
                            this.vx = 0; this.vy = 0;
                            if (Math.floor(this.actionTimer) % 100 === 0) {
                                for(let k=0; k<12; k++) {
                                    const ang = (k * (Math.PI*2/12));
                                    entities.enemyProjectiles.push({ x: this.x, y: this.y, vx: Math.cos(ang)*4, vy: Math.sin(ang)*4, radius: 10, color: '#ff5500', life: 200, shooter: this });
                                }
                            }
                        } else if (this.currentAttack === 2) { // Charge
                            if (this.chargeState === 0) this.actionTimer = 0;
                        } else if (this.currentAttack === 3) { // Laser Sweep
                             this.vx = 0; this.vy = 0;
                             if (Math.floor(this.actionTimer) % 8 === 0) {
                                 const ang = Math.sin(this.actionTimer * 0.1) + Math.atan2(player.y-this.y, player.x-this.x);
                                 entities.enemyProjectiles.push({ x: this.x, y: this.y, vx: Math.cos(ang)*8, vy: Math.sin(ang)*8, radius: 6, color: '#00ffff', life: 150, shooter: this });
                             }
                        } else if (this.currentAttack === 4) { // Minion Summon
                             if (Math.floor(this.actionTimer) % 60 === 0) {
                                 entities.enemies.push(new Enemy('drone'));
                                 entities.enemies.push(new Enemy('drone'));
                             }
                        } else if (this.currentAttack === 5) { // Shotgun Burst (fair - telegraphed)
                             this.vx *= 0.95; this.vy *= 0.95;
                             if (Math.floor(this.actionTimer) % 40 === 0) { // Every 40 frames
                                 const toPlayer = Math.atan2(player.y - this.y, player.x - this.x);
                                 for(let k=-2; k<=2; k++) { // 5-way spread
                                     const spread = k * 0.3; // 0.3 rad spread
                                     const ang = toPlayer + spread;
                                     entities.enemyProjectiles.push({ x: this.x, y: this.y, vx: Math.cos(ang)*6, vy: Math.sin(ang)*6, radius: 8, color: '#ff9900', life: 180, shooter: this });
                                 }
                             }
                        } else if (this.currentAttack === 6) { // Ring Pulse (fair - expands outward)
                             this.vx = 0; this.vy = 0;
                             if (Math.floor(this.actionTimer) % 80 === 0) { // Less frequent
                                 for(let k=0; k<8; k++) { // 8 bullets in ring
                                     const ang = (k * (Math.PI*2/8));
                                     entities.enemyProjectiles.push({ x: this.x, y: this.y, vx: Math.cos(ang)*3, vy: Math.sin(ang)*3, radius: 9, color: '#00ffff', life: 200 });
                                 }
                             }
                        } else if (this.currentAttack === 7) { // Homing Shots (fair - slow)
                             this.vx *= 0.9; this.vy *= 0.9;
                             if (Math.floor(this.actionTimer) % 50 === 0) {
                                 const toPlayer = Math.atan2(player.y - this.y, player.x - this.x);
                                 entities.enemyProjectiles.push({ 
                                     x: this.x, y: this.y, 
                                     vx: Math.cos(toPlayer)*2, vy: Math.sin(toPlayer)*2, 
                                     radius: 7, color: '#ff00aa', life: 250,
                                     homing: true // Flag for homing behavior
                                 });
                             }
                        } else if (this.currentAttack === 8) { // Barrage - Rapid fire straight at player
                             this.vx = 0; this.vy = 0;
                             if (Math.floor(this.actionTimer) % 6 === 0) { // Very rapid
                                 const toPlayer = Math.atan2(player.y - this.y, player.x - this.x);
                                 const spread = (seededRandom() - 0.5) * 0.2; // Small random spread
                                 entities.enemyProjectiles.push({ 
                                     x: this.x, y: this.y, 
                                     vx: Math.cos(toPlayer + spread)*7, 
                                     vy: Math.sin(toPlayer + spread)*7, 
                                     radius: 6, color: '#ffff00', life: 150
                                 });
                             }
                        } else if (this.currentAttack === 9) { // Meteor Rain - Telegraphed danger zones
                             this.vx *= 0.95; this.vy *= 0.95;
                             if (Math.floor(this.actionTimer) % 50 === 0) { // Reduced frequency (was 30, now 50)
                                 // Spawn 2 meteors instead of constant spam
                                 for(let m = 0; m < 2; m++) {
                                     const targetX = player.x + (seededRandom() - 0.5) * 250;
                                     const targetY = player.y + (seededRandom() - 0.5) * 250;
                                     
                                     // Create warning marker that persists
                                     const warningMarker = {
                                         x: targetX,
                                         y: targetY,
                                         life: 60, // 1 second warning (increased from 500ms)
                                         maxLife: 60,
                                         radius: 50, // Impact radius
                                         isMeteorWarning: true
                                     };
                                     
                                     entities.enemyProjectiles.push(warningMarker);
                                     
                                     // After warning, create impact
                                     setTimeout(() => {
                                         // Only 4 projectiles instead of 8 (50% reduction)
                                         for(let k=0; k<4; k++) {
                                             const ang = (k * (Math.PI*2/4));
                                             entities.enemyProjectiles.push({ 
                                                 x: targetX, y: targetY, 
                                                 vx: Math.cos(ang)*3, // Slower (was 4)
                                                 vy: Math.sin(ang)*3, 
                                                 radius: 8, // Smaller (was 10)
                                                 color: '#ff8800', 
                                                 life: 120 // Shorter range (was 180)
                                             });
                                         }
                                         // Impact explosion visual
                                         createExplosion(targetX, targetY, '#ff8800', 12);
                                     }, 1000); // Full 1 second warning (was 500ms)
                                 }
                             }
                        }


                        if (this.actionTimer <= 0) {
                            this.actionState = 'cooldown';
                            this.actionTimer = 120; // 2s Cooldown
                        }
                    }
                } else if (this.type !== 'tank') {
                    // SPLITTER: Ranged attacker - stops and fires
                    if (this.type === 'splitter') {
                        const targetIsPlayer = !this.hackState.active;
                        let target = targetIsPlayer ? player : null;
                        
                        // If hacked, find nearest non-hacked enemy
                        if (!targetIsPlayer) {
                            target = entities.enemies.find(e => 
                                e !== this && 
                                e.hp > 0 && 
                                !e.hackState.active &&
                                Math.sqrt((e.x - this.x)**2 + (e.y - this.y)**2) < 400
                            );
                        }
                        
                        if (target) {
                            const dx = target.x - this.x;
                            const dy = target.y - this.y;
                            const dist = Math.sqrt(dx*dx + dy*dy);
                            
                            // Keep distance (200-300 range), kite backwards if too close
                            const idealDist = 250;
                            const tooClose = 180;
                            
                            if (dist > idealDist) {
                                // Move closer
                                if (dist > 0) { 
                                    this.vx = (dx/dist) * this.speed * 0.8; 
                                    this.vy = (dy/dist) * this.speed * 0.8; 
                                }
                            } else if (dist < tooClose) {
                                // Kite backwards
                                if (dist > 0) { 
                                    this.vx = -(dx/dist) * this.speed * 0.6; 
                                    this.vy = -(dy/dist) * this.speed * 0.6; 
                                }
                            } else {
                                // In ideal range - slow down
                                this.vx *= 0.9;
                                this.vy *= 0.9;
                            }
                            
                            // Fire projectile
                            this.splitterAttackTimer += dt/16;
                            if (this.splitterAttackTimer >= this.splitterMaxAttackTimer && dist < 350) {
                                const angle = Math.atan2(dy, dx);
                                
                                // Create a large, slow, VERY visible projectile
                                entities.enemyProjectiles.push({
                                    x: this.x,
                                    y: this.y,
                                    vx: Math.cos(angle) * 3.5, // Slow speed for reaction time
                                    vy: Math.sin(angle) * 3.5,
                                    radius: 9, // Reduced from 14 - still visible but not confusing
                                    color: '#ff9500', // Matches splitter orange color
                                    life: 150, // Reduced from 250 - travels less distance
                                    splitterShot: true, // Flag for special rendering
                                    glowPhase: 0, // For pulsing glow effect
                                    targetWasPlayer: targetIsPlayer, // Track what it was shot at
                                    shooter: this // Track origin enemy for whip deflection
                                });
                                
                                // Visual feedback - charging effect
                                for(let i=0; i<8; i++) {
                                    const particleAngle = (Math.PI * 2 / 8) * i;
                                    entities.particles.push(new Particle(
                                        this.x + Math.cos(particleAngle) * 15,
                                        this.y + Math.sin(particleAngle) * 15,
                                        '#ff9500',
                                        1.2
                                    ));
                                }
                                
                                this.splitterAttackTimer = 0;
                            }
                        } else {
                            // No target - wander
                            const dx = player.x - this.x;
                            const dy = player.y - this.y;
                            const dist = Math.sqrt(dx*dx + dy*dy);
                            if (dist > 0) { 
                                this.vx = (dx/dist) * this.speed * 0.5; 
                                this.vy = (dy/dist) * this.speed * 0.5; 
                            }
                        }
                    } else {
                        // Regular enemy movement (drone, swarm)
                        const dx = player.x - this.x; const dy = player.y - this.y;
                        const dist = Math.sqrt(dx*dx + dy*dy);
                        if (dist > 0) { this.vx = (dx/dist)*this.speed; this.vy = (dy/dist)*this.speed; }
                    }
                }


                // Swarmers have Flight
                if(this.type === 'swarm') {
                    this.x += (this.vx * cryoSlow * empSlow) * (dt/16);
                    this.y += (this.vy * cryoSlow * empSlow) * (dt/16);
                } else {
                    if (this.type !== 'tank' && !(this.type==='boss' && this.currentAttack===2 && this.actionState === 'attacking')) {
                        this.x += (this.vx * cryoSlow * empSlow) * (dt/16);
                        this.y += (this.vy * cryoSlow * empSlow) * (dt/16);
                    }
                    
                    if ((this.type === 'tank' || (this.type === 'boss' && this.currentAttack===2)) && (this.chargeState === 2 || this.chargeState === 0 || this.chargeState === 3)) {
                          this.x += (this.vx * cryoSlow * empSlow) * (dt/16);
                          this.y += (this.vy * cryoSlow * empSlow) * (dt/16);
                    }


                    let sepX = 0, sepY = 0;
                    for (let other of entities.enemies) {
                        if (other === this || other.type === 'swarm') continue; // Ignore swarms
                        if (this.hackState.active || other.hackState.active) continue; // Hacked enemies ignore separation
                        
                        // Frozen enemies act as solid obstacles
                        const treatAsSolid = other.cryoState.frozen;
                        
                        const odx = this.x - other.x; const ody = this.y - other.y;
                        const odist = Math.sqrt(odx*odx + ody*ody);
                        const minSep = this.radius + other.radius + (treatAsSolid ? 10 : 5); // Extra space around frozen
                        
                        if (odist < minSep && odist > 0) { 
                            const f = (minSep - odist) / odist * (treatAsSolid ? 3.0 : 1.0); // Stronger push from frozen
                            sepX += odx * f; 
                            sepY += ody * f; 
                        }
                    }
                    if (this.type !== 'tank' && !(this.type==='boss' && this.currentAttack===2 && this.actionState === 'attacking')) {
                        this.x += (sepX * 2.0 * cryoSlow) * (dt/16);
                        this.y += (sepY * 2.0 * cryoSlow) * (dt/16);
                    }
                }


                this.x += this.pushX * (dt/16); this.y += this.pushY * (dt/16);
                this.pushX *= 0.8; this.pushY *= 0.8;
                if (this.flash > 0) this.flash -= (dt/16);


                const dist = Math.sqrt((player.x - this.x)**2 + (player.y - this.y)**2);
                if (dist < this.radius + player.radius && this.type !== 'splitter') { // Splitters don't do melee damage
                    // HACK: Hacked enemies attack other enemies instead of player
                    if (this.hackState.active && this.type !== 'boss') {
                        const nearestEnemy = entities.enemies.find(e => 
                            e !== this && 
                            e.hp > 0 && 
                            !e.hackState.active &&
                            Math.sqrt((e.x - this.x)**2 + (e.y - this.y)**2) < 200
                        );
                        if (nearestEnemy) {
                            nearestEnemy.takeDamage(this.dmg * 5, '#00ffff', false, 'normal'); // Increased from 3x to 5x damage
                            for (let i=0; i<8; i++) entities.particles.push(new Particle(nearestEnemy.x, nearestEnemy.y, '#00ffff', 1.5));
                            entities.lightnings.push(new LightningBolt(this.x, this.y, nearestEnemy.x, nearestEnemy.y, '#00ffff'));
                        }
                    } else {
                        player.takeHit(this.dmg);
                    }
                }
            }
            draw(ctx) {
                if ((this.type === 'tank' || (this.type==='boss' && this.currentAttack===2)) && this.chargeState === 1) {
                    ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(this.chargeAngle);
                    ctx.fillStyle = `rgba(255,0,0,${0.4+Math.sin(state.frameCount*0.5)*0.2})`; // BRIGHT RED
                    ctx.fillRect(0, -this.radius, 400, this.radius*2);
                    ctx.restore();
                }


                ctx.save(); ctx.translate(this.x, this.y);
                ctx.fillStyle = this.flash > 0 ? '#fff' : this.color;
                
                // Color Override for Elements
                if (this.cryoState.frozen) {
                    // Frozen solid - bright ice blue with glow
                    ctx.fillStyle = '#88d8ff';
                    ctx.shadowColor = '#88d8ff';
                    ctx.shadowBlur = 15;
                    
                    // Draw ice crystal shards radiating outward
                    ctx.strokeStyle = 'rgba(179, 245, 255, 0.9)';
                    ctx.fillStyle = 'rgba(179, 245, 255, 0.6)';
                    ctx.lineWidth = 2;
                    
                    const shardCount = 6;
                    const shardLength = this.radius * 0.8;
                    const shardWidth = this.radius * 0.3;
                    
                    for (let i = 0; i < shardCount; i++) {
                        const angle = (Math.PI * 2 * i / shardCount) + (this.animTick * 0.01);
                        const baseRadius = this.radius * 0.5; // Closer to enemy center for tighter jagged look
                        
                        ctx.save();
                        ctx.rotate(angle);
                        
                        // Draw diamond-shaped ice shard
                        ctx.beginPath();
                        ctx.moveTo(baseRadius, 0);
                        ctx.lineTo(baseRadius + shardLength * 0.5, -shardWidth);
                        ctx.lineTo(baseRadius + shardLength, 0);
                        ctx.lineTo(baseRadius + shardLength * 0.5, shardWidth);
                        ctx.closePath();
                        
                        ctx.fill();
                        ctx.stroke();
                        ctx.restore();
                    }
                    
                    // Add frozen core glow
                    ctx.fillStyle = 'rgba(136, 216, 255, 0.3)';
                    ctx.beginPath();
                    ctx.arc(0, 0, this.radius + 4, 0, Math.PI * 2);
                    ctx.fill();
                } else if (this.cryoState.slowed) {
                    // Slowed - light frost overlay
                    ctx.fillStyle = '#cce6ff';
                    
                    // Add occasional frost particles for visual feedback
                    if (seededRandom() < 0.05 && this.animTick % 10 < 1) {
                        entities.particles.push(new Particle(
                            this.x + (seededRandom() - 0.5) * this.radius,
                            this.y + (seededRandom() - 0.5) * this.radius,
                            '#cce6ff',
                            0.8
                        ));
                    }
                } else if (this.bioState.active) {
                    ctx.fillStyle = '#00cc44';
                } else if (this.pyroState.active) {
                    ctx.fillStyle = '#ffaa00';
                } else if (this.hackState.active) {
                    ctx.fillStyle = '#00ffff';
                }

                // CHAMPION GLOW - orange pulsing aura
                if (this.isChampion) {
                    const pulseIntensity = 0.5 + Math.sin(state.frameCount * 0.1) * 0.3;
                    ctx.shadowColor = '#ff6600';
                    ctx.shadowBlur = 25 * pulseIntensity;
                    
                    // Draw outer glow ring
                    ctx.strokeStyle = `rgba(255, 102, 0, ${0.6 * pulseIntensity})`;
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.arc(0, 0, this.radius + 8, 0, Math.PI * 2);
                    ctx.stroke();
                }

                if (this.type === 'boss') {
                    // Boss color changes based on state
                    let bossColor = this.color; // Base color (red in P1, magenta in P2)
                    
                    // Attacking: Brighten and add glow
                    if (this.actionState === 'attacking') {
                        if (this.phase === 2) {
                            bossColor = '#ff00ff'; // Bright magenta when attacking in phase 2
                            ctx.shadowColor = '#ff00ff';
                            ctx.shadowBlur = 20;
                        } else {
                            bossColor = '#ff5555'; // Bright red when attacking
                            ctx.shadowColor = '#ff0000';
                            ctx.shadowBlur = 20;
                        }
                    } 
                    // Cooldown: Darker
                    else if (this.actionState === 'cooldown') {
                        if (this.phase === 2) {
                            bossColor = '#990099'; // Dark magenta during cooldown
                        } else {
                            bossColor = '#990000'; // Dark red during cooldown
                        }
                    }
                    
                    ctx.fillStyle = bossColor;
                    ctx.rotate(this.animTick * 0.5);
                    ctx.beginPath(); ctx.moveTo(this.radius, 0); ctx.lineTo(-this.radius/2, this.radius); ctx.lineTo(-this.radius/2, -this.radius); ctx.fill();
                    
                    // Outline color matches phase
                    ctx.strokeStyle = this.phase === 2 ? '#ff00ff' : '#ff0000'; 
                    ctx.lineWidth = 4; 
                    ctx.stroke();
                } else if (this.type === 'drone') {
                    ctx.rotate(this.animTick); ctx.strokeStyle = this.color; ctx.lineWidth = 2;
                    ctx.beginPath(); ctx.moveTo(this.radius, 0); ctx.lineTo(-this.radius/2, this.radius/2); ctx.lineTo(-this.radius/2, -this.radius/2); ctx.closePath(); ctx.stroke();
                    ctx.beginPath(); ctx.arc(0,0, 4, 0, Math.PI*2); ctx.fill();
                } else if (this.type === 'tank') {
                    if (this.chargeState === 1) ctx.translate((seededRandom()-0.5)*4, (seededRandom()-0.5)*4);
                    ctx.shadowColor = this.color; ctx.shadowBlur = 10;
                    ctx.fillRect(-this.radius, -this.radius, this.radius*2, this.radius*2);
                    const scale = 0.8 + Math.sin(this.animTick)*0.1;
                    ctx.fillStyle = '#000'; ctx.fillRect(-this.radius*scale, -this.radius*scale, this.radius*2*scale, this.radius*2*scale);
                } else if (this.type === 'splitter') {
                    // Splitter: pulsing hexagon to indicate it will split
                    const pulse = 1 + Math.sin(this.animTick * 3) * 0.15; // Faster pulse
                    ctx.scale(pulse, pulse);
                    ctx.shadowColor = this.color; ctx.shadowBlur = 15;
                    ctx.beginPath();
                    for (let i = 0; i < 6; i++) {
                        const angle = (Math.PI / 3) * i;
                        const x = Math.cos(angle) * this.radius;
                        const y = Math.sin(angle) * this.radius;
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.closePath();
                    ctx.fill();
                    // Inner core
                    ctx.fillStyle = 'rgba(255,255,255,0.3)';
                    ctx.beginPath();
                    ctx.arc(0, 0, this.radius * 0.4, 0, Math.PI * 2);
                    ctx.fill();
                } else if (this.type === 'voidwalker') {
                    // Voidwalker: Rotating crystal/diamond with phase-based appearance
                    const isHacked = this.hackState.active;
                    const baseColor = isHacked ? '#00ff00' : '#9933ff';
                    const glowColor = isHacked ? '#00ff88' : '#cc66ff';
                    
                    // Apply opacity based on phase state
                    ctx.globalAlpha = this.opacity;
                    
                    // Warning circle on ground (during countdown)
                    if (this.phaseState === 'countdown' && this.warningCircleRadius > 0) {
                        const maxTimer = isHacked ? 60 : 120;
                        const progress = 1 - (this.countdownTimer / maxTimer);
                        
                        // Pulsing warning circle
                        ctx.strokeStyle = isHacked ? 'rgba(0, 255, 0, 0.4)' : 'rgba(153, 51, 255, 0.4)';
                        ctx.lineWidth = 3;
                        ctx.setLineDash([10, 5]);
                        ctx.beginPath();
                        ctx.arc(0, 0, this.warningCircleRadius, 0, Math.PI*2);
                        ctx.stroke();
                        ctx.setLineDash([]);
                        
                        // Inner fill
                        const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, this.warningCircleRadius);
                        gradient.addColorStop(0, isHacked ? 'rgba(0, 255, 0, 0.05)' : 'rgba(153, 51, 255, 0.05)');
                        gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
                        ctx.fillStyle = gradient;
                        ctx.beginPath();
                        ctx.arc(0, 0, this.warningCircleRadius, 0, Math.PI*2);
                        ctx.fill();
                    }
                    
                    // Pulse based on state
                    let pulseSpeed = this.phaseState === 'phased' ? 2 : 8;
                    let pulseIntensity = this.phaseState === 'phased' ? 0.1 : 0.25;
                    
                    if (this.phaseState === 'countdown') {
                        const maxTimer = isHacked ? 60 : 120;
                        const countdown = this.countdownTimer / maxTimer;
                        pulseSpeed = 8 + (1 - countdown) * 12; // Accelerates to 20
                        pulseIntensity = 0.25 + (1 - countdown) * 0.2;
                    }
                    
                    const pulse = 1 + Math.sin(this.pulsePhase * pulseSpeed) * pulseIntensity;
                    ctx.scale(pulse, pulse);
                    
                    // Rotation (faster when counting down)
                    const rotationSpeed = this.phaseState === 'countdown' ? 0.08 : 0.03;
                    ctx.rotate(this.animTick * rotationSpeed);
                    
                    // Shadow/glow
                    ctx.shadowColor = glowColor;
                    ctx.shadowBlur = this.phaseState === 'countdown' ? 30 : 20;
                    
                    // Draw diamond/crystal shape (4-pointed star)
                    const size = this.radius * 1.2;
                    
                    // Outer diamond
                    ctx.fillStyle = baseColor;
                    ctx.beginPath();
                    ctx.moveTo(0, -size);
                    ctx.lineTo(size * 0.5, 0);
                    ctx.lineTo(0, size);
                    ctx.lineTo(-size * 0.5, 0);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Inner crystal layers
                    if (this.phaseState === 'countdown') {
                        // Bright pulsing inner diamond
                        ctx.fillStyle = isHacked ? '#88ffcc' : '#ff66ff';
                        ctx.shadowBlur = 20;
                        ctx.beginPath();
                        ctx.moveTo(0, -size * 0.6);
                        ctx.lineTo(size * 0.3, 0);
                        ctx.lineTo(0, size * 0.6);
                        ctx.lineTo(-size * 0.3, 0);
                        ctx.closePath();
                        ctx.fill();
                        
                        // Bright center core
                        ctx.fillStyle = '#ffffff';
                        ctx.shadowBlur = 15;
                        ctx.beginPath();
                        ctx.moveTo(0, -size * 0.3);
                        ctx.lineTo(size * 0.15, 0);
                        ctx.lineTo(0, size * 0.3);
                        ctx.lineTo(-size * 0.15, 0);
                        ctx.closePath();
                        ctx.fill();
                    } else {
                        // Dim core when phased
                        ctx.fillStyle = baseColor;
                        ctx.globalAlpha = this.opacity * 0.6;
                        ctx.beginPath();
                        ctx.moveTo(0, -size * 0.5);
                        ctx.lineTo(size * 0.25, 0);
                        ctx.lineTo(0, size * 0.5);
                        ctx.lineTo(-size * 0.25, 0);
                        ctx.closePath();
                        ctx.fill();
                    }
                    
                    // Energy particles orbiting (during countdown)
                    if (this.phaseState === 'countdown') {
                        ctx.globalAlpha = 1.0;
                        const particleCount = 4;
                        for (let i = 0; i < particleCount; i++) {
                            const angle = (this.animTick * 0.1) + (i * Math.PI * 2 / particleCount);
                            const dist = size * 0.8;
                            const px = Math.cos(angle) * dist;
                            const py = Math.sin(angle) * dist;
                            
                            ctx.fillStyle = glowColor;
                            ctx.beginPath();
                            ctx.arc(px, py, 2, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    }
                    
                    ctx.globalAlpha = 1.0; // Reset opacity
                } else {
                    const pulse = 1 + Math.sin(this.animTick * 2) * 0.2;
                    ctx.scale(pulse, pulse); ctx.beginPath(); ctx.moveTo(0, -this.radius); ctx.lineTo(this.radius, this.radius); ctx.lineTo(-this.radius, this.radius); ctx.fill();
                }
                
                ctx.restore();
            }
        }


        class Projectile {
            constructor(x, y, vx, vy, damage, pierce, type, target, source, detectionRadius) {
                this.x = x; this.y = y; this.vx = vx; this.vy = vy;
                this.damage = damage; this.pierce = pierce; this.type = type; this.source = source;
                this.life = type === 'seeker' ? 180 : type === 'mine' ? 600 : type === 'gas_grenade' ? 90 : type === 'railgun' ? 45 : type === 'ricochet' ? 180 : 70; // Ricochet now lasts 3 seconds 
                this.trail = []; this.target = target;
                
                // Mine-specific properties
                if (type === 'mine') {
                    this.detectionRadius = detectionRadius || 60;
                    this.blastRadius = pierce; // Use pierce as blast radius for mines
                    this.triggered = false;
                    this.detonationTimer = 60; // 1 second countdown after trigger
                    this.pulsePhase = 0;
                }
                
                if (type === 'railgun' && typeof target === 'object' && target.level) {
                    this.railLevel = target.level;
                } else {
                    this.railLevel = 1;
                }
                if(type === 'railgun') {
                    this.origX = x; this.origY = y;
                    this.animProgress = 0; // Animation progress 0 to 1
                    this.maxAnimFrames = 8; // Frames to fully extend
                }


                if (type === 'flak_shell') {
                    this.life = 60; 
                    this.flakData = target; 
                    this.distTraveled = 0;
                }


                if (type === 'bio_spore') {
                      this.life = 60;
                      const angle = Math.atan2(target.y-y, target.x-x);
                      this.vx = Math.cos(angle)*6; this.vy = Math.sin(angle)*6;
                }


                this.speed = 12; 
                this.warmup = 15;
                this.triggering = false; this.triggerTimer = 30; 
                this.hasDamaged = false; 
                this.hitList = []; 
                
                if (type === 'meteor_warning') {
                    this.life = 40; // Reduced from 60 frames (~0.67s vs 1s)
                    this.maxLife = 40;
                }
            }
            update(dt) {
                if (this.type === 'flak_shell') {
                    this.x += this.vx * (dt/16);
                    this.y += this.vy * (dt/16);
                    this.distTraveled += Math.sqrt(this.vx*this.vx + this.vy*this.vy) * (dt/16);
                    
                    let hit = false;
                    for(let e of entities.enemies) {
                        if(Math.sqrt((e.x-this.x)**2 + (e.y-this.y)**2) < e.radius + 15) { hit = true; break; }
                    }


                    if (hit || this.distTraveled > this.flakData.range) {
                        createExplosion(this.x, this.y, '#ffff00', 10);
                        const baseAngle = Math.atan2(this.vy, this.vx);
                        const range = 250; 
                        const coneHalfAngle = Math.PI/6; // Widened from π/8 (50% wider cone) 
                        
                        // Buffed damage per pellet burst to compete with other weapons
                        const flakDmg = 45 * (1 + (this.flakData.level-1)*0.3) * (player.damage/15); // Increased from 30, better scaling 


                        entities.enemies.forEach(e => {
                            const dx = e.x - this.x; const dy = e.y - this.y;
                            const dist = Math.sqrt(dx*dx + dy*dy);
                            if (dist < range) {
                                const angleToEnemy = Math.atan2(dy, dx);
                                let diff = angleToEnemy - baseAngle;
                                while (diff <= -Math.PI) diff += Math.PI*2; while (diff > Math.PI) diff -= Math.PI*2;
                                if (Math.abs(diff) < coneHalfAngle) { 
                                    player.dealElementalDamage(e, flakDmg, 'flak', '#ffffff');
                                }
                            }
                        });

                        // Reduce shrapnel particles if many enemies present to prevent lag
                        const enemyCount = entities.enemies.length;
                        const shrapnelCount = enemyCount > 30 ? 10 : (enemyCount > 15 ? 15 : 20);
                        
                        for(let i=0; i<shrapnelCount; i++) {
                             const spread = (seededRandom() - 0.5) * coneHalfAngle * 2;
                             const ang = baseAngle + spread;
                             const speed = 5 + seededRandom() * 8;
                             entities.particles.push(new ShrapnelSpark(this.x, this.y, ang, speed)); 
                        }
                        
                        return false; 
                    }
                    this.life -= dt/16;
                    return this.life > 0;
                }


                if (this.type === 'bio_spore') {
                    this.x += this.vx * (dt/16);
                    this.y += this.vy * (dt/16);
                    if(this.target && this.target.hp > 0) {
                        const angle = Math.atan2(this.target.y-this.y, this.target.x-this.x);
                        this.vx += (Math.cos(angle)*8 - this.vx)*0.1;
                        this.vy += (Math.sin(angle)*8 - this.vy)*0.1;
                        if (Math.sqrt((this.x-this.target.x)**2 + (this.y-this.target.y)**2) < 20) {
                            player.dealElementalDamage(this.target, 0, 'bio', '#00cc44', false, 'bio_spread');
                            return false; 
                        }
                    }
                    this.life -= dt/16;
                    return this.life > 0;
                }


                if (this.type === 'railgun') {
                    const steps = 10; 
                    const len = 375 + (this.railLevel * 25); // Increased base from 250 (50% longer range) 
                    
                    // Animate extension
                    if (this.animProgress < 1) {
                        this.animProgress += (1 / this.maxAnimFrames);
                        if (this.animProgress > 1) this.animProgress = 1;
                    }
                    
                    // Keep static firing position - do NOT update with player movement
                    // origX and origY are set once in constructor


                    if (!this.hasDamaged && this.animProgress >= 0.3) { // Damage after 30% extension
                         this.hasDamaged = true;
                         const p1 = {x: this.origX, y: this.origY};
                         const p2 = {x: this.origX + this.vx*len, y: this.origY + this.vy*len}; 
                         
                         entities.enemies.forEach(e => {
                            const l2 = (p1.x-p2.x)**2 + (p1.y-p2.y)**2;
                            if (l2 == 0) return;
                            let t = ((e.x - p1.x) * (p2.x - p1.x) + (e.y - p1.y) * (p2.y - p1.y)) / l2;
                            t = Math.max(0, Math.min(1, t));
                            const px = p1.x + t * (p2.x - p1.x);
                            const py = p1.y + t * (p2.y - p1.y);
                            const dist = Math.sqrt((e.x - px)**2 + (e.y - py)**2);
                            
                            const hitbox = 30 + (this.railLevel * 5);
                            if(dist < e.radius + hitbox) {
                                 if(!this.hitList.includes(e)) {
                                     const distFromOrigin = Math.sqrt((e.x - this.origX)**2 + (e.y - this.origY)**2);
                                     const falloff = Math.max(0.1, 1.0 - (distFromOrigin / 400)); 
                                     
                                     const scaler = 1 + (this.railLevel * 0.2);
                                     player.dealElementalDamage(e, 100 * scaler * falloff, 'railgun', '#ffffff');
                                     this.hitList.push(e);
                                     entities.particles.push(new Particle(e.x, e.y, '#3c8cff', 1.0));
                                 }
                            }
                         });
                    }


                    this.life -= dt/16;
                    return this.life > 0;
                }


                if (this.type === 'meteor_warning') {
                    this.life -= dt/16;
                    if (this.life <= 0) {
                        createExplosion(this.x, this.y, '#00ffcc', 30);
                        entities.particles.push(new Shockwave(this.x, this.y, this.target.radius + 50));
                        entities.enemies.forEach(e => {
                            const dist = Math.sqrt((e.x-this.x)**2 + (e.y-this.y)**2);
                            if(dist < this.target.radius) {
                                // Full damage in main zone
                                player.dealElementalDamage(e, this.damage, 'meteor', '#00ffcc');
                            } else if (dist < this.target.radius * 1.5) {
                                // 50% splash damage in outer zone (50% larger than main zone)
                                player.dealElementalDamage(e, this.damage * 0.5, 'meteor', '#00ffcc');
                            }
                        });
                        return false;
                    }
                    return true;
                }

                // PROXIMITY MINES
                if (this.type === 'mine') {
                    this.pulsePhase += dt/16 * 0.1;
                    
                    // TRAVEL PHASE - fly toward target location (much longer travel time)
                    if (this.life > 480) { // Extended from 570 to allow longer travel (90 frames = 1.5 seconds travel)
                        // Move toward target
                        this.x += this.vx * (dt/16);
                        this.y += this.vy * (dt/16);
                        
                        // Slow down as we approach target - gradual deceleration
                        const slowdown = 0.97; // Gentler slowdown for longer glide
                        this.vx *= slowdown;
                        this.vy *= slowdown;
                        
                        // Check if reached target or close enough (works with virtual target points)
                        if (this.target) {
                            const dist = Math.sqrt((this.x - this.target.x)**2 + (this.y - this.target.y)**2);
                            if (dist < 80 || (this.vx*this.vx + this.vy*this.vy) < 0.3) {
                                // Arrived! Stop moving and start settling
                                this.vx = 0;
                                this.vy = 0;
                                this.life = 480; // Jump to settling phase
                            }
                        } else if ((this.vx*this.vx + this.vy*this.vy) < 0.3) {
                            // No target but velocity is low - settle anyway
                            this.vx = 0;
                            this.vy = 0;
                            this.life = 480;
                        }
                        
                        this.life -= dt/16;
                        return true;
                    }
                    
                    // SETTLING PHASE - mine arms and becomes active (30 frames = 0.5 seconds)
                    if (this.life > 450) {
                        this.life -= dt/16;
                        return true;
                    }
                    
                    // ARMED - slowly gravitate toward nearest enemy
                    if (!this.triggered) {
                        // Find nearest enemy and drift toward them slowly
                        let nearestEnemy = null;
                        let nearestDist = Infinity;
                        
                        for (let e of entities.enemies) {
                            const dist = Math.sqrt((e.x - this.x)**2 + (e.y - this.y)**2);
                            if (dist < nearestDist && dist < 300) { // Only drift toward enemies within 300 units
                                nearestDist = dist;
                                nearestEnemy = e;
                            }
                        }
                        
                        // Slow gravitational drift toward nearest enemy
                        if (nearestEnemy) {
                            const dx = nearestEnemy.x - this.x;
                            const dy = nearestEnemy.y - this.y;
                            const dist = Math.sqrt(dx*dx + dy*dy);
                            if (dist > 0) {
                                const driftSpeed = 0.3; // Very slow drift
                                this.x += (dx/dist) * driftSpeed * (dt/16);
                                this.y += (dy/dist) * driftSpeed * (dt/16);
                            }
                        }
                        
                        // Check for nearby enemies to trigger
                        for (let e of entities.enemies) {
                            const dist = Math.sqrt((e.x - this.x)**2 + (e.y - this.y)**2);
                            if (dist < this.detectionRadius) {
                                this.triggered = true;
                                this.detonationTimer = 60; // 1 second countdown
                                break;
                            }
                        }
                    }
                    
                    if (this.triggered) {
                        // Countdown to detonation with GRAVITY PULL
                        this.detonationTimer -= dt/16;
                        
                        // Pull enemies toward mine (extends beyond blast radius)
                        const gravityRadius = this.blastRadius * 1.6; // 60% beyond blast radius (increased from 30%)
                        entities.enemies.forEach(e => {
                            const dx = this.x - e.x;
                            const dy = this.y - e.y;
                            const dist = Math.sqrt(dx*dx + dy*dy);
                            
                            if (dist < gravityRadius && dist > 0) {
                                // Pull strength increases as detonation approaches
                                const detProgress = 1 - (this.detonationTimer / 60);
                                const distRatio = 1 - (dist / gravityRadius);
                                const pullStrength = 0.8 * detProgress * distRatio; // Increased from 0.5 - much stronger pull
                                
                                e.pushX += (dx/dist) * pullStrength;
                                e.pushY += (dy/dist) * pullStrength;
                                
                                // Visual feedback - particles being pulled
                                if (state.frameCount % 4 === 0) {
                                    entities.particles.push(new Particle(
                                        e.x + (seededRandom() - 0.5) * e.radius,
                                        e.y + (seededRandom() - 0.5) * e.radius,
                                        '#ff44cc', // Brighter magenta particles
                                        0.5
                                    ));
                                }
                            }
                        });
                        
                        if (this.detonationTimer <= 0) {
                            // Detonate!
                            createExplosion(this.x, this.y, '#ff44cc', 30); // Brighter magenta explosion
                            entities.particles.push(new Shockwave(this.x, this.y, this.blastRadius, '#ff44cc')); // Brighter magenta shockwave
                            
                            // Damage all enemies in blast radius
                            entities.enemies.forEach(e => {
                                const dist = Math.sqrt((e.x - this.x)**2 + (e.y - this.y)**2);
                                if (dist < this.blastRadius) {
                                    const falloff = 1 - (dist / this.blastRadius) * 0.3; // 30% falloff at edge
                                    player.dealElementalDamage(e, this.damage * falloff, 'mines', '#ff44cc'); // Brighter magenta damage numbers
                                }
                            });
                            
                            return false; // Mine destroyed
                        }
                    }
                    
                    this.life -= dt/16;
                    return this.life > 0;
                }

                // GAS GRENADE - Lob and create toxic cloud
                if (this.type === 'gas_grenade') {
                    this.x += this.vx * (dt/16);
                    this.y += this.vy * (dt/16);
                    
                    // Check if reached target or life expired
                    let shouldDetonate = false;
                    
                    if (this.target && this.target.hp > 0) {
                        const dist = Math.sqrt((this.x - this.target.x)**2 + (this.y - this.target.y)**2);
                        if (dist < 30) shouldDetonate = true;
                    }
                    
                    this.life -= dt/16;
                    if (this.life <= 0) shouldDetonate = true;
                    
                    if (shouldDetonate) {
                        // Create toxic gas cloud
                        createExplosion(this.x, this.y, '#99ff33', 15);
                        const level = player.weapons.gas;
                        entities.gasClouds.push(new GasCloud(this.x, this.y, this.pierce, this.damage, level));
                        return false;
                    }
                    
                    return true;
                }


                this.trail.push({x: this.x, y: this.y});
                if(this.trail.length > (this.type==='seeker'?15: this.type==='ricochet'?30:6)) this.trail.shift();


                if (this.type === 'seeker') {
                    if(Math.abs(this.x - player.x) > 2000 || Math.abs(this.y - player.y) > 2000) return false;
                    this.warmup -= (dt/16);
                    if (this.warmup <= 0) {
                        if (this.target && this.target.hp <= 0) this.target = entities.enemies[Math.floor(seededRandom()*entities.enemies.length)];
                        if (this.target) {
                            this.speed = Math.min(this.speed + 0.2 * (dt/16), 14); 
                            const angle = Math.atan2(this.target.y-this.y, this.target.x-this.x);
                            const steerStrength = 0.08; 
                            const targetVx = Math.cos(angle) * this.speed;
                            const targetVy = Math.sin(angle) * this.speed;
                            this.vx = this.vx + (targetVx - this.vx) * steerStrength;
                            this.vy = this.vy + (targetVy - this.vy) * steerStrength;
                        }
                    }
                }
                
                // RICOCHET DISC - Bounces between enemies (works like seeker)
                if (this.type === 'ricochet') {
                    // Initialize
                    if (this.bounces === undefined) this.bounces = 0;
                    if (this.maxBounces === undefined) this.maxBounces = 8;
                    if (this.hitEnemies === undefined) this.hitEnemies = new Set();
                    
                    // Check for collision with enemies
                    for (let i = 0; i < entities.enemies.length; i++) {
                        const e = entities.enemies[i];
                        if (e.hp > 0 && !this.hitEnemies.has(e)) { // Only hit if not already hit
                            const dist = Math.sqrt((e.x - this.x)**2 + (e.y - this.y)**2);
                            if (dist < e.radius + 15) {
                                // HIT!
                                this.hitEnemies.add(e); // Mark as hit
                                player.dealElementalDamage(e, this.damage * Math.pow(0.95, this.bounces), 'ricochet', '#ff8800');
                                createExplosion(this.x, this.y, '#ff8800', 15);
                                this.bounces++;
                                console.log(`HIT enemy ${this.bounces}/${this.maxBounces}, hit ${this.hitEnemies.size} unique enemies so far`);
                                
                                // Max bounces?
                                if (this.bounces >= this.maxBounces) {
                                    console.log(`DISC DIED: Max bounces ${this.bounces}/${this.maxBounces}`);
                                    return false;
                                }
                                
                                // Find new target (nearest unhit enemy)
                                this.target = null;
                                let nearestDist = Infinity;
                                for (let j = 0; j < entities.enemies.length; j++) {
                                    const candidate = entities.enemies[j];
                                    if (candidate !== e && candidate.hp > 0 && !this.hitEnemies.has(candidate)) {
                                        const d = Math.sqrt((candidate.x - this.x)**2 + (candidate.y - this.y)**2);
                                        if (d < nearestDist) {
                                            nearestDist = d;
                                            this.target = candidate;
                                        }
                                    }
                                }
                                
                                // No unhit enemies found - clear the hit list and allow re-hits
                                if (!this.target) {
                                    console.log(`All ${this.hitEnemies.size} enemies hit once, clearing hit list`);
                                    this.hitEnemies.clear();
                                    
                                    // Find nearest enemy (allowing re-hits now)
                                    for (let j = 0; j < entities.enemies.length; j++) {
                                        const candidate = entities.enemies[j];
                                        if (candidate !== e && candidate.hp > 0) {
                                            const d = Math.sqrt((candidate.x - this.x)**2 + (candidate.y - this.y)**2);
                                            if (d < nearestDist) {
                                                nearestDist = d;
                                                this.target = candidate;
                                            }
                                        }
                                    }
                                }
                                
                                // If STILL no target (only 1 enemy left), die
                                if (!this.target) {
                                    console.log(`Only 1 enemy left, disc dies`);
                                    return false;
                                }
                                
                                console.log(`Next target at ${nearestDist.toFixed(0)}px`);
                                break; // Only hit once per frame
                            }
                        }
                    }
                    
                    // Steer toward target (EXACTLY like seeker)
                    if (this.target && this.target.hp > 0) {
                        const angle = Math.atan2(this.target.y - this.y, this.target.x - this.x);
                        const steerStrength = 0.15;
                        const targetVx = Math.cos(angle) * 12;
                        const targetVy = Math.sin(angle) * 12;
                        this.vx = this.vx + (targetVx - this.vx) * steerStrength;
                        this.vy = this.vy + (targetVy - this.vy) * steerStrength;
                    } else {
                        // No target - find nearest
                        let nearest = null;
                        let nearestDist = Infinity;
                        for (let i = 0; i < entities.enemies.length; i++) {
                            const e = entities.enemies[i];
                            if (e.hp > 0) {
                                const d = Math.sqrt((e.x - this.x)**2 + (e.y - this.y)**2);
                                if (d < nearestDist) {
                                    nearestDist = d;
                                    nearest = e;
                                }
                            }
                        }
                        this.target = nearest;
                    }
                }
                
                // DRONE SHOT - Simple homing projectile
                if (this.type === 'drone_shot') {
                    if (this.target && this.target.hp > 0) {
                        const angle = Math.atan2(this.target.y - this.y, this.target.x - this.x);
                        const steerStrength = 0.1;
                        const targetVx = Math.cos(angle) * 10;
                        const targetVy = Math.sin(angle) * 10;
                        this.vx = this.vx + (targetVx - this.vx) * steerStrength;
                        this.vy = this.vy + (targetVy - this.vy) * steerStrength;
                    }
                }
                
                // TURRET SHOT - Basic homing projectile
                if (this.type === 'turret_shot') {
                    if (this.target && this.target.hp > 0) {
                        const angle = Math.atan2(this.target.y - this.y, this.target.x - this.x);
                        const steerStrength = 0.08;
                        const targetVx = Math.cos(angle) * 10;
                        const targetVy = Math.sin(angle) * 10;
                        this.vx = this.vx + (targetVx - this.vx) * steerStrength;
                        this.vy = this.vy + (targetVy - this.vy) * steerStrength;
                    }
                    
                    // Hit detection
                    for (let e of entities.enemies) {
                        if (e.hp > 0) {
                            const dist = Math.sqrt((e.x - this.x)**2 + (e.y - this.y)**2);
                            if (dist < e.radius + 8) {
                                player.dealElementalDamage(e, this.damage, 'turret', '#ff8800');
                                return false;
                            }
                        }
                    }
                }
                
                // EMP PULSE - Slow projectile that creates field on hit
                if (this.type === 'emp_pulse') {
                    if (this.target && this.target.hp > 0) {
                        const angle = Math.atan2(this.target.y - this.y, this.target.x - this.x);
                        const steerStrength = 0.05;
                        const targetVx = Math.cos(angle) * 8;
                        const targetVy = Math.sin(angle) * 8;
                        this.vx = this.vx + (targetVx - this.vx) * steerStrength;
                        this.vy = this.vy + (targetVy - this.vy) * steerStrength;
                    }
                    
                    // Hit detection
                    for (let e of entities.enemies) {
                        if (e.hp > 0) {
                            const dist = Math.sqrt((e.x - this.x)**2 + (e.y - this.y)**2);
                            if (dist < e.radius + 10) {
                                // Deal damage
                                player.dealElementalDamage(e, this.damage, 'emp', '#a855f7');
                                
                                // Create EMP field at impact point
                                const fieldRadius = (150 + player.weapons.emp * 15) * player.weaponStats.emp.area;
                                player.empFields.push({
                                    x: this.x,
                                    y: this.y,
                                    radius: fieldRadius,
                                    life: 150 // 2.5 seconds
                                });
                                
                                createExplosion(this.x, this.y, '#a855f7', 20);
                                return false;
                            }
                        }
                    }
                }
                
                this.x += this.vx * (dt/16); this.y += this.vy * (dt/16);
                this.life -= (dt/16); 
                if (this.type === 'ricochet' && this.life <= 0) {
                    console.log(`DISC DIED: Life expired (was alive for ~${600 - this.life} frames)`);
                }
                return this.life > 0;
            }
            draw(ctx) {
                if (this.type === 'flak_shell') {
                    ctx.fillStyle = '#ffff00'; ctx.beginPath(); ctx.arc(this.x,this.y,6,0,Math.PI*2); ctx.fill();
                    return;
                }
                if (this.type === 'bio_spore') {
                    ctx.fillStyle = '#00cc44'; ctx.beginPath(); ctx.arc(this.x,this.y,3,0,Math.PI*2); ctx.fill();
                    return;
                }
                if (this.type === 'gas_grenade') {
                    // Draw gas canister with toxic glow
                    ctx.save();
                    ctx.translate(this.x, this.y);
                    
                    const angle = Math.atan2(this.vy, this.vx);
                    ctx.rotate(angle);
                    
                    // Glow
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = '#99ff33';
                    
                    // Canister body
                    ctx.fillStyle = '#99ff33';
                    ctx.fillRect(-6, -4, 12, 8);
                    
                    // Dark center band
                    ctx.fillStyle = '#336600';
                    ctx.fillRect(-4, -3, 8, 6);
                    
                    // Trail particles
                    const trailLength = 5;
                    for (let i = 0; i < trailLength; i++) {
                        const t = i / trailLength;
                        const tx = -8 - (i * 4);
                        const alpha = (1 - t) * 0.5;
                        ctx.fillStyle = `rgba(153, 255, 51, ${alpha})`;
                        ctx.beginPath();
                        ctx.arc(tx, 0, 2, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    
                    ctx.restore();
                    return;
                }
                if (this.type === 'railgun') {
                    ctx.save();
                    const len = (375 + (this.railLevel * 25)) * this.animProgress; // Increased base from 250 (50% longer range)
                    const baseAlpha = this.life / 45;
                    const endX = this.origX + this.vx*len;
                    const endY = this.origY + this.vy*len;
                    
                    // Draw multiple layers for a more dramatic pulse effect
                    
                    // Layer 1: Outer energy glow (widest, most diffuse)
                    const outerGlow = ctx.createLinearGradient(this.origX, this.origY, endX, endY);
                    outerGlow.addColorStop(0, `rgba(30, 100, 200, ${baseAlpha * 0.3})`);
                    outerGlow.addColorStop(0.15, `rgba(40, 120, 220, ${baseAlpha * 0.25})`);
                    outerGlow.addColorStop(0.5, `rgba(20, 80, 180, ${baseAlpha * 0.15})`);
                    outerGlow.addColorStop(1, `rgba(10, 60, 150, 0)`);
                    
                    ctx.strokeStyle = outerGlow;
                    ctx.lineWidth = 20 + (this.railLevel * 3);
                    ctx.lineCap = 'round';
                    ctx.beginPath(); 
                    ctx.moveTo(this.origX, this.origY); 
                    ctx.lineTo(endX, endY); 
                    ctx.stroke();
                    
                    // Layer 2: Mid energy beam
                    const midGlow = ctx.createLinearGradient(this.origX, this.origY, endX, endY);
                    midGlow.addColorStop(0, `rgba(60, 140, 255, ${baseAlpha * 0.7})`);
                    midGlow.addColorStop(0.2, `rgba(50, 120, 240, ${baseAlpha * 0.6})`);
                    midGlow.addColorStop(0.6, `rgba(40, 100, 220, ${baseAlpha * 0.4})`);
                    midGlow.addColorStop(1, `rgba(30, 80, 200, 0)`);
                    
                    ctx.strokeStyle = midGlow;
                    ctx.lineWidth = 10 + (this.railLevel * 2);
                    ctx.beginPath(); 
                    ctx.moveTo(this.origX, this.origY); 
                    ctx.lineTo(endX, endY); 
                    ctx.stroke();
                    
                    // Layer 3: Core beam (bright white center)
                    const coreGradient = ctx.createLinearGradient(this.origX, this.origY, endX, endY);
                    coreGradient.addColorStop(0, `rgba(255, 255, 255, ${baseAlpha})`);
                    coreGradient.addColorStop(0.25, `rgba(255, 255, 255, ${baseAlpha * 0.85})`);
                    coreGradient.addColorStop(0.7, `rgba(180, 200, 255, ${baseAlpha * 0.5})`);
                    coreGradient.addColorStop(1, `rgba(120, 160, 230, 0)`);
                    
                    ctx.strokeStyle = coreGradient;
                    ctx.lineWidth = 3 + (this.railLevel * 0.5);
                    ctx.beginPath(); 
                    ctx.moveTo(this.origX, this.origY); 
                    ctx.lineTo(endX, endY); 
                    ctx.stroke();
                    
                    // Layer 4: Muzzle flash at origin
                    if (this.life > 40) { // Changed from 15 to 40
                        const flashAlpha = (this.life - 40) / 5; // Fades in first 5 frames
                        ctx.fillStyle = `rgba(255, 255, 255, ${flashAlpha * 0.8})`;
                        ctx.shadowBlur = 20;
                        ctx.shadowColor = '#3c8cff';
                        ctx.beginPath();
                        ctx.arc(this.origX, this.origY, 8 + (this.railLevel), 0, Math.PI*2);
                        ctx.fill();
                        ctx.shadowBlur = 0;
                    }
                    
                    // Layer 5: Energy particles along the beam for texture
                    if (this.life > 30 && this.animProgress > 0.5) { // Only show after beam is halfway extended
                        const fullLen = 375 + (this.railLevel * 25); // Increased base from 250
                        for (let i = 0; i < 5; i++) {
                            const t = (i / 5) * this.animProgress + (Math.sin(state.frameCount * 0.1 + i) * 0.05);
                            const px = this.origX + this.vx * fullLen * t;
                            const py = this.origY + this.vy * fullLen * t;
                            const particleAlpha = baseAlpha * (1 - t) * 0.6;
                            
                            ctx.fillStyle = `rgba(60, 140, 255, ${particleAlpha})`;
                            ctx.beginPath();
                            ctx.arc(px, py, 2 + this.railLevel * 0.3, 0, Math.PI*2);
                            ctx.fill();
                        }
                    }
                    
                    ctx.restore();
                    return;
                }


                if (this.type === 'meteor_warning') {
                    const progress = 1 - (this.life / this.maxLife);
                    ctx.save(); ctx.translate(this.x, this.y);
                    
                    // Multiple pulsing warning rings
                    for (let i = 0; i < 3; i++) {
                        const ringProgress = (progress + (i * 0.15)) % 1;
                        const ringAlpha = 0.4 * (1 - ringProgress);
                        const ringRadius = this.target.radius * (0.5 + ringProgress * 0.5);
                        ctx.strokeStyle = `rgba(255, 120, 50, ${ringAlpha})`;
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.arc(0, 0, ringRadius, 0, Math.PI*2);
                        ctx.stroke();
                    }
                    
                    // Impact zone fill - intensifies as meteor approaches
                    const fillAlpha = 0.2 + (progress * 0.3);
                    const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, this.target.radius * progress);
                    gradient.addColorStop(0, `rgba(255, 100, 0, ${fillAlpha})`);
                    gradient.addColorStop(0.6, `rgba(255, 150, 50, ${fillAlpha * 0.5})`);
                    gradient.addColorStop(1, 'rgba(255, 200, 100, 0)');
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(0, 0, this.target.radius * progress, 0, Math.PI*2);
                    ctx.fill();
                    
                    // Outer danger ring - solid line instead of dashed
                    ctx.strokeStyle = `rgba(255, 100, 0, ${0.8 + Math.sin(progress * 20) * 0.2})`;
                    ctx.lineWidth = 3;
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = 'rgba(255, 100, 0, 0.5)';
                    ctx.beginPath();
                    ctx.arc(0, 0, this.target.radius, 0, Math.PI*2);
                    ctx.stroke();
                    ctx.shadowBlur = 0;
                    
                    // Falling meteor with trail - comes in at 45 degree angle
                    const h = (this.life / this.maxLife) * 600;
                    const angleOffset = h * 0.7; // Diagonal approach
                    const meteorSize = 10 + (1 - this.life / this.maxLife) * 8; // Grows as it approaches
                    
                    // Meteor trail
                    for (let j = 0; j < 5; j++) {
                        const trailOffset = j * 15;
                        const trailAlpha = (1 - j / 5) * 0.6;
                        const trailSize = meteorSize * (1 - j / 6);
                        const trailAngleOffset = (h + trailOffset) * 0.7;
                        ctx.fillStyle = `rgba(255, 150, 50, ${trailAlpha})`;
                        ctx.shadowBlur = 15;
                        ctx.shadowColor = '#ff6600';
                        ctx.beginPath();
                        ctx.arc(-trailAngleOffset, -h - trailOffset, trailSize * 0.7, 0, Math.PI*2);
                        ctx.fill();
                    }
                    
                    // Main meteor body
                    const meteorGradient = ctx.createRadialGradient(-angleOffset, -h, 0, -angleOffset, -h, meteorSize);
                    meteorGradient.addColorStop(0, '#ffffff');
                    meteorGradient.addColorStop(0.3, '#ffaa00');
                    meteorGradient.addColorStop(0.7, '#ff6600');
                    meteorGradient.addColorStop(1, '#cc3300');
                    ctx.fillStyle = meteorGradient;
                    ctx.shadowColor = '#ff8800';
                    ctx.shadowBlur = 25;
                    ctx.beginPath();
                    ctx.arc(-angleOffset, -h, meteorSize, 0, Math.PI*2);
                    ctx.fill();
                    
                    // Fiery glow around meteor
                    ctx.fillStyle = `rgba(255, 100, 0, ${0.3})`;
                    ctx.shadowBlur = 35;
                    ctx.beginPath();
                    ctx.arc(-angleOffset, -h, meteorSize * 1.8, 0, Math.PI*2);
                    ctx.fill();
                    
                    ctx.shadowBlur = 0;
                    ctx.restore();
                    return;
                }


                if (this.type === 'seeker') {
                    const angle = Math.atan2(this.vy, this.vx);
                    ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(angle);
                    ctx.shadowBlur = 15; ctx.shadowColor = '#ff5500';
                    ctx.fillStyle = '#ff5500'; ctx.beginPath(); ctx.moveTo(-5, 0); ctx.lineTo(-25, -3); ctx.lineTo(-25, 3); ctx.fill();
                    ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.moveTo(5, 0); ctx.lineTo(-5, -4); ctx.lineTo(-5, 4); ctx.fill();
                    ctx.restore();
                } else if (this.type === 'ricochet') {
                    // Spinning orange/yellow blade with trail
                    const spinAngle = (Date.now() / 30) % (Math.PI * 2); // Fast spin
                    ctx.save();
                    ctx.translate(this.x, this.y);
                    ctx.rotate(spinAngle);
                    
                    // Outer glow
                    ctx.shadowBlur = 25;
                    ctx.shadowColor = '#ff8800';
                    
                    // Blade outer ring - orange
                    ctx.fillStyle = '#ff8800';
                    ctx.beginPath();
                    ctx.arc(0, 0, 10, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Inner core - bright yellow
                    ctx.fillStyle = '#ffcc00';
                    ctx.beginPath();
                    ctx.arc(0, 0, 6, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Center dot - white hot
                    ctx.fillStyle = '#ffffff';
                    ctx.beginPath();
                    ctx.arc(0, 0, 3, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Blade edges - 4 sharp points
                    ctx.strokeStyle = '#ffaa00';
                    ctx.lineWidth = 3;
                    ctx.shadowBlur = 15;
                    for (let i = 0; i < 4; i++) {
                        const angle = (Math.PI / 2) * i;
                        ctx.beginPath();
                        ctx.moveTo(0, 0);
                        ctx.lineTo(Math.cos(angle) * 12, Math.sin(angle) * 12);
                        ctx.stroke();
                    }
                    
                    ctx.shadowBlur = 0;
                    ctx.restore();
                    
                    // Trail particles
                    if (state.frameCount % 2 === 0) {
                        entities.particles.push({
                            x: this.x,
                            y: this.y,
                            vx: -this.vx * 0.3,
                            vy: -this.vy * 0.3,
                            color: '#ff8800',
                            life: 8,
                            size: 4,
                            update: function(dt) {
                                this.x += this.vx * (dt/16);
                                this.y += this.vy * (dt/16);
                                this.life -= dt/16;
                                this.size *= 0.94;
                                return this.life > 0;
                            },
                            draw: function(ctx) {
                                ctx.fillStyle = this.color;
                                ctx.shadowBlur = 6;
                                ctx.shadowColor = this.color;
                                ctx.globalAlpha = this.life / 8;
                                ctx.beginPath();
                                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                                ctx.fill();
                                ctx.globalAlpha = 1;
                                ctx.shadowBlur = 0;
                            }
                        });
                    }
                } else if (this.type === 'drone_shot') {
                    // Small cyan energy bolt
                    ctx.save();
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = '#00aaff';
                    ctx.fillStyle = '#00aaff';
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, 4, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                } else if (this.type === 'ricochet') {
                    // Bright orange spinning disc
                    ctx.save();
                    ctx.translate(this.x, this.y);
                    
                    // Rotation based on time
                    const spinAngle = state.frameCount * 0.3;
                    ctx.rotate(spinAngle);
                    
                    // Outer glow
                    ctx.shadowBlur = 25;
                    ctx.shadowColor = '#ff8800';
                    ctx.fillStyle = 'rgba(255, 136, 0, 0.6)';
                    ctx.beginPath();
                    ctx.arc(0, 0, 12, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Bright core disc
                    ctx.shadowBlur = 15;
                    ctx.fillStyle = '#ff8800';
                    ctx.beginPath();
                    ctx.arc(0, 0, 8, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Inner highlight
                    ctx.shadowBlur = 0;
                    ctx.fillStyle = '#ffaa00';
                    ctx.beginPath();
                    ctx.arc(0, 0, 4, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Spinning blade lines for visual motion
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 2;
                    ctx.shadowBlur = 8;
                    ctx.shadowColor = '#ffffff';
                    for (let i = 0; i < 4; i++) {
                        const angle = (Math.PI / 2) * i;
                        ctx.beginPath();
                        ctx.moveTo(Math.cos(angle) * 3, Math.sin(angle) * 3);
                        ctx.lineTo(Math.cos(angle) * 7, Math.sin(angle) * 7);
                        ctx.stroke();
                    }
                    
                    ctx.restore();
                } else if (this.type === 'drone_rocket') {
                    // Magenta plasma ball with spiraling energy
                    ctx.save();
                    ctx.translate(this.x, this.y);
                    
                    // Rotation for spiral effect
                    const rotation = state.frameCount * 0.2;
                    
                    // Outer plasma glow (magenta)
                    ctx.shadowBlur = 30;
                    ctx.shadowColor = '#ff00ff';
                    ctx.fillStyle = 'rgba(255, 0, 255, 0.5)';
                    ctx.beginPath();
                    ctx.arc(0, 0, 9, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Bright magenta core
                    ctx.shadowBlur = 20;
                    ctx.fillStyle = '#ff00ff';
                    ctx.beginPath();
                    ctx.arc(0, 0, 6, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // White hot center
                    ctx.shadowBlur = 0;
                    ctx.fillStyle = '#ffffff';
                    ctx.beginPath();
                    ctx.arc(0, 0, 3, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Spiraling energy trails (3 spirals)
                    ctx.strokeStyle = '#ff88ff';
                    ctx.lineWidth = 2;
                    ctx.shadowBlur = 8;
                    ctx.shadowColor = '#ff00ff';
                    for (let i = 0; i < 3; i++) {
                        const spiralOffset = (i * Math.PI * 2 / 3);
                        const spiralAngle = rotation + spiralOffset;
                        const spiralRadius = 7;
                        
                        ctx.beginPath();
                        ctx.moveTo(0, 0);
                        ctx.quadraticCurveTo(
                            Math.cos(spiralAngle - 0.5) * spiralRadius * 0.5,
                            Math.sin(spiralAngle - 0.5) * spiralRadius * 0.5,
                            Math.cos(spiralAngle) * spiralRadius,
                            Math.sin(spiralAngle) * spiralRadius
                        );
                        ctx.stroke();
                    }
                    
                    ctx.shadowBlur = 0;
                    ctx.restore();
                } else if (this.type === 'drone_rocket') {
                    // Orange mini-rocket
                    ctx.save();
                    const angle = Math.atan2(this.vy, this.vx);
                    ctx.translate(this.x, this.y);
                    ctx.rotate(angle);
                    
                    // Rocket body
                    ctx.fillStyle = '#ff8800';
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = '#ff8800';
                    ctx.fillRect(-6, -2, 10, 4);
                    
                    // Bright tip
                    ctx.fillStyle = '#ffff00';
                    ctx.fillRect(4, -1.5, 3, 3);
                    
                    // Engine glow
                    ctx.fillStyle = '#ffaa00';
                    ctx.shadowBlur = 20;
                    ctx.beginPath();
                    ctx.arc(-6, 0, 3, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.shadowBlur = 0;
                    ctx.restore();
                    
                    // Exhaust trail
                    if (state.frameCount % 2 === 0) {
                        entities.particles.push({
                            x: this.x,
                            y: this.y,
                            life: 8,
                            size: 3,
                            color: '#ff8800',
                            update: function(dt) {
                                this.life -= dt/16;
                                this.size *= 0.95;
                                return this.life > 0;
                            },
                            draw: function(ctx) {
                                ctx.fillStyle = this.color;
                                ctx.globalAlpha = this.life / 8;
                                ctx.shadowBlur = 8;
                                ctx.shadowColor = this.color;
                                ctx.beginPath();
                                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                                ctx.fill();
                                ctx.globalAlpha = 1;
                                ctx.shadowBlur = 0;
                            }
                        });
                    }
                } else if (this.type === 'mine') {
                    // Collapsar mine: Circular design with bright magenta/red gravity theme (smaller size)
                    ctx.save();
                    ctx.translate(this.x, this.y);
                    
                    const isArming = this.life > 570;
                    const armingProgress = isArming ? (600 - this.life) / 30 : 1; // 0 to 1 over 0.5 seconds
                    
                    // Determine visual state - BRIGHTER COLORS
                    let primaryColor, secondaryColor, pulseSpeed, glowIntensity;
                    
                    if (isArming) {
                        // Arming phase: pulsing magenta, building up energy
                        primaryColor = '#ff33bb'; // Brighter
                        secondaryColor = '#dd0099'; // Brighter
                        pulseSpeed = 0.3;
                        glowIntensity = armingProgress * 0.5; // Ramps up during arming
                    } else if (this.triggered) {
                        // Triggered: intense magenta/red pulsing with gravity waves
                        const countdown = this.detonationTimer / 60; // 0 to 1
                        primaryColor = '#ff44cc'; // Brighter
                        secondaryColor = '#ff0088'; // Brighter
                        pulseSpeed = 5 - (countdown * 4); // Speeds up as countdown approaches zero
                        glowIntensity = 1.5 - (countdown * 0.5); // Intensifies as it gets closer to detonation
                    } else {
                        // Armed and ready: steady magenta glow
                        primaryColor = '#ff44cc'; // Brighter
                        secondaryColor = '#ff0099'; // Brighter
                        pulseSpeed = 0.1;
                        glowIntensity = 0.3 + Math.sin(this.pulsePhase) * 0.2;
                    }
                    
                    const pulseIntensity = 0.5 + Math.sin(this.pulsePhase * pulseSpeed) * 0.5;
                    
                    // Gravity field rings when triggered (pulling effect) - WHITE/BRIGHT for visibility
                    if (this.triggered) {
                        const gravityRadius = this.blastRadius * 1.6;
                        for (let i = 0; i < 4; i++) {
                            const ringProgress = (this.pulsePhase * pulseSpeed * 0.5 + i * 0.25) % 1;
                            const ringAlpha = (1 - ringProgress) * 0.6;
                            const ringRadius = 15 + (ringProgress * (gravityRadius * 0.5));
                            ctx.strokeStyle = `rgba(255, 255, 255, ${ringAlpha})`; // WHITE gravity rings for visibility
                            ctx.lineWidth = 2;
                            ctx.beginPath();
                            ctx.arc(0, 0, ringRadius, 0, Math.PI*2);
                            ctx.stroke();
                        }
                    }
                    
                    // Detection radius ring (only when armed, not triggered)
                    if (!isArming && !this.triggered) {
                        ctx.strokeStyle = `rgba(255, 68, 204, ${0.15 + glowIntensity * 0.2})`; // Brighter magenta detection ring
                        ctx.lineWidth = 1;
                        ctx.setLineDash([5, 5]);
                        ctx.beginPath();
                        ctx.arc(0, 0, this.detectionRadius, 0, Math.PI*2);
                        ctx.stroke();
                        ctx.setLineDash([]);
                    }
                    
                    // Outer glow (smaller)
                    const glowSize = 10 + (pulseIntensity * glowIntensity * 3);
                    const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, glowSize);
                    gradient.addColorStop(0, primaryColor);
                    gradient.addColorStop(0.5, secondaryColor);
                    gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
                    
                    ctx.fillStyle = gradient;
                    ctx.shadowBlur = 15 + (glowIntensity * 10);
                    ctx.shadowColor = primaryColor;
                    ctx.beginPath();
                    ctx.arc(0, 0, glowSize, 0, Math.PI*2);
                    ctx.fill();
                    
                    // Main body - circular with rotating segments (smaller)
                    ctx.shadowBlur = 12;
                    ctx.fillStyle = primaryColor;
                    ctx.beginPath();
                    ctx.arc(0, 0, 6, 0, Math.PI*2);
                    ctx.fill();
                    
                    // Rotating energy segments (4 segments, smaller) - Keep original secondary color style
                    const rotationSpeed = isArming ? 0.1 : (this.triggered ? 0.5 : 0.05);
                    for (let i = 0; i < 4; i++) {
                        const angle = (this.pulsePhase * rotationSpeed) + (i * Math.PI / 2);
                        const segmentLength = 5;
                        const segmentDist = 7;
                        
                        ctx.strokeStyle = secondaryColor;
                        ctx.lineWidth = 2;
                        ctx.lineCap = 'round';
                        ctx.shadowBlur = 8;
                        ctx.shadowColor = secondaryColor;
                        
                        ctx.beginPath();
                        ctx.moveTo(
                            Math.cos(angle) * segmentDist,
                            Math.sin(angle) * segmentDist
                        );
                        ctx.lineTo(
                            Math.cos(angle) * (segmentDist + segmentLength),
                            Math.sin(angle) * (segmentDist + segmentLength)
                        );
                        ctx.stroke();
                    }
                    
                    // Inner core - pulses with state (smaller) - Keep original white
                    ctx.fillStyle = this.triggered ? '#ffffff' : '#ffffff';
                    ctx.shadowBlur = 6;
                    ctx.shadowColor = primaryColor;
                    ctx.beginPath();
                    ctx.arc(0, 0, 2.5 + (pulseIntensity * 1.5), 0, Math.PI*2);
                    ctx.fill();
                    
                    // Arming indicator - expanding ring during arming phase (smaller)
                    if (isArming) {
                        ctx.strokeStyle = `rgba(255, 51, 187, ${1 - armingProgress})`; // Brighter magenta arming ring
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.arc(0, 0, 6 + (armingProgress * 10), 0, Math.PI*2);
                        ctx.stroke();
                    }
                    
                    ctx.shadowBlur = 0;
                    ctx.restore();
                } else if (this.type === 'turret_shot') {
                    // Orange turret shot - simple glowing orb
                    ctx.save();
                    ctx.translate(this.x, this.y);
                    
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = '#ff8800';
                    ctx.fillStyle = '#ff8800';
                    ctx.beginPath();
                    ctx.arc(0, 0, 5, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.fillStyle = '#ffaa00';
                    ctx.beginPath();
                    ctx.arc(0, 0, 3, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.shadowBlur = 0;
                    ctx.restore();
                } else if (this.type === 'emp_pulse') {
                    // Purple EMP pulse - pulsing orb
                    ctx.save();
                    ctx.translate(this.x, this.y);
                    
                    const pulse = 0.8 + Math.sin(state.frameCount * 0.15) * 0.2;
                    
                    ctx.shadowBlur = 20 * pulse;
                    ctx.shadowColor = '#a855f7';
                    ctx.fillStyle = '#a855f7';
                    ctx.beginPath();
                    ctx.arc(0, 0, 6 * pulse, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.fillStyle = '#c084fc';
                    ctx.beginPath();
                    ctx.arc(0, 0, 4 * pulse, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.shadowBlur = 0;
                    ctx.restore();
                } else {
                    ctx.strokeStyle = 'rgba(0,255,245,0.5)'; ctx.lineWidth = 2; ctx.beginPath();
                    this.trail.forEach((p,i) => { if(i===0) ctx.moveTo(p.x,p.y); else ctx.lineTo(p.x,p.y); });
                    ctx.stroke(); ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(this.x, this.y, 3, 0, Math.PI*2); ctx.fill();
                }
            }
        }


        class Shockwave {
            constructor(x, y, maxR, color = '#00ffff') { this.x=x; this.y=y; this.r=1; this.maxR=maxR; this.life=1; this.color=color; }
            update() { this.r += (this.maxR-this.r)*0.1; this.life-=0.05; return this.life>0; }
            draw(ctx) {
                ctx.globalAlpha=this.life; ctx.strokeStyle=this.color; ctx.lineWidth=3;
                ctx.shadowBlur = 10; ctx.shadowColor = this.color;
                ctx.beginPath(); ctx.arc(this.x, this.y, this.r, 0, Math.PI*2); ctx.stroke();
                ctx.shadowBlur = 0;
                ctx.globalAlpha=1;
            }
        }


        class ShrapnelSpark {
            constructor(x, y, angle, speed) {
                this.x = x; this.y = y; 
                this.vx = Math.cos(angle) * speed;
                this.vy = Math.sin(angle) * speed;
                this.life = 1.0;
                this.angle = angle;
            }
            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.vx *= 0.9; 
                this.vy *= 0.9; 
                this.life -= 0.05; 
                return this.life > 0;
            }
            draw(ctx) {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle);
                ctx.globalAlpha = this.life;
                ctx.fillStyle = '#ffffaa';
                ctx.fillRect(0, -1, 10 + (this.life * 5), 2);
                ctx.globalAlpha = 1.0;
                ctx.restore();
            }
        }


        class Pickup {
            constructor(x, y, val, type='xp') { this.x = x; this.y = y; this.val = val; this.type = type; this.magnetized = false; }
            update(dt) {
                const dx = player.x - this.x; const dy = player.y - this.y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                
                if (this.magnetized || dist < player.pickupRadius) {
                    if(!this.magnetized) this.magnetized = true;
                    const speed = 15;
                    this.x += (dx/dist)*speed*(dt/16); this.y += (dy/dist)*speed*(dt/16);
                }
                
                if(this.magnetized) {
                     // Only data cores and mod crates magnetize other pickups
                     const isDataCore = (this.type === 'core' || this.type === 'mod_crate');
                     if (isDataCore) {
                         const magnetRange = 9999; // Data cores = infinite range (reverted)
                         entities.pickups.forEach(p => {
                             if(p !== this && !p.magnetized) {
                                 const dist = Math.sqrt((p.x-this.x)**2 + (p.y-this.y)**2);
                                 if(dist < magnetRange) {
                                     p.magnetized = true;
                                 }
                             }
                         });
                     }
                     // Normal XP shards DON'T magnetize other pickups (this was the bug!)
                }


                if (dist < player.radius + 10) { 
                    if (this.type === 'xp') gainXp(this.val);
                    if (this.type === 'health') { player.heal(30, true); } // Reduced from 50 to 30 
                    if (this.type === 'shield_cell') { 
                        // Instantly restore one full shield bar (prioritize depleted bars)
                        if (player.shield1 < 100) {
                            player.shield1 = 100;
                        } else if (player.shield2 < 100) {
                            player.shield2 = 100;
                        }
                        // Visual/audio feedback
                        createExplosion(player.x, player.y, '#00d1b2', 20);
                    }
                    if (this.type === 'magnet') { activateMagnet(); }
                    if (this.type === 'nexus_core') {
                        // Collect Nexus Core - increment counter
                        const currentCores = parseInt(localStorage.getItem('neonrogue_nexusCores') || '0');
                        localStorage.setItem('neonrogue_nexusCores', currentCores + 1);
                        createExplosion(player.x, player.y, '#ff00ff', 30);
                    }
                    if (this.type === 'core') { gainXp(state.xpToNext * 3); } 
                    if (this.type === 'mod_crate') { 
                        if(state.screen !== 'game') return true; 
                        triggerModPickup();
                    }
                    return false; 
                }
                return true;
            }
            draw(ctx) {
                if (this.type === 'xp') {
                    ctx.fillStyle = '#00d1b2'; ctx.shadowColor = '#00d1b2'; ctx.shadowBlur = 8;
                    ctx.beginPath(); ctx.moveTo(this.x, this.y-5); ctx.lineTo(this.x+5, this.y); ctx.lineTo(this.x, this.y+5); ctx.lineTo(this.x-5, this.y); ctx.fill(); ctx.shadowBlur = 0;
                } else if (this.type === 'health') {
                    // Health pack - glowing red cross with pulsing animation
                    const pulse = 0.8 + Math.sin(Date.now() * 0.005) * 0.2;
                    
                    // Background glow
                    ctx.fillStyle = `rgba(255, 50, 50, ${0.3 * pulse})`;
                    ctx.shadowColor = '#ff3232';
                    ctx.shadowBlur = 20 * pulse;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, 12, 0, Math.PI*2);
                    ctx.fill();
                    
                    // White cross with red glow
                    ctx.fillStyle = '#ffffff';
                    ctx.shadowColor = '#ff0000';
                    ctx.shadowBlur = 8;
                    // Vertical bar
                    ctx.fillRect(this.x - 2, this.y - 8, 4, 16);
                    // Horizontal bar
                    ctx.fillRect(this.x - 8, this.y - 2, 16, 4);
                    
                    // Outer frame
                    ctx.strokeStyle = '#ff3232';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(this.x - 10, this.y - 10, 20, 20);
                    
                    ctx.shadowBlur = 0;
                } else if (this.type === 'shield_cell') {
                    // Shield Cell - Cyan hexagon with energy core
                    const pulse = 0.7 + Math.sin(Date.now() * 0.008) * 0.3;
                    
                    ctx.save();
                    ctx.translate(this.x, this.y);
                    
                    // Outer glow
                    ctx.shadowColor = '#00d1b2';
                    ctx.shadowBlur = 15 * pulse;
                    
                    // Hexagon shape
                    ctx.fillStyle = '#00d1b2';
                    ctx.beginPath();
                    for (let i = 0; i < 6; i++) {
                        const angle = (Math.PI / 3) * i;
                        const x = Math.cos(angle) * 8;
                        const y = Math.sin(angle) * 8;
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.closePath();
                    ctx.fill();
                    
                    // Inner core with animation
                    ctx.fillStyle = '#ffffff';
                    ctx.globalAlpha = pulse;
                    ctx.beginPath();
                    ctx.arc(0, 0, 4, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.globalAlpha = 1;
                    
                    // "S" text for Shield
                    ctx.font = 'bold 12px Arial';
                    ctx.fillStyle = '#003d33';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('S', 0, 0);
                    
                    ctx.shadowBlur = 0;
                    ctx.restore();
                } else if (this.type === 'magnet') {
                    // Magnet - Simple iconic design with pulsing field
                    const pulse = 0.7 + Math.sin(Date.now() * 0.006) * 0.3;
                    
                    // Magnetic field rings - cyan/white theme
                    ctx.save();
                    ctx.translate(this.x, this.y);
                    
                    for (let i = 0; i < 3; i++) {
                        const fieldRadius = 10 + i * 5;
                        ctx.strokeStyle = `rgba(100, 200, 255, ${0.3 * pulse * (1 - i / 3)})`;
                        ctx.lineWidth = 1.5;
                        ctx.beginPath();
                        ctx.arc(0, 0, fieldRadius, 0, Math.PI*2);
                        ctx.stroke();
                    }
                    
                    // Stylized M letter with glow
                    ctx.font = 'bold 20px Arial';
                    ctx.fillStyle = '#ffffff';
                    ctx.shadowColor = '#00ccff';
                    ctx.shadowBlur = 12 * pulse;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('M', 0, 0);
                    
                    // Subtle circle background
                    ctx.globalAlpha = 0.3;
                    ctx.fillStyle = '#00ccff';
                    ctx.shadowBlur = 0;
                    ctx.beginPath();
                    ctx.arc(0, 0, 12, 0, Math.PI*2);
                    ctx.fill();
                    ctx.globalAlpha = 1;
                    
                    ctx.shadowBlur = 0;
                    ctx.restore();
                } else if (this.type === 'nexus_core') {
                    // Nexus Core - Premium purple/magenta glowing crystal
                    const pulse = 0.6 + Math.sin(Date.now() * 0.004) * 0.4;
                    const rotation = Date.now() * 0.001;
                    
                    ctx.save();
                    ctx.translate(this.x, this.y);
                    ctx.rotate(rotation);
                    
                    // Outer glow aura
                    const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, 25);
                    gradient.addColorStop(0, `rgba(255, 0, 255, ${0.4 * pulse})`);
                    gradient.addColorStop(0.5, `rgba(180, 0, 200, ${0.2 * pulse})`);
                    gradient.addColorStop(1, 'rgba(255, 0, 255, 0)');
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(0, 0, 25, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Main hexagon crystal
                    ctx.fillStyle = '#aa00ff';
                    ctx.strokeStyle = '#ff00ff';
                    ctx.lineWidth = 2;
                    ctx.shadowColor = '#ff00ff';
                    ctx.shadowBlur = 20 * pulse;
                    ctx.beginPath();
                    for (let i = 0; i < 6; i++) {
                        const angle = (Math.PI / 3) * i;
                        const x = Math.cos(angle) * 12;
                        const y = Math.sin(angle) * 12;
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                    
                    // Inner glow core
                    ctx.fillStyle = '#ffffff';
                    ctx.globalAlpha = pulse;
                    ctx.shadowBlur = 10;
                    ctx.beginPath();
                    ctx.arc(0, 0, 5, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.globalAlpha = 1;
                    
                    // Energy particles orbiting
                    for (let i = 0; i < 4; i++) {
                        const orbitAngle = rotation * 2 + (i * Math.PI / 2);
                        const orbitRadius = 16;
                        const px = Math.cos(orbitAngle) * orbitRadius;
                        const py = Math.sin(orbitAngle) * orbitRadius;
                        ctx.fillStyle = `rgba(255, 100, 255, ${pulse})`;
                        ctx.shadowBlur = 8;
                        ctx.beginPath();
                        ctx.arc(px, py, 2, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    
                    ctx.shadowBlur = 0;
                    ctx.restore();
                } else if (this.type === 'core') {
                    ctx.fillStyle = '#ff00ff'; ctx.font = 'bold 24px Orbitron'; ctx.fillText('DATA', this.x-20, this.y+10);
                } else if (this.type === 'mod_crate') {
                    ctx.fillStyle = '#ffdd57'; ctx.shadowColor = '#ffdd57'; ctx.shadowBlur = 15;
                    ctx.fillRect(this.x-10, this.y-10, 20, 20); ctx.shadowBlur = 0;
                    ctx.fillStyle = '#000'; ctx.font = 'bold 12px Arial'; ctx.fillText('?', this.x-4, this.y+4);
                }
            }
        }
        
        class Particle {
            constructor(x, y, color, speed) {
                this.x=x; this.y=y; this.color=color; this.life=1;
                const a = seededRandom()*Math.PI*2; const s = seededRandom()*speed*3;
                this.vx = Math.cos(a)*s; this.vy = Math.sin(a)*s;
            }
            update() { this.x+=this.vx; this.y+=this.vy; this.life-=0.05; return this.life>0; }
            draw(ctx) { ctx.globalAlpha=this.life; ctx.fillStyle=this.color; ctx.fillRect(this.x,this.y,3,3); ctx.globalAlpha=1; }
        }


        class MuzzleFlash {
            constructor(x,y) { this.x=x; this.y=y; this.life=3; }
            update() { this.life--; return this.life>0; }
            draw(ctx) { ctx.fillStyle='rgba(200,255,255,0.8)'; ctx.beginPath(); ctx.arc(this.x,this.y,10,0,Math.PI*2); ctx.fill(); }
        }


        class LightningBolt {
            constructor(x1, y1, x2, y2) { this.x1=x1; this.y1=y1; this.x2=x2; this.y2=y2; this.life=8; }
            update() { this.life--; return this.life>0; }
            draw(ctx) {
                ctx.shadowBlur = 15; ctx.shadowColor = '#ffeb3b';
                ctx.lineWidth = 4; ctx.strokeStyle = `rgba(255, 235, 59, ${this.life/8})`; // Yellow
                ctx.beginPath(); ctx.moveTo(this.x1,this.y1);
                const dist = Math.sqrt((this.x2-this.x1)**2 + (this.y2-this.y1)**2);
                const steps = Math.max(3, Math.floor(dist / 30));
                for(let i=1; i<steps; i++) {
                    const t = i / steps; const r = (seededRandom()-0.5) * 40;
                    ctx.lineTo(this.x1 + (this.x2-this.x1)*t + r, this.y1 + (this.y2-this.y1)*t + r);
                }
                ctx.lineTo(this.x2,this.y2); ctx.stroke(); ctx.shadowBlur = 0;
            }
        }
        
        class GasCloud {
            constructor(x, y, radius, tickDamage, level) {
                this.x = x;
                this.y = y;
                this.radius = radius;
                this.tickDamage = tickDamage;
                this.level = level;
                this.life = 300; // 5 seconds
                this.maxLife = 300;
                this.tickTimer = 0;
                this.opacity = 0;
                this.cloudParticles = [];
                
                // OPTIMIZED: Reduced particle count for better performance
                const particleCount = Math.floor(30 + (radius / 80) * 10); // Reduced from 50 base
                for (let i = 0; i < particleCount; i++) {
                    const angle = seededRandom() * Math.PI * 2;
                    const dist = Math.sqrt(seededRandom()) * radius; // Square root for even distribution
                    this.cloudParticles.push({
                        offsetX: Math.cos(angle) * dist,
                        offsetY: Math.sin(angle) * dist,
                        size: 8 + seededRandom() * 12, // Slightly larger particles
                        orbitAngle: angle,
                        orbitSpeed: (seededRandom() - 0.5) * 0.015,
                        orbitRadius: 5 + seededRandom() * 15,
                        phase: seededRandom() * Math.PI * 2,
                        pulseSpeed: 0.02 + seededRandom() * 0.03
                    });
                }
            }
            
            update(dt) {
                this.life -= dt/16;
                this.tickTimer += dt/16;
                
                // Fade in/out
                if (this.life > 270) {
                    this.opacity = Math.min(0.8, (300 - this.life) / 30);
                } else if (this.life < 60) {
                    this.opacity = this.life / 60 * 0.8;
                } else {
                    this.opacity = 0.8;
                }
                
                // Damage tick every 20 frames (~0.33s)
                if (Math.floor(this.tickTimer) % 20 === 0 && this.tickTimer > 1) {
                    entities.enemies.forEach(e => {
                        const dist = Math.sqrt((e.x - this.x)**2 + (e.y - this.y)**2);
                        if (dist < this.radius) {
                            player.dealElementalDamage(e, this.tickDamage, 'gas', '#99ff33');
                        }
                    });
                }
                
                // Update swirling particles
                this.cloudParticles.forEach(p => {
                    p.orbitAngle += p.orbitSpeed * (dt/16);
                    p.phase += p.pulseSpeed * (dt/16);
                });
                
                return this.life > 0;
            }
            
            draw(ctx) {
                ctx.save();
                ctx.translate(this.x, this.y);
                
                // OPTIMIZED: Simplified rendering with fewer calculations per particle
                this.cloudParticles.forEach((p, i) => {
                    // Particle drifts in small orbit
                    const driftX = Math.cos(p.orbitAngle) * p.orbitRadius;
                    const driftY = Math.sin(p.orbitAngle) * p.orbitRadius;
                    const x = p.offsetX + driftX;
                    const y = p.offsetY + driftY;
                    
                    // Simplified pulsing - use pre-calculated phase
                    const pulse = 0.7 + Math.sin(p.phase) * 0.3;
                    const size = p.size * pulse;
                    
                    // Varied opacity for depth (simpler calculation)
                    const baseOpacity = this.opacity * (0.3 + (i % 3) * 0.15);
                    
                    // OPTIMIZED: Simpler gradient with fewer color stops
                    const gradient = ctx.createRadialGradient(x, y, 0, x, y, size);
                    gradient.addColorStop(0, `rgba(153, 255, 51, ${baseOpacity})`);
                    gradient.addColorStop(0.6, `rgba(102, 204, 0, ${baseOpacity * 0.4})`);
                    gradient.addColorStop(1, 'rgba(51, 153, 0, 0)');
                    
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(x, y, size, 0, Math.PI * 2);
                    ctx.fill();
                });
                
                // OPTIMIZED: Simpler outer glow
                const outerGlow = ctx.createRadialGradient(0, 0, this.radius * 0.7, 0, 0, this.radius);
                outerGlow.addColorStop(0, 'rgba(153, 255, 51, 0)');
                outerGlow.addColorStop(0.9, `rgba(153, 255, 51, ${this.opacity * 0.08})`);
                outerGlow.addColorStop(1, 'rgba(153, 255, 51, 0)');
                
                ctx.fillStyle = outerGlow;
                ctx.beginPath();
                ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.restore();
            }
        }
        
        class FloatingText {
            constructor(x, y, text, color='#fff', isCrit=false, type='normal', sourceId=null, elementType=null) { 
                this.x=x; this.y=y; this.text=text; this.life=50; this.color=color; 
                this.isCrit = isCrit;
                this.sourceId = sourceId; // Weapon source (ion, tesla, beam, etc)
                this.elementType = elementType; // Element type for DOTs (fire, ice, volt, bio, hack)
                
                // Random Drift
                this.vx = (seededRandom()-0.5) * 2;
                if(isCrit) { this.life = 30; this.y -= 20; } // Faster crit (40 -> 30)
                if(type === 'dot') { this.x += (seededRandom()-0.5)*20; this.y += (seededRandom()-0.5)*20; }
            }
            update(dt) { 
                this.x += this.vx * (dt/16);
                this.y -= (this.isCrit ? 2 : 0.5) * (dt/16); // Faster rise for crits
                this.life -= (dt/16); 
                return this.life > 0; 
            }
            draw(ctx) { 
                ctx.globalAlpha = Math.min(1, this.life/30);
                if (this.isCrit) {
                    ctx.fillStyle = '#ffdd57'; 
                    ctx.font = '900 24px "Orbitron"';
                    ctx.shadowColor = '#ff5500'; ctx.shadowBlur = 10;
                    // Single pulse: grows then shrinks once
                    const scale = 1 + Math.sin((30-this.life)*0.21)*0.3; // Faster cycle
                    ctx.save(); ctx.translate(this.x, this.y); ctx.scale(scale, scale);
                    ctx.fillText(this.text + "!", 0, 0);
                    ctx.restore();
                } else {
                    ctx.fillStyle = this.color; 
                    ctx.font = 'bold 16px "Orbitron"'; 
                    ctx.shadowColor = 'black'; ctx.shadowBlur = 4; 
                    ctx.fillText(this.text, this.x, this.y);
                    
                    // Draw elemental icon next to damage if present
                    if (this.elementType) {
                        ctx.shadowBlur = 0;
                        ctx.font = 'bold 16px "Orbitron"'; // Increased from 12px to 16px to match text
                        const iconOffset = ctx.measureText(this.text).width + 4;
                        
                        // Elemental icon colors and symbols
                        const elementIcons = {
                            'fire': { color: '#ff5722', symbol: '🔥' },
                            'ice': { color: '#88d8ff', symbol: '❄' },
                            'volt': { color: '#ffeb3b', symbol: '⚡' },
                            'bio': { color: '#00cc44', symbol: '☣' }, // Changed from ☠ to ☣ for better readability
                            'hack': { color: '#00ffff', symbol: '⚙' }
                        };
                        
                        if (elementIcons[this.elementType]) {
                            const icon = elementIcons[this.elementType];
                            ctx.fillStyle = icon.color;
                            ctx.fillText(icon.symbol, this.x + iconOffset, this.y);
                        }
                    }
                }
                ctx.globalAlpha=1; ctx.shadowBlur = 0; 
            }
        }


        // --- Core ---


        function initGame() {
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            
            // Initialize seed from input or generate new one
            const seedInput = document.getElementById('seed-input').value.trim();
            if (seedInput && /^\d{6}$/.test(seedInput)) {
                // Valid 6-digit seed provided
                state.seed = parseInt(seedInput);
            } else {
                // Generate random seed
                state.seed = generateSeed();
            }
            setSeed(state.seed);
            
            player = new Player();
            entities = { enemies: [], projectiles: [], enemyProjectiles: [], particles: [], pickups: [], texts: [], lightnings: [], gasClouds: [] };
            state.score=0; state.level=1; state.xp=0; state.xpToNext=10; 
            state.startTime=Date.now(); state.screen='game'; state.rerolls=3;
            state.paused = false; state.timeScale = 1.0; state.pendingLevelUps = 0; state.zoom = 0.70; 
            state.bossActive = false; state.bossWave = 0; state.pendingSwap = null;
            state.bossTimer = 0; state.gameTime = 0;
            state.saveCharges = 3; state.savedUpgrade = null;
            state.weaponStats = {}; // Reset weapon stats tracking
            window.upgradesSaveMode = false;
            // Reset HUD
            document.getElementById('boss-hud').classList.remove('active');
            
            updateHud(); 
            state.lastTime = Date.now();
            document.getElementById('hud').style.display='flex';
            document.getElementById('start-hint').style.display='block';
            gameLoop();
        }


        function createExplosion(x, y, color, count) {
            // Scale down particle creation if we're already at high counts
            const currentCount = entities.particles.length;
            let scaledCount = count;
            
            if(currentCount > 200) {
                scaledCount = Math.max(1, Math.floor(count * 0.3)); // Reduce to 30%
            } else if(currentCount > 150) {
                scaledCount = Math.max(2, Math.floor(count * 0.5)); // Reduce to 50%
            } else if(currentCount > 100) {
                scaledCount = Math.max(3, Math.floor(count * 0.7)); // Reduce to 70%
            }
            
            for(let i=0; i<scaledCount; i++) {
                entities.particles.push(new Particle(x, y, color, 1.0));
            }
        }

        // MULTISTRIKE SYSTEM
        // Base multistrike: Simple one extra cast, no chaining
        // Cascade mod: Doubles chance + enables chaining with 50% decay
        function checkMultistrike(fireFunc, damageMultiplier = 1.0, depth = 0, maxDepth = 5) {
            // Base multistrike (no cascade) - just one extra cast
            if (player.activeMod !== 'cascade') {
                if (depth === 0 && seededRandom() < player.multicast) {
                    setTimeout(() => fireFunc(damageMultiplier, 1), 100);
                }
                return;
            }
            
            // Cascade mod: 25% boost + chaining with 50% decay
            if (depth >= maxDepth) return; // Max chain depth
            
            const baseChance = player.multicast * 1.25; // Cascade gives 25% boost (reduced from 2x)
            const decayedChance = baseChance * Math.pow(0.5, depth); // 50% decay per level
            
            if (seededRandom() < decayedChance) {
                setTimeout(() => fireFunc(damageMultiplier, depth + 1), 100);
            }
        }


        function activateMagnet() {
            entities.pickups.forEach(p => {
                p.magnetized = true;
                // Magnet lasts 10 seconds
                setTimeout(() => { p.magnetized = false; }, 10000);
            });
        }


        function triggerModPickup() {
            const possible = ['repulsor', 'overclock', 'chrono', 'revive', 'laststand', 'shieldburst', 'cascade']; 
            
            // Pick 2 random mods (ensure they're different)
            const shuffled = possible.sort(() => seededRandom() - 0.5);
            const mod1 = shuffled[0];
            const mod2 = shuffled[1];
            
            state.paused = true;
            document.getElementById('mod-confirm-screen').classList.add('active');
            
            const def1 = modDefs[mod1];
            const def2 = modDefs[mod2];
            
            // Build side-by-side card UI
            const hasExistingMod = player.activeMod !== null;
            const warningText = hasExistingMod 
                ? `<div class="text-yellow-400 text-sm mb-4">You have: <span class="text-teal-300">${modDefs[player.activeMod].name}</span> - Choosing a new mod will replace it!</div>`
                : '';
            
            document.getElementById('mod-confirm-content').innerHTML = `
                <div class="text-3xl font-bold text-white mb-2">BOSS DEFEATED</div>
                <div class="text-xl text-teal-400 mb-4">Choose Your Mod</div>
                ${warningText}
                
                <div style="display: flex; flex-direction: column; gap: 16px; width: 100%; max-width: 550px; margin: 0 auto 20px; padding: 0 20px;">
                    <!-- Mod 1 Card -->
                    <div class="card legendary" onclick="selectMod('${mod1}')" style="margin: 4px 0 4px 45px;">
                        <div class="card-header">
                            <i class="fas ${def1.icon}"></i>
                        </div>
                        <div class="card-content">
                            <h3>${def1.name}</h3>
                            <p>${def1.desc}</p>
                        </div>
                    </div>
                    
                    <!-- Mod 2 Card -->
                    <div class="card legendary" onclick="selectMod('${mod2}')" style="margin: 4px 0 4px 45px;">
                        <div class="card-header">
                            <i class="fas ${def2.icon}"></i>
                        </div>
                        <div class="card-content">
                            <h3>${def2.name}</h3>
                            <p>${def2.desc}</p>
                        </div>
                    </div>
                </div>
                
                <button onclick="closeModConfirm()" style="padding: 10px 20px; background: rgba(100,100,100,0.3); border: 2px solid #666; color: #999; border-radius: 4px; cursor: pointer; font-size: 14px;">
                    Skip (Keep Current Mod)
                </button>
            `;
        }

        function selectMod(id) {
            // If player has existing mod, show in-game confirmation dialog
            if (player.activeMod !== null && player.activeMod !== id) {
                const currentDef = modDefs[player.activeMod];
                const newDef = modDefs[id];
                
                // Show replacement confirmation modal
                const confirmScreen = document.getElementById('mod-confirm-screen');
                const confirmContent = document.getElementById('mod-confirm-content');
                
                confirmContent.innerHTML = `
                    <div class="text-center">
                        <div class="text-xl font-bold text-red-400 mb-4">⚠️ REPLACE MOD?</div>
                        <div class="text-gray-300 mb-2">Current: <span class="text-teal-400">${currentDef.name}</span></div>
                        <div class="text-gray-300 mb-4">New: <span class="text-yellow-400">${newDef.name}</span></div>
                        <div class="text-red-300 text-sm mb-6">This will permanently destroy your current mod!</div>
                        
                        <div class="flex gap-4 justify-center">
                            <button onclick="confirmModReplacement('${id}')" class="bg-red-500 hover:bg-red-400 text-white font-bold py-3 px-6 rounded transition">
                                REPLACE
                            </button>
                            <button onclick="cancelModReplacement()" class="bg-gray-600 hover:bg-gray-500 text-white font-bold py-3 px-6 rounded transition">
                                CANCEL
                            </button>
                        </div>
                    </div>
                `;
                
                confirmScreen.classList.add('active');
            } else {
                equipMod(id);
            }
        }
        
        function confirmModReplacement(id) {
            equipMod(id);
            document.getElementById('mod-confirm-screen').classList.remove('active');
        }
        
        function cancelModReplacement() {
            document.getElementById('mod-confirm-screen').classList.remove('active');
            // Don't unpause - still in mod selection
        }

        function equipMod(id) {
            player.activeMod = id;
            // Initialize mod-specific timers if needed
            if (id === 'chrono') {
                player.chronoCooldown = 0; // Ready to use
                player.chronoActive = false;
            }
            if (id === 'revive') {
                player.reviveCooldown = 0; // Ready to use
            }
            if (id === 'laststand') {
                player.hasLastStand = true;
            }
            if (id === 'shieldburst') {
                player.hasShieldBurst = true;
            }
            if (id === 'cascade') {
                // Cascade mod: 25% boost to all multistrike (reduced from 2x)
                player.multicast *= 1.25; // Boost current multicast by 25%
                player.cascadeMultiplier = 1.25; // Track that future gains should be boosted
            }

            updateHud();
            closeModConfirm();
        }


        // Old button handlers removed - using inline onclick in HTML
        
        function closeModConfirm() {
            document.getElementById('mod-confirm-screen').classList.remove('active');
            state.paused = false;
            state.pendingMod = null;
            state.pendingMods = null;
            state.lastTime = Date.now();
        }


        function togglePause() {
            if (state.screen !== 'game') return;
            state.paused = !state.paused;
            if (state.paused) { 
                document.getElementById('pause-screen').classList.add('active'); 
                
                // Show stats tab by default
                document.getElementById('stats-tab').classList.remove('hidden');
                document.getElementById('kit-tab').classList.add('hidden');
                document.getElementById('stats-tab-btn').classList.add('active', 'border-teal-500', 'text-teal-500');
                document.getElementById('stats-tab-btn').classList.remove('border-transparent', 'text-gray-400');
                document.getElementById('kit-tab-btn').classList.remove('active', 'border-teal-500', 'text-teal-500');
                document.getElementById('kit-tab-btn').classList.add('border-transparent', 'text-gray-400');
                
                // Populate stats
                const grid = document.getElementById('stats-grid');
                grid.innerHTML = '';
                const addStat = (label, val, gold=false) => {
                    grid.innerHTML += `<div class="stat-row"><span class="stat-label">${label}</span><span class="stat-val ${gold?'gold':''}">${val}</span></div>`;
                };

                addStat('LEVEL', state.level);
                addStat('HP', `${Math.floor(player.hp)} / ${Math.floor(player.maxHp)}`, player.maxHp > 150);
                addStat('DAMAGE', `+${Math.round((player.damage/15 - 1)*100)}%`, player.damage > 15);
                const cdr = Math.round((1 - (player.fireRate / 500)) * 100); // Base is 500
                addStat('COOLDOWN REDUCTION', `${cdr > 0 ? '-' : ''}${cdr}%`, cdr !== 0); // Don't highlight at 0%
                addStat('ARMOR', player.armor, player.armor > 20);
                addStat('SPEED', player.speed.toFixed(1), player.speed > 3.5);
                addStat('CRIT CHANCE', `${Math.round(player.critChance*100)}%`, player.critChance > 0.07);
                addStat('MULTISTRIKE', `${Math.round(player.multicast*100)}%`, player.multicast > 0.07);
                addStat('LUCK', player.luck, player.luck > 0);
                addStat('ELEM CHANCE', `${Math.round(player.elementalMult * 50)}%`, player.elementalMult > 1.0);
                addStat('XP GAIN', `+${Math.round(player.xpGain*100)}%`, player.xpGain > 0);
                addStat('REGEN', `${player.regen.toFixed(2)}/s`, player.regen > 0);

                // Populate kit view
                const kitGrid = document.getElementById('kit-grid');
                kitGrid.innerHTML = '';
                
                // Show weapons
                Object.keys(player.weapons).forEach(wKey => {
                    if (player.weapons[wKey] > 0) {
                        const wDef = weaponDefs[wKey];
                        const wStats = player.weaponStats[wKey];
                        const level = player.weapons[wKey];
                        const augElement = player.weaponAugments[wKey]; // Single element or null
                        
                        const dmgModified = Math.abs(wStats.dmg - 1.0) > 0.01;
                        const rateModified = Math.abs(wStats.rate - 1.0) > 0.01;
                        const areaModified = Math.abs(wStats.area - 1.0) > 0.01;
                        
                        // Elemental augment display (single augment)
                        let augDisplay = '';
                        if (augElement) {
                            let augHTML = '';
                            if (augElement === 'fire') augHTML = `<span class="text-orange-400"><i class="fas fa-fire"></i> Fire</span>`;
                            if (augElement === 'ice') augHTML = `<span class="text-cyan-400"><i class="fas fa-snowflake"></i> Cryo</span>`;
                            if (augElement === 'volt') augHTML = `<span class="text-yellow-400"><i class="fas fa-bolt"></i> Volt</span>`;
                            if (augElement === 'bio') augHTML = `<span class="text-purple-400"><i class="fas fa-biohazard"></i> Bio</span>`;
                            if (augElement === 'hack') augHTML = `<span class="text-green-400"><i class="fas fa-terminal"></i> Hack</span>`;
                            if (augHTML) {
                                augDisplay = `<div class="text-xs mt-2">${augHTML}</div>`;
                            }
                        }
                        
                        kitGrid.innerHTML += `
                            <div class="bg-gray-800 bg-opacity-50 border border-gray-700 p-4 rounded">
                                <div class="flex items-center gap-3 mb-2">
                                    <i class="fas ${wDef.icon} text-2xl text-teal-400"></i>
                                    <div>
                                        <h3 class="text-white font-bold text-lg">${wDef.name}</h3>
                                        <p class="text-gray-400 text-sm">Level ${level}</p>
                                    </div>
                                </div>
                                <p class="text-gray-300 text-sm mb-3">${wDef.desc}</p>
                                <div class="grid grid-cols-3 gap-2 text-sm">
                                    <div class="text-center">
                                        <div class="text-gray-400">Damage</div>
                                        <div class="${dmgModified ? 'text-yellow-400 font-bold' : 'text-white'}">
                                            +${((wStats.dmg - 1.0) * 100).toFixed(0)}%
                                        </div>
                                    </div>
                                    <div class="text-center">
                                        <div class="text-gray-400">Cooldown</div>
                                        <div class="${rateModified ? 'text-yellow-400 font-bold' : 'text-white'}">
                                            -${((1.0 - wStats.rate) * 100).toFixed(0)}%
                                        </div>
                                    </div>
                                    <div class="text-center">
                                        <div class="text-gray-400">Area</div>
                                        <div class="${areaModified ? 'text-yellow-400 font-bold' : 'text-white'}">
                                            +${((wStats.area - 1.0) * 100).toFixed(0)}%
                                        </div>
                                    </div>
                                </div>
                                ${augDisplay}
                            </div>
                        `;
                    }
                });
                
                // Show equipped mod
                if (player.activeMod) {
                    const modDef = modDefs[player.activeMod];
                    if (modDef) {
                        kitGrid.innerHTML += `
                            <div class="bg-yellow-900 bg-opacity-30 border-2 border-yellow-500 p-4 rounded">
                                <div class="flex items-center gap-3 mb-2">
                                    <i class="fas ${modDef.icon} text-2xl text-yellow-400"></i>
                                    <div>
                                        <h3 class="text-yellow-400 font-bold text-lg">${modDef.name}</h3>
                                        <p class="text-gray-400 text-sm">Equipped Mod</p>
                                    </div>
                                </div>
                                <p class="text-gray-300 text-sm">${modDef.desc}</p>
                            </div>
                        `;
                    }
                }


            } else { 
                document.getElementById('pause-screen').classList.remove('active'); 
                state.lastTime = Date.now(); 
            }
        }
        
        // Tab switching handlers
        document.getElementById('stats-tab-btn').onclick = () => {
            document.getElementById('stats-tab').classList.remove('hidden');
            document.getElementById('kit-tab').classList.add('hidden');
            document.getElementById('stats-tab-btn').classList.add('active', 'border-teal-500', 'text-teal-500');
            document.getElementById('stats-tab-btn').classList.remove('border-transparent', 'text-gray-400');
            document.getElementById('kit-tab-btn').classList.remove('active', 'border-teal-500', 'text-teal-500');
            document.getElementById('kit-tab-btn').classList.add('border-transparent', 'text-gray-400');
        };
        
        document.getElementById('kit-tab-btn').onclick = () => {
            document.getElementById('kit-tab').classList.remove('hidden');
            document.getElementById('stats-tab').classList.add('hidden');
            document.getElementById('kit-tab-btn').classList.add('active', 'border-teal-500', 'text-teal-500');
            document.getElementById('kit-tab-btn').classList.remove('border-transparent', 'text-gray-400');
            document.getElementById('stats-tab-btn').classList.remove('active', 'border-teal-500', 'text-teal-500');
            document.getElementById('stats-tab-btn').classList.add('border-transparent', 'text-gray-400');
        }


        window.closeGlossary = () => {
            document.getElementById('glossary-screen').classList.remove('active');
            document.getElementById('pause-screen').classList.add('active');
        };


        document.getElementById('glossary-btn').onclick = () => {
            document.getElementById('pause-screen').classList.remove('active');
            document.getElementById('glossary-screen').classList.add('active');
        };


        function drawIndicators() {
            const screenW = width / state.zoom; const screenH = height / state.zoom;
            const centerX = player.x; const centerY = player.y; const padding = 40;
            const drawArrow = (x, y, color) => {
                const dx = x - centerX; const dy = y - centerY; const angle = Math.atan2(dy, dx);
                const marginX = screenW/2 - padding; const marginY = screenH/2 - padding;
                if (Math.abs(dx) < 1 && Math.abs(dy) < 1) return;
                if (Math.abs(dx) > marginX || Math.abs(dy) > marginY) {
                    let cx = dx; let cy = dy; 
                    const slope = (Math.abs(dx) > 0.1) ? dy/dx : 10000 * Math.sign(dy);
                    if (Math.abs(dx) > marginX) { cx = Math.sign(dx) * marginX; cy = cx * slope; }
                    if (Math.abs(cy) > marginY) { cy = Math.sign(dy) * marginY; cx = cy / slope; if (Math.abs(cx) > marginX) cx = Math.sign(dx) * marginX; }
                    const px = centerX + cx; const py = centerY + cy;
                    ctx.save(); ctx.translate(px, py); ctx.rotate(angle); ctx.fillStyle = color;
                    ctx.beginPath(); ctx.moveTo(10, 0); ctx.lineTo(-10, 8); ctx.lineTo(-10, -8); ctx.fill(); ctx.restore();
                }
            };
            entities.enemies.forEach(e => { if (e.type === 'tank' || e.type === 'boss') drawArrow(e.x, e.y, '#ff0000'); });
            entities.pickups.forEach(p => { if (p.type === 'health') drawArrow(p.x, p.y, '#00cc44'); if (p.type === 'magnet') drawArrow(p.x, p.y, '#ffffff'); });
        }


        function toggleLockKit() {
            state.kitLocked = !state.kitLocked;
            state.lockUsed = true; // User has manually interacted - don't auto-enable again
            const el = document.getElementById('lock-kit-toggle');
            if(state.kitLocked) el.classList.add('toggle-active');
            else el.classList.remove('toggle-active');
        }


        function gameLoop() {
            animationFrameId = requestAnimationFrame(gameLoop);
            if (state.screen !== 'game') return;


            const now = Date.now(); 
            let dt = now - state.lastTime;
            state.lastTime = now;
            if (dt > 50) dt = 16; // Clamp large deltas (tab switching, etc) to prevent physics explosions
            
            if (state.paused) return; 


            state.gameTime += (dt * state.timeScale);
            if(state.breathingRoomTimer > 0) state.breathingRoomTimer -= dt/16;

            let targetTimeScale = input.active ? 1.0 : 0.1;
            
            // CHRONO SHIELD MOD: Slow time to 20% when below 30% HP, but player stays at 100%
            if (player.activeMod === 'chrono' && player.chronoActive && input.active) {
                targetTimeScale = 0.2; // 20% slow (everything except player)
            }
            
            state.timeScale += (targetTimeScale - state.timeScale) * 0.1;
            const scaledDt = dt * state.timeScale;


            state.frameCount++;
            
            // Health Regeneration handled in player.update() - removed duplicate system here
            
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.fillStyle = '#050608'; ctx.fillRect(0, 0, width, height);


            const tx = width/2 - player.x * state.zoom; const ty = height/2 - player.y * state.zoom;
            // Framerate-independent camera lerp (targets ~60fps behavior)
            const lerpFactor = 1 - Math.pow(0.85, dt/16); // Smooth follow that works at any framerate
            state.camera.x += (tx - state.camera.x) * lerpFactor; 
            state.camera.y += (ty - state.camera.y) * lerpFactor;
            
            if (!Number.isFinite(state.camera.x)) state.camera.x = 0;
            if (!Number.isFinite(state.camera.y)) state.camera.y = 0;


            let sx=0, sy=0;
            if(state.shake>0) { sx=(seededRandom()-0.5)*state.shake; sy=(seededRandom()-0.5)*state.shake; state.shake*=0.9; }


            // SAFE GRID
            const gs = 80 * state.zoom;
            ctx.strokeStyle = '#1e2130'; ctx.lineWidth = 2; ctx.beginPath();
            let offsetX = state.camera.x % gs; let offsetY = state.camera.y % gs;
            if (isNaN(offsetX)) offsetX = 0; if (isNaN(offsetY)) offsetY = 0;
            
            let loopGuard = 0;
            for (let x = offsetX; x < width; x += gs) { ctx.moveTo(x, 0); ctx.lineTo(x, height); loopGuard++; if(loopGuard>1000) break; }
            loopGuard = 0;
            for (let y = offsetY; y < height; y += gs) { ctx.moveTo(0, y); ctx.lineTo(width, y); loopGuard++; if(loopGuard>1000) break; }
            ctx.stroke();


            ctx.save(); ctx.translate(state.camera.x+sx, state.camera.y+sy); ctx.scale(state.zoom, state.zoom);


            // CHAMPION SPAWN: Levels 15, 25, 35, 45 - spawns with normal enemies
            if (!state.bossActive && state.bossWave !== state.level && (state.level === 15 || (state.level > 15 && (state.level - 15) % 10 === 0))) {
                state.bossActive = true; // Flag to track champion is active
                state.bossWave = state.level;
                // DON'T clear enemies - champion joins the fight!
                
                const champion = new Enemy('champion');
                // Give champion ONE random ability (instead of 2 like boss)
                const abilityPool = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
                champion.abilities = [abilityPool[Math.floor(seededRandom() * abilityPool.length)]];
                entities.enemies.push(champion);
                
                // Dynamic Champion Name
                const name = `CHAMPION ${champion.abilityNames[champion.abilities[0]]}`;
                document.getElementById('boss-name-display').innerText = name;

                document.getElementById('boss-hud').classList.add('active');
                const warn = document.getElementById('boss-warning');
                warn.style.display = 'block';
                setTimeout(() => warn.style.display = 'none', 3000);
            }


            const mins = state.gameTime / 60000;
            // Boost early game spawn cap for levels 1-5
            const baseSpawnCap = state.level < 5 ? 8 : 5;
            const spawnCap = baseSpawnCap + Math.floor(mins * 15) + state.level; 
            
            // During champion fights, spawn at 60% normal rate
            const spawnInterval = state.bossActive ? 
                Math.floor((25 - Math.min(12, state.level)) * 1.67) : // 67% slower during champion = 60% rate
                (25 - Math.min(12, state.level));
            
            if(state.breathingRoomTimer <= 0 && entities.enemies.length < spawnCap && state.frameCount % spawnInterval === 0) { 
                let type = 'drone'; const r = seededRandom();
                if(state.score>300 && r>0.7) type='swarm';
                if(state.score>500 && r>0.99 && state.level >= 5) type='tank';
                // Splitters appear after level 8, 8% chance (reduced from 15%)
                if(state.level >= 8 && r>0.7 && r<=0.78) type='splitter';
                // Voidwalkers appear after level 15, 4% chance, max 2-3 on screen
                if(state.level >= 15 && r>0.85 && r<=0.89) {
                    const maxVoidwalkers = state.level >= 25 ? 3 : 2;
                    const voidwalkerCount = entities.enemies.filter(e => e.type === 'voidwalker').length;
                    if (voidwalkerCount < maxVoidwalkers) {
                        type='voidwalker';
                    }
                }
                entities.enemies.push(new Enemy(type));
            }


            if (entities.particles.length > 80) entities.particles.splice(0, entities.particles.length - 80);


            entities.pickups = entities.pickups.filter(p => { const a=p.update(scaledDt); if(a) p.draw(ctx); return a; });
            
            // Chrono Shield: Player moves at 100% speed even when time is slowed
            const playerDt = (player.activeMod === 'chrono' && player.chronoActive) ? dt : scaledDt;
            player.update(playerDt); player.draw(ctx);
            
            // Apply EMP field effects before enemy updates
            if (player.empFields && player.empFields.length > 0) {
                entities.enemies.forEach(e => {
                    e.empSlowStacks = 0; // Reset stacks each frame
                    
                    player.empFields.forEach(field => {
                        const dist = Math.sqrt((e.x - field.x)**2 + (e.y - field.y)**2);
                        if (dist < field.radius) {
                            e.empSlowStacks++;
                        }
                    });
                });
            }
            
            // Enemy updates with spatial culling
            entities.enemies = entities.enemies.filter(e => { 
                e.update(scaledDt); 
                e.draw(ctx); 
                return e.hp>0; 
            });
            
            // OFF-SCREEN CHAMPION INDICATORS
            // Draw distinct orange indicators for champions that are off-screen
            ctx.save();
            const screenHalfW = (width / state.zoom) / 2;
            const screenHalfH = (height / state.zoom) / 2;
            
            entities.enemies.forEach(e => {
                if (!e.isChampion) return; // Only for champions
                
                const dx = e.x - player.x;
                const dy = e.y - player.y;
                
                // Check if champion is off-screen
                const isOffScreen = Math.abs(dx) > screenHalfW || Math.abs(dy) > screenHalfH;
                if (!isOffScreen) return;
                
                // Calculate edge position
                const angle = Math.atan2(dy, dx);
                const edgeX = Math.cos(angle) * (screenHalfW - 40);
                const edgeY = Math.sin(angle) * (screenHalfH - 40);
                
                ctx.translate(edgeX, edgeY);
                ctx.rotate(angle);
                
                // Pulsing orange champion indicator (larger and more distinct)
                const pulse = 0.7 + Math.sin(state.frameCount * 0.15) * 0.3;
                
                // Outer glow
                ctx.shadowBlur = 25 * pulse;
                ctx.shadowColor = '#ff6600';
                
                // Large triangle (champion indicator)
                ctx.fillStyle = `rgba(255, 102, 0, ${0.9 * pulse})`;
                ctx.beginPath();
                ctx.moveTo(20, 0);
                ctx.lineTo(-12, -14);
                ctx.lineTo(-12, 14);
                ctx.closePath();
                ctx.fill();
                
                // Bright outline
                ctx.strokeStyle = '#ffaa00';
                ctx.lineWidth = 3;
                ctx.stroke();
                
                // Inner accent
                ctx.fillStyle = '#ffcc00';
                ctx.beginPath();
                ctx.moveTo(14, 0);
                ctx.lineTo(-6, -8);
                ctx.lineTo(-6, 8);
                ctx.closePath();
                ctx.fill();
                
                ctx.shadowBlur = 0;
                ctx.setTransform(1, 0, 0, 1, 0, 0);
                ctx.translate(width / 2 - player.x * state.zoom, height / 2 - player.y * state.zoom);
                ctx.scale(state.zoom, state.zoom);
            });
            ctx.restore();
            
            // Particle system with performance limits
            entities.particles = entities.particles.filter(p => { 
                const a = p.update(); 
                if(a) {
                    // Cull particles far from player view
                    const dx = Math.abs(p.x - player.x);
                    const dy = Math.abs(p.y - player.y);
                    if(dx < 1500 && dy < 1500) { // Only draw nearby particles
                        p.draw(ctx);
                    }
                }
                return a; 
            });
            
            // Hard cap on particle count to prevent performance degradation
            const MAX_PARTICLES = 250;
            if(entities.particles.length > MAX_PARTICLES) {
                entities.particles = entities.particles.slice(-MAX_PARTICLES);
            }
            
            entities.gasClouds = entities.gasClouds.filter(c => { const a=c.update(scaledDt); if(a) c.draw(ctx); return a; });
            entities.lightnings = entities.lightnings.filter(l => { const a=l.update(); if(a) l.draw(ctx); return a; });
            entities.texts = entities.texts.filter(t => { const a=t.update(scaledDt); if(a) t.draw(ctx); return a; });


            if (player.beamActive && player.beamTargets.length > 0) {
               player.beamTargets.forEach(t => {
                   ctx.shadowBlur = 10; ctx.shadowColor = '#ff00ff';
                   ctx.strokeStyle = '#ff00ff'; ctx.lineWidth = 4 + Math.sin(state.frameCount*0.5)*2;
                   ctx.beginPath(); ctx.moveTo(player.x, player.y); ctx.lineTo(t.x, t.y); ctx.stroke(); ctx.shadowBlur = 0;
               });
            }


            entities.enemyProjectiles = entities.enemyProjectiles.filter(ep => {
                // Early culling for projectiles far from player
                const roughDx = Math.abs(ep.x - player.x);
                const roughDy = Math.abs(ep.y - player.y);
                if(roughDx > 1500 || roughDy > 1500) return false; // Remove distant projectiles
                
                // Special rendering for meteor warnings
                if (ep.isMeteorWarning) {
                    ep.life -= (scaledDt/16);
                    
                    const progress = 1 - (ep.life / ep.maxLife);
                    ctx.save();
                    ctx.translate(ep.x, ep.y);
                    
                    // Pulsing danger zone - gets more intense as impact approaches
                    for (let i = 0; i < 3; i++) {
                        const ringProgress = (progress + (i * 0.2)) % 1;
                        const ringAlpha = 0.5 * (1 - ringProgress);
                        const ringRadius = ep.radius * (0.5 + ringProgress * 0.5);
                        ctx.strokeStyle = `rgba(255, 100, 0, ${ringAlpha})`;
                        ctx.lineWidth = 4;
                        ctx.beginPath();
                        ctx.arc(0, 0, ringRadius, 0, Math.PI*2);
                        ctx.stroke();
                    }
                    
                    // Filled danger zone - intensifies
                    const fillAlpha = 0.15 + (progress * 0.25);
                    ctx.fillStyle = `rgba(255, 100, 0, ${fillAlpha})`;
                    ctx.beginPath();
                    ctx.arc(0, 0, ep.radius, 0, Math.PI*2);
                    ctx.fill();
                    
                    // Outer warning ring
                    ctx.strokeStyle = `rgba(255, 0, 0, ${0.8 + Math.sin(progress * 30) * 0.2})`;
                    ctx.lineWidth = 3;
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = 'rgba(255, 100, 0, 0.6)';
                    ctx.beginPath();
                    ctx.arc(0, 0, ep.radius, 0, Math.PI*2);
                    ctx.stroke();
                    ctx.shadowBlur = 0;
                    
                    ctx.restore();
                    
                    return ep.life > 0;
                }
                
                // Homing for DEFLECTED projectiles - track origin enemy
                if (ep.deflected && ep.originEnemy) {
                    // Check if origin enemy is still alive
                    if (ep.originEnemy.hp > 0) {
                        const dx = ep.originEnemy.x - ep.x;
                        const dy = ep.originEnemy.y - ep.y;
                        const dist = Math.sqrt(dx*dx + dy*dy);
                        if (dist > 0) {
                            const turnSpeed = 0.12; // Strong homing for deflected shots
                            const targetAngle = Math.atan2(dy, dx);
                            const currentAngle = Math.atan2(ep.vy, ep.vx);
                            let angleDiff = targetAngle - currentAngle;
                            while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                            while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
                            
                            const newAngle = currentAngle + angleDiff * turnSpeed;
                            const speed = Math.sqrt(ep.vx*ep.vx + ep.vy*ep.vy);
                            ep.vx = Math.cos(newAngle) * speed;
                            ep.vy = Math.sin(newAngle) * speed;
                        }
                    } else {
                        // Origin enemy died, target nearest enemy
                        let nearestEnemy = null;
                        let minDist = Infinity;
                        entities.enemies.forEach(e => {
                            if (e.hp > 0) {
                                const d = Math.sqrt((e.x - ep.x)**2 + (e.y - ep.y)**2);
                                if (d < minDist) {
                                    minDist = d;
                                    nearestEnemy = e;
                                }
                            }
                        });
                        if (nearestEnemy) {
                            ep.originEnemy = nearestEnemy; // Update target
                        }
                    }
                }
                
                // Homing behavior for flagged projectiles
                if (ep.homing && ep.life > 0) {
                    const dx = player.x - ep.x;
                    const dy = player.y - ep.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    if (dist > 0) {
                        const turnSpeed = 0.05; // Gentle homing
                        const targetAngle = Math.atan2(dy, dx);
                        const currentAngle = Math.atan2(ep.vy, ep.vx);
                        let angleDiff = targetAngle - currentAngle;
                        // Normalize angle difference
                        while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
                        while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
                        const newAngle = currentAngle + angleDiff * turnSpeed;
                        const speed = Math.sqrt(ep.vx*ep.vx + ep.vy*ep.vy);
                        ep.vx = Math.cos(newAngle) * speed;
                        ep.vy = Math.sin(newAngle) * speed;
                    }
                }
                
                ep.x += ep.vx * (scaledDt/16); ep.y += ep.vy * (scaledDt/16); ep.life -= (scaledDt/16);
                
                // Special rendering for DEFLECTED projectiles - purple glow and trail
                if (ep.deflected) {
                    ep.glowPhase = (ep.glowPhase || 0) + 0.2;
                    const glowIntensity = 0.8 + Math.sin(ep.glowPhase) * 0.2;
                    
                    // Create purple trail particles
                    if (Math.random() < 0.3) {
                        entities.particles.push({
                            x: ep.x,
                            y: ep.y,
                            vx: 0,
                            vy: 0,
                            color: '#ff00ff',
                            life: 15,
                            size: ep.radius * 0.8,
                            update: function(dt) {
                                this.life -= dt/16;
                                this.size *= 0.95;
                                return this.life > 0;
                            },
                            draw: function(ctx) {
                                ctx.globalAlpha = this.life / 15;
                                ctx.fillStyle = this.color;
                                ctx.shadowBlur = 10;
                                ctx.shadowColor = this.color;
                                ctx.beginPath();
                                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                                ctx.fill();
                                ctx.globalAlpha = 1;
                                ctx.shadowBlur = 0;
                            }
                        });
                    }
                    
                    // Outer purple glow
                    ctx.shadowBlur = 25 * glowIntensity;
                    ctx.shadowColor = '#ff00ff';
                    ctx.fillStyle = '#ff00ff';
                    ctx.globalAlpha = 0.5;
                    ctx.beginPath();
                    ctx.arc(ep.x, ep.y, ep.radius * 1.5, 0, Math.PI*2);
                    ctx.fill();
                    
                    // Core projectile
                    ctx.globalAlpha = 1;
                    ctx.shadowBlur = 15;
                    ctx.fillStyle = '#ffffff';
                    ctx.beginPath();
                    ctx.arc(ep.x, ep.y, ep.radius, 0, Math.PI*2);
                    ctx.fill();
                    
                    // Inner purple core
                    ctx.shadowBlur = 0;
                    ctx.fillStyle = '#ff00ff';
                    ctx.beginPath();
                    ctx.arc(ep.x, ep.y, ep.radius * 0.6, 0, Math.PI*2);
                    ctx.fill();
                    
                    ctx.globalAlpha = 1;
                    ctx.shadowBlur = 0;
                }
                // Special rendering for splitter shots - HIGHLY VISIBLE
                else if (ep.splitterShot) {
                    ep.glowPhase = (ep.glowPhase || 0) + 0.15;
                    const glowIntensity = 0.7 + Math.sin(ep.glowPhase) * 0.3;
                    
                    // Outer glow
                    ctx.shadowBlur = 25 * glowIntensity;
                    ctx.shadowColor = ep.color;
                    ctx.fillStyle = ep.color;
                    ctx.globalAlpha = 0.4;
                    ctx.beginPath();
                    ctx.arc(ep.x, ep.y, ep.radius * 1.5, 0, Math.PI*2);
                    ctx.fill();
                    
                    // Core projectile
                    ctx.globalAlpha = 1;
                    ctx.shadowBlur = 15;
                    ctx.fillStyle = '#ffffff';
                    ctx.beginPath();
                    ctx.arc(ep.x, ep.y, ep.radius, 0, Math.PI*2);
                    ctx.fill();
                    
                    // Inner bright core
                    ctx.shadowBlur = 0;
                    ctx.fillStyle = ep.color;
                    ctx.beginPath();
                    ctx.arc(ep.x, ep.y, ep.radius * 0.6, 0, Math.PI*2);
                    ctx.fill();
                    
                    ctx.globalAlpha = 1;
                    ctx.shadowBlur = 0;
                } else {
                    // Regular enemy projectiles
                    ctx.fillStyle = ep.color; 
                    ctx.beginPath(); 
                    ctx.arc(ep.x, ep.y, ep.radius, 0, Math.PI*2); 
                    ctx.fill();
                }
                
                const dx = player.x - ep.x; const dy = player.y - ep.y;
                
                // Deflected projectiles damage enemies along their path
                if (ep.deflected) {
                    let hitAnyEnemy = false;
                    for(let e of entities.enemies) {
                        if (ep.hitEnemies && ep.hitEnemies.includes(e)) continue; // Skip already hit
                        
                        const edx = e.x - ep.x;
                        const edy = e.y - ep.y;
                        const dist = Math.sqrt(edx*edx + edy*edy);
                        
                        if(dist < e.radius + ep.radius) {
                            // Check if this is the origin enemy for auto-crit
                            const isOriginEnemy = (ep.originEnemy && ep.originEnemy === e);
                            
                            if (isOriginEnemy) {
                                // AUTO-CRIT on origin enemy at full strength
                                const originalCrit = player.critChance;
                                player.critChance = 1.0; // 100% crit chance
                                player.dealElementalDamage(e, ep.deflectedDamage, 'whip', '#ff00ff');
                                player.critChance = originalCrit;
                                hitAnyEnemy = true;
                                break; // Remove projectile after hitting origin
                            } else {
                                // 50% damage to other enemies in path
                                player.dealElementalDamage(e, ep.deflectedDamage * 0.5, 'whip', '#ff00ff', false);
                                if (!ep.hitEnemies) ep.hitEnemies = [];
                                ep.hitEnemies.push(e);
                                // Don't break - continue through enemies
                            }
                        }
                    }
                    if (hitAnyEnemy) return false; // Remove projectile if hit origin
                }
                
                // Splitter shots from hacked splitters damage enemies instead of player
                if (ep.splitterShot && !ep.targetWasPlayer) {
                    let hitAnyEnemy = false;
                    
                    // If piercing, check all enemies and hit each once
                    if (ep.piercing) {
                        for(let e of entities.enemies) {
                            if (e.hackState.active) continue; // Don't hit other hacked enemies
                            
                            // Check if we've already hit this enemy
                            if (ep.hitEnemies.has(e)) continue;
                            
                            const edx = e.x - ep.x;
                            const edy = e.y - ep.y;
                            const dist = Math.sqrt(edx*edx + edy*edy);
                            
                            if(dist < e.radius + ep.radius) {
                                e.takeDamage(25, '#00ffff', false, 'normal'); // Decent damage, hacked color
                                createExplosion(ep.x, ep.y, '#00ffff', 8);
                                for(let i=0; i<6; i++) {
                                    entities.particles.push(new Particle(ep.x, ep.y, '#00ffff', 1.5));
                                }
                                ep.hitEnemies.add(e); // Mark this enemy as hit
                                hitAnyEnemy = true;
                                // Don't break - keep going to hit other enemies
                            }
                        }
                        // Piercing projectiles only die when life runs out, not on hit
                    } else {
                        // Non-piercing: old behavior (stop on first hit)
                        for(let e of entities.enemies) {
                            if (e.hackState.active) continue;
                            const edx = e.x - ep.x;
                            const edy = e.y - ep.y;
                            const dist = Math.sqrt(edx*edx + edy*edy);
                            if(dist < e.radius + ep.radius) {
                                e.takeDamage(25, '#ff9500', false, 'normal');
                                createExplosion(ep.x, ep.y, '#ff9500', 8);
                                for(let i=0; i<6; i++) {
                                    entities.particles.push(new Particle(ep.x, ep.y, '#ff9500', 1.5));
                                }
                                return false; // Stop projectile
                            }
                        }
                    }
                }
                
                // Normal collision with player (for non-hacked shots or hacked shots that missed enemies)
                if(Math.sqrt(dx*dx + dy*dy) < player.radius + ep.radius) {
                    if (player.invulnTimer <= 0) { 
                        player.takeHit(ep.splitterShot ? 20 : 15); // Splitter shots hurt more
                        if(ep.splitterShot) {
                            createExplosion(ep.x, ep.y, '#ff9500', 10);
                        }
                        return false;
                    }
                }
                return ep.life > 0;
            });


            entities.projectiles = entities.projectiles.filter(p => {
                const active = p.update(scaledDt);
                if(!active) return false;
                if (p.type !== 'meteor_warning' && p.type !== 'mine' && p.type !== 'grenade' && p.type !== 'railgun' && p.type !== 'flak_shell' && p.type !== 'bio_spore' && p.type !== 'ricochet') {
                    let hit = false;
                    // Optimize: only check enemies that could possibly collide
                    for(let e of entities.enemies) {
                        const dx = p.x - e.x; const dy = p.y - e.y;
                        const roughDist = Math.abs(dx) + Math.abs(dy); // Manhattan distance (faster)
                        if (roughDist < 60) { // Quick early rejection
                            if(Math.sqrt(dx*dx + dy*dy) < e.radius+10) {
                                let hitColor = '#ffffff';
                                if(p.type === 'seeker') hitColor = '#ff5500';
                                
                                player.dealElementalDamage(e, p.damage, p.source, hitColor);
                                
                                hit=true; 
                                if (p.type === 'seeker') {
                                    createExplosion(p.x, p.y, '#ff5500', 5);
                                    // Add explosive shockwave effect at impact (orange)
                                    entities.particles.push(new Shockwave(p.x, p.y, 75, '#ff7733'));
                                    // Limit seeker splash to nearby enemies only
                                    const splashDist = 75;
                                    entities.enemies.forEach(subE => {
                                        const sdx = p.x - subE.x;
                                        const sdy = p.y - subE.y;
                                        if(Math.abs(sdx) + Math.abs(sdy) < splashDist * 1.5) { // Quick check first
                                            if(Math.sqrt(sdx*sdx + sdy*sdy) < splashDist) {
                                                player.dealElementalDamage(subE, p.damage * 0.5, 'seeker', '#ffffff');
                                            }
                                        }
                                    });
                                }
                                if(p.pierce>0) { p.pierce--; hit=false; } else break;
                            }
                        }
                    }
                    if(hit) return false;
                }
                p.draw(ctx); return true;
            });


            drawIndicators();
            ctx.restore();
            
            if (state.timeScale < 0.9) {
                ctx.fillStyle = `rgba(0, 20, 40, ${0.4 * (1 - state.timeScale)})`; 
                ctx.fillRect(0, 0, width, height);
            }
            if(state.frameCount%5===0) updateHud();
        }


        // --- RPG Logic ---


        function gainXp(amt) {
            state.xp += Math.ceil(amt * (1 + player.xpGain)); 
            state.score += 10;
            let nextCurve;
            
            // Faster early game: reduced XP for levels 1-5
            if (state.level < 5) nextCurve = 8 + (state.level * 6); // 14, 20, 26, 32 (was 20, 30, 40, 50)
            else if (state.level < 10) nextCurve = 10 + (state.level * 10); // 60, 70, 80, 90, 100
            else nextCurve = 110 + ((state.level - 10) * 15); 


            if(state.xp >= state.xpToNext) {
                state.level++; state.xp=0; state.xpToNext = nextCurve;
                // Rerolls at levels 10, 20, 30, etc (elemental levels)
                if (state.level >= 10 && (state.level === 10 || (state.level - 10) % 10 === 0)) state.rerolls++;
                state.pendingLevelUps++;
                if (state.screen === 'game') showLevelUp();
            }
        }


        function rerollUpgrades() { if(state.rerolls > 0) { state.rerolls--; generateCards(); } }
        
        function toggleSaveMode() {
            if (state.saveCharges <= 0) return;
            window.upgradesSaveMode = !window.upgradesSaveMode;
            const saveBtn = document.getElementById('save-btn');
            const cards = document.querySelectorAll('#cards-container .card');
            if (window.upgradesSaveMode) {
                saveBtn.innerHTML = '<i class="fas fa-times"></i> CANCEL';
                saveBtn.style.background = '#ff3860';
                cards.forEach(card => { if (!card.classList.contains('disabled')) card.classList.add('save-mode'); });
            } else {
                saveBtn.innerHTML = '<i class="fas fa-save"></i> SAVE (<span id="save-count">' + state.saveCharges + '</span>)';
                saveBtn.style.background = '#00d1b2';
                cards.forEach(card => card.classList.remove('save-mode'));
            }
        }


        function showLevelUp() {
            state.screen = 'levelup';
            entities.projectiles = entities.projectiles.filter(p => p.type === 'mine' || p.type === 'grenade' || p.type === 'meteor_warning' || p.type === 'railgun');
            document.getElementById('levelup-screen').classList.add('active');
            
            // Show Lock Kit Toggle if slots full
            const full = player.getActiveWeaponCount() >= 4;
            document.getElementById('lock-kit-toggle').style.display = full ? 'flex' : 'none';
            
            // Auto-enable kit lock when all slots are filled, but ONLY if user hasn't manually changed it
            if (full && !state.kitLocked && !state.lockUsed) {
                state.kitLocked = true;
                state.lockUsed = true; // Mark that we've auto-enabled it once
                document.getElementById('lock-kit-toggle').classList.add('toggle-active');
            }

            generateCards();
        }


        function generateCards() {
            const container = document.getElementById('cards-container');
            container.innerHTML = '';
            const btn = document.getElementById('reroll-btn');
            const saveBtn = document.getElementById('save-btn');
            document.getElementById('reroll-count').innerText = state.rerolls;
            document.getElementById('save-count').innerText = state.saveCharges;
            
            if (state.level === 10 || (state.level > 10 && (state.level - 10) % 10 === 0)) {
                document.getElementById('lvl-subtitle').innerText = "ELEMENTAL SYNERGY";
                document.getElementById('lvl-title').innerText = "ELEMENTAL SYNERGY";
                document.getElementById('lvl-title').className = "text-3xl text-red-500 font-bold mb-1";
                btn.style.display = 'none';
                saveBtn.style.display = 'none';
                const unlockedWeapons = Object.keys(player.weapons).filter(k => player.weapons[k] > 0);
                if (unlockedWeapons.length === 0) unlockedWeapons.push('ion'); 


                const generatedAugments = new Set();
                let attempts = 0;
                while(generatedAugments.size < 4 && attempts < 50) { 
                    attempts++;
                    const weap = unlockedWeapons[Math.floor(seededRandom() * unlockedWeapons.length)];
                    const el = elementalDefs[Math.floor(seededRandom() * elementalDefs.length)];
                    const key = `${weap}-${el.id}`;
                    if(generatedAugments.has(key)) continue;


                    generatedAugments.add(key);
                    const wName = weaponDefs[weap].name;
                    const currentAug = player.weaponAugments[weap];
                    const hasAugment = currentAug !== null;
                    const elName = `${wName} ${el.name.split(' ')[0]}`; 
                    let desc = `${el.desc}`; // Use actual element description
                    if (hasAugment) {
                        const currentElName = elementalDefs.find(e => e.id === currentAug).name.split(' ')[0];
                        desc = `Replace ${currentElName} with ${el.name.split(' ')[0]}. ${el.desc}`;
                    }
                    createCard(container, elName, desc, el.icon, 'elemental', (e) => {
                        if(e.target.closest('.card').classList.contains('disabled')) return;
                        e.target.closest('.card').classList.add('disabled');
                        player.weaponAugments[weap] = el.id; // Set single augment (replaces old)
                        resumeGame();
                    }, null, null, true, el.id); // isElementalAugment=true, augmentElement=el.id
                }
                return;
            }


            document.getElementById('lvl-subtitle').innerText = "SELECT SYSTEM AUGMENT";
            document.getElementById('lvl-title').innerText = "SYSTEM UPGRADE";
            document.getElementById('lvl-title').className = "text-3xl text-yellow-400 font-bold mb-1";
            btn.style.display = 'flex'; btn.disabled = state.rerolls <= 0;
            saveBtn.style.display = 'flex'; 
            saveBtn.disabled = state.saveCharges <= 0;
            saveBtn.style.background = '#00d1b2'; // Reset to teal
            window.upgradesSaveMode = false; // Ensure save mode is off


            let options = []; let offensivePool = []; let otherPool = [];
            Object.keys(weaponDefs).forEach(k => { 
                const weaponDef = weaponDefs[k];
                // Filter weapons by ship: only show if no ship lock OR matches player's ship
                if (k !== 'multi' && (!weaponDef.shipLocked || weaponDef.shipLocked === player.selectedShip)) {
                    offensivePool.push({ ...weaponDef, id: k });
                }
            });
            statDefs.forEach(s => { 
                // Flux Emitter only available at level 10+ (when elementals unlock)
                if (s.id === 'elem' && state.level < 10) return;
                if (s.offensive) offensivePool.push(s); 
                else otherPool.push(s); 
            });

            // Add Elemental Masteries (Level 10+, only for elements player has)
            if (state.level >= 10) {
                Object.keys(masteryDefs).forEach(elemId => {
                    // Check if player has this element on any weapon
                    const hasElement = Object.values(player.weaponAugments).includes(elemId);
                    // Check if already taken
                    const alreadyTaken = player.elementalMasteries[elemId];
                    if (hasElement && !alreadyTaken) {
                        // Add masteries 3 times to increase appearance rate
                        offensivePool.push(masteryDefs[elemId]);
                        offensivePool.push(masteryDefs[elemId]);
                        offensivePool.push(masteryDefs[elemId]);
                    }
                });
            }

            // Add Synergies (Level 20+, only for element pairs player has)
            if (state.level >= 20) {
                Object.keys(synergyDefs).forEach(synId => {
                    const syn = synergyDefs[synId];
                    // Check if player has both elements
                    const hasElem1 = Object.values(player.weaponAugments).includes(syn.elements[0]);
                    const hasElem2 = Object.values(player.weaponAugments).includes(syn.elements[1]);
                    // Check if already taken
                    const alreadyTaken = player.synergies[synId];
                    if (hasElem1 && hasElem2 && !alreadyTaken) {
                        // Add synergies 4 times to increase appearance rate (rarer than masteries)
                        offensivePool.push(syn);
                        offensivePool.push(syn);
                        offensivePool.push(syn);
                        offensivePool.push(syn);
                    }
                });
            }


            // Multistrike is now always available (no mod required)
            
            const fullWeaponCount = player.getActiveWeaponCount();
            
            // 1. FORCE WEAPON IF SLOT OPEN
            const forcedWeapon = fullWeaponCount < 4;
            const locked = state.kitLocked && fullWeaponCount >= 4;


            // Build Weighted Pool Logic
            const getRarity = (luck) => {
                 const r = seededRandom() + (luck * 0.0002); // Reduced from 0.0003 (33% nerf)
                 // Adjusted rates: C:50, U:30, R:15, E:4.5, L:0.5
                 if (r > 0.995) return 'legendary'; // 0.5% (was 2%)
                 if (r > 0.955) return 'epic';      // 4% (was 8%)
                 if (r > 0.80) return 'rare';       // 15.5% (was 15%)
                 if (r > 0.50) return 'uncommon';   // 30% (was 25%)
                 return 'common';                    // 50% (was 50%)
            };


            const pickedIds = new Set();
            const createOption = (forceType = null) => {
                 let pool = [...offensivePool, ...otherPool];
                 
                 // Remove magnet (pickup) from pool if at cap (6 upgrades)
                 if (player.pickupUpgradeCount >= 6) {
                     pool = pool.filter(o => o.id !== 'pickup');
                 }
                 
                 if (locked) {
                     pool = pool.filter(o => o.type !== 'weapon' || player.weapons[o.id] > 0);
                 } else if (forceType === 'new_weapon') {
                     pool = offensivePool.filter(o => o.type === 'weapon' && player.weapons[o.id] === 0);
                 } else if (forceType === 'upgrade_weapon') {
                     pool = offensivePool.filter(o => o.type === 'weapon' && player.weapons[o.id] > 0);
                 } else if (forceType === 'upgrade_attribute') {
                     pool = offensivePool.filter(o => o.type === 'weapon' && player.weapons[o.id] > 0);
                 }


                 // Filter out already picked options for this hand
                 pool = pool.filter(p => !pickedIds.has(p.id));


                 if(pool.length === 0) pool = [...otherPool].filter(p => !pickedIds.has(p.id)); // Fallback


                 if(pool.length === 0) return null; // Should rarely happen

                 // Weighted selection: Masteries and Synergies are rarer
                 let weightedPool = [];
                 pool.forEach(option => {
                     if (option.type === 'mastery') {
                         // Masteries: 15% as likely (add once)
                         weightedPool.push(option);
                     } else if (option.type === 'synergy') {
                         // Synergies: 10% as likely (add once)
                         weightedPool.push(option);
                     } else {
                         // Normal options: 100% weight (add 10 times)
                         for (let i = 0; i < 10; i++) {
                             weightedPool.push(option);
                         }
                     }
                 });

                 const choice = weightedPool[Math.floor(seededRandom() * weightedPool.length)];
                 pickedIds.add(choice.id);
                 
                 // Masteries and Synergies use special 'elemental' rarity (red outline)
                 let rarity;
                 if (choice.type === 'mastery' || choice.type === 'synergy') {
                     rarity = 'elemental';
                 } else {
                     rarity = getRarity(player.luck);
                 }
                 
                 return { ...choice, rarity };
            };


            // Card 1: Saved upgrade if available, otherwise new weapon or random
            if (state.savedUpgrade) {
                options.push(state.savedUpgrade);
                state.savedUpgrade = null;
            } else if (forcedWeapon && !locked) {
                options.push(createOption('new_weapon'));
            } else {
                options.push(createOption());
            }


            // Card 2, 3, 4: All random (no forced weapon upgrade)
            options.push(createOption());
            options.push(createOption());
            options.push(createOption());


            // SAFETY: Filter out null options and ensure we always have exactly 4 options
            options = options.filter(o => o !== null);
            
            // If somehow we don't have 4 options, fill with random stat upgrades
            while (options.length < 4) {
                options.push(createOption());
                // Ultimate fallback if createOption returns null
                if (options[options.length - 1] === null) {
                    options[options.length - 1] = { 
                        id: 'hp', 
                        type: 'stat', 
                        name: 'Hull Repair', 
                        desc: 'Max HP & Heal', 
                        icon: 'fa-heart', 
                        rarity: 'common' 
                    };
                }
            }
            
            // Render
            options.forEach(opt => {
                if(!opt) return; // Safety


                let mult = 1; 
                if(opt.rarity === 'uncommon') mult=1.5;
                if(opt.rarity === 'rare') mult=2.5; // Buffed
                if(opt.rarity === 'epic') mult=4; // Buffed
                if(opt.rarity === 'legendary') mult=6; // Buffed


                let title = opt.name; let desc = opt.desc;


                if (opt.type === 'weapon') {
                    const lvl = player.weapons[opt.id];
                    if (lvl === 0) { 
                        title = opt.name; 
                        desc = weaponDefs[opt.id].desc;
                        opt.rarity = 'common'; 
                    }
                    else if (lvl > 0) {
                        // Single attribute upgrade based on weapon's valid upgrades
                        let validAttrs = weaponDefs[opt.id].validUpgrades || ['dmg', 'rate', 'area'];
                        
                        const attr = validAttrs[Math.floor(seededRandom() * validAttrs.length)];
                        opt.upgradeAttr = attr; // Store which attribute to upgrade
                        opt.upgradeAmount = mult; // Store multiplier
                        
                        // Rarity-based bonuses: Buffed to compete with globals
                        const bonusMap = { 'common': 8, 'uncommon': 12, 'rare': 20, 'epic': 35, 'legendary': 50 };
                        const bonus = bonusMap[opt.rarity] || 8;
                        
                        title = opt.name; // Just weapon name
                        
                        if (attr === 'dmg') {
                            desc = `Damage: +${bonus}%`;
                        } else if (attr === 'rate') {
                            desc = `Cooldown: -${bonus}%`;
                        } else if (attr === 'area') {
                            desc = `Area: +${bonus}%`;
                        }
                        
                        // Add legendary bonus indicator for weapon upgrades
                        if (opt.rarity === 'legendary') {
                            desc += ` + Grants 2 levels!`;
                        }
                    }
                } else {
                    // Standardized format: [Stat]: +X%
                    if (opt.id === 'hp') desc = `Max HP: +${Math.floor(25*mult)} & Heal`;
                    else if (opt.id === 'luck') desc = `Luck: +${Math.floor(10*mult)}`;
                    else if (opt.id === 'xp') desc = `XP Gain: +${Math.floor(10*mult)}%`;
                    else if (opt.id === 'multi') desc = `Multistrike: +${Math.floor(7.5*mult)}%`;
                    else if (opt.id === 'crit') desc = `Crit Chance: +${Math.floor(15*mult)}%`;
                    else if (opt.id === 'regen') {
                        let rVal = 0.2; // Base: 0.2 HP/sec
                        if(opt.rarity === 'uncommon') rVal = 0.4;
                        if(opt.rarity === 'rare') rVal = 0.6;
                        if(opt.rarity === 'epic') rVal = 1.0;
                        if(opt.rarity === 'legendary') rVal = 1.2;
                        desc = `HP Regen: +${rVal.toFixed(1)}/s`;
                    }
                    else if (opt.id === 'elem') {
                        let eVal = 5;
                        if(opt.rarity === 'uncommon') eVal = 8;
                        if(opt.rarity === 'rare') eVal = 12;
                        if(opt.rarity === 'epic') eVal = 18;
                        if(opt.rarity === 'legendary') eVal = 25;
                        desc = `Elemental Proc: +${eVal}%`;
                    }
                    else if (opt.id === 'spd') {
                        let sVal = 5;
                        if(opt.rarity === 'uncommon') sVal = 8;
                        if(opt.rarity === 'rare') sVal = 12;
                        if(opt.rarity === 'epic') sVal = 20;
                        if(opt.rarity === 'legendary') sVal = 30;
                        desc = `Move Speed: +${sVal}%`;
                    }
                    else if (opt.id === 'pickup') {
                         desc = `Magnet Range: +${Math.floor(10*mult)}%`;
                    }
                    else if (opt.id === 'armor') {
                        let armorVal = 1;
                        if(opt.rarity === 'uncommon') armorVal = 2;
                        if(opt.rarity === 'rare') armorVal = 3;
                        if(opt.rarity === 'epic') armorVal = 4;
                        if(opt.rarity === 'legendary') armorVal = 5;
                        desc = `Armor: +${armorVal}`;
                    }
                    else {
                        desc = opt.desc; // Just use the description directly, no bonus percentage
                    }
                    
                    // Add legendary bonus indicator (except for HP)
                    if (opt.rarity === 'legendary') {
                        desc += ` + Level up all weapons!`;
                    }
                }


                // Pass synergy elements for dual icon display
                const synergyElements = opt.type === 'synergy' ? opt.elements : null;
                
                createCard(container, title, desc, opt.icon, opt.rarity, (e) => {
                    const card = e.target.closest('.card');
                    if (window.upgradesSaveMode) {
                        if (card.classList.contains('disabled')) return;
                        
                        // Save the upgrade
                        state.savedUpgrade = opt;
                        state.saveCharges--;
                        window.upgradesSaveMode = false;
                        
                        // Update visual feedback
                        const saveBtn = document.getElementById('save-btn');
                        const allCards = document.querySelectorAll('#cards-container .card');
                        
                        // Remove save-mode from all cards
                        allCards.forEach(c => c.classList.remove('save-mode'));
                        
                        // Mark this card as saved
                        card.classList.add('saved');
                        
                        // Reset button to normal state but show "SAVED" feedback
                        saveBtn.style.background = '#00d1b2';
                        saveBtn.innerText = 'SAVED!';
                        saveBtn.disabled = true; // Disable for this level
                        
                        // After delay, update button text with remaining charges
                        setTimeout(function() {
                            const btn = document.getElementById('save-btn');
                            btn.innerHTML = '<i class="fas fa-save"></i> SAVE (<span id="save-count">' + state.saveCharges + '</span>)';
                            // Don't re-enable here - stays disabled for current level
                        }, 1000);
                        
                        // Don't resume game - player can still pick another upgrade
                        return;
                    }
                    if(card.classList.contains('disabled')) return;
                    card.classList.add('disabled');


                    if (opt.type === 'weapon') {
                        if (player.weapons[opt.id] === 0 && player.getActiveWeaponCount() >= 4) { 
                            state.pendingSwap = opt.id;
                            document.getElementById('levelup-screen').classList.remove('active');
                            showSwapScreen();
                        } else {
                            // BASE POWER PROGRESSION: Every level increases all weapon stats slightly
                            // This makes late game (level 20-30+) feel more powerful even without rarity bonuses
                            const currentLevel = player.weapons[opt.id];
                            if (currentLevel > 0) {
                                // Apply base increases across all stats (multiplicative)
                                // More aggressive scaling since weapons rarely get past level 10 in typical runs
                                // At level 5: ~32% dmg, 23% rate, 12% area
                                // At level 10: ~74% dmg, 51% rate, 25% area
                                player.weaponStats[opt.id].dmg *= 1.055;   // +5.5% dmg per level (increased from 2%)
                                player.weaponStats[opt.id].rate *= 1.04;   // +4% rate per level (increased from 1.5%)
                                player.weaponStats[opt.id].area *= 1.02;   // +2% area per level (reduced from 4% - half as strong)
                            }
                            
                            // Legendary weapon upgrades grant +2 levels to that weapon
                            if (opt.rarity === 'legendary') {
                                player.weapons[opt.id] += 2;
                            } else {
                                player.weapons[opt.id]++;
                            }
                            
                            // Apply specific attribute upgrade (this is the BONUS on top of base)
                            if (opt.upgradeAttr && opt.upgradeAmount) {
                                const attr = opt.upgradeAttr;
                                const amt = opt.upgradeAmount;
                                // Apply bonus based on rarity - reduced area bonuses
                                const bonusMap = { 
                                    'common': { dmg: 0.05, rate: 0.05, area: 0.03 },      // Area: 3% (was 5%)
                                    'uncommon': { dmg: 0.075, rate: 0.075, area: 0.05 },  // Area: 5% (was 7.5%)
                                    'rare': { dmg: 0.15, rate: 0.15, area: 0.08 },        // Area: 8% (was 15%)
                                    'epic': { dmg: 0.30, rate: 0.30, area: 0.15 },        // Area: 15% (was 30%)
                                    'legendary': { dmg: 0.40, rate: 0.40, area: 0.20 }    // Area: 20% (was 40%)
                                };
                                const bonuses = bonusMap[opt.rarity] || bonusMap['common'];
                                const bonus = bonuses[attr] || 0.05;
                                
                                if (attr === 'dmg') {
                                    player.weaponStats[opt.id].dmg *= (1 + bonus);
                                } else if (attr === 'rate') {
                                    player.weaponStats[opt.id].rate *= (1 + bonus);
                                } else if (attr === 'area') {
                                    player.weaponStats[opt.id].area *= (1 + bonus);
                                }
                            }
                            resumeGame();
                        }
                    } else {
                        if (opt.type === 'mastery') {
                            player.elementalMasteries[opt.id] = true;
                            resumeGame();
                        } else if (opt.type === 'synergy') {
                            player.synergies[opt.id] = true;
                            resumeGame();
                        } else {
                            applyStat(opt.id, mult, opt.rarity); resumeGame();
                        }
                    }
                }, synergyElements); // Pass synergyElements, upgradeAttr=null by default
            });
        }


        function createCard(parent, title, desc, icon, rarity, onClick, synergyElements = null, upgradeAttr = null, isElementalAugment = false, augmentElement = null) {
            const el = document.createElement('div');
            el.className = `card ${rarity}`;
            
            // Add elemental styling ONLY for elemental augment cards (not weapon upgrades)
            if (isElementalAugment && augmentElement) {
                if (augmentElement === 'fire') el.classList.add('elem-fire');
                if (augmentElement === 'ice') el.classList.add('elem-ice');
                if (augmentElement === 'volt') el.classList.add('elem-volt');
                if (augmentElement === 'bio') el.classList.add('elem-bio');
                if (augmentElement === 'hack') el.classList.add('elem-hack');
            }
            
            // For synergies, show both element icons
            let iconHTML;
            if (synergyElements && synergyElements.length === 2) {
                const elem1 = elementalDefs.find(e => e.id === synergyElements[0]);
                const elem2 = elementalDefs.find(e => e.id === synergyElements[1]);
                iconHTML = `
                    <div style="display: flex; gap: 12px; justify-content: center;">
                        <i class="fas ${elem1.icon}" style="color: ${elem1.color}; font-size: 2rem;"></i>
                        <i class="fas ${elem2.icon}" style="color: ${elem2.color}; font-size: 2rem;"></i>
                    </div>
                `;
            } else {
                iconHTML = `<i class="fas ${icon}"></i>`;
            }
            
            el.innerHTML = `
                <div class="card-header">
                    ${iconHTML}
                </div>
                <div class="card-content">
                    <h3>${title}</h3>
                    <p>${desc}</p>
                </div>
            `;
            el.onclick = onClick;
            
            // Add legendary particles to ALL legendary cards
            if (rarity === 'legendary') {
                for (let i = 0; i < 12; i++) {
                    const particle = document.createElement('div');
                    particle.className = 'legendary-particle';
                    particle.style.setProperty('--start-x', `${seededRandom() * 100}%`);
                    particle.style.setProperty('--drift-x', `${(seededRandom() - 0.5) * 60}px`);
                    particle.style.setProperty('--delay', `${seededRandom() * 2}s`);
                    el.appendChild(particle);
                }
            }
            
            parent.appendChild(el);
        }


        function resumeGame() {
            state.pendingLevelUps--;
            if (state.pendingLevelUps > 0) { generateCards(); } 
            else {
                document.getElementById('levelup-screen').classList.remove('active');
                state.screen = 'game'; state.lastTime = Date.now();
                player.invulnTimer = 120;
            }
        }


        // --- Weapon Swap UI ---
        function showSwapScreen() {
            const container = document.getElementById('swap-container');
            container.innerHTML = '';
            document.getElementById('swap-screen').classList.add('active');
            
            Object.keys(player.weapons).forEach(k => {
                const lvl = player.weapons[k];
                if (lvl > 0) {
                    const el = document.createElement('div');
                    el.className = 'card common'; 
                    const def = weaponDefs[k];
                    el.innerHTML = `<i class="fas ${def.icon}"></i><div class="card-content"><h3>${def.name}</h3><p>Level ${lvl}</p></div>`;
                    el.onclick = () => confirmSwap(k);
                    container.appendChild(el);
                }
            });
        }


        function confirmSwap(oldId) {
            player.weapons[oldId] = 0;
            player.weaponAugments[oldId] = { fire: 0, ice: 0, volt: 0, bio: 0 };
            
            player.weapons[state.pendingSwap] = 1;
            
            document.getElementById('swap-screen').classList.remove('active');
            state.pendingSwap = null;
            resumeGame();
        }


        function cancelSwap() {
            document.getElementById('swap-screen').classList.remove('active');
            state.pendingSwap = null;
            document.getElementById('levelup-screen').classList.add('active');
        }


        function applyStat(id, mult, rarity) {
            // Legendary passives boost all weapon levels by +1 (for ALL legendaries, not just non-hp)
            if (rarity === 'legendary') {
                Object.keys(player.weapons).forEach(w => {
                    if (player.weapons[w] > 0) {
                        player.weapons[w]++; // +1 level for global legendary
                    }
                });
            }
            
            if(id==='hp') { 
                player.maxHp += 25*mult; // Increased from 20 to 25 (25% buff)
                player.heal(25*mult, true); // Heal with overshield allowed
            }
            // Global damage and cooldown removed - only weapon-specific now
            if(id==='armor') player.armor += 4*mult; // Increased from 3 to 4 (33% buff)
            if(id==='pickup') {
                player.pickupRadius *= (1 + 0.06*mult); // Reduced from 0.10 to 0.06 (40% nerf)
                player.pickupUpgradeCount += mult; // Track upgrades for cap
            }
            if(id==='regen') {
                // Regen now ticks every 1 second instead of 5 seconds, so values are 5x smaller
                let regenAmt = 0.2; // Base: 0.2 HP/sec
                if (mult >= 6) regenAmt = 1.2; // Max: 1.2 HP/sec (was 6 per 5 sec)
                else if (mult >= 4) regenAmt = 1.0; // 1.0 HP/sec (was 5 per 5 sec)
                else if (mult >= 2.5) regenAmt = 0.6; // 0.6 HP/sec (was 3 per 5 sec)
                else if (mult >= 1.5) regenAmt = 0.4; // 0.4 HP/sec (was 2 per 5 sec)
                player.regen += regenAmt;
            }
            if(id==='luck') player.luck += 10*mult; 
            if(id==='xp') player.xpGain += 0.1*mult; 
            if(id==='multi') {
                const multiplier = player.cascadeMultiplier || 1; // 1.25x if cascade mod active
                player.multicast *= (1 + (0.075 * mult * multiplier));
            } 
            if(id==='crit') player.critChance *= (1 + 0.15*mult);
            if(id==='elem') {
                let val = 0.05;
                if(rarity === 'uncommon') val = 0.08;
                if(rarity === 'rare') val = 0.12;
                if(rarity === 'epic') val = 0.18;
                if(rarity === 'legendary') val = 0.25;
                player.elementalMult += val;
            }
            if(id==='spd') {
                let val = 0.05;
                if(rarity === 'uncommon') val = 0.08;
                if(rarity === 'rare') val = 0.12;
                if(rarity === 'epic') val = 0.20;
                if(rarity === 'legendary') val = 0.30;
                player.speed *= (1 + val);
            }
        }


        function updateHud() {
            const hpPct = Math.max(0, (player.hp / player.maxHp) * 100);
            const xpPct = Math.min(100, (state.xp / state.xpToNext) * 100);
            document.getElementById('hp-bar').style.width = `${hpPct}%`;
            
            // Update HP text inside bar
            const hpTextEl = document.getElementById('hp-text');
            const currentHp = Math.ceil(Math.max(0, player.hp));
            hpTextEl.innerText = `${currentHp} / ${Math.ceil(player.maxHp)}`;
            
            // Update shield orbs based on charge level
            // Note: Shield 2 is RIGHT orb, Shield 1 is LEFT orb (depletes right to left)
            const orb1 = document.getElementById('shield-orb-1'); // LEFT
            const orb2 = document.getElementById('shield-orb-2'); // RIGHT
            
            // Left orb (shield1)
            if (player.shield1 >= 100) {
                orb1.style.color = '#00d1b2';
                orb1.style.filter = 'drop-shadow(0 0 8px #00d1b2)';
                orb1.style.opacity = '1';
            } else if (player.shield1 > 0) {
                // Charging - slightly dimmed with reduced glow
                orb1.style.color = '#00d1b2';
                orb1.style.filter = 'drop-shadow(0 0 3px #00d1b2)';
                orb1.style.opacity = '0.6';
            } else {
                // Empty
                orb1.style.color = 'rgba(0,209,178,0.3)';
                orb1.style.filter = 'none';
                orb1.style.opacity = '0.3';
            }
            
            // Right orb (shield2) - depletes first
            if (player.shield2 >= 100) {
                orb2.style.color = '#00d1b2';
                orb2.style.filter = 'drop-shadow(0 0 8px #00d1b2)';
                orb2.style.opacity = '1';
            } else if (player.shield2 > 0) {
                // Charging - slightly dimmed with reduced glow
                orb2.style.color = '#00d1b2';
                orb2.style.filter = 'drop-shadow(0 0 3px #00d1b2)';
                orb2.style.opacity = '0.6';
            } else {
                // Empty
                orb2.style.color = 'rgba(0,209,178,0.3)';
                orb2.style.filter = 'none';
                orb2.style.opacity = '0.3';
            }
            
            document.getElementById('xp-bar').style.width = `${xpPct}%`;
            document.getElementById('lvl-text').innerText = `LVL ${state.level}`;
            document.getElementById('score').innerText = state.score;
            const t = Math.floor((state.gameTime)/1000);
            document.getElementById('time').innerText = `${Math.floor(t/60).toString().padStart(2,'0')}:${(t%60).toString().padStart(2,'0')}`;


            const slotContainer = document.getElementById('weapon-slots');
            slotContainer.innerHTML = '';
            
            // RENDER 4 WEAPON SLOTS
            const activeWeapons = Object.keys(player.weapons).filter(k => player.weapons[k] > 0 && k !== 'multi' && k !== 'nuke');
            for(let i=0; i<4; i++) {
                const wId = activeWeapons[i];
                const slot = document.createElement('div');
                slot.className = 'weapon-slot';
                if (wId && weaponDefs[wId]) {
                    const def = weaponDefs[wId];
                    const lvl = player.weapons[wId];
                    const augs = player.weaponAugments[wId];
                    slot.classList.add('active');
                    slot.innerHTML = `<i class="fas ${def.icon}"></i><div class="level-badge">${lvl}</div>`;
                    
                    // COOLDOWN OVERLAY
                    let pct = 0;
                    if(wId === 'tesla') pct = player.teslaTimer / player.maxTeslaTimer;
                    if(wId === 'seeker') pct = player.seekerTimer / player.maxSeekerTimer;
                    if(wId === 'whip') pct = player.whipTimer / Math.max(40, 120 / player.weaponStats.whip.rate);
                    if(wId === 'meteor') pct = player.meteorTimer / player.maxMeteorTimer;
                    if(wId === 'railgun') pct = player.railgunTimer / player.maxRailgunTimer;
                    if(wId === 'flak') pct = player.flakTimer / player.maxFlakTimer;
                    if(wId === 'pylons') pct = player.pylonTimer / player.maxPylonTimer;
                    if(wId === 'mines') pct = player.minesTimer / player.maxMinesTimer;
                    if(wId === 'gas') pct = player.gasTimer / player.maxGasTimer;
                    if(wId === 'ricochet') pct = player.ricochetTimer / Math.max(60, 150 / player.weaponStats.ricochet.rate);
                    
                    if (wId === 'ion') {
                        const currentIonRate = player.fireRate / Math.min(4, Math.max(1, player.weapons.ion));
                         if (currentIonRate > 250 && player.lastShot > 0) {
                             pct = player.lastShot / currentIonRate;
                         }
                    }
                    if(wId === 'beam' && !player.beamActive) {
                         pct = player.beamCooldown / 3000 * 16; 
                    }


                    if (pct > 0) {
                        const ol = document.createElement('div');
                        ol.className = 'cooldown-overlay';
                        ol.style.background = `conic-gradient(rgba(0,0,0,0.8) ${pct*100}%, rgba(0,0,0,0) ${pct*100}%)`;
                        slot.appendChild(ol);
                    }


                    // Single Augment Border Logic
                    const augElement = augs; // Single element or null
                    let borderColor = null;
                    if (augElement === 'fire') borderColor = '#ff5722';
                    if (augElement === 'ice') borderColor = '#88d8ff';
                    if (augElement === 'volt') borderColor = '#ffeb3b';
                    if (augElement === 'bio') borderColor = '#00cc44';
                    if (augElement === 'hack') borderColor = '#00ffff';


                    if (borderColor) {
                        slot.style.borderColor = borderColor;
                        slot.style.boxShadow = `0 0 5px ${borderColor}`;
                        slot.querySelector('i').style.color = borderColor;
                    }


                } else {
                    slot.innerHTML = `<i class="fas fa-lock text-gray-700"></i>`;
                }
                slotContainer.appendChild(slot);
            }
            
            // Update mod slot separately
            updateModSlot();
        }
        
        // Update mod slot in separate container (bottom left)
        function updateModSlot() {
            const modContainer = document.getElementById('mod-slot-container');
            if (!modContainer) return;
            
            modContainer.innerHTML = '';
            
            const modSlot = document.createElement('div');
            modSlot.className = 'weapon-slot mod-slot';
            if (player.activeMod) {
                const mDef = modDefs[player.activeMod];
                modSlot.classList.add('active');
                modSlot.innerHTML = `<i class="fas ${mDef.icon}" style="font-size: 18px;"></i>`; // Match weapon slot icon size
                // Passive mods are always active - gentle pulsing glow
                modSlot.style.animation = 'modPulse 2s infinite';
                
                // Add cooldown overlay for chrono and revive mods
                if (player.activeMod === 'chrono' && player.chronoCooldown > 0) {
                    const cooldownPct = 1 - (player.chronoCooldown / 3600); // 3600 = 60 seconds
                    const ol = document.createElement('div');
                    ol.className = 'cooldown-overlay';
                    ol.style.background = `conic-gradient(rgba(0,0,0,0.8) ${cooldownPct*100}%, rgba(0,0,0,0) ${cooldownPct*100}%)`;
                    modSlot.appendChild(ol);
                    
                    // Timer text
                    const remainingSeconds = Math.ceil(player.chronoCooldown / 60);
                    if (remainingSeconds > 0) {
                        const timerText = document.createElement('div');
                        timerText.style.position = 'absolute';
                        timerText.style.bottom = '-18px';
                        timerText.style.left = '50%';
                        timerText.style.transform = 'translateX(-50%)';
                        timerText.style.fontSize = '10px';
                        timerText.style.color = '#ffdd57';
                        timerText.style.fontWeight = 'bold';
                        timerText.style.textShadow = '0 0 3px #000';
                        timerText.innerText = `${remainingSeconds}s`;
                        modSlot.appendChild(timerText);
                    }
                } else if (player.activeMod === 'revive' && player.reviveCooldown > 0) {
                    const cooldownPct = 1 - (player.reviveCooldown / 7200); // 7200 = 2 minutes
                    const ol = document.createElement('div');
                    ol.className = 'cooldown-overlay';
                    ol.style.background = `conic-gradient(rgba(0,0,0,0.8) ${cooldownPct*100}%, rgba(0,0,0,0) ${cooldownPct*100}%)`;
                    modSlot.appendChild(ol);
                    
                    // Timer text
                    const remainingSeconds = Math.ceil(player.reviveCooldown / 60);
                    if (remainingSeconds > 0) {
                        const timerText = document.createElement('div');
                        timerText.style.position = 'absolute';
                        timerText.style.bottom = '-18px';
                        timerText.style.left = '50%';
                        timerText.style.transform = 'translateX(-50%)';
                        timerText.style.fontSize = '10px';
                        timerText.style.color = '#ffdd57';
                        timerText.style.fontWeight = 'bold';
                        timerText.style.textShadow = '0 0 3px #000';
                        timerText.innerText = `${remainingSeconds}s`;
                        modSlot.appendChild(timerText);
                    }
                }
            } else {
                modSlot.innerHTML = `<i class="fas fa-microchip text-gray-700" style="font-size: 18px;"></i>`;
            }
            modContainer.appendChild(modSlot);
        }
        
        function gameOver() {
            state.screen = 'gameover'; 
            document.getElementById('final-level').innerText = state.level;
            document.getElementById('final-score').innerText = state.score;
            document.getElementById('final-seed').innerText = state.seed.toString().padStart(6, '0');
            
            // Format and display run time
            const totalSeconds = Math.floor(state.gameTime / 1000);
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = totalSeconds % 60;
            document.getElementById('final-time').innerText = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            
            // Populate weapon stats breakdown
            const statsList = document.getElementById('weapon-stats-list');
            statsList.innerHTML = '';
            
            // Weapon display names - only actual weapons
            const weaponNames = {
                'ion': 'Ion Cannon',
                'beam': 'Plasma Beam',
                'seeker': 'Seeker Missiles',
                'rad': 'Radiation Field',
                'tesla': 'Tesla Coils',
                'whip': 'Plasma Whip',
                'meteor': 'Meteor Strike',
                'railgun': 'Railgun',
                'flak': 'Flak Cannon',
                'pylons': 'Energy Pylons',
                'mines': 'Collapsar Mines',
                'gas': 'Toxic Barrage',
                'ricochet': 'Ricochet Disc',
                'drones': 'Combat Drones'
            };
            
            // Filter to only actual weapons and sort by damage
            const weaponArray = Object.entries(state.weaponStats)
                .filter(([weapon, stats]) => weaponNames[weapon]) // Only known weapons
                .map(([weapon, stats]) => ({ weapon, ...stats }))
                .sort((a, b) => b.damage - a.damage);
            
            // Calculate totals
            const totalDamage = weaponArray.reduce((sum, w) => sum + w.damage, 0);
            const totalKills = weaponArray.reduce((sum, w) => sum + w.kills, 0);
            
            // Create table structure with proper header - 4 columns only
            const table = document.createElement('div');
            table.className = 'w-full font-mono text-xs'; // Smaller font (text-xs instead of text-sm)
            
            // Header row - 4 columns: Weapon, Damage, %, Kills
            const header = document.createElement('div');
            header.className = 'grid grid-cols-[120px_75px_40px_50px] gap-2 px-2 py-2 border-b border-gray-600 text-gray-400 font-bold uppercase';
            header.innerHTML = `
                <span class="text-left">Weapon</span>
                <span class="text-right">Damage</span>
                <span class="text-right">%</span>
                <span class="text-right">Kills</span>
            `;
            table.appendChild(header);
            
            // Display each weapon as table row
            weaponArray.forEach(w => {
                const weaponName = weaponNames[w.weapon];
                const damagePercent = totalDamage > 0 ? ((w.damage / totalDamage) * 100).toFixed(0) : 0; // No decimal
                
                const row = document.createElement('div');
                row.className = 'grid grid-cols-[120px_75px_40px_50px] gap-2 px-2 py-1 bg-gray-900 bg-opacity-30 hover:bg-opacity-50 rounded mb-1';
                row.innerHTML = `
                    <span class="text-teal-300 font-bold text-left truncate" title="${weaponName}">${weaponName}</span>
                    <span class="text-orange-400 text-right">${Math.floor(w.damage).toLocaleString()}</span>
                    <span class="text-gray-500 text-right">${damagePercent}%</span>
                    <span class="text-red-400 text-right">${w.kills}</span>
                `;
                table.appendChild(row);
            });
            
            // Add totals row
            const totalsRow = document.createElement('div');
            totalsRow.className = 'grid grid-cols-[120px_75px_40px_50px] gap-2 px-2 py-2 mt-2 border-t border-gray-600 font-bold';
            totalsRow.innerHTML = `
                <span class="text-white text-left">TOTAL</span>
                <span class="text-orange-300 text-right">${Math.floor(totalDamage).toLocaleString()}</span>
                <span class="text-gray-600 text-right">-</span>
                <span class="text-red-300 text-right">${totalKills}</span>
            `;
            table.appendChild(totalsRow);
            statsList.appendChild(table);
            
            // Update meta progression stats
            updateMetaStats();
            
            document.getElementById('gameover-screen').classList.add('active');
        }


        // --- Input ---
        const handleStart = (x,y) => { 
            input.active=true; input.origin={x,y}; input.current={x,y}; input.vector={x:0,y:0}; document.getElementById('start-hint').style.display='none'; 
        };
        const handleMove = (x,y) => {
            if(!input.active) return;
            input.current = {x, y}; // Track current position for joystick visual
            const dx = x - input.origin.x; const dy = y - input.origin.y;
            const dist = Math.sqrt(dx*dx + dy*dy); const max = 60;
            if(dist>0) { const l = Math.min(dist,max); input.vector.x=(dx/dist)*(l/max); input.vector.y=(dy/dist)*(l/max); }
        };
        const handleEnd = () => { input.active=false; input.vector={x:0,y:0}; };


        window.addEventListener('touchstart', e=>{if(state.screen==='game') handleStart(e.touches[0].clientX,e.touches[0].clientY)},{passive:false});
        window.addEventListener('touchmove', e=>{if(state.screen==='game') handleMove(e.touches[0].clientX,e.touches[0].clientY)},{passive:false});
        window.addEventListener('touchend', handleEnd);
        window.addEventListener('mousedown', e=>{if(state.screen==='game') handleStart(e.clientX,e.clientY)});
        window.addEventListener('mousemove', e=>{if(state.screen==='game') handleMove(e.clientX,e.clientY)});
        window.addEventListener('mouseup', handleEnd);


        const startBtn = document.getElementById('start-btn');
        console.log('Start button:', startBtn ? 'found' : 'NOT FOUND');
        if (startBtn) {
            startBtn.onclick = () => {
                console.log('Start button clicked!');
                // Save selected ship
                const selectedShip = ships[currentShipIndex];
                if (!selectedShip.locked) {
                    localStorage.setItem('neonrogue_selectedShip', selectedShip.name);
                }
                
                document.getElementById('menu-screen').classList.remove('active'); 
                initGame(); 
            };
        }
        
        const restartBtn = document.getElementById('restart-btn');
        if (restartBtn) {
            restartBtn.onclick = () => { 
                document.getElementById('gameover-screen').classList.remove('active'); 
                document.getElementById('menu-screen').classList.add('active');
                // Clear seed input when returning to menu
                const seedInput = document.getElementById('seed-input');
                if (seedInput) seedInput.value = '';
            };
        }
        
        
        // Copy seed button - use event delegation since gameover screen might not be loaded yet
        document.addEventListener('click', (e) => {
            if (e.target.id === 'copy-seed-btn' || e.target.closest('#copy-seed-btn')) {
                e.preventDefault();
                const btn = document.getElementById('copy-seed-btn');
                const seed = state.seed.toString().padStart(6, '0');
                const originalHTML = btn.innerHTML;
                
                // Try modern clipboard API first, fallback to execCommand
                if (navigator.clipboard && navigator.clipboard.writeText) {
                    navigator.clipboard.writeText(seed).then(() => {
                        btn.innerHTML = '<i class="fas fa-check"></i> COPIED';
                        btn.classList.add('text-teal-400');
                        setTimeout(() => {
                            btn.innerHTML = originalHTML;
                            btn.classList.remove('text-teal-400');
                        }, 2000);
                    }).catch(() => {
                        // Fallback if clipboard API fails
                        fallbackCopy(seed, btn, originalHTML);
                    });
                } else {
                    // Fallback for older browsers
                    fallbackCopy(seed, btn, originalHTML);
                }
            }
        });
        
        function fallbackCopy(text, btn, originalHTML) {
            const textArea = document.createElement('textarea');
            textArea.value = text;
            textArea.style.position = 'fixed';
            textArea.style.left = '-999999px';
            textArea.style.top = '0';
            document.body.appendChild(textArea);
            textArea.focus();
            textArea.select();
            try {
                const successful = document.execCommand('copy');
                if (successful) {
                    btn.innerHTML = '<i class="fas fa-check"></i> COPIED';
                    btn.classList.add('text-teal-400');
                    setTimeout(() => {
                        btn.innerHTML = originalHTML;
                        btn.classList.remove('text-teal-400');
                    }, 2000);
                }
            } catch (err) {
                console.error('Copy failed:', err);
                alert('Seed: ' + text); // Fallback - show in alert
            }
            document.body.removeChild(textArea);
        }
        
        // Seed input validation - only allow digits
        document.getElementById('seed-input').addEventListener('input', (e) => {
            e.target.value = e.target.value.replace(/\D/g, '').slice(0, 6);
        });
        
        // ===== SAVE/LOAD SYSTEM =====
        
        // Save data structure for meta progression
        function getSaveData() {
            return {
                version: 1, // For future compatibility
                timestamp: Date.now(),
                // Add your meta progression data here when you implement it
                // For now, we'll just save a placeholder
                metaProgress: {
                    totalRuns: parseInt(localStorage.getItem('neonrogue_totalRuns') || '0'),
                    totalKills: parseInt(localStorage.getItem('neonrogue_totalKills') || '0'),
                    highestLevel: parseInt(localStorage.getItem('neonrogue_highestLevel') || '0'),
                    highestScore: parseInt(localStorage.getItem('neonrogue_highestScore') || '0'),
                    totalPlaytime: parseInt(localStorage.getItem('neonrogue_totalPlaytime') || '0'),
                    nexusCores: parseInt(localStorage.getItem('neonrogue_nexusCores') || '0')
                }
            };
        }
        
        // Load save data from object
        function loadSaveData(data) {
            if (!data || !data.metaProgress) {
                alert('Invalid save file!');
                return false;
            }
            
            // Load meta progression data
            const meta = data.metaProgress;
            localStorage.setItem('neonrogue_totalRuns', meta.totalRuns || 0);
            localStorage.setItem('neonrogue_totalKills', meta.totalKills || 0);
            localStorage.setItem('neonrogue_highestLevel', meta.highestLevel || 0);
            localStorage.setItem('neonrogue_highestScore', meta.highestScore || 0);
            localStorage.setItem('neonrogue_totalPlaytime', meta.totalPlaytime || 0);
            localStorage.setItem('neonrogue_nexusCores', meta.nexusCores || 0);
            
            return true;
        }
        
        // Export save to file
        function exportSave() {
            const saveData = getSaveData();
            const dataStr = JSON.stringify(saveData, null, 2);
            const blob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = `neonrogue_save_${Date.now()}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            // Visual feedback
            const btn = document.getElementById('export-btn');
            const originalText = btn.innerHTML;
            btn.innerHTML = '<i class="fas fa-check mr-2"></i>EXPORTED!';
            btn.classList.add('bg-teal-600');
            setTimeout(() => {
                btn.innerHTML = originalText;
                btn.classList.remove('bg-teal-600');
            }, 2000);
        }
        
        // Import save from file
        function importSave(file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const data = JSON.parse(e.target.result);
                    if (loadSaveData(data)) {
                        // Show detailed feedback
                        const meta = data.metaProgress;
                        const msg = `Save imported successfully!\n\n` +
                            `Total Runs: ${meta.totalRuns || 0}\n` +
                            `Total Kills: ${meta.totalKills || 0}\n` +
                            `Highest Level: ${meta.highestLevel || 0}\n` +
                            `Highest Score: ${meta.highestScore || 0}\n\n` +
                            `Page will reload to apply changes.`;
                        alert(msg);
                        // Refresh the page to apply changes
                        location.reload();
                    }
                } catch (err) {
                    alert('Error reading save file: ' + err.message);
                }
            };
            reader.readAsText(file);
        }
        
        // Display stats screen
        function showStats() {
            const nexusCores = parseInt(localStorage.getItem('neonrogue_nexusCores') || '0');
            const totalRuns = parseInt(localStorage.getItem('neonrogue_totalRuns') || '0');
            const totalKills = parseInt(localStorage.getItem('neonrogue_totalKills') || '0');
            const highestLevel = parseInt(localStorage.getItem('neonrogue_highestLevel') || '0');
            const highestScore = parseInt(localStorage.getItem('neonrogue_highestScore') || '0');
            const totalPlaytime = parseInt(localStorage.getItem('neonrogue_totalPlaytime') || '0');
            
            // Update display
            document.getElementById('stat-cores').textContent = nexusCores.toLocaleString();
            document.getElementById('stat-runs').textContent = totalRuns.toLocaleString();
            document.getElementById('stat-kills').textContent = totalKills.toLocaleString();
            document.getElementById('stat-level').textContent = highestLevel;
            document.getElementById('stat-score').textContent = highestScore.toLocaleString();
            
            // Format playtime
            const hours = Math.floor(totalPlaytime / 3600);
            const minutes = Math.floor((totalPlaytime % 3600) / 60);
            document.getElementById('stat-time').textContent = `${hours}h ${minutes}m`;
            
            // Show modal
            document.getElementById('stats-screen').classList.add('active');
        }
        
        // Export button handlers
        document.getElementById('export-btn').addEventListener('click', exportSave);
        document.getElementById('gameover-export-btn').addEventListener('click', exportSave);
        
        // Import button handler
        document.getElementById('import-btn').addEventListener('click', () => {
            document.getElementById('import-file-input').click();
        });
        
        document.getElementById('import-file-input').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                importSave(file);
            }
            // Reset input so same file can be selected again
            e.target.value = '';
        });
        
        // Stats screen handlers
        document.getElementById('view-stats-btn').addEventListener('click', showStats);
        document.getElementById('close-stats-btn').addEventListener('click', () => {
            document.getElementById('stats-screen').classList.remove('active');
        });
        
        // Ship carousel (currently locked, for future expansion)
        console.log('Initializing ship system...');
        let currentShipIndex = 0;
        const ships = [
            {
                name: 'PATHFINDER',
                desc: 'Balanced all-around vessel',
                hp: 150,
                dmg: '100%',
                spd: '100%',
                weapon: 'Ion Cannons',
                locked: false
            },
            {
                name: 'ENGINEER',
                desc: 'Deploy turrets as you move',
                hp: 150,
                dmg: '90%',
                spd: '100%',
                weapon: 'Auto-Turret',
                unlockCores: 10,
                unlockAchievement: 'Survive to Level 20',
                locked: true
            },
            {
                name: 'DISRUPTOR',
                desc: 'Crowd control specialist',
                hp: 130,
                dmg: '95%',
                spd: '110%',
                weapon: 'EMP Pulse',
                unlockCores: 20,
                unlockAchievement: 'Survive to Level 30',
                locked: true
            }
        ];
        console.log('Ships defined:', ships.length, 'ships');
        
        // Draw ship on canvas
        function drawShipIcon() {
            console.log('drawShipIcon called');
            const canvas = document.getElementById('ship-canvas');
            if (!canvas) {
                console.error('Canvas not found!');
                return;
            }
            console.log('Canvas found, drawing ship:', ships[currentShipIndex].name);
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            const ship = ships[currentShipIndex];
            
            // Center the ship
            ctx.save();
            ctx.translate(35, 35);
            ctx.scale(1.8, 1.8);
            
            if (ship.name === 'PATHFINDER') {
                // PATHFINDER - Sleek Arrowhead Fighter (Teal/Cyan)
                
                // Main body - sharp arrowhead
                ctx.fillStyle = '#0d3b47';
                ctx.strokeStyle = '#00d1b2';
                ctx.lineWidth = 2.5;
                ctx.shadowColor = '#00d1b2';
                ctx.shadowBlur = 15;
                ctx.beginPath();
                ctx.moveTo(14, 0);    // Sharp front
                ctx.lineTo(-6, 7);    // Bottom wing
                ctx.lineTo(-3, 0);    // Back center
                ctx.lineTo(-6, -7);   // Top wing
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
                
                // Glowing engine
                ctx.fillStyle = '#00fff5';
                ctx.shadowBlur = 20;
                ctx.shadowColor = '#00fff5';
                ctx.beginPath();
                ctx.arc(-2, 0, 3, 0, Math.PI * 2);
                ctx.fill();
                
            } else if (ship.name === 'ENGINEER') {
                // ENGINEER - Hexagonal Utility Ship (Orange/Bronze)
                
                // Hexagon body
                ctx.fillStyle = '#4a2511';
                ctx.strokeStyle = '#ff8800';
                ctx.lineWidth = 2.5;
                ctx.shadowColor = '#ff8800';
                ctx.shadowBlur = 15;
                ctx.beginPath();
                for (let i = 0; i < 6; i++) {
                    const angle = (Math.PI / 3) * i;
                    const x = Math.cos(angle) * 8;
                    const y = Math.sin(angle) * 8;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
                
                // Orange core
                ctx.fillStyle = '#ff8800';
                ctx.shadowBlur = 20;
                ctx.shadowColor = '#ff8800';
                ctx.beginPath();
                ctx.arc(0, 0, 4, 0, Math.PI * 2);
                ctx.fill();
                
            } else if (ship.name === 'DISRUPTOR') {
                // DISRUPTOR - Diamond Lightning Ship (Purple/Violet)
                
                // Diamond body
                ctx.fillStyle = '#2d1b4e';
                ctx.strokeStyle = '#a855f7';
                ctx.lineWidth = 2.5;
                ctx.shadowColor = '#a855f7';
                ctx.shadowBlur = 15;
                ctx.beginPath();
                ctx.moveTo(12, 0);    // Front
                ctx.lineTo(0, 8);     // Bottom
                ctx.lineTo(-8, 0);    // Back
                ctx.lineTo(0, -8);    // Top
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
                
                // Purple energy core
                ctx.fillStyle = '#c084fc';
                ctx.shadowBlur = 20;
                ctx.shadowColor = '#a855f7';
                ctx.beginPath();
                ctx.arc(0, 0, 4, 0, Math.PI * 2);
                ctx.fill();
            }
            
            ctx.shadowBlur = 0;
            ctx.restore();
        }
        
        // Draw ship icon on page load
        drawShipIcon();
        
        // Check if ships are unlocked
        function checkShipUnlocks() {
            const nexusCores = parseInt(localStorage.getItem('neonrogue_nexusCores') || '0');
            const highestLevel = parseInt(localStorage.getItem('neonrogue_highestLevel') || '0');
            
            ships.forEach(ship => {
                if (ship.unlockCores !== undefined) {
                    // Check if unlock requirements are met
                    const coresUnlocked = nexusCores >= ship.unlockCores;
                    const levelUnlocked = highestLevel >= parseInt(ship.unlockAchievement.match(/\d+/)[0]);
                    ship.canUnlock = coresUnlocked && levelUnlocked;
                    // Ship stays locked until player manually unlocks it (and spends cores)
                    if (ship.locked === undefined) ship.locked = true; // Default to locked
                }
            });
        }
        
        // Unlock a ship (spend cores)
        function unlockShip(ship) {
            if (!ship.canUnlock) return;
            
            // Deduct cores
            const currentCores = parseInt(localStorage.getItem('neonrogue_nexusCores') || '0');
            const newCores = currentCores - ship.unlockCores;
            localStorage.setItem('neonrogue_nexusCores', newCores.toString());
            
            // Unlock ship
            ship.locked = false;
            
            // Refresh display
            checkShipUnlocks();
            updateShipDisplay();
        }
        window.unlockShip = unlockShip; // Make globally accessible for inline onclick
        
        // Update ship display
        function updateShipDisplay() {
            const ship = ships[currentShipIndex];
            document.getElementById('ship-name').textContent = ship.locked ? 'CLASSIFIED' : ship.name;
            document.getElementById('ship-desc').textContent = ship.locked ? 'Requirements not met' : ship.desc;
            
            if (ship.locked) {
                const nexusCores = parseInt(localStorage.getItem('neonrogue_nexusCores') || '0');
                const canUnlock = ship.canUnlock;
                
                document.getElementById('ship-stats').innerHTML = `
                    <div class="${canUnlock ? 'text-teal-400' : 'text-red-400'}">${canUnlock ? 'READY TO UNLOCK' : 'LOCKED'}</div>
                    <div class="text-xs">Requires: ${ship.unlockCores} Nexus Cores ${canUnlock ? `(You have ${nexusCores})` : ''}</div>
                    <div class="text-xs">${ship.unlockAchievement}</div>
                    ${canUnlock ? `<button onclick="unlockShip(ships[${currentShipIndex}])" class="mt-2 px-4 py-2 bg-teal-500 hover:bg-teal-600 text-white rounded font-bold">UNLOCK (Spend ${ship.unlockCores} Cores)</button>` : ''}
                `;
            } else {
                document.getElementById('ship-stats').innerHTML = `
                    <div>HP: <span class="text-white">${ship.hp}</span> • DMG: <span class="text-white">${ship.dmg}</span> • SPD: <span class="text-white">${ship.spd}</span></div>
                    <div>WEAPON: <span class="text-teal-400">${ship.weapon}</span></div>
                `;
            }
            
            drawShipIcon();
            
            // Update arrow states
            document.getElementById('ship-prev').disabled = currentShipIndex === 0;
            document.getElementById('ship-next').disabled = currentShipIndex === ships.length - 1;
        }
        
        // Check unlocks on load
        checkShipUnlocks();
        updateShipDisplay();
        
        const shipPrevBtn = document.getElementById('ship-prev');
        const shipNextBtn = document.getElementById('ship-next');
        
        if (shipPrevBtn) {
            shipPrevBtn.addEventListener('click', () => {
                if (currentShipIndex > 0) {
                    currentShipIndex--;
                    updateShipDisplay();
                }
            });
        }
        
        if (shipNextBtn) {
            shipNextBtn.addEventListener('click', () => {
                if (currentShipIndex < ships.length - 1) {
                    currentShipIndex++;
                    updateShipDisplay();
                }
            });
        }
        
        // Corner icon buttons - open modals
        const seedCornerBtn = document.getElementById('seed-corner-btn');
        const saveCornerBtn = document.getElementById('save-corner-btn');
        
        if (seedCornerBtn) {
            seedCornerBtn.addEventListener('click', () => {
                document.getElementById('seed-modal').classList.add('active');
            });
        }
        
        if (saveCornerBtn) {
            saveCornerBtn.addEventListener('click', () => {
                document.getElementById('save-modal').classList.add('active');
            });
        }
        
        // Modal close buttons
        const seedCloseBtn = document.getElementById('seed-close-btn');
        const saveCloseBtn = document.getElementById('save-close-btn');
        
        if (seedCloseBtn) {
            seedCloseBtn.addEventListener('click', () => {
                document.getElementById('seed-modal').classList.remove('active');
            });
        }
        
        if (saveCloseBtn) {
            saveCloseBtn.addEventListener('click', () => {
                document.getElementById('save-modal').classList.remove('active');
            });
        }
        
        // Auto-save stats after each run (you can call this from game over)
        function updateMetaStats() {
            // Increment total runs
            const totalRuns = parseInt(localStorage.getItem('neonrogue_totalRuns') || '0') + 1;
            localStorage.setItem('neonrogue_totalRuns', totalRuns);
            
            // Update highest level
            const highestLevel = parseInt(localStorage.getItem('neonrogue_highestLevel') || '0');
            if (state.level > highestLevel) {
                localStorage.setItem('neonrogue_highestLevel', state.level);
            }
            
            // Update highest score
            const highestScore = parseInt(localStorage.getItem('neonrogue_highestScore') || '0');
            if (state.score > highestScore) {
                localStorage.setItem('neonrogue_highestScore', state.score);
            }
            
            // Update total playtime (in seconds)
            const totalPlaytime = parseInt(localStorage.getItem('neonrogue_totalPlaytime') || '0');
            const runTime = Math.floor((Date.now() - state.startTime) / 1000);
            localStorage.setItem('neonrogue_totalPlaytime', totalPlaytime + runTime);
            
            // Total kills - you'll need to track this in your enemy death code
            // For now, just use score as a proxy
            const totalKills = parseInt(localStorage.getItem('neonrogue_totalKills') || '0');
            localStorage.setItem('neonrogue_totalKills', totalKills + Math.floor(state.score / 10));
        }
        
        // ===== END SAVE/LOAD SYSTEM =====
        
        document.getElementById('pause-btn').onclick = togglePause;
        document.getElementById('resume-btn').onclick = togglePause;
        document.getElementById('quit-btn').onclick = () => { 
            document.getElementById('pause-screen').classList.remove('active'); 
            document.getElementById('menu-screen').classList.add('active'); 
            state.screen='menu'; 
            document.getElementById('hud').style.display='none';
        };
    </script>
</body>
</html>